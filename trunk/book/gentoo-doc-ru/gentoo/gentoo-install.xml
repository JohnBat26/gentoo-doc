<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbookxi.rng" type="xml"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="gentoo-install">
    <info>
        <title>Gentoo Linux: установка и настройка</title>
    </info>
    <para>Ссылка на оригинал: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://posix.ru/distro/gentoo_old/">http://posix.ru/distro/gentoo_old/</link></para>
    <para>Автор: Алексей Федорчук (<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="mailto:alv@linux-online.ru?subject=По%20поводу%20статьи%20о%20Gentoo">alv@linux-online.ru</link>)</para>
    <para>С версии: 1.0</para>
    <para><emphasis role="italic">Вступление:</emphasis> это сборник моих заметок про Gentoo, написанных в то время, когда я был пользователем этого дистрибутива. Кое-что из приводимого ниже безнадежно устарело, но кое-что может помочь в составлении Gen-To. Собственно, в расчете на это я их и размещаю. — 2006.03.07</para>
    <section>
        <title>О Gentoo Linux</title>
        <para>Gentoo Linux — один из типичных представителей т.н. Source Based дистрибутивов. То есть систем, основанных не на прекомпилированных бинарных пакетах, а собираемых непосредственно из исходных текстов. Gentoo относительно молод, но известностью сравнялся с такими ветеранами дистростроения, как Red Hat или Debian. </para>
        <para>Gentoo создан в 2001 г. Дэниелем Роббинсом. Официальный сайт проекта — <link xlink:href="http://www.gentoo.org">http://www.gentoo.org</link>. (Русский: <link xlink:href="http://gentoo.ru">http://gentoo.ru</link>)</para>
        <para>С самого начала Gentoo являл собой синтез наиболее передовых технологий Linux с традиционными достижениями BSD-систем (в первую очередь — FreeBSD). В частности, в нем приняты сценарии начальной загрузки системы в BSD-стиле — большинство популярных дистрибутивов Linux наследуют схему инициализации системы, унаследованную от Unix System V (именно она была принята за основу Линусом Торвальдсом при создании своего ядра).</para>
        <para>Главная особенность Gentoo также идейно унаследована от FreeBSD. В последней, как известно, только базовые компоненты (т.н. Distribution) устанавливаются из прекомпилированных пакетов. Для установки же пользовательских приложений предназначена т.н. система портов. Это — набор средств для автоматизированного получения из Сети (с мастер-сайтов разработчиков или их официальных зеркал) исходных текстов программ, их конфигурирования, компиляции, установки и регистрации в специальной базе данных. Конечно, и FreeBSD поставляется с наборами прекомпилированных пакетов (packages), однако роль их сугубо вспомогательная.</para>
        <para><indexterm><primary>Portage</primary></indexterm><indexterm>Портеж</indexterm>В Gentoo концепция портов (именуемых здесь портежами — Portages) проводится еще более последовательно, чем во FreeBSD. Поскольку здесь этим путем можно установить (или — обновить) не только прикладные программы, но и все базовые компоненты системы, вплоть до ядра, компилятора gcc и главной системной библиотеки glibс.</para>
        <para>Система портежей Gentoo позволяет:</para>
        <orderedlist>
            <listitem>
                <para>очень гибкое конфигурирование системы, с подбором только необходимых (и осознанно выбираемых) приложений;</para>
            </listitem>
            <listitem>
                <para>открыть путь для оптимизации системы не только под различные архитектуры (а на данный момент дистрибутивом поддерживаются, кроме i86, также Sparc, PowerPC и Alpha), но и под конкретные типы процессоров;</para>
            </listitem>
            <listitem>
                <para>средства генерации бинарных пакетов (аналог packages FreeBSD), которые могут быть установлены на целевую платформу, отличную от host-машины;</para>
            </listitem>
            <listitem>
                <para>оптимизировать пакеты с учетом особенностей целевой (например, более слабой) машины.</para>
            </listitem>
        </orderedlist>
        <para>Дополнительным плюсом дистрибутива Gentoo является его прекрасная документированность. На сайте проекта доступны <link xlink:href="http://www.gentoo.org/doc/ru/handbook/">Gentoo Handbook</link> (таже входит в данный сборник см. <xref xlink:href="#gentoo-handbook"/>) и множество более частных источников информации, ряд из которых переведен на русский язык.</para>
        <para>Название дистрибутива (произносится как "джен-ту") может показаться несколько странным. Но объясняется просто — это один из видов пингвина (научное название Pygoscelis papua), обитающий на Циркум-Антарктических островах (Фолклендских, Кергелен, Южная Георгия).</para>
        <para>В специальной литературе можно прочитать, что джен-ту отличается небольшим размером и стремительностью. Именно эти его качества и воплощены в дистрибутиве Gentoo.</para>
    </section>
    <section>
        <title>Получение дистрибутива</title>
        <para>Все версии дистрибутива Gentoo доступны на основном сервере проекта и на ряде его зеркал. Скачивание — по протоколам http и ftp, разумеется, свободно и бесплатно. Конечно, за некоторую сумму можно заказать и CD-вариант, но в наших условиях это не актуально.</para>
        <para>Процесс получения Gentoo имеет некоторые особенности, отличающие его от получения (приобретения) любого пакетного дистрибутива. Если для последнего достаточно скачать iso-образы CD-дисков и записать их на соответствующие носители, продуктивное использование Gentoo требует выхода в Интернет. Правда, не обязательно с той же машины, на которую он устанавливается — вполне допустима ситуация, когда необходимые компоненты получаются, например, по рабочему каналу, а сама система устанавливается дома.</para>
        <para>Итак, первое, что необходимо для установки — скачать образ инсталляционного диска. Объемы образов — достаточно скромны, обычно около 200 Мбайт (в зависимости от версии). Образы эти являют собой Live CD — то есть фактически полноценную Linux-систему, запускаемую с компакт-диска. И включающую набор не только системных утилит, но и пользовательских приложений.</para>
        <para>Образ инсталляционного диска обычно содержит все необходимое для установки. Однако в некоторых версиях его оказывается недостаточно — потребуется еще три архива (<filename>*.tar.bz2</filename>), содержащие (в прекомпилированном виде) компоненты базовой системы. Первый из них (файл <filename>stage1-*</filename>, объемом около 10 Мбайт) специфичен для архитектуры (i86, PowerPC, Sparc и т.д.). Два других тарбалла (<filename>stage2-*</filename> и <filename>stage3-*</filename>, около 50 и 80 Мбайт, соответственно), кроме этого, для PC-архитектуры представлены в нескольких вариантах, оптимизированных под конкретные процессоры: от i486 до Pentium-4 (включая и Athlon). Ясно, что скачиванию подлежат только тарбаллы, соответствующие реалиям пользователя.</para>
        <para>Далее, для установки пре-релиза потребуется скачать архив системы портежей — один из файлов вида <filename>portage-200<replaceable>XXXXX</replaceable>.tar.bz2</filename>, расположенных в каталоге <filename>~/gentoo/snapshots</filename> (в стабильной версии текущий архив портежей размещен на установочном диске). Как легко понять, цифры в имени файла соответствуют дате создания архива (а обновляется система портежей чуть ли не ежедневно), и лучше выбирать последний по времени.</para>
        <para>И наконец, при установке на машину без выхода в сеть неплохо заблаговременно скачать архивы исходных текстов базовых компонентов системы — об их составе я скажу несколько позже. И не обязательно с сайта разработчика: исходники всех портированных в Gentoo программ можно найти на сайте проекта в каталоге <filename>~/gentoo/distfiles</filename> (или <filename>~/gentoo/gentoo-sources</filename>, содержание их идентично). Наличие их очень упростит жизнь, однако, как будет показано ниже, обойтись без них можно.</para>
        <para>А вот без чего никак не обойтись — это без одного из дополнительных носителей, на котором будут размещены скачанные компоненты. При установке на "чистую" машину ими могут быть: второй CD (при наличии двух приводов, например, пишущего и читающего) или Zip (как нетрудно подсчитать — желательно 250-мегабайтного объема, иначе их придется менять в процессе установки). Можно также временно подцепить дополнительный винчестер с уже существующим разделом и какой-либо файловой системой (из числа поддерживаемых) на нем. Ну и заблаговременно переписать на эти носители все требуемые файлы — тарбаллы <filename>stage2-*</filename>, <filename>stage3-*</filename> и <filename>portage-*</filename> — обязательно, прочие — по возможности и желанию.</para>
        <para>К слову сказать, на тот же носитель хорошо поместить и инструкцию по установке с сайта Gentoo (добавлю, и все прочие файлы документации — тоже, отнюдь не повредят). Или, по крайней мере, держать ее распечатку под рукой — зело способствует. И можно приступать к установке.</para>
        <para>Помещать тарбаллы базовой системы и системы портежей, а также документацию, можно где угодно — хоть в корне файловой системы дополнительного накопителя. А вот под архивы исходников лучше создать на нем отдельный каталог, например, src — ниже будет ясно, почему.</para>
    </section>
    <section>
        <title>Загрузка системы и первые шаги</title>
        <para>Редкий инсталляционный диск Linux-дистрибутива ныне не является загрузочным. И Gentoo тут — не исключение: чтобы загрузиться с любого из вышепоименованных образов, достаточно поместить диск в привод, нажать на Reset, выставить соответствующие опции в Setup BIOS и подождать некоторое время, по возможности вникая в появляющиеся сообщения об имеющемся оборудовании (впрочем, все эти сведения можно будет получить и потом — командой dmesg.</para>
        <para>Ожидание завершается выводом приглашения на ввод пользовательского имени (login), ответом на что служит волшебное слово root, а затем и пароля — на это отвечаем просто нажатием клавиши Enter. За этим появляется приглашение командной строки — и можно приступить к дальнейшим действиям.</para>
        <para>Они не вполне тривиальны. Еще одна отличительная особенность дистрибутива Gentoo, о которой я не упомянул ранее — полное отсутствие какого-либо инсталлятора, все манипуляции по установке осуществляются прямыми директивами из командной строки и прямым редактированием конфигурационных файлов в текстовом редакторе. Что начинающего (да и не очень начинающего) пользователя может просто обескуражить.</para>
        <para>Однако все не так страшно. Во-первых, в нашем распоряжении — вышеупомянутая подробная, буквально пошаговая, инструкция по установке. А во-вторых (и об этом также говорилось ранее), установочный диск Gentoo — не просто загрузочный, а так называемый Live CD. То есть просто-напросто загружающий полноценную рабочую Linux-среду с корневой файловой системой в оперативной памяти (способной монтировать в себя файловые системы любых устройств). И потому в процессе установки в руках пользователя — вся мощь ОС Linux, включая командную оболочку bash и 6 виртуальных консолей (авторизоваться в любой из них можно точно так же, как и в первой — вводом имени root без пароля). Ну а в третьих — загружаемое с CD Linux-ядро собрано с поддержкой абсолютно всех опций, которые могут потребоваться при установке (встроенной в ядро или модульной).</para>
        <para>И потому первое действие после старта системы — загрузка всех необходимых модулей. Это будут модули поддержки:</para>
        <orderedlist>
            <listitem>
                <para>устройств хранения данных — SCSI-адаптеров, контроллеров IDE-RAID, Zip-приводов (atapi-floppy, в терминологии Linux), короче, всего, на что мы собираемся устанавливать систему или считывать устанавливаемые компоненты;</para>
            </listitem>
        </orderedlist>
        <orderedlist>
            <listitem>
                <para>файловых систем: это потребуется, только если устанавливаемые тарбаллы и архивы исходников размещены на разделе с файловой системой FATxx — поддержка всех родных (native) файловых систем Linux, включая XFS, встроена в установочное ядро);</para>
            </listitem>
            <listitem>
                <para>сетевого адаптера — если таковой, вместе с постоянным подключением к Сети, имеется;</para>
            </listitem>
            <listitem>
                <para>соединения ppp — это даст возможность использовать при установке модемное подключение к Сети.</para>
            </listitem>
        </orderedlist>
        <para>При этом возможно, что многие из перечисленных устройств (в частности, сетевые карты) будут корректно определены при загрузке системы и соответствующие модули загрузятся автоматически, что проверяется командой</para>
        <screen><prompt>$</prompt> <userinput>modprobe <replaceable>имя_модуля</replaceable></userinput></screen>
        <para>В остальных случаях это придется сделать вручную, командой</para>
        <screen><prompt>$</prompt> <userinput>insmod имя_модуля</userinput></screen>
        <para>Имена поддерживаемых модулей можно посмотреть (авторизовавшись в следующей виртуальной консоли) в соответствующих подкаталогах каталога <filename>/lib/modules/2.6.XX.X/kernel/</filename> — ведь наша корневая система пока находится в оперативной памяти.</para>
        <para>Следующий шаг — настройка сетевого соединения (при постоянном подключении). Если машина использует динамически выделяемый IP-адрес, назначаемый через DHCP-сервер (а в большинстве случаев это так и есть), делается это элементарно просто, командой</para>
        <screen><prompt>$</prompt> <userinput>dhcpcd eth0</userinput></screen>
        <para>Все остальное происходит почти автоматически. При статическом IP-адресе потребуется ручная настройка, но на этом я останавливаться не буду (все вопросы конфигурирования сети очень подробно рассмотрены в руководстве).</para>
        <para>При отсутствии постоянного подключения необходимо смонтировать носитель со скачанными ранее архивными файлами. Для этого в каталоге /mnt создаем соответствующую ситуации точку монтирования, например,</para>
        <screen><prompt>$</prompt> <userinput>mkdir /mnt/zip</userinput></screen>
        <para>для Zip-диска, или</para>
        <screen><prompt>$</prompt> <userinput>mkdir /mnt/cd2</userinput></screen>
        <para>для второго CD (каталог для установочного CD — /mnt/cdrom, — там уже имеется, и диск этот в него уже смонтирован). А теперь даем команду монтирования. Для zip-диска "из коробки" она будет выглядеть так:</para>
        <screen><prompt>$</prompt> <userinput>mount /dev/hdd4 -t msdos /mnt/zip</userinput></screen>
        <para>где, кроме явного указания файловой системы, обращаю внимание, что файл устройства — именно <filename>/dev/hdd4</filename>: при фабричной разметке на zip-дисках создается один, но четвертый, первичный раздел. И еще одна тонкость: вследствие особенностей реализации файловой системы devfs в дистрибутиве Gentoo, zip-диск должен находиться в приводе в момент старта системы — иначе соответствующий файл устройства просто не будет создан.</para>
        <para>Аналогичны и действия по монтированию второго CD или дискового раздела. Единственно, что в этом случае может не потребоваться явного указания на тип файловой системы (хотя и вреда от него, конечно, не будет).</para>
        <para>Завершив монтирование носителя установочных файлов, следует перво-наперво активизировать еще одну виртуальную консоль и вывести на нее <link xlink:href="#gentoo-handbook">инструкцию по инсталляции</link> — дабы сверять с ней все дальнейшие шаги, как со Священным писанием:</para>
        <screen><prompt>$</prompt> <userinput>lynx /mnt/mount_point/build.html</userinput></screen>
        <para>При наличии модемного подключения к Сети можно настроить и его — даже если все требуемые файлы, включая исходники базовой системы, размещены на смонтированном носителе, не исключено, что в процессе их синхронизации может потребоваться какой-либо специфичный для Gentoo патч, скачать который по модему — дело пары минут, а то и секунд. Хотя должен предупредить, что установить базовую систему чисто по модему (что вполне реально, скажем, для FreeBSD) — не то что невозможно, но, скажем так, весьма долго и накладно для кармана.</para>
        <para>Для настройки модемного соединения проще всего использовать программу wvdial, находящуюся на Live CD (в каталоге <filename>/usr/bin</filename>). Подгрузив модули поддержки протокола ppp (общий, ppp_generic, и асинхронного соединения, ppp_async), запускаем программу</para>
        <screen><prompt>$</prompt> <userinput>wvdialconf /etc/wvdial.conf</userinput></screen>
        <para>Она автоматически определит порт, к которому подключен модем, определит его скорость и создаст строку инициализации, занеся все эти сведения в файл, указанный в качестве аргумента. В результате содержание его примет вид, подобный следующему:</para>
        <programlisting>[Dialer Defaults]
Modem = /dev/ttyS0
Baud = 115200
Init1 = ATZ
Init2 = ATQ0 V1 E1 S0=0 &amp;C1 &amp;D2 +FCLASS=0
ISDN = 0
Modem Type = Analog Modem                
            </programlisting>
        <para>Пользователю остается только добавить туда строку, определяющую способ дозвона. По умолчанию он — тоновый, тогда как в наших условиях, скорее всего, потребуется импульсный дозвон:</para>
        <programlisting>Dial Command = ATDP</programlisting>
        <para>Остальное же — обычная информация: телефон провайдера</para>
        <programlisting>Phone = </programlisting>
        <para>имя пользователя и его пароль</para>
        <programlisting>Username =
Password =</programlisting>
        <para>Теперь, проследив, чтобы в файле <filename>/etc/hostname</filename> наличествовала единственная строка</para>
        <programlisting>localhost</programlisting>
        <para>подкорректируем содержимое файла <filename>/etc/resolv.conf</filename>: значение строки nameserver должно соответствовать реальному IP-адресу DNS-сервера провайдера. И теперь при необходимости для дозвона можно использовать команду</para>
        <screen><prompt>$</prompt> <userinput>wvdial</userinput></screen>
        <para>А больше на этапе установки нам ничего и не требуется — все остальное сделает система портежей.</para>
        <para>Возникает вопрос: а каким образом редактировать все вышепоименованные конфигурационные файлы (и те файлы, которые потребуется редактировать в дальнейшем)? Этой цели в дистрибутиве Gentoo штатно служит текстовый редактор nano — очень простой в освоении и обращении, снабженный встроенной справкой и обеспечивающий достаточные базовые функции редактирования. Нужно только не забывать запускать его в форме</para>
        <screen><prompt>$</prompt> <userinput>nano -w <replaceable>имя_файла</replaceable></userinput></screen>
        <para>где опция <option>-w</option> отключает режим переноса строк — конфигурационные файлы на это, как правило, реагируют болезненно. Поскольку редактор понадобится нам за время установки неоднократно, резонно было бы сразу определить псевдоним:</para>
        <screen><prompt>$</prompt> <userinput>alias nano='nano -w'</userinput></screen>
        <para>благо, как уже говорилось, в нашем распоряжении полнофункциональная оболочка bash.</para>
    </section>
    <section>
        <title>Установка — первый этап</title>
        <para>Вот теперь подготовительные мероприятия закончены — можно начинать собственно установку, начальный этап которой происходит внутри корневой файловой системы Live CD. Первый шаг на этом этапе — создание дисковых разделов и файловых систем на них. Эти вопросы были предметом детального рассмотрения в моей статье, подготовленной к печати (Открытые системы, #11, 2002) и потому здесь я на них остановлюсь лишь вкратце.</para>
        <para>Для первой операции можно использовать одну из программ — fdisk, cfdisk, parted, все они имеются на Live CD. А созданию файловых систем служат специфичные для них утилиты: mkefs для ext2fs, mkfs.xfs — для XFS, mkswap — для раздела подкачки, и так далее. Рекомендуемая в руководстве схема разбиения для одного диска (первого на первом IDE-канале) приведена в табл. 1.</para>
        <table>
            <title>Таблица 1. Рекомендуемая схема разбиения диска для установки Gentoo</title>
            <tgroup cols="4">
                <thead>
                    <row>
                        <entry>Раздел</entry>
                        <entry>Размер</entry>
                        <entry>Тип</entry>
                        <entry>Устройство</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>Загрузочный</entry>
                        <entry>100 Мбайт</entry>
                        <entry>ext2fs или ext3fs</entry>
                        <entry><filename>/dev/hda1</filename></entry>
                    </row>
                    <row>
                        <entry>Раздел подкачки</entry>
                        <entry>128 Мбайт=&lt;2*RAM=&lt;2 Гбайт</entry>
                        <entry> Linux swap</entry>
                        <entry><filename>/dev/hda2</filename></entry>
                    </row>
                    <row>
                        <entry>Корневой раздел</entry>
                        <entry>1,5 Гбайт минимум</entry>
                        <entry>XFS, ext3</entry>
                        <entry><filename>/dev/hda3</filename></entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
        <para>Разумеется, эта рекомендация — приблизительна. Так, 1,5 Гбайт для корневого раздела — лишь абсолютно необходимый минимум. При интенсивном использовании системы портежей цифру эту нужно увеличить в два-три раза, а то и более. Или выделить файловую систему /usr в отдельный раздел. Кроме того, на мой взгляд, абсолютно необходимо создать отдельный раздел под файловую систему /home — для домашних каталогов пользователей. А в некоторых случаях целесообразно выделение и каталогов /var и /tmp.</para>
        <para>Если под установку Gentoo предполагается задействовать более одного физического диска, можно прибегнуть к таким современным технологиям, как программные RAID-массивы или система управления логическими томами (LVM — Logical Volumes Manager). Рассмотрение их далеко выходит за рамки настоящей статьи. Скажу только, что первая технология способствует повышению быстродействия дисковых операций или (иногда — и) сохранности данных. А система LVM позволяет достичь непревзойденной гибкости в управлении уже созданными и смонтированными файловыми системами (в частности, динамического перераспределения занимаемого ими дискового пространства). И, разумеется, на установочном Live CD содержится весь необходимый инструментарий для работы с программными RAID-массивами и системой LVM. Впрочем, нет препятствий и к использованию дисков, подключенных к аппаратному контроллеру IDE-RAID, хотя это потребует некоторых дополнительных действий (детали — в руководстве по установке).</para>
        <para>Следующий шаг — монтирование созданных файловых систем в структуру корневой системы (напомню, она — в оперативной памяти). Но сначала — активизируем раздел подкачки:</para>
        <screen><prompt>$</prompt> <userinput>swapon /dev/hda2</userinput></screen>
        <para>что будет способствовать быстродействию при всех дальнейших манипуляциях, особенно при не очень большом объеме ОЗУ.</para>
        <para>Теперь необходимо создать точку монтирования для той файловой системы, которая в дальнейшем станет корневой:</para>
        <screen><prompt>$</prompt> <userinput>mkdir /mnt/gentoo</userinput></screen>
        <para>и смонтировать в нее соответствующий раздел:</para>
        <screen><prompt>$</prompt> <userinput>mount /dev/hda3 /mnt/gentoo</userinput></screen>
        <para>Если создавались отдельные разделы под каталоги /boot, /usr, /home — они тоже потребуют своих точек монтирования, теперь уже относительно каталога <filename>/mnt/gentoo</filename>:</para>
        <screen><prompt>$</prompt> <userinput>mkdir /mnt/gentoo{/boot,/usr,/home}</userinput></screen>
        <para>и выполнить для них команды монтирования:</para>
        <screen><prompt>$</prompt> <userinput>mount /dev/hda1 /mnt/gentoo/boot</userinput></screen>
        <para>и так далее. Теперь командой </para>
        <screen><prompt>$</prompt> <userinput>cd /mnt/gentoo/</userinput></screen>
        <para>переходим в будущий корневой каталог Gentoo и вспоминаем наконец о наших архивных файлах. Разворачиваем тарбалл первой очереди, находящий на инсталляционном CD:</para>
        <screen><prompt>$</prompt> <userinput>tar -xvjpf /mnt/cdrom/nocompress/stage1-x86-*.tar.bz2</userinput></screen>
        <para>Здесь и далее следует обратить внимание на опцию <option>-p</option> в командной строке: она необходима для сохранения оригинальных атрибутов доступа к файлам, извлекаемым из архива. По самой же команде разворачивается иерархия каталогов в дереве <filename>/mnt/gentoo</filename> (<filename>/mnt/gentoo/etc</filename>, <filename>/mnt/gentoo/proc</filename> и т.д.) и устанавливается некий минимум прекомпилированных программ, необходимых для дальнейшей инсталляции, в том числе и ftp-клиент wget. И действительно, при постоянном подключении к Сети более ничего не потребуется — можно переходить к подготовке смены корневого каталога. Однако тем, кто не может им похвастаться, предварительно придется распаковать два оставшихся тарбалла, stage2* и stage3*.</para>
        <para>Делается это точно так же, как и развертывание первого, только пути к соответствующим файлам нужно указать те, что соответствуют их реальному расположению, например:</para>
        <screen><prompt>$</prompt> <userinput>tar -xvjpf /mnt/zip/stage2*.tar.bz2</userinput></screen>
        <para>и так далее. После этого мы имеем в каталоге <filename>/mnt/gentoo</filename> тот самый набор прекомпилированных библиотек, утилит и приложений, который объединяется понятием base Linux. И, соответственно, морально готовы к тому, чтобы сделать каталог <filename>/mnt/gentoo</filename> корневым.</para>
    </section>
    <section>
        <title>Этап второй — подготовка к смене корня</title>
        <para>Однако этот ответственный шаг требует некоторых подготовительных мероприятий — ведь после него все остальные ветви нынешнего корневого каталога станут недоступными. Правда, только с текущей, первой, консоли — во всех прочих сеансах корневым останется каталог в оперативной памяти.</para>
        <para>Для начала, чтобы не делать двойную работу, скопируем настроенные нами конфигурационные файлы — ведь и они пока существуют только виртуально:</para>
        <screen><prompt>$</prompt> <userinput>cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</userinput>
<prompt>$</prompt> <userinput>cp /etc/hostname /mnt/gentoo/etc/hostname</userinput>
<prompt>$</prompt> <userinput>cp /etc/wvdial.conf /mnt/gentoo/etc/wvdial.conf</userinput></screen>
        <para>Теперь воспользуемся замечательным свойством современных ядер Linux — возможностью доступа к одной и той же файловой системе через разные точки монтирования. И смонтируем таким образом файловую систему процессов (она, как ясно из названия, представляет протекающие в системе процессы в виде файлов):</para>
        <screen><prompt>$</prompt> <userinput>mount -o bind /proc /mnt/gentoo/proc</userinput></screen>
        <para>К слову сказать, таким же образом можно поступить и с тем носителем, на котором у нас размещены архивы системы портежей и исходников (если последние мы туда помещали). А можно, просто размонтировав его (доступ к ним из виртуального корня Live CD больше не обязателен), смонтировать заново — но уже относительно будущего нового корня:</para>
        <screen><prompt>$</prompt> <userinput>mount /dev/hdd4 /mnt/gentoo/mnt</userinput></screen>
        <para>Ведь в нем развернута собственная корневая система, имеющая все положенные компоненты. Правда, в этом случае мы потеряем доступ к инструкции по установке — а она нам еще потребуется. Вообще говоря, обойтись с этим носителем можно самыми разными способами — например, не перемонтируя его, просто обращаться с других виртуальных консолей. Я опишу самый, на мой взгляд, удобный.</para>
        <para>Не предпринимая никаких размонтировочных действий, переходим в каталог <filename>/mnt/gentoo/usr</filename> (таковой ведь у нас тоже имеется). И из него разворачиваем архив портежей, точно так же, как мы это делали для основных тарбаллов:</para>
        <screen><prompt>$</prompt> <userinput>tar -xvjpf /mnt/zip/portage*.tar.bz2</userinput></screen>
        <para>Если исходников на вспомогательном носителе нет — можно оставить его в покое, нужды в нем больше не возникнет. Если же исходники имеются — создаем в новообразованном каталоге <filename>/mnt/gentoo/usr/portage</filename> подкаталог distfiles и копируем в него все наши архивы исходных текстов:</para>
        <screen><prompt>$</prompt> <userinput>cp /mnt/zip/src/* /mnt/gentoo/usr/portage/distfiles</userinput></screen>
        <para>Теперь они находятся именно там, где их ожидает встретить система портежей, прежде чем обращаться к Сети (и выдавать сообщение об ошибке при отсутствии подключения). А дополнительный носитель оставляем смонтированным — чтобы подсматривать в документацию через другой виртуальный терминал.</para>
        <para>Теперь все готово к волнующему моменту — смене корневого каталога. Итак, командой</para>
        <screen><prompt>$</prompt> <userinput>chroot /mnt/gentoo /bin/bash</userinput></screen>
        <para>объявляем каталог <filename>/mnt/gentoo</filename> корнем, одновременно запуская новый экземпляр командной оболочки (уже из нового источника). Теперь пересчитываем пути к системным библиотекам</para>
        <screen><prompt>$</prompt> <userinput>env-update</userinput></screen>
        <para>ответом на что будет сообщение</para>
        <screen>Regenerating /etc/ld.so.cache...</screen>
        <para>И устанавливаем для нового экземпляра оболочки переменные окружения:</para>
        <screen><prompt>$</prompt> <userinput>source /etc/profile</userinput></screen>
        <para>Всё, мы — внутри системы Gentoo Linux, причем уже очень даже реальной, не имеющей никакого отношения к виртуальной системе, загруженной с Live CD. И далее все пути к файлам в абсолютной форме (типа /usr/portage) будут указываться с учетом того, что отныне наш <filename>/</filename> — это не что иное, как <filename>/mnt/gentoo</filename>.</para>
    </section>
    <section>
        <title>Третий этап — внутри Gentoo</title>
        <para>Итак, мы уже как бы установили операционную систему Gentoo Linux (без перезагрузки, прошу обратить внимание). И вот тут-то и начинается самый охмурежь — рядом планомерных и последовательных действий мы можем после перезагрузки (ну куда же без нее) получить не просто полнофункциональную и аккуратно настроенную, но, не побоюсь громких слов, — идеально оптимизированную систему.</para>
        <para>Требуемые к тому действия описываются в предположении: а) установки всех трех тарбаллов и системы портежей, б) помещения в каталог <filename>/usr/portage/distfiles</filename> (уже относительно нового корня — <filename>/mnt/gentoo</filename>) некоторого набора минимально необходимых исходников, и в) хоть какого-то соединения с Интернетом (на крайний случай). Без последнего можно, как я неоднократно говорил, и обойтись — но тут уж потребуется ювелирная точность в выборе предварительно скачанных (и ныне помещенных в <filename>/usr/portage/distfiles</filename>) архивов исходников.</para>
        <para>В чем смысл этих действий? Да ни много, ни мало, как в полной пересборке базовой системы (те, кто имел дело с FreeBSD, неизбежно вспомнят тут make world) и доустановки необходимых компонентов. Поскольку это — не apt-get, и не установка прекомпилированных пакетов, все требуемое извлекается непосредственно из исходников. И потому первое, что нам потребуется — настройка условий компиляции.</para>
        <para>Глобальные параметры сборки посредством системы портежей описываются в файле <filename>/etc/make.conf</filename>. Вызываем его в редакторе nano (не забыв про опцию <option>-w</option>, если не решили этот вопрос разом — определением псевдонима) и начинаем действовать.</para>
        <para>Первое, что бросается в глаза после открытия вышеупомянутого файла — переменная <envar>USE</envar>. Смысл ее — в определении условий предкомпиляционного конфигурирования исходников. То есть, она эквивалента опциям <option>--enable/disable</option> или <option>--with/without</option> скрипта <filename>./configure</filename>, с исполнения которого начинается ручная сборка любой программы. И, задав значения этой переменной (несложно догадаться, что указав</para>
        <programlisting>USE="gpm"</programlisting>
        <para>мы включаем поддержку службы консольной мыши во всех собираемых через портежи программах (разумеется, тех, где это имеет физический смысл). А задав значение</para>
        <programlisting>USE="-gpm"</programlisting>
        <para>таковую отключаем раз и навсегда (на самом деле — не совсем навсегда, но это тема отдельной беседы).</para>
        <para>Список включенных по умолчанию значений переменной USE можно подсмотреть в файле <filename>/usr/portage/profiles/default-x86-XX/make.defaults</filename>. А полный (и логично классифицированный) список доступных значений можно найти в файле документации — <filename>use-howto.html</filename>. Мы ведь списали его на дополнительный носитель? Да? — тогда можем вызвать с очередной виртуальной консоли...</para>
        <para>Следующая переменная файла <filename>/etc/make.conf</filename>:</para>
        <programlisting>CHOST='i686-pc-linux-gnu'</programlisting>
        <para>Она указывает на архитектуру машины, на которой будут собираться программы. И ее, при необходимости, нужно будет привести в соответствие с реалиями оной. Правда, ныне такая необходимость возникнет редко — разве что поменять первую шестерку на пятерку в случае Pentium-просто...</para>
        <para>А вот следующая строка,</para>
        <programlisting>CFLAGS="*"</programlisting>
        <para>очень важна. Ею задаются именно те флаги оптимизации, передаваемые компилятору для оптимизации под конкретный процессор. Вдаваться в детали опять же не буду — и это тема особого, и очень подробного, разговора. Достаточно помнить, что флаг <option>-O3</option> (а именно он указан здесь по умолчанию) устанавливает самый высокий уровень оптимизации, а оба флага <option>-mcpu=*</option> и <option>-march=*</option> указывают, под какой именно процессор оптимизировать следует. Различие между ними — в том, что программа, собранная с флагом -mcpu=i686, будучи оптимизирована под класс процессоров Pentium Pro и выше (а с формальной точки зрения, и P-II, и P-III, и даже P-4 принадлежат к нему), теоретически способна запуститься и на Pentium-100, тогда как флаг <option>-march=athlon-xp</option> потребует именно того процессора, который указан — даже на просто Athlon'е скомпилированная с ним программа работать не будет.</para>
        <para>Смысл переменной</para>
        <programlisting>CXXFLAGS=</programlisting>
        <para>аналогичен — только для программ, написанных не на Си, а на Си++. И ее имеет смысл определить просто, через переменную CFLAGS=</para>
        <programlisting>CXXFLAGS="${CFLAGS}"</programlisting>
        <para>как это и сделано в example-файле. Остальные строки которого определяют условия скачивания (в частности, ftp-клиента по умолчанию). Менять их на данном этапе — оснований не вижу, кроме разве что идиосинкразии к wget, используемому по умолчанию.</para>
        <para>Определившись с условиями, можно начинать перестройку. Для этого меняем каталог</para>
        <screen><prompt>$</prompt> <userinput>cd /usr/portage</userinput></screen>
        <para>и запускаем сценарий</para>
        <screen><prompt>$</prompt> <userinput>scripts/bootstrap.sh</userinput></screen>
        <para>Он производит сборку пакетов binutils, gcc, gettext и glibc (замещая установленные из тарбаллов прекомпилированные их варианты), а после сборки glibc — пересборку binutils, gcc и gettext. Достигая, таким образом, их идеальной оптимизации... Хотя и ценой временных затрат — процесс даже на мощной машине вполне может занять часок-другой.</para>
        <para>Теперь можно полюбоваться на список пакетов, установленных в нашей системе — ибо это и есть тот самый base Linux с очень небольшими коррективами. Для этого даем команду</para>
        <screen><prompt>$</prompt> <userinput>emerge -p system</userinput></screen>
        <para>Если есть желание, время, а главное — полный набор исходников в <filename>/usr/portage/distfiles</filename>, можно завершить пересборку базовой системы командой</para>
        <screen><prompt>$</prompt> <userinput>emerge system</userinput></screen>
        <para>Здесь без постоянного коннекта с очень большой вероятностью рано или поздно последует сообщение об ошибке — о невозможности получить пакет имя_рек с такого-то адреса. Если имеется модем, к подбору исходников мы подошли ответственно, — не беда: активизируем еще одну виртуальную консоль (а на ней будет жить наша первозданная Live-система с CD) и дозваниваемся до провайдера через программу wvdial (а она у нас пока существует только в той самой виртуальной Live-системе), а потом повторяем последнюю команду. И, скорее всего, дело было в каком-нибудь исконно Gentoo'ском патчике объемом в пару килобайт, так что процедура эта нас не разорит. Если же обуяет приступ жадности, можно просто продолжить, а к <command>emerge system</command> вернуться в другой раз — после полного зеркалирования каталога <filename>distfiles</filename> с сайта Gentoo, и за казенный счет, разумеется :-)</para>
    </section>
    <section>
        <title>Этап четвертый: в недра ядра</title>
        <para>На предыдущем этапе были перестроены все компоненты базовой системы, кроме одного — зато самого главного: ядра системы. Перекомпиляция ядра — процедура, рано или поздно неизбежная для пользователя любого дистрибутива Linux, даже самого user-ориентированного. Перед пользователем же Source Based дистрибутива она встает с неотвратимостью рока уже при установке системы.</para>
        <para>Gentoo — опять не составляет исключения. Хотя в заключительных разделах я расскажу, как при крайней необходимости можно обойти этот этап, однако по хорошему к тому нет никаких причин. И потому, хотя тема пересборки ядра — совершенно отдельная, и нам придется еще не раз к ней возвращаться, применительно случаю постараюсь осветить ее здесь в минимально возможном объеме.</para>
        <para>Чтобы пересобрать ядро, для начала нужно иметь его исходники. Ни на инсталляционном диске, ни в составе тарбаллов stage2-3 мы их не найдем. Что делать?</para>
        <para>При подключении к Сети — все просто: к нашим услугам система портежей. Отправляемся в каталог /usr/portage, просматриваем содержимое подкаталога sys-kernel — и остается только дивиться свалившемуся на голову богачеству: даже отметая классово чуждые портежи ядер для Sparc, PPC, Alpha, на выбор предоставляется чуть не дюжина вариантов. Подчеркну, речь идет не о прекомпилированных ядрах, а именно о вариантах исходников, снабженных патчами, обеспечивающими дополнительные опции относительно ядра первозданного.</para>
        <para>Разумеется, и последнее, каноническое ядро от Линуса Торвальдса — тоже доступно (под известным именем vanilla-sources) для тех, кто хочет быть святее папы римского. Далее — фирменная коронка, gentoo-sources, это — лучший выбор с точки зрения функциональности). Ну и ac-sources — ядро от Алана Кокса, в патчах которого обычно воплощены новейшие достижения ядреной науки и техники.</para>
        <para>Есть и более специфичные варианты: usermode-sources — ядро для запуска Linux в Linux, в т.н. пользовательской моде (предназначается обычно для тестирования); openmosix-sources — ядро с поддержкой одноименной (openMosix) кластерной технологии, и т.д..</para>
        <para>Так что в этих условиях главное — определиться с выбором. А потом — простая команда</para>
        <screen><prompt>$</prompt> <userinput>emerge sys-kernel/name-sources</userinput></screen>
        <para>некоторый период ожидания, пока скачиваются сами исходники ядра и все необходимые патчи , еще чуть-чуть времени на развертывание архивов — и вперед, в каталог <filename>/usr/src/linux</filename> для конфигурирования.</para>
        <para>При наличии предусмотрительно скачанных исходников ядра, наиболее явно необходимых патчей и модемного подключения — сложнее, но не намного. Выполняем ту же команду. Если повезет — все по прежней схеме, но предупреждаю, шансов на это мало: почти наверняка при предварительном скачивании какой-то Gentoo-специфичный патч будет пропущен (учтем также наше пока еще очень ограниченное знакомство с системой портежей вообще — в дальнейшем такой ситуации можно и избежать). Но не беда: получив сообщение об ошибке, соединяемся с Сетью и либо скачиваем недостающий патч вручную (хоть через браузер lynx — полный адрес к недостающему компоненту будет выведен), либо (и это, товарищи, правильнее) запускаем процедуру по новой. Разорвав соединение по завершении установки исходников ядра.</para>
        <para>И не нужно бояться, что это больно ударит по карману: при соединении по линии, способной вынести протокол V90, скачивание большинства патчей занимает минуты. И wget при обрыве коннекта способен к докачке — так что непроизводительные расходы сведены к минимуму.</para>
        <para>Хуже, если нет ни полного комплекта исходников, ни модема. И это не смертельно, но придется кое-чем поступиться (надеюсь, не принципами). То есть: просто тупо распаковываем архив исходников ядра в каталог <filename>/usr/src</filename>, распаковываем и накладываем минимально необходимые патчи, далее — обычным порядком, как описано ниже. Можно и просто ограничиться каноническим ядром Линуса. Недостаток — кроме возможных потерь некоторых функций, эти действия не будут зафиксированы в базе данных портежей (имеющей место пребывания в каталоге <filename>/var/db/pkg</filename>), то есть система портежей о них как-бы и не узнает (на самом деле — не совсем, но все равно — этот способ может рассматриваться как временное решение).</para>
        <para>И еще одно временное решение — вообще отказаться от пересборки ядра. А как при этом получить возможность загрузить систему — я расскажу под занавес (если вы к тому времени сами не догадаетесь).</para>
        <para>В любом случае, кроме последнего, исходники ядра мы получили, так что можно отправляться в вышеупомянутый каталог <filename>/usr/src/linux</filename> (или <filename>/usr/src/linux-<replaceable>номер_версии-имя_варианта</replaceable></filename>, без разницы, — первый лишь символическая на него ссылка). И давать команду</para>
        <screen><prompt>$</prompt> <userinput>make menuconfig</userinput></screen>
        <para>которая сгенерирует меню настройки опций ядра. Любители отвечать черному экрану могут выбрать и <command>make config</command> — но я к ним не принадлежу.</para>
        <para>Сам процесс конфигурирования описывать не буду — это совсем другая история. Отмечу только обязательные опции. Первая из них — поддержка экспериментальных и разрабатываемых опций: большинство продвинутых возможностей ядра Linux описываются именно этими терминами (что не мешает им функционировать вполне справно). В секции файловых систем необходимо отметить поддержку файловых систем процессов (procfs), файловой системы виртуальной памяти (Virtual Memory Filesystem) и файловой системы устройств (devfs). И, конечно же, тех файловых систем, которые были размещены на созданных разделах (например, XFS или ext3fs — про поддержку ext2fs, надеюсь, не забудет ни один линуксоид). Ну и учесть поддержку требуемых устройств — сами знаете, что у вас вкручено в машине.</para>
        <para>Закончив с конфигурированием, выходим из системы меню (не забыв сохранить изменения) и даем последовательность команд:</para>
        <screen><prompt>$</prompt> <userinput>make dep</userinput>
<prompt>$</prompt> <userinput>make clean</userinput>
<prompt>$</prompt> <userinput>make bzImage</userinput>
<prompt>$</prompt> <userinput>make modules</userinput>
<prompt>$</prompt> <userinput>make modules_install</userinput></screen>
        <para>Разумеется, не обязательно последовательно, можно и одной строкой, разделяя символом ; (или, правильнее, &amp;&amp;). А то и вообще в форме, рекомендованной руководством:</para>
        <screen><prompt>$</prompt> <userinput>make dep &amp;&amp; make clean bzImage modules modules_install</userinput></screen>
        <para>Теперь остается только скопировать образовавшийся образ ядра в загрузочный каталог</para>
        <screen><prompt>$</prompt> <userinput>cp /usr/src/linux/arch/i386/boot/bzImage /boot</userinput></screen>
        <para>И ядерный вопрос можно считать закрытым. Хотя остается еще вопрос, косвенным образом с ним связанный — программы поддержки файловых систем. Их, в соответствие с выбором и предпочтениями, устанавливаем через систему портежей, например, команда</para>
        <screen><prompt>$</prompt> <userinput>emerge sys-apps/xfsprogs</userinput></screen>
        <para>установит все необходимое для работы с файловой системой XFS. Напомню, что архив исходников пакета xfsprogs должен иметься в каталоге distfiles.</para>
        <para>Попутно через систему портежей можно установить и другие программы, однако я пока ограничился бы только тем, что облегчит завершение конфигурирования, а именно — службой консольной мыши:</para>
        <screen><prompt>$</prompt> <userinput>emerge sys-libs/gpm</userinput></screen>
        <para>А теперь активизируем ее. Если мы имеем наиболее типичного ныне грызуна с колесиком и под разъем PS/2, это будет выглядеть так:</para>
        <screen><prompt>$</prompt> <userinput>gpm -t imps2 -m /dev/psaux</userinput></screen>
        <para>И на следующих этапах гораздо проще будет выделять нужные фрагменты и вставлять их щелчком средней клавиши, нежели набрать вручную.</para>
    </section>
    <section>
        <title>Финал: постинсталляционное конфигурирование</title>
        <para>Собственно установка на этом закончена. Осталось довести систему до идеала не только изнутри, но и снаружи. И первый шаг здесь — настройка часового пояса: для Source Based дистрибутивов это не последнее дело (утилита управления компиляцией make обращает внимание на даты создания файлов). Реализуем просто: созданием символической ссылки</para>
        <screen><prompt>$</prompt> <userinput>ln -sf /usr/share/zoneinfo/path/timezonefile /etc/localtime</userinput></screen>
        <para>Рискну предположить, что компонент пути path/timezonefile для большинства моих читателей окажется в диапазоне от Europe/Kaliningrad до Asia/Kamchatka (наличие Анадыря в нашей стране почему-то упорно игнорируется — но, слава богу, хоть о Петропавловске-Камчатском знают). Если системное время в BIOS установлено на не время по Гринвичу, дополнительно потребуется внести коррективы в файл <filename>/etc/rc.conf</filename>.</para>
        <para>Теперь увековечим монтирование новых файловых систем. Как? — очень просто, лобовым редактированием ответственного за сие файла <filename>/etc/fstab</filename>. Вызываем его:</para>
        <screen><prompt>$</prompt> <userinput>nano -w /etc/fstab</userinput></screen>
        <para>И видим, если исключить комментарии, следующую картину:</para>
        <screen>/dev/BOOT             /boot         ext2       noauto,noatime    1 1
/dev/ROOT             /             xfs        noatime           0 0
/dev/SWAP             none          swap       sw                0 0
/dev/cdroms/cdrom0    /mnt/cdrom    iso9660    noauto,ro         0 0
proc                  /proc         proc       defaults          0 0

#tmpfs                /dev/shm      tmpfs      defaults          0 0</screen>
        <para>Если мы следовали рекомендациям инструкции, остается только заменить символы верхнего регистра конкретными реалиями, как то: <filename>/dev/hda1</filename>, <filename>/dev/hda3</filename>, <filename>/dev/hda2</filename>. Или, что будет более корректно, <filename>/dev/discs/disc0/part1</filename> и т.д., сняв при этом комментарий со строки <code>#tmpfs</code>. Если же использовалась какая-либо иная схема разбиения — можно в одной из ранее активизированных консолей с помощью команды mount без аргументов подсмотреть, какой раздел с какой файловой системой куда монтировался. И просто перетащить мышью (не зря же мы ее запускали) соответствующие значения в наш <filename>/etc/fstab</filename>. Ну и всякого рода коррективы (типа монтирования FAT-разделов, флоппи-дисков, zip-накопителей и еще чего требуется) также никто не запрещает.</para>
        <para>Внимательный читатель обратил внимание — в строке <code>/dev/BOOT</code> по умолчанию стоит значение noauto, предписывающее не монтировать соответствующий раздел автоматически при старте системы. Именно так рекомендуется делать при использовании GRUB — он принят в Gentoo в качестве загрузчика по умолчанию. Так вот, настало время обеспечить загрузку системы. Для этого даем команду grub и после появления одноименного приглашения последовательно вводим:</para>
        <screen><prompt>grub&gt;</prompt> <userinput>root (hd0,0)</userinput>
<prompt>grub&gt;</prompt> <userinput>setup (hd0)</userinput></screen>
        <para>вслед за чем выходим из программы:</para>
        <screen><prompt>grub&gt;</prompt> <userinput>quit</userinput></screen>
        <para>Начальный загрузчик установлен в первый раздел первого диска, тот самый, который в текущий момент смонтирован у нас как <filename>/boot</filename>. И который в дальнейшем не будет монтироваться автоматически — дополнительная защита, в первую очередь от человеческого фактора. Так что в дальнейшем не следует удивляться, если, собрав новое ядро системы, вы не сможете его сразу скопировать в каталог <filename>/boot</filename> — предварительно оный придется смонтировать вручную.</para>
        <para>Теперь остается GRUB настроить. Для этого посредством того же редактора создаем файл его меню:</para>
        <screen><prompt>$</prompt> <userinput>nano -w /boot/grub/menu.lst</userinput></screen>
        <para>и записываем в него две секции. Строки первой относятся к GRUB в целом:</para>
        <programlisting>default 0
timeout <replaceable>[значение_в_секундах]</replaceable>
splashimage=(hd0,0)/boot/grub/splash.xpm.gz</programlisting>
        <para>Она указывает на ОС, загружаемую по умолчанию, время ожидания выбора в секундах и описывает путь к файлу графической заставки. Последняя штатно — нечто вроде аметиста с морионовым оттенком. Не нравится — заставку можно убрать (стерев или закомментировав третью строку). Или — изготовить собственную соответствующем формате.</para>
        <para>Вторая секция описывает непосредственно загрузку Gentoo.</para>
        <programlisting>title=My Love Gentoo Linux
root (hd0,0)
kernel /boot/<replaceable>имя_образа</replaceable> root=/dev/hda3</programlisting>
        <para>Первая строка — произвольное название пункта меню. Вторая определяет имя устройства, с которого будет загружаться система. Имя это дается в нотации GRUB, отличной от принятой в Linux: дело в том, что GRUB способен загрузить ядро с не смонтированной файловой системы, относящейся к незагруженной операционке. И это распространяется не только на Linux, но на практически любую ОС из клана свободных Unix'ов (например, на FreeBSD или OpenBSD). </para>
        <para>В третьей строке определяется имя образа ядра, подлежащего загрузке, и устройство, на котором после этого будет располагаться корневая файловая система. Если мы собирали собственное ядро, в качестве образа будет выступать тот самый файл <filename>/boot/bzImage</filename>, который был скопирован в каталог <filename>/boot</filename> после компиляции. Если же ядро не собиралось, значение kernel, как будет показано ниже, проще всего определить как <filename>/boot/linux</filename>. А имя устройства с корневым каталогом на этот раз дается в нотации Linux — ведь соответствующее ядро уже загружено, и оно знает, что такое <filename>/dev/hda?</filename>.</para>
        <para>Напомню еще раз, что все действия по редактированию меню GRUB можно выполнить, просто перетаскивая мышью соответствующие фрагменты руководства (там приведены все необходимые примеры) в наш <filename>/boot/grub/menu.lst</filename> и редактируя их в соответствии с собственными реалиями.</para>
    </section>
    <section>
        <title>И всё же — суперфинал</title>
        <para>Настройкой загрузчика можно считать завершенной официальную часть инсталляции. Однако для полного счастья не хватает еще некоторых штрихов. Так, руководство рекомендует (и это — более чем резонно) оптимизировать режим работы жесткого диска на предмет использования DMA — что весьма способствует его быстродействию. Для такого рода штук предназначен файл <filename>/etc/conf.d/local.start</filename>. Открываем его в редакторе и после комментария (по умолчанию там больше ничего нет) приписываем строку</para>
        <programlisting>hdparm -d 1 /dev/hda</programlisting>
        <para>Если физических дисков больше одного — повторяем ее для каждого устройства. А затем, воспользовавшись случаем, обеспечим здесь же и загрузку консольной мыши при старте системы:</para>
        <programlisting>gpm -t imps2 -m /dev/psaux</programlisting>
        <para>Теперь обратимся к локализации. Не смотря на свое исходно американское происхождение, Gentoo — дистрибутив интернациональный (это ясно из состава команды его разработчиков). И потому в нем есть все базовые средства для работы с языками, отличными от американского. Нужно только немного потрудиться для их активизации.</para>
        <para>Достигается это можно редактированием файла <filename>/etc/rc.conf</filename>. Что может показаться необычным для пользователей Linux. Но мы помним, что в Gentoo принят порядок начальной загрузки в стиле BSD (а не в стиле System V, как в большинстве распространенных дистрибутивов Linux, за исключением Slackware и его сородичей). Впрочем, вдаваться в подробности пока не буду — это тема для отдельной беседы. Пока же — голая практика: все, что мы хотим видеть загруженным при старте машины, должно быть явным образом указано в файле <filename>/etc/rc.conf</filename>. И именно в том порядке, в каком требуется.</para>
        <para>Так что открываем этот универсальный файл</para>
        <screen><prompt>$</prompt> <userinput>nano -w /etc/rc.conf</userinput></screen>
        <para>отыскиваем в начале его строку</para>
        <programlisting>KEYMAP="us"</programlisting>
        <para>и заменяем чуждую нам Америку на что-нибудь родное, от братчиков Кирилла и Мефодия. Что именно — определяем в какой-либо из иных виртуальных консолей командой</para>
        <screen><prompt>$</prompt> <userinput>ls /usr/share/keymaps/i386/qwerty/ru*</userinput></screen>
        <para>В ответ она выведет на экран такой список:</para>
        <screen>/usr/share/keymaps/i386/qwerty/ru1.map.gz
/usr/share/keymaps/i386/qwerty/ru2.map.gz
/usr/share/keymaps/i386/qwerty/ru3.map.gz
/usr/share/keymaps/i386/qwerty/ru4.map.gz
/usr/share/keymaps/i386/qwerty/ru-cp1251.map.gz
/usr/share/keymaps/i386/qwerty/ru.map.gz
/usr/share/keymaps/i386/qwerty/ru-ms.map.gz
/usr/share/keymaps/i386/qwerty/ru_win.map.gz
/usr/share/keymaps/i386/qwerty/ru-yawerty.map.gz</screen>
        <para>Можно видеть, что в нем присутствуют кириллические раскладки на все случаи жизни (а пути к ним, хотя и взяты с Live CD, соответствуют тем, что будут в инсталлированной системе). Дело, конечно, сугубо личное (я бы даже сказал, интимное), но по мне предпочтительна ru4: это раскладка для кодировки KOI8-R с Windows-маркировкой клавиш (не путать с собственно раскладкой для Windows-кодировки — ее, как видно из списка, тоже можно использовать) и переключением с латиницы на кириллицу по нажатию CapsLock. Так что вписываем</para>
        <programlisting>KEYMAP="ru4"</programlisting>
        <para>и переходим к следующей строке, определяющей экранный шрифт консоли — <code>CONSOLEFONT</code>. Очевидно, что умолчальное ее значение описывает шрифт без символов кириллицы. Но — их у нас есть, в чем легко убедиться, просмотрев каталог <filename>/usr/share/consolefonts</filename>. Шрифтов там немерянно, и среди них легко отыскиваются семейства <filename>alt-*.psf.gz</filename> и <filename>cp866-*.psf.gz</filename>. И то, и другое нам (почти) подходит — это экранные шрифты с символами кириллицы в кодировке CP866 (она же — альтернативная, кодировка DOS или IBM). Почему так — ведь мы только что установили раскладку KOI8-R для клавиатуры, да и шрифты (семейства <filename>koi8r-*.gz</filename>), имеются? Распространяться не буду, ограничившись словами: это лучше, Леня.</para>
        <para>А слово "почти" я добавил потому, что все имеющиеся стандартно кириллические шрифты далеки от совершенства как эстетически, так и медицински. Так что в дальнейшем лучше будет воспользоваться шрифтами из пакета Виктора Вагнера console-tools-cyrillic — там есть очень симпатичные экземпляры, но об этом — как-нибудь в другой раз. Пока же просто вписываем, например,</para>
        <programlisting>CONSOLEFONT="cp866-8x16"</programlisting>
        <para>И начинаем рассуждать логически: как же так, раскладка клавиатуры KOI8, а кодировка экранного шрифта — CP866. Ясно, что без загрузки карты трансформации одного в другое не обойтись. И такая карта у нас есть тоже — в каталоге <filename>/usr/share/consoletrans</filename> обнаруживаем файл koi2alt. Имя которого и вписываем в строку</para>
        <programlisting>CONSOLETRASLATION="koi2alt"</programlisting>
        <para>сняв с нее предварительно стоящий по умолчанию комментарий. Откладываем в уме, что таким образом карта соответствия будет загружена только на одной, первой, из виртуальных консолей (она же — консоль системная) — к этому мы еще вернемся. А пока, дабы покончить с файлом /etc/rc.conf, вспоминаем, что системные часы нашей машины установлены по местному часовому поясу (скорее всего — хотя в последнее время я осознал преимущества времени гринвичского) — тому самому, который мы определили через файл-ссылку <filename>/etc/localtime</filename>. И обращаем внимание, что строка</para>
        <programlisting>CLOCK="UTC"</programlisting>
        <para>указывает у нас, напротив, именно на время по Гринвичу (UTC=GMT). Заменяем UTC на localtime — и файл <filename>/etc/rc.conf</filename> можно закрывать (прочие его строки можно оставить без изменений, если вам лично не известны веские причины их сделать).</para>
        <para>А вот теперь пора довести до конца дело с картами соответствия. Открываем файл <filename>/etc/init.d/local</filename>: как явствует из названия, он предназначен для всякой всячины местного значения (и исполняется после всех остальных конфигурационных файлов). И вставляем в его конец с помощью редактора (или перетаскиваем мышью из данного руководства) простенький скрипт (оператор цикла):</para>
        <programlisting>for i in 1 2 3 4 5 6
        do
        echo -ne '' &gt; /dev/vc/$i
done</programlisting>
        <para>В первой его строке определяется значение переменной <varname>i</varname> (ее можно обозвать любым другим образом) как диапазона цифр от 1 до 6 (по умолчанию у нас именно шесть виртуальных консолей), вторая — указывает, что следующей строкой будет тело цикла. А тело цикла — вывод "магической последовательности" ESC-(K (именно она и обеспечивает активизацию карты соответствия) и ее перенаправление на виртуальные консоли, номера которых заданы переменной <varname>i</varname>, то есть <filename>/dev/vc/1</filename> — <filename>/dev/vc6</filename>. Это — если используется файловая система устройств (devfs), в противном случае (если не был снят комментарий со строки tmpfs в файле <filename>/etc/fstab</filename>) имена консолей будут обычными — <filename>/dev/tty0</filename> - <filename>/dev/tty5</filename>.</para>
        <para>Отступление для любовников (или невольников) кодировки CP1251. Все сказанное о русификации применимо и к ней. Нужно только определить в файле <filename>/etc/fstab</filename> загрузку соответствующих раскладки клавиатуры (они, как уже говорилось, имеются) и карты соответствия CP1251-&gt;CP866. А вот ее придется поискать (где — за ненадобностью не помню) или просто слямзить из любого отечественного дистрибутива — Altlinux или ASPLinux.</para>
        <para>Все же открою секрет — почему в консоли в любом случае предпочтительны экранные шрифты в кодировке DOS. Так уж исторически сложилось: вследствие аппаратных особенностей VGA-адаптеров (а в консоли мы имеем дело именно с режимом VGA, сколь бы крутой GeForce не стоял в машине) только они обеспечивают нормальный вывод на экран символов псевдографики. Кроме того, их просто больше, и некоторые среди них, как я говорил, лучше. Так что есть резон загружать именно их, даже если программы с псевдографикой не используются совсем. В том числе и Midnight Commander — но какой же русский не любит детей командира Нортона!</para>
        <para>Мы же пока завершим русификацию. Для чего установим собственно локаль последней строкой в файле <filename>/etc/init.d/local</filename> (опять прекрасный каламбур, господа!):</para>
        <programlisting>export  LANG="ru_RU.KOI8-R"</programlisting>
        <para>Она обеспечит установку всех локально-зависимых переменных (не только страны, языка, набора символов, но и формата даты, времени, денежной единицы, и так далее) в значения, принятые для нашей многострадальной Отчизны. Тем не менее, для представления чисел я сделал бы исключение, добавив строку</para>
        <programlisting>export  LC_NUMERIC="POSIX"</programlisting>
        <para>Ведь в любых программах, связанных со счетом, удобнее оперировать с десятичной точкой, а не запятой (а говорят, что некоторые такие программы этого просто требуют).</para>
        <para>В итоге, выполнив несложную последовательность действий, мы получили корректно русифицированную систему — русифицированную ничуть не хуже, чем те дистрибутивы, кириллической поддержкой в которых гордятся (и — справедливо гордятся) именитые отечественные разработчики — Altlinux и ASPLinux. А поскольку мы сделали все это своими руками и с полным пониманием сути действий, у нас тоже есть основание для гордости. Правда, "лобовым" способом, без учета специфики дистрибутива — но зато работающим всегда и везде. А к "идеологически правильному" (для Gentoo) методу локализации можно будет вернуться позднее.</para>
        <para>Можно, конечно, активизировав внесенные в конфигурацию изменения командой etc-update, продолжать устанавливать программы (Иксы, например). Или даже начинать обычную работу — установленная система, внутри которой мы находимся, это вполне уже позволяет. Однако для полной проверки лучше все-таки сначала перезагрузиться.</para>
        <para>Итак, временно расстаемся с нашим новым Gentoo командой <command>exit</command>, после чего вновь оказываемся в системе Live CD, той же командой зарываем все виртуальные консоли, кроме первой (а у нас их могло расплодиться немало) и готовимся к выходу.</para>
        <para>Хотя — стоп. А собирали ли мы при установке ядро системы. Если да — все в порядке, тотальный unmount:</para>
        <screen><prompt>$</prompt> <userinput>umount /mnt/gentoo/boot</userinput>
<prompt>$</prompt> <userinput>umount /mnt/gentoo</userinput></screen>
        <para>и что было смонтировано руками, а затем — <command>reboot</command> (или <command>halt</command>, если есть желание прерваться — при первой загрузке хорошо бы внимательно следить за ее ходом по сообщениям на экране).</para>
        <para>Если же ядро не собиралось (за отсутствием каких-то исходников — другого оправдания такому разгильдяйству нет), то совершаем последнее установочное действие: просто тупо копируем ядро с Live CD (оно, как мы уже убедились, не только работоспособно, но и поддерживает большинство жизненно необходимых функций):</para>
        <screen><prompt>$</prompt> <userinput>cp /cdroot/boot/linux /mnt/gentoo/boot/</userinput></screen>
        <para>Правда, у нас не собиралось не только ядро, но и модули. И это не беда, их тоже копируем с CD:</para>
        <screen><prompt>$</prompt> <userinput>cp -R /cdroot/lib/modules /mnt/gentoo/lib/modules</userinput></screen>
        <para>А далее — все то же, размонтирование и перезагрузка. Конечно, в ходе ее мы рискуем получить кое-какие сообщения об ошибках, но, по моему опыту — ни одна из них не критична. И загрузившаяся система будет вполне пригодной к использования. По крайней мере, до тех пор, пока не разживемся всеми необходимыми архивами и все-таки ядро не пересоберем — от этого все равно не уйти.</para>
    </section>
    <section>
        <title>Заключительный аккорд</title>
        <para>У терпеливого читателя, добравшегося до этих строк, может возникнуть три совершенно законных вопроса: не слишком ли все это сложно, на кой все это нужно, и кому все это нужно. Постараюсь ответить последовательно.</para>
        <para>Относительно сложности — могу заверить, что это из той самой оперы, когда глаза боятся, а руки делают. Проверено на собственном опыте — причем первый из них проводился в подмосковной деревне, где не то что постоянного подключения к Сети — и телефона-то с модемом не было. И все исходники скачивались на службе (в полутора часах езды) и таскались домой на CD и съемном винчестере. И если праведно выполнять все заветы инструкции по установке, то сложностей возникнет не много (надеюсь, что и настоящий мемуар поспособствует их преодолению).</para>
        <para>Второй вопрос — а зачем их было преодолевать, когда можно легко и быстро развернуть любой пакетный дистрибутив, разработчики которого уже решили все мои проблемы. Отвечаю: решить-то они решили, но — не скажу плохо, просто в меру своих представлений, как это нужно народу (и конкретно мне, как его представителю). Gentoo же позволяет не просто поставить систему, идеально оптимизированную под железо, но и настроить ее тоже в соответствие именно со своим представлением об идеале. Причем — с полным осознанием, что и зачем делается, немало способствующим общему образованию.</para>
        <para>Ну а третий ответ очевиден из второго. Дистрибутив Gentoo нужен пользователю, которому требуется система, настроенная на максимальную производительность для конкретной тяжелой задачи — счетной, графической, GIS или CAD. Разработчику, которому надоело проводить время компиляции тысяч и тысяч строк кода за игрой в тетрис. Сисадмину, у которого в системе не должно быть ничего лишнего, но все необходимое должно быть. Изучающему Linux, которого не устраивают готовые рецепты, предлагаемые руководствами пакетных дистрибутивов. И наконец, тому, кто просто стремится к идеалу — пусть идеал этот и недостижим...</para>
    </section>
</article>
