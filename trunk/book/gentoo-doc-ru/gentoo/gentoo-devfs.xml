<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbookxi.rng" type="xml"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <info>
        <title>Руководство по файловой системе для устройств</title>
    </info>
    <para>Ссылка на оригинал: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gentoo.org/doc/ru/devfs-guide.xml">http://www.gentoo.org/doc/ru/devfs-guide.xml</link>
    </para>
    <para>C версии: 1.0</para>
    <section>
        <title>Что такое devfs?</title>
        <section>
            <title>Старые (добрые?) времена</title>
            <para>Традиционная реализация Linux предоставляет пользователю абстрактный каталог устройств, называемый <filename>/dev</filename>. Внутри этого каталога находятся device nodes, специальные файлы, символизирующие устройства внутри системы. Например, <filename>/dev/hda</filename> символизирует первое IDE устройство в вашей системе. Файлы устройств позволяют создавать программы, которые взаимодействуют с устройствами так, как если бы устройства были обычными файлами, вместо использования специальных API. </para>
            <para>Файлы устройств подразделяются на две группы, называемые character devices (символьные устройства) и block devices (блочные устройства). Первая группа содержит устройства, для котрых отсутствует буферизация чтения/записи. Вторая группа, естественно, содержит устройства, для которых чтение/запись буферизируется. Из обоих типов устройств может быть прочитан за раз один символ или блок. Поэтому такой способ присваивания имён может сбивать с толку и на самом деле неправилен. </para>
            <para>Если посмотреть на конкретное устройство, можно обнаружить что-то, похожее на это: </para>
            <example>
                <title>Исследование информации о файле устройства</title>
                <screen><prompt>#</prompt> <userinput>ls -l /dev/hda</userinput>
brw-rw----    1 root     disk       3,   0 Jul  5  2000 /dev/hda</screen>
            </example>
            <para>В предыдущем примере мы увидели, что <filename>/dev/hda</filename> — это блочное устройство. Однако важнее то, что ему присвоено два специальных номера <code>3, 0</code>. Эта пара называется <emphasis role="italic">major-minor</emphasis>. Она используется ядром, чтобы соотнести файл устройства и реальное устройство. major (старший) относится к типу устройства, minor (младший) к конкретному устройству. Выглядит запутано, не правда ли? </para>
            <para>Ещё два примера — <filename>/dev/hda4</filename> и <filename>/dev/tty5</filename>. Первое устройство соответствует четвёртому разделу на первом IDE-устройстве. Его пара major-minor <code>3, 4</code>. Другими словами, minor соответствует разделу, тогда как major соответствует устройству. Во втором примере пара major-minor — <code>4, 5</code>. В этом случае первое число соответствует драйверу терминала, тогда как второе соответствует номеру терминала (в данном случае пятый терминал). </para>
        </section>
        <section>
            <title>Проблемы</title>
            <para>Если вы заглядывали в папку <filename>/dev</filename>, вы обнаружили, что там перечислены не только все ваши устройства, но и все возможные устройства, которые только могут быть. Другими словами, у вас есть файлы устройств для устройств, которых у вас нет. Управление такой кучей устройств по крайней мере можно назвать громоздким. Представьте, что надо поменять права на все устройства, реально существующие в вашей системе, оставив остальные без изменений. </para>
            <para>Затем вы добавили новое оборудование в вашу систему, для него может не оказаться уже существующего файла. Продвинутые пользователи знают, что эта задача может быть выполнена с помощью команды <command>./MAKEDEV</command> внутри директории <filename>/dev</filename>, но разве вы сразу знаете, что за устройство вам придётся создать? </para>
            <para>Когда у вас есть программы, взаимодействующие с оборудованием при помощи файлов устройств, вы не можете смонтировать корневой раздел только для чтения, в то время как в дальнейшем нет необходимости в том, чтобы он был смонтирован на чтение и запись. И вы не можете иметь <filename>/dev</filename> на отдельном разделе, так как mount необходим, <filename>/dev</filename> чтобы монтировать разделы. </para>
        </section>
        <section>
            <title>Решения</title>
            <para>Как вы могли себе представить, kernel hackers нашли достаточно решений для вышеперечисленных проблем. Однако многие из этих решений имеют собственные проблемы описанные в <link xlink:href="http://www.atnf.csiro.au/people/rgooch/linux/docs/devfs.html#faq-why">http://www.atnf.csiro.au/people/rgooch/linux/docs/devfs.html#faq-why</link>. Мы не будем обсуждать эти варианты, а сконцентрируемся на одном способе, который был реализован в официальной версии исходников ядра: </para>
        </section>
        <section>
            <title>devfs как абсолютный победитель?</title>
            <para>devfs решает все перечисленные проблемы. Она просто предоставляет пользователю доступ к существующим устройствам, добавляет новые device nodes (файлы устройств), когда найдены новые устройства, и делает возможным монтировать корневую файловую систему в режиме read only (только чтение). А также решает многие проблемы, которые мы раньше не обсуждали, потому что они не так интересны для пользователей... </para>
            <para>Как пример, с devfs вам не надо беспокоится о паре major/minor. Она продолжат поддерживаться (для обратной совместимости), но в ней нет необходимости. Это позволяет Linux поддерживать ещё больше устройств, так как больше нет ограничений (числа всегда имеют границы :) </para>
            <para>Однако у devfs есть свои проблемы, не столь очевидные для пользователей, но достаточно серьезные, чтобы разработчики ядра пометили ее как obsolete (устаревшее), порекомендовав использовать <link xlink:href="#">udev</link>, которая также поддерживается Gentoo. </para>
            <para>Чтобы узнать, почему devfs считается устаревшей, читайте <link xlink:href="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev-FAQ">udev FAQ</link> и <link xlink:href="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev_vs_devfs">udev versus devfs document</link>. </para>
        </section>
    </section>
    <section>
        <title>Навигация через дерево устройств</title>
        <section>
            <title>Директории</title>
            <para>Одна из первых особенностей которые вы можете заметить это то что devfs использует директории для объединения устройств вместе. Это повышает читабельность, так как теперь все связанные между собой устройства находятся внутри одной общей директории. </para>
            <para>Например, все устройства, относящиеся к IDE, находятся в директории <filename>/dev/ide/,</filename> а все относящиеся к SCSI в директории <filename>/dev/scsi/</filename>. SCSI и IDE диски во многом похожи, у них одинаковая структура поддиректорий. </para>
            <para>IDE и SCSI диски управляются при помощи адаптера (встроенного или отдельной платой), называемого <emphasis role="italic">host</emphasis>. Каждый адаптер может иметь несколько каналов. Канал называется <emphasis role="italic">bus</emphasis>. На каждом канале может быть несколько IDs (идентификаторов). ID служит для идентификации диска. Этот ID называется target. Многие SCSI устройства могут иметь множество LUN (<emphasis role="italic">Logical Unit Numbers</emphasis> — <emphasis role="italic">Номер Логического Устройства</emphasis>), Например устройства которые управляют несколькими носителями одновременно (hi-end tapedrives). У вас скорее всего будет только один lun, <filename>lun0/</filename>. </para>
            <para>Итак, несмотря на то, что раньше использовался <filename>/dev/hda4</filename>, теперь появился <filename>/dev/ide/host0/bus0/target0/lun0/part4</filename>. Это намного проще... нет, не спорьте со мной... это проще... как бы то ни было! :) </para>
            <note>
                <para>Вы также можете использовать более похожие на Unix названия для жёстких дисков, такие как <filename>c0b0t0u0p2</filename>. Они могут быть найдены в <filename>/dev/ide/hd</filename>, <filename>/dev/scsi/hd</filename> и.т.д. </para>
            </note>
            <para>Чтобы дать вам лучше понять идею с директориями, вот листинг директорий которые есть у меня: </para>
            <example>
                <title>Дирректории в <filename>/dev</filename></title>
                <screen>cdroms/     cpu/        discs/          floppy/
ide/        input/      loop/           misc/
netlink/    printers/   pts/            pty/
scsi/       sg/         shm/            sound/
sr/         usb/        vc/             vcc/</screen>
            </example>
        </section>
        <section>
            <title>Обратная совместимость при помoщи devfsd</title>
            <para>Использование этой новой структуры выглядит здорово, но многие утилиты и программы используют предыдущую, старую структуру. Для уверенности, что система не будет нарушена, был создан <command>devfsd</command>. Этот демон создаёт символьные ссылки на новые файлы устройств, но со старыми именами (compatibility symlinks). </para>
            <example>
                <title>Созданные символьные ссылки</title>
                <screen><prompt>$</prompt> <userinput>ls -l /dev/hda4</userinput>
lr-xr-xr-x    1 root     root           33 Aug 25 12:08 /dev/hda4 -> ide/host0/bus0/target0/lun0/part4</screen>
            </example>
            <para>При помощи <command>devfsd</command>, вы можете устанавливать права доступа, создавать новые файлы устройств и т.д. Всё это описывается в следующей главе. </para>
        </section>
    </section>
    <section>
        <title>Администрирование дерева устройств</title>
        <section>
            <title>Перезагрузка devfsd</title>
            <para>Если вы изменили файл <filename>/etc/devfsd.conf</filename>, и хотите чтобы изменения вступили в силу, вым не обязательно перезагружаться. В зависимости от того, что вы хотите, вы можете использовать любой из следующих сигналов: </para>
            <para><emphasis role="bold">SIGHUP</emphasis> заставит <command>devfsd</command> перечитать конфигурационный файл, перегрузить разделяемые объекты (shared objects) и сгенерировать событие REGISTER для каждого листа в дереве устройств. </para>
            <para><emphasis role="bold">SIGUSR1</emphasis> сделает то же самое, но не будет событий REGISTER. </para>
            <para>Чтобы послать сигнал, просто используйте <command>kill</command> или <command>killall</command>:</para>
            <example>
                <title>Посылка сигнала SIGHUP демону devfsd</title>
                <screen><prompt>#</prompt> <userinput>kill -s SIGHUP `pidof devfsd`</userinput>
<lineannotation>или</lineannotation>
<prompt>#</prompt> <userinput>killall -s SIGHUP devfsd</userinput></screen>
            </example>
        </section>
        <section>
            <title>Удаление compatibility symlinks</title>
            <warning>
                <para>В настоящее время Gentoo не может существовать без этих ссылок. </para>
            </warning>
            <para>Если вы хотите удалить из вашей системы ссылки которые засоряют <filename>/dev</filename> (в Gentoo они используются по умолчанию), отредактируйте <filename>/etc/devfsd.conf</filename> и удалите следующие две строчки: </para>
            <example>
                <title><filename>/etc/devfsd.conf</filename> для обратной совместимости</title>
                <programlisting><lineannotation># Закоментируйте эти две строчки для удаления симлинков</lineannotation>
REGISTER        .*  MKOLDCOMPAT
UNREGISTER      .*  RMOLDCOMPAT</programlisting>
            </example>
            <para>Вам придётся перезагрузится, чтобы изменения вступили в силу. </para>
        </section>
        <section>
            <title>Удаление возможности автосоздания файлов устройств</title>
            <para>Когда вы загружаете модуль, devfs автоматически создаёт файлы устройств. Если вы не хотите, чтобы он так делал, удалите эту строчку из <filename>/etc/devfsd.conf</filename>:</para>
            <example>
                <title><filename>/etc/devfsd.conf</filename>, autoload functionality</title>
                <programlisting>LOOKUP      .*  MODLOAD</programlisting>
            </example>
        </section>
    </section>
    <section>
        <title>Вопросы, относящиеся к правам доступа</title>
        <section>
            <title>Установка/изменение прав доступа при помощи PAM</title>
            <para>Хотя вы можете установить права доступа в <filename>/etc/devfsd.conf</filename>, мы советуем использовать <indexterm><primary>Pluggable Authentification Modules</primary></indexterm><indexterm><primary>PAM</primary></indexterm>PAM (<firstterm>Pluggable Authentification Modules</firstterm>). Так как PAM имеет решающий голос при установке прав доступа, и может проигнорировать изменения, которые вы сделали в <filename>/etc/devfsd.conf</filename>.</para>
            <para>PAM использует <filename>/etc/security/console.perms</filename> для установки прав доступа. Файл состоит из двух частей: в первой описываются группы, а во второй права.</para>
            <para>Давайте сначала взглянем на часть с группами. Как пример мы рассмотрим sound-group:</para>
            <example>
                <title>Sound group в <filename>/etc/security/console.perms</filename></title>
                <programlisting>&lt;sound>=/dev/dsp* /dev/audio* /dev/midi* \
    /dev/mixer* /dev/sequencer* \
    /dev/sound/* /dev/snd/* /dev/beep \
    /dev/admm* \
    /dev/adsp* /dev/aload* /dev/amidi* /dev/dmfm* \
    /dev/dmmidi* /dev/sndstat</programlisting>
            </example>
            <para>Синтаксис достаточно прост: вы начинаете с имени группы, и заканчиваете списком устройств, принадлежащих этой группе. </para>
            <para>Теперь для того, чтобы с группами можно было что-нибудь сделать, рассмотрим следующую часть, описывающую, как управлять правами. </para>
            <example>
                <title>Права доступа для sound group в <filename>/etc/security/console.perms</filename></title>
                <programlisting>&lt;console>  0600 &lt;sound>      0600 root.audio</programlisting>
            </example>
            <orderedlist>
                <listitem>
                    <para>Первое поле — это проверка терминала. На большинстве систем это console-group. PAM будет проверять это поле при каждом входе в систему. Если вход произошёл на устройстве, содержащемся в console-group, PAM проверит и возможно сменит права на некоторые файлы устройств. </para>
                </listitem>
                <listitem>
                    <para>Второе поле содержит права, которые установятся на файл устройства после удачного входа в систему. Когда человек вошел в систему, а файлы устройств принадлежат пользователю и группе по умолчанию, PAM сменит владельца на вошедшего пользователя и установит на них права из второго поля. В данном случае используется 0600 (пользователь имеет право на чтение/запись, все остальные нет). </para>
                </listitem>
                <listitem>
                    <para>В третьем поле содержатся группы устройств, чьи права будут изменены. В данном случае, вторая группа (все устройства, относящиеся к звуку) будут изменены. </para>
                </listitem>
                <listitem>
                    <para>Четвёртое поле определяет права, которые будут установлены на файлы устройств после возврата в состояние по умолчанию. Другими словами, если человек, который владеет правами на все файлы устройств, выйдет из системы, PAM установит права обратно в состояние по умолчанию, описанному в этом четвёртом поле. </para>
                </listitem>
                <listitem>
                    <para>Пятое поле определяет собственника (с группой если вам надо) к которому будут установлены атрибуты устройства после возврата в состояние по умолчанию Другими словами, если человек, владеющий правами на все файлы устройств, выйдет из системы, PAM установит собственника обратно в состояние по умолчанию, описанному в пятом поле. </para>
                </listitem>
            </orderedlist>
        </section>
        <section>
            <title>Установка/изменение прав доступа при помощи devfsd</title>
            <para>Если вы действительно хотите установить права, используя <filename>/etc/devfsd.conf</filename>, тогда используйте синтаксис приведённый в этом примере: </para>
            <example>
                <title>Права в <filename>/etc/devfsd.conf</filename></title>
                <programlisting>REGISTER    ^cdroms/.*  PERMISSIONS root.cdrom 0660</programlisting>
            </example>
            <para>Второе поле — это группа устройств, начиная с <filename>/dev</filename>. Это регулярное выражение, означающее, что вы можете выбрать несколько файлов устройств с одним правилом. </para>
            <para>Четвёртое поле — это владелец файла устройства. В отличие от PAM, он не изменяется (если он не упоминается в <filename>console.perms</filename>, так как PAM главнее). </para>
            <para>Пятое поле содержит права на файлы устройств. </para>
        </section>
        <section>
            <title>Ручная установка прав и их сохранение devfsd</title>
            <para>Это обычная ситуация для Gentoo: если вы делаете <command>chown</command> и <command>chmod</command> некоторым файлам устройств, то <systemitem class="daemon">devfsd</systemitem> сохраняют информацию, когда вы вы выключаете систему. Это происходит из-за того, что файл <filename>/etc/devfsd.conf</filename> содержит следующие строчки: </para>
            <example>
                <title><filename>/etc/devfsd.conf</filename> для сохранения прав доступа</title>
                <programlisting>REGISTER        ^pt[sy]/.*   IGNORE
CHANGE          ^pt[sy]/.*   IGNORE
CREATE          ^pt[sy]/.*   IGNORE
DELETE          ^pt[sy]      IGNORE
REGISTER        ^log         IGNORE
CHANGE          ^log         IGNORE
CREATE          ^log         IGNORE
DELETE          ^log         IGNORE
REGISTER        .*           COPY    /lib/dev-state/$devname $devpath
CHANGE          .*           COPY    $devpath /lib/dev-state/$devname
CREATE          .*           COPY    $devpath /lib/dev-state/$devname
DELETE          .*           CFUNCTION GLOBAL unlink
/lib/dev-state/$devname
RESTORE         /lib/dev-state</programlisting>
            </example>
            <para>Другими словами, изменённые файлы устройств копируются в <filename>/lib/dev-state</filename>, когда выключается система, и копируются в <filename>/dev</filename>, когда система грузится. </para>
            <para>Другая возможность - монтировать <filename>/lib/dev-state</filename> в <filename>/dev</filename> во время загрузки. Чтобы это сделать, вы должны быть уверены, что devfs не монтируется автоматически (это значит, что вы должны перекомпилировать ядро), и что <filename>/dev/console</filename> существует. Затем, где-то в начале bootscripts (загрузочных скриптов) вашей системы, вы должны разместить: </para>
            <example>
                <title>Монтирование <filename>/lib/dev-state</filename> в <filename>/dev</filename></title>
                <programlisting>mount --bind /dev /lib/dev-state
mount -t devfs none /dev
devfsd /dev</programlisting>
            </example>
        </section>
    </section>
</article>
