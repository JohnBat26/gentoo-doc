<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbookxi.rng" type="xml"?>
<article xmlns="http://docbook.org/ns/docbook"
        xmlns:xi="http://www.w3.org/2001/XInclude"
        xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
<info><title>Gentoo и СУБД</title></info><section><info><title>Руководство по MySQL для начинающих</title></info>
<para>Ссылка на оригинал: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gentoo.org/doc/ru/udev-guide.xml">http://www.gentoo.org/doc/ru/mysql-howto.xml</link>
</para>
<para>C версии: 1.5</para><section><info><title>1. Начало работы с MySQL</title></info><section><info><title>
<anchor xml:id="doc_chap1_sect1"/>Введение</title></info>
<para>MySQL — это популярный сервер баз данных, используемый в различных областях. Аббревиатура SQL означает Structured Query Language (язык структурированных запросов), именно его использует MySQL для общения с другими программами. Более того, в MySQL есть собственные расширенные функции SQL, дающие дополнительные возможности пользователям. В этом руководстве рассматривается процесс начальной установки MySQL, настройка баз данных и таблиц, заведение новых пользователей. Итак, начнем с установки. </para></section><section><info><title>
<anchor xml:id="doc_chap1_sect2"/>Установка MySQL</title></info>
<para>Сначала нужно установить MySQL. Если вам нужны определенные возможности MySQL, установите соответствующие флаги USE, которые позволяют точнее регулировать процесс установки. </para>
<para>
<anchor xml:id="doc_chap1_pre1"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1.1: Установка MySQL</para>
</entry>
</row>
<row>
<entry>
<para>(просмотр имеющихся флагов USE)</para>
<para># emerge --pretend --verbose mysql</para>
<para>(установка MySQL)</para>
<para># emerge mysql</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>По завершении установки вы увидите такое сообщение: </para>
<para>
<anchor xml:id="doc_chap1_pre2"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1.2: Сообщение программы MySQL einfo</para>
</entry>
</row>
<row>
<entry>
<para>You might want to run:</para>
<para>"emerge --config =dev-db/mysql-[version]"</para>
<para>if this is a new install.</para>
<para/>
<para>Рекомендуется запустить команду</para>
<para>"emerge --config =dev-db/mysql-[версия]"</para>
<para>после первоначальной установки MySQL.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Поскольку у нас первоначальная установка, запустим команду. Во время настройки базы данных MySQL вам потребуется по запросу нажать клавишу ENTER. В процессе настройки устанавливается главная база данных MySQL, содержащая служебные сведения о базах данных, таблицах, пользователях, правах доступа и т.д. При настройке будет рекомендовано как можно раньше изменить корневой пароль. Мы определенно это сделаем, чтобы кто-нибудь не смог улучшить момент и взломать наш сервер MySQL, настроенный по умолчанию. </para>
<para>
<anchor xml:id="doc_chap1_pre3"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1.3: Настройка MySQL</para>
</entry>
</row>
<row>
<entry>
<para># ebuild /var/db/pkg/dev-db/mysql-[version]/mysql-[version].ebuild config</para>
<para> * MySQL DATADIR is /var/lib/mysql</para>
<para> * Press ENTER to create the mysql database and set proper</para>
<para> * permissions on it, or Control-C to abort now...</para>
<para/>
<para>   Preparing db table</para>
<para>   Preparing host table</para>
<para>   Preparing user table</para>
<para>   Preparing func table</para>
<para>   Preparing tables_priv table</para>
<para>   Preparing columns_priv table</para>
<para>   Installing all prepared tables</para>
<para/>
<para>   To start mysqld at boot time you have to copy support-files/mysql.server</para>
<para>   to the right place for your system</para>
<para/>
<para>   PLEASE REMEMBER TO SET A PASSWORD FOR THE MySQL root USER !</para>
<para>   To do so, issue the following commands to start the server</para>
<para>   and change the applicable passwords:</para>
<para>(обратите внимание на следующие 3 строки)</para>
<para>   /etc/init.d/mysql start</para>
<para>   /usr/bin/mysqladmin -u root -h pegasos password 'new-password'</para>
<para>   /usr/bin/mysqladmin -u root password 'new-password'</para>
<para>   Depending on your configuration, a -p option may be needed</para>
<para>   in the last command. See the manual for more details.</para>
<para/>
<para>(различные сообщения, не относящиеся к установке, опущены для краткости)</para>
<para/>
<para>   * For security reasons you should set your MySQL root</para>
<para>   * password as soon as possible.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Важно: Начиная с mysql-4.0.24-r2, пароли вводятся на этапе настройки, что повышает надежность ввода корневого пароля. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Сценарий установки уже отобразил команды, нужные для установки пароля. Теперь запустим их. </para>
<para>
<anchor xml:id="doc_chap1_pre4"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1.4: Установка корневого пароля MySQL</para>
</entry>
</row>
<row>
<entry>
<para># /etc/init.d/mysql start</para>
<para> * Re-caching dependency info (mtimes differ)...</para>
<para> * Starting mysqld (/etc/mysql/my.cnf) ...        [ ok ]</para>
<para>(вместо 'новый-пароль' укажите ваш пароль)</para>
<para># /usr/bin/mysqladmin -u root -h localhost password 'новый-пароль'</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь вы можете убедиться в работоспособности нового пароля, попытавшись войти на свой сервер MySQL: </para>
<para>
<anchor xml:id="doc_chap1_pre5"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1.5: Вход на сервер MySQL программой mysql</para>
</entry>
</row>
<row>
<entry>
<para>$ mysql -u root -h localhost -p</para>
<para>Enter password:</para>
<para>Welcome to the MySQL monitor. Commands end with ; or \g.</para>
<para>Your MySQL connection id is 4 to server version: 4.0.25</para>
<para/>
<para>Type 'help;' or '\h' for help. Type '\c' to clear the buffer.</para>
<para/>
<para>mysql&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Параметр -u указывает пользователя, который будет входить в систему. Параметр -h указывает узел сети. Обычно это localhost, если вы настраиваете не удаленный сервер. Наконец, -p сообщает программе-клиенту mysql, что для доступа к базе данных будет вводится пароль. Обратите внимание на приглашение mysql&gt;. Именно здесь вы будете вводить все свои команды. Теперь, находясь в среде mysql в качестве корневого пользователя, мы можем начать настройку базы данных. </para></section></section><section><info><title>
<anchor xml:id="doc_chap2"/>2.  Настройка базы данных</title></info><section><info><title>
<anchor xml:id="doc_chap2_sect1"/>Создание базы данных</title></info>
<para>Мы вошли, и на экране — приглашение mysql. Сначала взглянем на список уже имеющихся баз данных. Для этого введем команду SHOW DATABASES. </para>
<para>
<anchor xml:id="doc_chap2_pre1"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.1: Вывод списка баз данных MySQL</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SHOW DATABASES;</para>
<para>+----------+</para>
<para>| Database |</para>
<para>+----------+</para>
<para>| mysql    |</para>
<para>| test     |</para>
<para>+----------+</para>
<para>2 rows in set (0.09 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Важно: Запомните, что команды MySQL следует заканчивать точкой с запятой — ; </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Несмотря на то, что база данных test уже создана, создадим свою собственную. Базы данных создаются командой CREATE DATABASE. Мы назовем свою gentoo. </para>
<para>
<anchor xml:id="doc_chap2_pre2"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.2: Создание базы данных gentoo</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; CREATE DATABASE gentoo;</para>
<para>Query OK, 1 row affected (0.08 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Ответ дает понять, что команда выполнена без каких-либо ошибок. В данном случае, изменилась одна строка. Это относится к главной базе данных mysql, в которой содержится список всех баз данных. Но вам не нужно слишком беспокоиться о второстепенных подробностях. Последнее число означает время выполнения запроса. Убедиться, что база данных создана, мы можем, снова запустив команду SHOW DATABASES. </para>
<para>
<anchor xml:id="doc_chap2_pre3"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.3: Проверка наличия базы данных</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SHOW DATABASES;</para>
<para>+----------+</para>
<para>| Database |</para>
<para>+----------+</para>
<para>| gentoo   |</para>
<para>| mysql    |</para>
<para>| test     |</para>
<para>+----------+</para>
<para>3 rows in set (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Разумеется, наша база данных создана. Чтобы заняться созданием таблиц в новой базе данных gentoo, нам потребуется установить ее как текущую. Для этого используем команду USE. Параметром этой команды указывается название базы данных, которую нужно сделать текущей. Еще текущую базу можно устанавливать в командной строке, указывая ее название после параметра -D. Давайте продолжим и переключимся на базу данных gentoo. </para>
<para>
<anchor xml:id="doc_chap2_pre4"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.4: Переключение базы данных</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; USE gentoo;</para>
<para>Database changed</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь текущей является только что созданная база данных gentoo. Теперь, используя ее, мы можем заняться созданием таблиц и наполнением их информацией. </para></section></section><section><info><title>
<anchor xml:id="doc_chap3"/>3.  Работа с таблицами в MySQL</title></info><section><info><title>
<anchor xml:id="doc_chap3_sect1"/>Создание таблицы</title></info>
<para>В структуру MySQL входят базы данных, таблицы, записи и поля. В базах данных собраны таблицы, в таблицах собраны записи, в записях — поля, в которых, в свою очередь, хранится собственно информация. Такая структура позволяет пользователям выбирать, каким образом обращаться к своей информации. Только что мы работали с базами данных, теперь давайте поработаем с таблицами. Для начала, список таблиц можно вывести так же, как и список баз данных, используя команду SHOW TABLES. Сейчас в нашей базе данных gentoo еще нет таблиц, как показывает эта команда: </para>
<para>
<anchor xml:id="doc_chap3_pre1"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.1: Пустая база данных gentoo</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SHOW TABLES;</para>
<para>Empty set (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Значит, нужно создать несколько таблиц. Чтобы это сделать, используем команду CREATE TABLE. Однако, эта команда довольно сильно отличается от простой команды CREATE DATABASE. Ей передается список аргументов следующего вида: </para>
<para>
<anchor xml:id="doc_chap3_pre2"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.2: Синтаксис CREATE TABLE</para>
</entry>
</row>
<row>
<entry>
<para>CREATE TABLE [имя_таблицы] ([имя_поля] [тип_данных_поля]([размер]));</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>имя_таблицы — имя создаваемой таблицы. В данном случае, давайте создадим таблицу с названием developers (разработчики). В таблице будут находится имена разработчиков, адреса электронной почты и род занятий. имя_поля будет содержать имена полей. Нам нужны три имени: name (имя), email (почта) и job (род занятий). В параметре тип_данных_поля укажем тип заносимой информации. Перечень возможных форматов находится на <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://dev.mysql.com/doc/mysql/en/column-types.html">странице описания типов столбцов MySQL (англ.)</link>. Здесь мы для всех полей укажем тип VARCHAR. VARCHAR — один из простейших типов данных, предназначенный для работы со строками. размер указывает, сколько данных можно сохранить в одном поле. Укажем 128. Это значит, что поле сможет содержать 128 байт данных типа VARCHAR. Cейчас можно упрощенно считать, что это 128 знаков текста, хотя на вышеупомянутом сайте представлено более точное описание. Теперь, зная, какую мы собираемся создать таблицу, сделаем это. </para>
<para>
<anchor xml:id="doc_chap3_pre3"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.3: Создание таблицы</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; CREATE TABLE developers ( name VARCHAR(128), email VARCHAR(128), job VARCHAR(128));</para>
<para>Query OK, 0 rows affected (0.11 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Похоже, таблица создалась нормально. Давайте проверим это командой SHOW TABLES: </para>
<para>
<anchor xml:id="doc_chap3_pre4"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.4: Проверка таблицы</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SHOW TABLES;</para>
<para>+------------------+</para>
<para>| Tables_in_gentoo |</para>
<para>+------------------+</para>
<para>| developers       |</para>
<para>+------------------+</para>
<para>1 row in set (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Да, это она! Но не показано никакой информации о введенных типах полей. Для этого используем команду DESCRIBE (или ее краткий вариант, DESC), параметром которой указывается имя таблицы. Посмотрим, что она выдаст для таблицы developers. </para>
<para>
<anchor xml:id="doc_chap3_pre5"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.5: Описание таблицы developers</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; DESCRIBE developers;</para>
<para>+-------+--------------+------+-----+---------+-------+</para>
<para>| Field | Type         | Null | Key | Default | Extra |</para>
<para>+-------+--------------+------+-----+---------+-------+</para>
<para>| name  | varchar(128) | YES  |     | NULL    |       |</para>
<para>| email | varchar(128) | YES  |     | NULL    |       |</para>
<para>| job   | varchar(128) | YES  |     | NULL    |       |</para>
<para>+-------+--------------+------+-----+---------+-------+</para>
<para>3 rows in set (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Показаны различные поля и их типы. Видно также несколько дополнительных атрибутов, выходящих за рамки этого руководства. За дополнительными сведениями можно обратиться к <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://dev.mysql.com/doc/mysql/en/">Руководству по MySQL (англ.)</link>. Теперь у нас есть рабочая таблица. Давайте двинемся дальше и наполним ее. </para>
<para>
<anchor xml:id="doc_chap3_sect2"/>Заполнение базы данных MySQL</para>
<para>Таблица заполняется (данные добавляются) командой INSERT. Как и у команды CREATE TABLE, у нее есть определенный формат: </para>
<para>
<anchor xml:id="doc_chap3_pre6"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.6: Синтаксис INSERT</para>
</entry>
</row>
<row>
<entry>
<para>INSERT INTO имя_таблицы (столбец1, столбец2, ...) VALUES('знач1','знач2',...); </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Эту команду используют для вставки записей в таблицу. Сначала указывается имя таблицы, в которую нужно добавить информацию. Затем может идти список столбцов, в которые добавляются данные, а в VALUES указываются значения, которые добавляются в таблицу. Можно опустить список полей, если значения добавляются в каждое в том же порядке, в каком определены поля в таблице. Сейчас мы добавим данные в теблицу developers. Вставьте записи как в примере: </para>
<para>
<anchor xml:id="doc_chap3_pre7"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.7: Добавление информации в таблицу developers</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; INSERT INTO developers VALUES('Joe Smith', 'joesmith@gentoo.org', 'toolchain');</para>
<para>Query OK, 1 row affected (0.06 sec)</para>
<para>(Если вы не знаете порядок полей в таблице или хотите добавить</para>
<para>неполную запись)</para>
<para>mysql&gt; INSERT INTO developers (job, name) VALUES('outsourced', 'Jane</para>
<para>Doe');</para>
<para>Query OK, 1 row affected (0.01 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Согласно полученному ответу, запись, похоже, добавилась правильно. Но что если требуется ввести более одной записи? Именно здесь пригодиться команда LOAD DATA. Она загружает записи из файла, разделенного знаками табуляции. Попробуем создать файл с записями в своем домашнем каталоге. Назовем его records.txt. Вот пример: </para>
<para>
<anchor xml:id="doc_chap3_pre8"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.8: ~/records.txt</para>
</entry>
</row>
<row>
<entry>
<para>John Doe        johndoe@gentoo.org      portage</para>
<para>Chris White     chriswhite@gentoo.org   documentation</para>
<para>Sam Smith       samsmith@gentoo.org     amd64</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Важно: Всегда уточняйте, с какими данными работаете. Чрезвычайно небезопасно использовать LOAD DATA, если вы не знаете, что находится внутри файла! </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Вообще, у команды LOAD DATA весьма пространное определение, но сейчас мы используем простейшую форму. </para>
<para>
<anchor xml:id="doc_chap3_pre9"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.9: Синтаксис LOAD DATA</para>
</entry>
</row>
<row>
<entry>
<para>LOAD DATA LOCAL INFILE '/путь/к/файлу' INTO TABLE имя_таблицы;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Здесь тоже все просто. Укажите путь к файлу и имя таблицы. В нашем случае — это файл ~/records.txt и таблица developers. </para>
<para>
<anchor xml:id="doc_chap3_pre10"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.10: Загрузка данных</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; LOAD DATA LOCAL INFILE '~/records.txt' INTO TABLE developers;</para>
<para>Query OK, 3 rows affected (0.00 sec)</para>
<para>Records: 3  Deleted: 0  Skipped: 0  Warnings: 0</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Важно: Если вы столкнетесь со странностями, убедитесь, что поля разделены табуляторами. Если вы вставляете информацию в файл из другого источника, табуляторы могут преобразоваться в пробелы. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Сработало. Но эта команда просто добавляет записи и не дает проконтролировать работу MySQL. Множество веб-приложений используют сценарии sql для быстрой и легкой настройки базы данных MySQL. Если вы хотите использовать сценарий sql, вам понадобится запустить mysql в пакетном режиме (в качестве ввода используется файл со сценарием). Вот пример запуска mysql в пакетном режиме: </para>
<para>
<anchor xml:id="doc_chap3_pre11"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.11: MySQL в пакетном режиме</para>
</entry>
</row>
<row>
<entry>
<para>$ mysql -u root -h localhost -p &lt; sqlfile</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Как и в случае с LOAD DATA, убедитесь, что знаете, что именно выполняет файл sqlfile. Не делая этого, вы можете подвергнуть вашу базу данных серьезному риску утечки! Другой путь заключается в использовании команды source. Эта команда запускает команды mysql из файла, когда mysql находится в интерактивном режиме. Вот как взять команды sql из файла: </para>
<para>
<anchor xml:id="doc_chap3_pre12"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.12: Исполнение команд sql из файла</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; source sqlfile;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Если вы столкнетесь с веб-приложением, которому нужно, чтобы вы запустили файл с командами sql, можно использовать одну из двух команд, показанных выше. Итак, наша таблица сформирована, но как же работать с полями? Это делается поиском в таблице при помощи запросов. </para></section><section><info><title>
<anchor xml:id="doc_chap3_sect3"/>Запросы к таблицам в MySQL</title></info>
<para>Одна из главных функций любой базы данных SQL — запросы. Они помогают обратить данные из таблиц во что-то полезное. Большинство запросов выполняется командой SELECT. Эта команда довольно сложна, поэтому в этом документе мы рассмотрим лишь три основных ее формы. </para>
<para>
<anchor xml:id="doc_chap3_pre13"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.13: Формы SELECT</para>
</entry>
</row>
<row>
<entry>
<para>(Выборка всех записей в таблице)</para>
<para>SELECT * FROM имя_таблицы;</para>
<para>(Выборка конкретных записей в таблице)</para>
<para>SELECT * FROM имя_таблицы WHERE поле=значение;</para>
<para>(Выборка конкретных полей)</para>
<para>SELECT поле1,поле2,поле3 FROM имя_таблицы [WHERE поле=значение];</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Посмотрим на первую форму. Она относительно проста и позволяет взглянуть на всю таблицу. Попробуем: запустим эту команду, чтобы увидеть, что находится в нашей таблице. </para>
<para>
<anchor xml:id="doc_chap3_pre14"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.14: Содержимое таблицы developers</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SELECT * FROM developers;</para>
<para>+-------------+-----------------------+----------------+</para>
<para>| name        | email                 | job            |</para>
<para>+-------------+-----------------------+----------------+</para>
<para>| Joe Smith   | joesmith@gentoo.org   | toolchain      |</para>
<para>| John Doe    | johndoe@gentoo.org    | portage        |</para>
<para>| Chris White | chriswhite@gentoo.org | documentation  |</para>
<para>| Sam Smith   | samsmith@gentoo.org   | amd64          |</para>
<para>| Jane Doe    | NULL                  | Outsourced job |</para>
<para>+-------------+-----------------------+----------------+</para>
<para>5 rows in set (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Видно данные, не только вставленные путем INSERT, но и вставленные командой LOAD DATA. Теперь, к примеру, нужно посмотреть запись для Chris White. Это можно сделать, используя вторую форму выборки. </para>
<para>
<anchor xml:id="doc_chap3_pre15"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.15: Выборка конкретной записи, используя SELECT</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SELECT * FROM developers WHERE name = 'Chris White';</para>
<para>+-------------+-----------------------+---------------+</para>
<para>| name        | email                 | job           |</para>
<para>+-------------+-----------------------+---------------+</para>
<para>| Chris White | chriswhite@gentoo.org | documentation |</para>
<para>+-------------+-----------------------+---------------+</para>
<para>1 row in set (0.08 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Как и ожидалось, отобрана нужная искомая запись. Теперь, допустим, что нужно знать только род занятий и адрес электронной почты, но не имя. Это делается при помощи третьей формы SELECT, как показано ниже. </para>
<para>
<anchor xml:id="doc_chap3_pre16"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.16: Выборка нужной записи и полей с помощью SELECT</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SELECT email,job FROM developers WHERE name = 'Chris White';</para>
<para>+-----------------------+---------------+</para>
<para>| email                 | job           |</para>
<para>+-----------------------+---------------+</para>
<para>| chriswhite@gentoo.org | documentation |</para>
<para>+-----------------------+---------------+</para>
<para>1 row in set (0.04 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Этот способ выборки легче в управлении, особенно при больших объемах информации, как показано далее. Сейчас, войдя как суперпользователь, вы обладаете неограниченными правами на любые действия в MySQL. Пользователь с такими привилегиями в серверной среде может быть достаточно трудноуправляемым. Чтобы управлять тем, кто и что может делать с базами данных, надо устанавливать привилегии. </para></section></section><section><info><title>
<anchor xml:id="doc_chap4"/>4.  Привилегии в MySQL</title></info><section><info><title>
<anchor xml:id="doc_chap4_sect1"/>Предоставление привилегий командой GRANT</title></info>
<para>Привилегиями определяются возможности доступа пользователей к базам данных, таблицам... почти ко всему. Сейчас только суперпользователь root из MySQL может обращаться к базе данных gentoo, согласно данным разрешениям. Давайте создадим двух самых обычных пользователей, например, guest (гостя) и admin (администратора), которые будут обращаться к базе данных gentoo и работать с информацией из нее. Пусть пользователь guest будет ограничен в правах, и все, что он сможет — это получать информацию из базы данных. admin получит те же права доступа, что и root, но только к базе данных gentoo (не к основным базам mysql). Но прежде, чем начать, давайте взглянем на несколько упрощенный формат команды GRANT. </para>
<para>
<anchor xml:id="doc_chap4_pre1"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.1: Синтаксис GRANT</para>
</entry>
</row>
<row>
<entry>
<para>GRANT [привилегии] ON база_данных.* TO '[пользователь]'@'[узел]'</para>
<para>IDENTIFIED BY '[пароль]';</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Команда GRANT считается способом создания пользователя. Поздние версии MySQL, однако, также содержат функцию CREATE_USER, хотя GRANT до сих пор предпочительнее. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь нужны привилегии, которые можно присваивать. Используя все вышесказанное, можно устанавливать следующие привилегии: </para>
<orderedlist>
<listitem>
<para>ALL - дается полный доступ ко всей базе данных </para>
</listitem>
<listitem>
<para>CREATE - пользователям позволяется создавать таблицы </para>
</listitem>
<listitem>
<para>SELECT - пользователям позволяется делать запросы к таблицам </para>
</listitem>
<listitem>
<para>INSERT - пользователям позволяется вставлять данные в таблицу </para>
</listitem>
<listitem>
<para>SHOW DATABASES - разрешается выводить список баз данных </para>
</listitem>
<listitem>
<para>USAGE - у пользователя нет привилегий </para>
</listitem>
<listitem>
<para>GRANT OPTION - пользователям разрешается давать привилегии </para>
</listitem>
</orderedlist>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Если вы используете MySQL для обмена данными с веб-приложением, то разъясняемые здесь привилегии CREATE, SELECT, INSERT, а также привилегии DELETE и UPDATE (описанные в <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://dev.mysql.com/doc/mysql/en/grant.html">руководстве по MySQL, раздел GRANT and REVOKE Syntax (англ.)</link>) — единственные, которые, вероятно, потребуются. Многие совершают ошибку, раздавая все привилегии, когда это, в действительности, не нужно. Сверьтесь с разработчиками приложений, действительно ли такие разрешения создадут проблемы в работе. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Для нашего пользователя admin подойдет ALL. А для пользователя guest привилегии SELECT будет достаточно для доступа на чтение. В качестве базы данных укажем gentoo, на нее будут установлены разрешения. .* означает «все таблицы». Если потребуется, можно установить права доступа к отдельным таблицам. Дальше идет имя пользователя и имя узла, с которого будет работать пользователь. В большинстве случаев это будет узел localhost. Наконец, задается пароль пользователя. Исходя из этого, давайте создадим пользователей. </para>
<para>
<anchor xml:id="doc_chap4_pre2"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.2: Создание пользователей admin и guest</para>
</entry>
</row>
<row>
<entry>
<para>(admin)</para>
<para>mysql&gt; GRANT ALL ON gentoo.* TO 'admin'@'localhost' IDENTIFIED BY 'пароль';</para>
<para>(guest)</para>
<para>mysql&gt; GRANT SELECT ON gentoo.* TO 'guest'@'localhost' IDENTIFIED BY 'пароль';</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Итак, пользователи созданы; теперь протестируем их. Сначала выйдем из mysql, написав quit в строке приглашения: </para>
<para>
<anchor xml:id="doc_chap4_pre3"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.3: Выход из MySQL</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; quit</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь мы снова в консоли. Пользователи настроены, давайте посмотрим, что они могут делать. </para></section><section><info><title>
<anchor xml:id="doc_chap4_sect2"/>Проверка прав пользователей</title></info>
<para>Попробуем зайти как пользователь guest. В данный момент у пользователя guest есть только право выборки (SELECT). В основном, это сводится к возможности поиска и ничему другому. Зайдем как пользователь guest. </para>
<para>
<anchor xml:id="doc_chap4_pre4"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.4: Вход опользователя guest</para>
</entry>
</row>
<row>
<entry>
<para>$ mysql -u guest -h localhost -p</para>
<para>Enter password:</para>
<para>Welcome to the MySQL monitor. Commands end with ; or \g.</para>
<para>Your MySQL connection id is 6 to server version: 4.0.25</para>
<para/>
<para>Type 'help;' or '\h' for help. Type '\c' to clear the buffer.</para>
<para/>
<para>mysql&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь нам нужно проверить его ограничения. Переключимся на базу данных gentoo: </para>
<para>
<anchor xml:id="doc_chap4_pre5"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.5: Переключение на базу gentoo</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; USE gentoo;</para>
<para>Reading table information for completion of table and column names</para>
<para>You can turn off this feature to get a quicker startup with -A</para>
<para/>
<para>Database changed</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь попытаемся сделать что-нибудь недозволенное. Попробуем создать таблицу. </para>
<para>
<anchor xml:id="doc_chap4_pre6"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.6: Попытка создать таблицу пользователем guest</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; CREATE TABLE test (test VARCHAR(20), foobar VARCHAR(2));</para>
<para>ERROR 1044: Access denied for user: 'guest@localhost' to database 'gentoo'</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Как видно, это не удалось, из-за того, что у пользователя недостаточно прав. Но ему дано право на использование SELECT. Давайте проверим: </para>
<para>
<anchor xml:id="doc_chap4_pre7"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.7: Попытка выборки командой SELECT</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SELECT * FROM developers;</para>
<para>+-------------+-----------------------+----------------+</para>
<para>| name        | email                 | job            |</para>
<para>+-------------+-----------------------+----------------+</para>
<para>| Joe Smith   | joesmith@gentoo.org   | toolchain      |</para>
<para>| John Doe    | johndoe@gentoo.org    | portage        |</para>
<para>| Chris White | chriswhite@gentoo.org | documentation  |</para>
<para>| Sam Smith   | samsmith@gentoo.org   | amd64          |</para>
<para>| Jane Doe    | NULL                  | Outsourced job |</para>
<para>+-------------+-----------------------+----------------+</para>
<para>5 rows in set (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Команда успешно отработала, а получили представление о том, на что способны права пользователей. Но мы ведь еще создали пользователя admin. Он создавался для демонстрации того, что даже у пользователей, которым даны все права, могут быть ограничения. Выйдите из MySQL и зайдите как пользователь admin. </para>
<para>
<anchor xml:id="doc_chap4_pre8"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.8: Вход пользователя admin</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; quit</para>
<para>Bye</para>
<para>$ mysql -u admin -h localhost -p</para>
<para>Enter password:</para>
<para>Welcome to the MySQL monitor. Commands end with ; or \g.</para>
<para>Your MySQL connection id is 7 to server version: 4.0.25</para>
<para/>
<para>Type 'help;' or '\h' for help. Type '\c' to clear the buffer.</para>
<para/>
<para>mysql&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Для начала, попробуем создать новую базу данных как пользователь admin. У пользователя admin схожие права с учетной записью root в MySQL, и он может вносить любые изменения, выбрав базу данных gentoo. Мы проверим права его доступа к главной базе данных MySQL. Вспомним, что ранее мы дали ему права только для доступа к конкретной базе данных. </para>
<para>
<anchor xml:id="doc_chap4_pre9"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.9: Попытка создания новой базы данных</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; CREATE DATABASE gentoo2;</para>
<para>ERROR 1044: Access denied for user: 'admin@localhost' to database 'gentoo2'</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Разумеется, пользователь admin не может создавать базы данных в основной базе MySQL, несмотря на все права на базу данных gentoo. Но admin все еще может изменять базу данных gentoo, как показывает вставка данных в следующем примере. </para>
<para>
<anchor xml:id="doc_chap4_pre10"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.10: Права admin в базе данных gentoo</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; USE gentoo;</para>
<para>Reading table information for completion of table and column names</para>
<para>You can turn off this feature to get a quicker startup with -A</para>
<para/>
<para>Database changed</para>
<para>mysql&gt; INSERT INTO developers VALUES('Bob Simmons', 'bobsimmons@gentoo.org', 'python');</para>
<para>Query OK, 1 row affected (0.08 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Пользователь admin может обращаться к базе gentoo, как захочет. Но иногда требуется лишить пользователя прав. Это может быть что угодно, начиная с проблематичного пользоватля, и заканчивая ушедшим сотрудником. Давайте разберемся, как отзывать разрешения с помощью команды REVOKE. </para></section><section><info><title>
<anchor xml:id="doc_chap4_sect3"/>Удаление прав пользователя командой REVOKE</title></info>
<para>Команда REVOKE позволяет запретить доступ пользователю. Можно либо запретить любой доступ, либо только определенный. В самом деле, формат очень похож на GRANT. </para>
<para>
<anchor xml:id="doc_chap4_pre11"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.11: Синтаксис REVOKE</para>
</entry>
</row>
<row>
<entry>
<para>REVOKE [привилегии] ON база_данных.* FROM '[пользователь]'@'[узел]';</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Параметры объясняются в разделе команды GRANT. А сейчас мы запретим пользователю любой вид доступа. Скажем, мы выяснили, что учетная запись guest вызывает проблемы с безопасностью. Мы решаем отозвать все права. Заходим как root делаем необходимое. </para>
<para>
<anchor xml:id="doc_chap4_pre12"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.12: Отзыв разрешений для пользователя user</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; REVOKE ALL ON gentoo.* FROM 'guest'@'localhost';</para>
<para>Query OK, 0 rows affected (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: В данном случае, доступ пользователя прост, поэтому отмена прав на одну базу данных — не проблема. Но обычно вам, скорее всего, потребуется использовать *.* вместо gentoo.*, чтобы заодно отменить доступ пользователя ко всем остальным базам данных.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Давайте выйдем и попробуем зайти как пользователь guest. </para>
<para>
<anchor xml:id="doc_chap4_pre13"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.13: Попытка зайти как пользователь guest</para>
</entry>
</row>
<row>
<entry>
<para>$ mysql -u guest -h localhost -p</para>
<para>Enter password:</para>
<para>Welcome to the MySQL monitor. Commands end with ; or \g.</para>
<para>Your MySQL connection id is 9 to server version: 4.0.25</para>
<para/>
<para>Type 'help;' or '\h' for help. Type '\c' to clear the buffer.</para>
<para/>
<para>mysql&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Хотя нам удалось войти, доступ к базе gentoo уже пропал. </para>
<para>
<anchor xml:id="doc_chap4_pre14"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.14: Пользователю guest запрещен доступ </para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; USE gentoo;</para>
<para>ERROR 1044: Access denied for user: 'guest@localhost' to database 'gentoo'</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>И наш проблематичный пользователь больше не может обращаться к базе gentoo. Заметьте, что пользователь сохранил возможность входа. Это потому, что он остается в основной базе данных MySQL. Теперь взглянем, как полностью удалить учетную запись командой DELETE, и посмотрим на таблицу пользователей MySQL. </para></section><section><info><title>
<anchor xml:id="doc_chap4_sect4"/>Удаление учетных записей командой DELETE</title></info>
<para>Таблица пользователей MySQL — это список пользователей и информации о них. Убедитесь, что вы зашли как root. Используйте основную базу данных MySQL. </para>
<para>
<anchor xml:id="doc_chap4_pre15"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.15: Использование основной базы mysql</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; USE mysql;</para>
<para>Reading table information for completion of table and column names</para>
<para>You can turn off this feature to get a quicker startup with -A</para>
<para/>
<para>Database changed</para>
<para>mysql&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Посмотрим, какие в базе mysql существуют таблицы: </para>
<para>
<anchor xml:id="doc_chap4_pre16"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.16: Список таблиц БД mysql</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SHOW TABLES;</para>
<para>+-----------------+</para>
<para>| Tables_in_mysql |</para>
<para>+-----------------+</para>
<para>| columns_priv    |</para>
<para>| db              |</para>
<para>| func            |</para>
<para>| host            |</para>
<para>| tables_priv     |</para>
<para>| user            |</para>
<para>+-----------------+</para>
<para>6 rows in set (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Таблица user — та, что нужна. В ней 30 различных полей, и ее сложно читать. Для облегчения чтения используем третью форму команды SELECT. Искомые поля — Host (узел) и User (пользователь). </para>
<para>
<anchor xml:id="doc_chap4_pre17"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.17: Нахождение пользователя guest в таблице user</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SELECT Host,User FROM user WHERE User = 'guest';</para>
<para>+-----------+-------+</para>
<para>| Host      | User  |</para>
<para>+-----------+-------+</para>
<para>| localhost | guest |</para>
<para>+-----------+-------+</para>
<para>1 row in set (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь, получив информацию, мы можем избавиться от пользователя guest. Это делается командой DELETE; вот ее синтаксис: </para>
<para>
<anchor xml:id="doc_chap4_pre18"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.18: Синтаксис DELETE</para>
</entry>
</row>
<row>
<entry>
<para>DELETE FROM имя_таблицы WHERE поле='значение';</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Вы могли заметить, что формат DELETE чем-то схож с форматом SELECT. Укажем поле User и значение guest. Это удалит запись из таблицы user, где пользователь — guest, удаляя нашу гостевую учетную запись. Сделаем так: </para>
<para>
<anchor xml:id="doc_chap4_pre19"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.19: Удаление пользователя guest</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; DELETE FROM user WHERE User='guest';</para>
<para>Query OK, 1 row affected (0.07 sec)</para>
<para>(Команда FLUSH PRIVILEGES нужна, чтобы обновить разрешения)</para>
<para>mysql&gt; FLUSH PRIVILEGES;</para>
<para>Query OK, 0 rows affected (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Похоже, сработало. Проверим: выйдите и попробуйте зайти как пользователь guest. </para>
<para>
<anchor xml:id="doc_chap4_pre20"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.20: Попытка входа пользователя guest</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; quit</para>
<para>Bye</para>
<para>$ mysql -u guest -h localhost -p</para>
<para>Enter password:</para>
<para>ERROR 1045: Access denied for user: 'guest@localhost' (Using password: YES)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Все, пользователь успешно удален! </para>
<para>
<anchor xml:id="doc_chap4_sect5"/>Заключение</para>
<para>В этом руководстве в основном рассматривалась настройка MySQL из командной строки. Существует несколько альтернатив с графическим интерфейсом: </para>
<orderedlist>
<listitem>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.phpmyadmin.net/home_page/">phpMyAdmin </link> — популярное средство администрирования MySQL, написанное на php. </para>
</listitem>
<listitem>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://sourceforge.net/projects/mysqlnavigator/">mysqlnavigator </link> — оболочка MySQL для Qt. </para>
</listitem>
<listitem>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://gmyclient.sourceforge.net/">gmyclient</link> — клиент MySQL для GNOME. </para>
</listitem>
<listitem>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.knoda.org/">knoda</link> — клиент MySQL для KDE. </para>
</listitem>
</orderedlist>
<para>На этом заканчивается введение в MySQL. Надеюсь, что оно помогло вам лучше разобраться в основах MySQL и настройке базы данных. Пожалуйста, присылайте свои соображения мне по адресу Chris White. </para>
<para/>
<para/></section></section></section><section><info><title>PostgreSQL Guide</title></info>
<para>Ссылка на оригинал: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gentoo.org/doc/ru/udev-guide.xml">http://www.gentoo.org/doc/en/postgres-howto.xml</link>
</para>
<para>C версии: 1.5</para><section><info><title>1.  Introduction</title></info><section><info><title>
<anchor xml:id="doc_chap1_sect11"/>PostgreSQL introduction</title></info>
<para>When talking to most developers about the different database solutions to use, two major databases will usually form the answer. One would be MySQL, and the other is what this document will refer to, PostgreSQL. The advantages of one over the other is a somewhat long winded debate, however it is just to say that PostgreSQL has had a more firm grasp on true relational database structure than MySQL. Most of the standard features such as FOREIGN KEY was only just added in MySQL 5. However, whatever the case may be, this document assumes that you have selected PostgreSQL as the database to use. The first place to start is the emerge process. In the next section, the installation process through emerge will be described, as well as the basic configuration. </para></section><section><info><title>
<anchor xml:id="doc_chap1_sect21"/>PostgreSQL installation</title></info>
<para>To begin, we must first emerge the PostgreSQL package. To do so, run the following code to first ensure that the options for it are properly set: </para>
<para>
<anchor xml:id="doc_chap1_pre11"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 1.1: Checking the PostgreSQL build options</para>
</entry>
</row>
<row>
<entry>
<para># emerge -pv postgresql</para>
<para/>
<para>These are the packages that I would merge, in order:</para>
<para/>
<para>Calculating dependencies ...done!</para>
<para>[ebuild  N    ] dev-db/postgresql-8.0.4  -doc -kerberos +nls +pam +perl -pg-intdatetime +python +readline (-selinux) +ssl -tcl +xml +zlib 0 kB</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Here's a list of what the different build options indicate: </para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>USE Flag</para>
</entry>
<entry>
<para>Meaning</para>
</entry>
</row>
<row>
<entry>
<para>doc</para>
</entry>
<entry>
<para>This USE flag enables or disables the installation of documentation outside of the standard man pages. The one good time to disable this option is if you are low on space, or you have alternate methods of getting a hold of the documentation (online, etc.) </para>
</entry>
</row>
<row>
<entry>
<para>kerberos</para>
</entry>
<entry>
<para>When connecting to the database, with this option enabled, the admin has the option of using kerberos to authenticate their users/services to the database. </para>
</entry>
</row>
<row>
<entry>
<para>nls</para>
</entry>
<entry>
<para>If this option is enabled, PostgreSQL can utilize translated strings for non-English speaking users. </para>
</entry>
</row>
<row>
<entry>
<para>pam</para>
</entry>
<entry>
<para>If this option is enabled, and the admin configures the PostgreSQL configuration file properly, users/services will be able to login to a PostgreSQL database using PAM (Pluggable Authentication Module). </para>
</entry>
</row>
<row>
<entry>
<para>perl</para>
</entry>
<entry>
<para>If this option is enabled, perl bindings for PostgreSQL will be built. </para>
</entry>
</row>
<row>
<entry>
<para>pg-intdatetime</para>
</entry>
<entry>
<para>If this option is enabled, PostgreSQL will support 64 bit integer date types. </para>
</entry>
</row>
<row>
<entry>
<para>python</para>
</entry>
<entry>
<para>If this option is enabled, PostgreSQL will be built with python bindings. </para>
</entry>
</row>
<row>
<entry>
<para>readline</para>
</entry>
<entry>
<para>If this option is enabled, PostgreSQL will support readline style command line editing. This includes command history and isearch. </para>
</entry>
</row>
<row>
<entry>
<para>selinux</para>
</entry>
<entry>
<para>If this option is enabled, an selinux policy for PostgreSQL will be installed. </para>
</entry>
</row>
<row>
<entry>
<para>ssl</para>
</entry>
<entry>
<para>If this option is enabled, PostgreSQL will utilize the OpenSSL library to encrypt traffic between PostgreSQL clients and servers. </para>
</entry>
</row>
<row>
<entry>
<para>tcl</para>
</entry>
<entry>
<para>If this option is enabled, PostgreSQL will build tcl bindings. </para>
</entry>
</row>
<row>
<entry>
<para>xml</para>
</entry>
<entry>
<para>If this option is enabled, XPATH style xml support will be built. More information on using xml support with PostgreSQL can be found on: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.throwingbeans.org/postgresql_and_xml.html">PostgreSQL and XML</link>. </para>
</entry>
</row>
<row>
<entry>
<para>zlib</para>
</entry>
<entry>
<para>This isn't really used by PostgreSQL itself, but by pg_dump to compress the dumps it produces. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Once you've customized PostgreSQL to meet your specific needs, go ahead and start the emerge: </para>
<para>
<anchor xml:id="doc_chap1_pre21"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 1.2: Emerge-ing PostgreSQL</para>
</entry>
</row>
<row>
<entry>
<para># emerge postgresql</para>
<para>(Output shortened)</para>
<para>&gt;&gt;&gt; /usr/lib/libecpg.so.5 -&gt; libecpg.so.5.0</para>
<para>&gt;&gt;&gt; /usr/bin/postmaster -&gt; postgres</para>
<para> * Make sure the postgres user in /etc/passwd has an account setup with /bin/bash as the shell</para>
<para> *</para>
<para> * Execute the following command</para>
<para> * emerge --config =postgresql-8.0.4</para>
<para> * to setup the initial database environment.</para>
<para> *</para>
<para>&gt;&gt;&gt; Regenerating /etc/ld.so.cache...</para>
<para>&gt;&gt;&gt; dev-db/postgresql-8.0.4 merged.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>As shown by the einfo output, there is some post setup that must be done. The next chapter will look at the actual configuration of PostgreSQL. </para></section></section><section><info><title>
<anchor xml:id="doc_chap21"/>2.  PostgreSQL configuration</title></info><section><info><title>
<anchor xml:id="doc_chap2_sect11"/>Setting up the initial database environment</title></info>
<para>As noted in the earlier emerge output, the initial database environment must be setup. However, before this is done, one thing needs to be considered. Unlike, say MySQL, PostgreSQL's "root" password is the password of the actual user. However, only the user is created by the ebuild not the password. So before we can begin, the password must be set for the postgres user: </para>
<para>
<anchor xml:id="doc_chap2_pre11"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.1: Setting the password</para>
</entry>
</row>
<row>
<entry>
<para># passwd postgres</para>
<para>New UNIX password:</para>
<para>Retype new UNIX password:</para>
<para>passwd: password updated successfully</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Now that this is setup, the creation of the initial database environment can occur: </para>
<para>
<anchor xml:id="doc_chap2_pre21"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.2: Configuring the database environment with emerge --config</para>
</entry>
</row>
<row>
<entry>
<para># emerge --config =postgresql-8.0.4</para>
<para/>
<para/>
<para>Configuring pkg...</para>
<para/>
<para> * Creating the data directory ...</para>
<para> * Initializing the database ...</para>
<para>The files belonging to this database system will be owned by user "postgres".</para>
<para>This user must also own the server process.</para>
<para/>
<para>The database cluster will be initialized with locale C.</para>
<para/>
<para>fixing permissions on existing directory /var/lib/postgresql/data ... ok</para>
<para>creating directory /var/lib/postgresql/data/global ... ok</para>
<para>creating directory /var/lib/postgresql/data/pg_xlog ... ok</para>
<para>creating directory /var/lib/postgresql/data/pg_xlog/archive_status ... ok</para>
<para>creating directory /var/lib/postgresql/data/pg_clog ... ok</para>
<para>creating directory /var/lib/postgresql/data/pg_subtrans ... ok</para>
<para>creating directory /var/lib/postgresql/data/base ... ok</para>
<para>creating directory /var/lib/postgresql/data/base/1 ... ok</para>
<para>creating directory /var/lib/postgresql/data/pg_tblspc ... ok</para>
<para>selecting default max_connections ... 100</para>
<para>selecting default shared_buffers ... 1000</para>
<para>creating configuration files ... ok</para>
<para>creating template1 database in /var/lib/postgresql/data/base/1 ... ok</para>
<para>initializing pg_shadow ... ok</para>
<para>enabling unlimited row size for system tables ... ok</para>
<para>initializing pg_depend ... ok</para>
<para>creating system views ... ok</para>
<para>loading pg_description ... ok</para>
<para>creating conversions ... ok</para>
<para>setting privileges on built-in objects ... ok</para>
<para>creating information schema ... ok</para>
<para>vacuuming database template1 ... ok</para>
<para>copying template1 to template0 ... ok</para>
<para/>
<para>WARNING: enabling "trust" authentication for local connections</para>
<para>You can change this by editing pg_hba.conf or using the -A option the</para>
<para>next time you run initdb.</para>
<para/>
<para>Success. You can now start the database server using:</para>
<para/>
<para>    /usr/bin/postmaster -D /var/lib/postgresql/data</para>
<para>or</para>
<para>    /usr/bin/pg_ctl -D /var/lib/postgresql/data -l logfile start</para>
<para/>
<para> *</para>
<para> * You can use /etc/init.d/postgresql script to run PostgreSQL instead of pg_ctl.</para>
<para> *</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Now the initial database environment is setup. The next section will look at verifying the install and setting up users to access the database. </para></section><section><info><title>
<anchor xml:id="doc_chap2_sect2"/>PostgreSQL database setup</title></info>
<para>Now that PostgreSQL is setup, it's a good idea at this point to verify the installation. First, make sure the service starts up ok: </para>
<para>
<anchor xml:id="doc_chap2_pre31"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.3: Starting up the PostgreSQL service</para>
</entry>
</row>
<row>
<entry>
<para># /etc/init.d/postgresql start</para>
<para>* Starting PostgreSQL ...                                          [ ok ]</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Once this is verified working, it's also a good idea to add it to the default runlevel so it starts at boot: </para>
<para>
<anchor xml:id="doc_chap2_pre41"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.4: Adding to the default runlevel</para>
</entry>
</row>
<row>
<entry>
<para># rc-update add postgresql default</para>
<para>* postgresql added to runlevel default</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Now that the service has started, it's time to try setting up a test database. To start out, let's create a test database by using the createdb command. We'll also pass along the -U option to set the user (it defaults to the current user name if you don't), and the -W option to request the password we created earlier. Finally we give it the name of the database we want to create: </para>
<para>
<anchor xml:id="doc_chap2_pre5"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.5: Creating a database with createdb</para>
</entry>
</row>
<row>
<entry>
<para>$ createdb -U postgres -W test</para>
<para>Password:</para>
<para>CREATE DATABASE</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>The database was successfully created, and we can confirm that the database can run basic tasks. We'll go ahead and drop this database (remove it) with the dropdb command: </para>
<para>
<anchor xml:id="doc_chap2_pre6"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.6: Dropping a database with dropdb</para>
</entry>
</row>
<row>
<entry>
<para>$ dropdb -U postgres -W test</para>
<para>Password:</para>
<para>DROP DATABASE</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Right now, only the postgres user can run commands. Obviously this is not the sort of setup one would like in a multi-user environment. The next section will look at working with user accounts. </para></section><section><info><title>
<anchor xml:id="doc_chap2_sect3"/>Setting up database user accounts</title></info>
<para>As mentioned earlier, having to login as the postgres user is somewhat undesirable in a mult-user environment. In most cases there will be various users and services accessing the server, and each have different permission requirements. So, to handle this, the createuser command can be used. This command is an alternative to running a few SQL queries, and is a lot more flexible from an admin standpoint. We'll go ahead and create two users, a 'superuser' that can add other users and administer the db, and a standard user: </para>
<para>
<anchor xml:id="doc_chap2_pre7"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.7: Setting up the superuser</para>
</entry>
</row>
<row>
<entry>
<para>(replace chris with the username you'd like to use)</para>
<para>$ createuser -a -d -P -E -U postgres -W chris</para>
<para>Enter password for new user:</para>
<para>Enter it again:</para>
<para>Password:</para>
<para>CREATE USER</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>There, we've created the superuser. The command line option -a specifies that this user can add other users. -d means that this user can create databases. -P let's you enter a password for the user and -E will encrypt it for security purposes. Now then, we'll test this new user's permissions out by setting up our standard user: </para>
<para>
<anchor xml:id="doc_chap2_pre8"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.8: Setting up the standard user</para>
</entry>
</row>
<row>
<entry>
<para>(replace chris with the username you've just created)</para>
<para>$ createuser -A -D -P -E -U chris -W testuser</para>
<para>Enter password for new user:</para>
<para>Enter it again:</para>
<para>Password:</para>
<para>CREATE USER</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Success! Our new user was created using the previously created superuser. The -A and -D options do the opposite of -a and -d, and instead deny the user the ability to create other users and databases. Now that there are users to work with, the next chapter will look at using the new database. </para></section></section><section><info><title>
<anchor xml:id="doc_chap31"/>3.  Using PostgreSQL</title></info><section><info><title>
<anchor xml:id="doc_chap3_sect11"/>Setting up permissions</title></info>
<para>Now there is a user that can create databases and add other users, and the main postgres user that can do anything. The user created earlier can currently login to the server, and that's about it. In general, users need to be able to insert data and retrieve data, and sometimes any other number of tasks. So, for this new user to be able to do anything, they must be setup with the proper permissions. This can easily be done by passing the -O parameter to createdb. We'll start by making a new database, MyDB with our superuser that will be owned by the previous testuser: </para>
<para>
<anchor xml:id="doc_chap3_pre17"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.1: Creating the MyDB database</para>
</entry>
</row>
<row>
<entry>
<para>$ createdb -O testuser -U chris -W MyDB</para>
<para>Password:</para>
<para>CREATE DATABASE</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Alright, now we have a new MyDB database, and a testuser that can access it. To test this out, we'll login as the testuser to the new MyDB database. We'll do this with the psql program. This program is what's used to connect to the PostgreSQL database from command line. So connect to the new database like so: </para>
<para>
<anchor xml:id="doc_chap3_pre21"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.2: Logging into the MyDB database as the testuser</para>
</entry>
</row>
<row>
<entry>
<para>$ psql -U testuser -W MyDB</para>
<para>Password:</para>
<para>Welcome to psql 8.0.4, the PostgreSQL interactive terminal.</para>
<para/>
<para>Type:  \copyright for distribution terms</para>
<para>       \h for help with SQL commands</para>
<para>       \? for help with psql commands</para>
<para>       \g or terminate with semicolon to execute query</para>
<para>       \q to quit</para>
<para/>
<para>MyDB=&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>So, the testuser is now logged into the database, and can begin to initiate some commands. To get a feel for using PostgreSQL, the next section will take a look at some of the basic commands in navigating the psql client. </para>
<para>
<anchor xml:id="doc_chap3_sect21"/>Basic PostgreSQL commands and creating a table</para>
<para>For those who are used to MySQL, this is somewhat of a definite read. This is where PostgreSQL may get somewhat unique with regards to running commands. To start, here is a list of some commands that will be discussed: </para>
<informaltable frame="all">
<tgroup cols="3"><tbody>
<row>
<entry>
<para>Command</para>
</entry>
<entry>
<para>Usage</para>
</entry>
<entry>
<para>MySQL Equivalent</para>
</entry>
</row>
<row>
<entry>
<para>\c[onnect] [DBNAME|- [USER]]</para>
</entry>
<entry>
<para>Connects to another database</para>
</entry>
<entry>
<para>USE DATABASE</para>
</entry>
</row>
<row>
<entry>
<para>\q</para>
</entry>
<entry>
<para>Quit the psql client</para>
</entry>
<entry>
<para>quit</para>
</entry>
</row>
<row>
<entry>
<para>\i FILE</para>
</entry>
<entry>
<para>Run commands from FILE </para>
</entry>
<entry>
<para>source FILE</para>
</entry>
</row>
<row>
<entry>
<para>\o [FILE]</para>
</entry>
<entry>
<para>Send query results to FILE </para>
</entry>
<entry>
<para>INTO OUTFILE, but outputs everything (not just SELECTS)</para>
</entry>
</row>
<row>
<entry>
<para>\d [NAME]</para>
</entry>
<entry>
<para>Describe a database or table (as well as other items)</para>
</entry>
<entry>
<para>DESC(RIBE)</para>
</entry>
</row>
<row>
<entry>
<para>\db [PATTERN]</para>
</entry>
<entry>
<para>List available tables that match PATTERN (all if no pattern is given) </para>
</entry>
<entry>
<para>SHOW TABLES</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>With the exception of \c[onnect], all the commands shown will be used later on in the section. So right now the database is empty. That said, we need to insert some data. The first step to inserting data, however, is to put it in a table. Right now there are no tables in the database, so we need to create one. This is done with the CREATE TABLE command. We'll make a table of items. They will contain a Product ID, Description, and price: </para>
<para>
<anchor xml:id="doc_chap3_pre31"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.3: Creating the products table</para>
</entry>
</row>
<row>
<entry>
<para>MyDB=&gt; CREATE TABLE products (</para>
<para>MyDB(&gt;   product_id SERIAL,</para>
<para>MyDB(&gt;   description TEXT,</para>
<para>MyDB(&gt;   price DECIMAL</para>
<para>MyDB(&gt; );</para>
<para>NOTICE:  CREATE TABLE will create implicit sequence "products_product_id_seq"</para>
<para>for serial column "products.product_id"</para>
<para>CREATE TABLE</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>You can ignore the NOTICE, it's perfectly harmless. Looking at the last line of the function, CREATE TABLE seems to indicate that the command has succeeded. However, let's go ahead and verify that the table was indeed successfully created with the \d command: </para>
<para>
<anchor xml:id="doc_chap3_pre41"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.4: Looking at the newly created table</para>
</entry>
</row>
<row>
<entry>
<para>MyDB=&gt; \d products</para>
<para>                                 Table "public.products"</para>
<para>   Column    |  Type   |                            Modifiers</para>
<para>-------------+---------+------------------------------------------------------------------</para>
<para> product_id  | integer | not null default nextval('public.products_product_id_seq'::text)</para>
<para> description | text    |</para>
<para> price       | numeric |</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Indeed the table was successfully created. Now that the table is created, it needs to be populated with data. The next section will look at populating the database with data. </para></section><section><info><title>
<anchor xml:id="doc_chap3_sect31"/>Inserting data into the database</title></info>
<para>This section will look at the two ways of populating the newly created table with data. First let's look at the most basic command, INSERT: </para>
<para>
<anchor xml:id="doc_chap3_pre51"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.5: INSERT syntax</para>
</entry>
</row>
<row>
<entry>
<para>INSERT INTO [tablename] (column1,column2,column3) VALUES(value1,value2,value3)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>tablename contains the name of the table to insert the data into. (column1,column2,column3) lets you specify the specific columns to insert the values into. VALUES(value1,value2,value3) is the listing of values. The values are inserted into the same order as the columns (column1 gets value1, column2 gets value2, column3 gets value3). These counts must be the same. So let's go ahead and insert an item into the table: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Important: From working with databases for a long time, I personally recommend specifying INSERT statements exactly as above. Developers often make the mistake of using INSERT INTO without specifying columns. This is unproductive, as if a new column gets added to the database, it will cause in error if the value to column count is not the same. You should always specify the columns unless you're 300% sure you'll never add a column. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>
<anchor xml:id="doc_chap3_pre61"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.6: Inserting data into the table</para>
</entry>
</row>
<row>
<entry>
<para>MyDB=&gt; INSERT INTO products (description,price) VALUES('A test product', 12.00);</para>
<para>INSERT 17273 1</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>The last line needs a bit of explaining. The return of an insert command is an OID (Object Identifier) and the number of rows inserted. OID's are a bit beyond the scope of this guide, and the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.postgresql.org/docs/8.1/static/datatype-oid.html">PostgreSQL manual</link> has some good information on it. Now, for a situation where you have 20,000 products, these insert statements can be a little tedious. However, not all is lost. The COPY command can be used to insert data into a table from a file or stdin. In this example, let's assume that you have a csv (comma separated values) file, which contains the product id, description, and price. The file looks like this: </para>
<para>
<anchor xml:id="doc_chap3_pre71"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.7: products.csv</para>
</entry>
</row>
<row>
<entry>
<para>2,meat,6.79</para>
<para>3,soup,0.69</para>
<para>4,soda,1.79</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Now we'll use the COPY command to populate our data: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Important: The COPY FROM STDIN command is used because only the postgres user can insert data from a file (for obvious security reasons). </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>
<anchor xml:id="doc_chap3_pre81"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.8: Using COPY to populate the products table</para>
</entry>
</row>
<row>
<entry>
<para>MyDB=&gt; COPY products FROM STDIN WITH DELIMITER AS ',';</para>
<para>Enter data to be copied followed by a newline.</para>
<para>End with a backslash and a period on a line by itself.</para>
<para>&gt;&gt; 2,meat,6.79</para>
<para>&gt;&gt; 3,soup,0.69</para>
<para>&gt;&gt; 4,soda,1.79</para>
<para>&gt;&gt; \.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Unfortunately, this line doesn't return the same status information as the INSERT INTO statement. How do we know the data was inserted? The next section will look at running queries to check our data. </para></section><section><info><title>
<anchor xml:id="doc_chap3_sect4"/>Using PostgreSQL queries</title></info>
<para>This section will look at using the SELECT statement to view data in our tables. The basic SELECT format looks like this: </para>
<para>
<anchor xml:id="doc_chap3_pre91"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.9: SELECT syntax</para>
</entry>
</row>
<row>
<entry>
<para>SELECT (column1,column2|*) FROM (table) [WHERE (conditionals)]</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>There are two ways to select columns. The first is using * to select all columns, and the second is to specify a list of specific columns you wish to see. The second is quite handy when you want to find a specific column in a rather large list of them. Let's start out with using SELECT with * to specify all columns: </para>
<para>
<anchor xml:id="doc_chap3_pre101"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.10: Viewing the products table</para>
</entry>
</row>
<row>
<entry>
<para>MyDB=&gt; SELECT * FROM products;</para>
<para> product_id |  description   | price</para>
<para>------------+----------------+-------</para>
<para>          1 | A test product | 12.00</para>
<para>          2 | meat           |  6.79</para>
<para>          3 | soup           |  0.69</para>
<para>          4 | soda           |  1.79</para>
<para>(4 rows)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>As shown here, all the data we inserted earlier is indeed in the table. Now let's say we only want to see the description and the price, and don't care about the product id. In this case we'll use the column specific SELECT form: </para>
<para>
<anchor xml:id="doc_chap3_pre111"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.11: Viewing specific columns from the products table</para>
</entry>
</row>
<row>
<entry>
<para>MyDB=&gt; SELECT description,price FROM products;</para>
<para>  description   | price</para>
<para>----------------+-------</para>
<para> A test product | 12.00</para>
<para> meat           |  6.79</para>
<para> soup           |  0.69</para>
<para> soda           |  1.79</para>
<para>(4 rows)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Now only the product and price is shown, letting us focus on only the important data. Now let's say that we want to see only the items that are greater than $2.00. Here's where the WHERE clause comes in handy: </para>
<para>
<anchor xml:id="doc_chap3_pre121"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.12: Viewing specific rows from the products table</para>
</entry>
</row>
<row>
<entry>
<para>MyDB=&gt; SELECT description,price FROM products WHERE price &gt; 2.00;</para>
<para>  description   | price</para>
<para>----------------+-------</para>
<para> A test product | 12.00</para>
<para> meat           |  6.79</para>
<para>(2 rows)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Now a listing of products over $2.00 is displayed, focusing the data even more. These forms of querying for information are very powerful, and can help create extremely useful reports. </para></section><section><info><title>
<anchor xml:id="doc_chap3_sect5"/>Conclusion</title></info>
<para>This concludes the PostgreSQL Guide. A big thanks goes to Masatomo Nakano, the previous Gentoo PostgreSQL maintainer for his help in answering my questions. Any suggestions on this guide should be sent to Chris White. For more extensive documentation, see the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.postgresql.org/">PostgreSQL website</link>. </para>
<para/></section></section></section>
</article>