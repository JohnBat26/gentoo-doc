<?xml version="1.0" encoding="utf-8"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="linuxndi" xreflabel="Linux не для идиотов">
   <info><author>
         <personname>
            <firstname>Артём</firstname>
            <surname>Капитула</surname>
         </personname>
      </author>
      <pubdate>2007</pubdate>
      <title>Linux не для идиотов</title><titleabbrev>Linux не для идиотов</titleabbrev><abstract>
         <para>С версии: 1.1</para>
         <para>Обновлено в версии: 2.0</para>
      </abstract></info>
   <section xml:id="overview_linuxndi">
      <title>Предисловие</title>
      <para>Я много лет работал с Linux, и, общаясь со многими единомышленниками, сделал один странный вывод: нам катастрофически не хватает документации. Причем не инструкций вида «сделайте так и вот так» и не справочных руководств, а некоторого «мостика» между новичком, который видел только графическую оболочку подобную GNOME или KDE, и профессионалом, который может скомпилировать необходимый ему драйвер, даже если этот драйвер упорно сопротивляется.</para>
      <para>Соответственно, я попытался сделать попытку написать книжку (хотя на книгу этот материал не тянет, скорей на методичку), которая позволила бы сравнительно просто перейти с пользовательского уровня знакомства с Linux на более высокий уровень, не проходя по типичным ошибкам, и за сравнительно короткое время.</para>
      <para>Некоторое время я использовал фрагменты этой книги также как часть учебного курса в Челябинском Государственном университете (ЧелГУ) для того, чтобы мои студенты могли ориентироваться в системе несколько лучше, чем на уровне команд <command>ls</command>/<command>ps</command>/<command>exit</command>. Конечно, если честно – как учебное пособие эта маленькая книга непригодна, но, как мне кажется, она неплохо подходит как дополнительная литература. </para>
      <para>Если у вас есть пожелания и дополнения – пишите мне почтой на <link xlink:href="mailto:dalt74@gmail.com">dalt74@gmail.com</link> , я постараюсь учесть ваши замечания в следующей редакции. Большое спасибо всем тем кто участвовал в рецензировании и помогал советами и замечаниями. </para>
      <para>Искренне ваш, Артем Капитула (no-dashi, dalth &amp; viking)</para>
      <para>P.S. если вы будете распечатывать или выкладывать это пособие – пожалуйста, указывайте ссылку на автора и оригинальный источник, договорились?</para>
      <para>P.P.S. пока что есть следующий to-do list: основы DNS, базовые настройки серверов и рабочих станций под типичные нужды. Ориентировочный срок следующей редакции – через три месяца.</para>
   </section>
   <section xml:id="kernel_and_modules">
      <title>Ядро и модули</title>
      <para>Ядро Linux является единственным процессом, имеющим непосредственный доступ к аппаратуре – все остальные процессы обращаются к устройствам только через ядро. В ядре Linux можно выделить несколько важных подсистем: <indexterm><primary>Подсистема управления памятью</primary></indexterm>подсистему управления памятью; <indexterm><primary>Планировщик задач</primary></indexterm>планировщик задач; подсистему <indexterm><primary>VFS</primary></indexterm><indexterm><primary>Виртуальная файловая система</primary></indexterm>VFS – виртуальную файловую систему и драйверы. </para>
      <para>Подсистема управления памятью управляет распределением оперативной памяти между задачами, а также обслуживает файл подкачки, планировщик задач управляет разделением процессорного времени между задачами (процессами и нитями), подсистема VFS предназначена для обслуживания файловых операций.</para>
      <para>Драйверы предназначены для управления устройствами и поддержки различных протоколов. Существует две разновидности драйверов – статически подключенные в ядро драйверы и загружаемые модули; первые всегда загружены, вторые могут быть загружены при необходимости и выгружены, когда необходимость в них отпала. Каждый модуль и само ядро содержат сигнатуру версии – специальную метку, которая описывает версию ядра и некоторые опции, использованные при компиляции ядра. Кроме того, ядра версии 2.6 могут поддерживать цифровую подпись модулей. Это было сделано для повышения надежности системы – по умолчанию ядро не будет загружать и использовать драйверы, предназначенные для другой версии ядра, или собранные с другими опциями, поскольку это может привести к возникновению проблем. Версию ядра можно узнать с помощью команды <command>uname</command> :</para>
      <screen><prompt>$</prompt> <userinput>uname -r</userinput>
2.6.8.1</screen>
      <para>В принципе, утилиты для работы с модулями поддерживают возможность загрузки модулей, собранных для другого ядра – но пользоваться этой возможностью следует с крайней осторожностью, поскольку это может привести к непредсказуемым последствиями – от ошибок ядра (kernel panic) и вплоть до странных потерь данных и непонятных ошибок, взявшихся на пустом месте.</para>
      <para>В большинстве дистрибутивов образ ядра располагается в каталоге <filename>/boot</filename>, а загружаемые модули ядра располагаются в <filename>/lib/modules/<replaceable>&lt;версия_ядра&gt;</replaceable></filename>, там же располагается таблица зависимостей модулей, поскольку некоторые модули могут нуждаться для своей работы в других модулях (например, драйвер поддержки SCSI-дисков нуждается в драйвере поддержки SCSI – как следствие этого, если объекты какого-либо модуля используются другим драйвером, такой модуль невозможно выгрузить). Следующий листинг демонстрирует достаточно типичное содержание каталога модулей для ядер линейки 2.6:</para>
      <screen><prompt>$</prompt> <userinput>ls -l /lib/modules/2.6.8.1/</userinput>
total 616
lrwxrwxrwx   1 root root     18 Авг 27 15:36 build -&gt; /usr/src/linux
drwxr-xr-x  10 root root   4096 Окт  1 13:55 kernel
-rw-r--r--   1 root root 108680 Окт  1 13:56 modules.alias
-rw-r--r--   1 root root     69 Окт  1 13:56 modules.ccwmap
-rw-r--r--   1 root root 153967 Окт  1 13:56 modules.dep
-rw-r--r--   1 root root     73 Окт  1 13:56 modules.ieee1394map
-rw-r--r--   1 root root    357 Окт  1 13:56 modules.inputmap
-rw-r--r--   1 root root  16658 Окт  1 13:56 modules.isapnpmap
-rw-r--r--   1 root root  85093 Окт  1 13:56 modules.pcimap
-rw-r--r--   1 root root  68078 Окт  1 13:56 modules.symbols
-rw-r--r--   1 root root 150781 Окт  1 13:56 modules.usbmap
lrwxrwxrwx   1 root root     18 Окт  1 13:22 source -&gt; /usr/src/linux

<prompt>$</prompt> <userinput>find /lib/modules/2.6.8.1/kernel -type f | head -20</userinput>		
/lib/modules/2.6.8.1/kernel/arch/i386/kernel/cpuid.ko
/lib/modules/2.6.8.1/kernel/arch/i386/kernel/microcode.ko
/lib/modules/2.6.8.1/kernel/arch/i386/kernel/msr.ko
/lib/modules/2.6.8.1/kernel/crypto/blowfish.ko
/lib/modules/2.6.8.1/kernel/crypto/deflate.ko
/lib/modules/2.6.8.1/kernel/crypto/md5.ko
/lib/modules/2.6.8.1/kernel/crypto/twofish.ko
/lib/modules/2.6.8.1/kernel/drivers/acpi/fan.ko
/lib/modules/2.6.8.1/kernel/drivers/acpi/processor.ko
/lib/modules/2.6.8.1/kernel/drivers/acpi/thermal.ko
/lib/modules/2.6.8.1/kernel/drivers/base/firmware_class.ko
/lib/modules/2.6.8.1/kernel/drivers/block/cryptoloop.ko
/lib/modules/2.6.8.1/kernel/drivers/block/loop.ko
/lib/modules/2.6.8.1/kernel/drivers/block/nbd.ko
/lib/modules/2.6.8.1/kernel/drivers/block/paride/epat.ko
/lib/modules/2.6.8.1/kernel/drivers/block/paride/paride.ko
/lib/modules/2.6.8.1/kernel/drivers/block/paride/pd.ko
/lib/modules/2.6.8.1/kernel/drivers/block/paride/pg.ko
/lib/modules/2.6.8.1/kernel/drivers/bluetooth/bcm203x.ko
/lib/modules/2.6.8.1/kernel/drivers/bluetooth/bfusb.ko</screen>
      <para>Бинарные файлы модулей содержатся в подкаталоге kernel, и имеют расширение “<filename>.o</filename>” для ядер линейки 2.4 и расширение “<filename>.ko</filename>” для ядер линейки 2.6. В файлах <filename>modules.***map</filename> перечисляются символы (функции и переменные), экспортируемые модулями.</para>
      <para>Часто в одном каталоге с модулями содержатся ссылки на каталоги, в которых хранились исходные тексты ядра и в котором производилась сборка ядра (это ссылки <filename>source</filename> и <filename>build</filename>, соответственно). Эти ссылки, как правило, используются для того, чтобы скомпилировать модули или программы, которые зависят от версии ядра (например, эти ссылки используются при инсталляции модуля поддержки видеокарт nvidia).</para>
      <para>Учет взаимосвязей между загруженными модулями производится с помощью счетчика ссылок – модуль увеличивает свой счетчик ссылок как только какой-либо его объект начинает использоваться другими драйверами. Когда объекты модуля освобождаются, счетчик ссылок уменьшается. Модуль может быть выгружен, если число ссылок на него станет равно 0. В ядрах версии 2.6 существует возможность произвести принудительную выгрузку модуля даже если он используется, но этим пользоваться без крайней необходимости не рекомендуется, поскольку очень возможно возникновение ошибок.</para>
      <para>Ядро содержит множество переменных и функций, которые используются различными драйверами, и соответственно, если какой-либо драйвер должен обратиться к такому объекту, он должен знать его адрес. Некоторые драйверы также содержат переменные и функции, которые должны быть доступны другим драйверам, и адреса таких объектов тоже размещаются в специальной таблице. При загрузке модуля ядро и программа загрузки модулей устанавливает адреса всех объектов, в которых нуждается загружаемый модуль, и только после этого модуль может начать инициализацию.</para>
      <para>Загрузка модулей и их выгрузка осуществляются утилитами modprobe, insmod и rmmod. Программы modinfo и depmod предназначены для получения служебной информации о загружаемых модулях. В процессе своей работы эти утилиты опираются на конфигурационные файлы <filename>/etc/modprobe.conf</filename> (для ядер 2.6.X) или <filename>modules.conf</filename> (для ядер 2.4.X).</para>
   </section>
   <section xml:id="load_os">
      <title>Загрузка операционной системы</title>
      <para>Для компьютеров архитектуры x86 последовательность загрузки хорошо описана в специализированной литературе, но мы все-таки кратко ее повторим. После включения компьютера первым загружается BIOS. Он тестирует аппаратуру и инициализирует устройства. После этого BIOS прочитывает начальный сектор загрузочного жесткого диска (MBR), убеждается что он содержит код первичного загрузчика, и передает управление прочитанному коду. Кроме кода первичного загрузчика, начальный сектор также может содержать таблицу разделов жесткого диска.</para>
      <para>В задачи первичного загрузчика входит чтение основного кода загрузчика операционной системы и передача управления ему, после чего основная часть загрузчика может считать конфигурационный файл, загрузить ядро операционной системы, установить параметры для ядра и передать ядру управление. Ядро инициализирует драйверы, проверяет параметры и, опираясь на параметры, пытается смонтировать корневую файловую систему, после чего (если не было проинструктировано об ином) запускает программу <command>/sbin/init</command>. Дальнейшая работа init подробно описана во множестве книг и статей.</para>
      <para>В настоящий момент в мире Linux наиболее распространен загрузчик GRUB. Этот загрузчик состоит из нескольких частей – первичного загрузчкиа, собственно основного кода который организует интерфейс пользователя, и набора мини-драверов различных файловых систем, позволяющих прочесть необходимые файлы с файловой системы в момент когда операционная система еще недоступна. Каждая из этих компонент работает на одноим из двух этапов загрузки. Рассмотрим эти этапы:</para>
      <para>Этап 0 – здесь срабатывает первичный загрузчик GRUB. Он компактен и умещается в один блок жесткого диска, что позволяет при желании разместить его в MBR. В задачи кода stage_0 входит прочтение кода необходимого на следующем этапе (собственно кода загрузчика и мини-драйвера файловой системы где расположены основные файлы загрузчика), и передача управления прочитанному коду.</para>
      <para>Этап 1 – это на этом этапе первичным загрузчиком в память уже загружен основной код загрузчика, а также мини-драйвер файловой системы, на которой расположены конфигурационные файлы загрузчика, ядро и необходимые драйверы. Основной код, используя функции мини-драйвера, прочитывает конфигурационный файл и организует диалог с пользователем. В зависимости от выбора пользователя, используя мини-драйвер файловой системы, с диска прочитываются файлы ядра и необходимых драйверов, после чего управление передается ядру. Как вариант, пользователь может отказаться от загрузки Linux и инструктировать GRUB прочесть загрузочный сектор некоторого раздела жесткого диска и передать управление ему.</para>
      <para>Первичный загрузчик из состава GRUB может быть расположен как в MBR, так и в загрузочном секторе какого-либо раздела жесткого диска – или даже храниться в файле и быть вызван из другого загрузчика (например NTLOADER).</para>
      <para>Нередко случаются ситуации, когда корневая файловая система располагается на устройстве, чей драйвер скомпилирован в виде модуля, или драйвер корневой файловой системы скомпилирован в виде модуля. Получается замкнутый круг – чтобы смонтировать корневую файловую систему, необходимо прочесть драйвер, а чтобы прочесть драйвер – нужно смонтировать корневую файловую систему. Чтобы разорвать этот порочный круг, в Linux была введен поддержка initrd – INITial RamDisk.</para>
      <para>Initial ramdisk – это файл, который прочитывается загрузчиком ОС и загружается в память вместе с ядром. Ядро интерпретирует фрагмент памяти, куда загружен этот файл, как блочное устройство с помощью специального драйвера, статически вкомпилированного в ядро. После инициализации статически скомпилированных драйверов ядро монтирует файловую систему, хранящуюся в initrd и загружает с нее драйверы и запускает программы, необходимые для монтирования корневой файловой системы.</para>
      <para>Обычно файл с образом ядра хранится в каталоге <filename>/boot</filename> и называется <filename>vmlinuz-<replaceable>&lt;версия&gt;</replaceable></filename>, там же располагается файл <filename>initrd-<replaceable>&lt;версия&gt;</replaceable>.img</filename>, содержащий образ файловой системы initrd. Для каждой версии ядра необходим свой образ initrd, в который включены модули для этой версии ядра. В большинстве случаев образ initrd поставляется в бинарном пакете вместе с ядром, или автоматически создается в процессе построения ядра из исходных текстов в момент выполнения команды make install, если же возникает ситуация, когда необходимо повторно собрать образ initrd (например, в сервере сменили SCSI-контроллер), можно воспользоваться специальной командой mkinitrd, позволяющей произвести повторную генерацию initrd:</para>
      <screen><prompt>$</prompt> <userinput>mkinitrd /tmp/initrd-2.4.8.1.img 2.6.8.1</userinput>
<prompt>$</prompt> <userinput>cp /tmp/initrd-2.4.8.1.img /boot</userinput>
<prompt>$</prompt> <userinput>reboot</userinput></screen>
      <para>Для Linux существует два основных загрузчика – LILO и GRUB. Второй является более поздней разработкой и немного удобней в использовании, а LILO используется по историческим или личным причинам (например, он нравится системному администратору), либо в некоторых случаях, когда требуются специфичные для LILO функции. Для более подробной справки лучше обратиться к справочному руководству (<command>man grub</command>, <command>man lilo</command>).</para>
      <para>Из интересных особенностей GRUB и LILO следует отметить то, что и оба этих загрузчика, и ядро оперируют термином корневой файловой системы – но если с точки зрения ядра эта та файловая система, которая содержит программу /sbin/init, то с точки зрения обоих загрузчиков корневой файловой системой является та, которая содержит образ ядра и файл initrd.</para>
   </section>
   <section xml:id="memory_organization">
      <title>Организация памяти</title>
      <para>Подсистема виртуальной памяти управляет распределением оперативной памяти между задачами (процессами). Каждая задача считает, что ей выделен непрерывный участок памяти максимального размера, поддерживаемого на соответствующей архитектуре (для архитектуры x86 это 4GB). Из них первый гигабайт резервируется для себя ядром, второй отдается под код программы и разделяемые библиотеки (оба этих фрагмента ядром защищаются), а два последних гигабайта отдаются собственно программе под ее данные – но это только то, как видит это все программа.</para>
      <para>На самом же деле программа занимает только тот объем памяти, с которым она реально работает. Большинство памяти существует только “на бумаге”, т.е. будет предоставлена программе в тот момент, когда она обратится в эту область. Ядро распределяет память страницами фиксированного размера. Процедура, когда страница оперативной памяти объявляется частью адресного пространства процесса, называется отображением этой страницы в адресное пространство процесса.</para>
      <para>Соответственно, ядро отображает реально используемые страницы в виртуальное адресное пространство процесса. Когда процесс обращается к некоторой странице своего адресного пространства, ядро проверяет, имеет ли он право на доступ к этой странице, и если проверка пройдена и доступ получен, то ядро переадресовывает обращение на реальный адрес этой страницы. Если это первое обращение к странице, ядро попытается найти свободную страницу и в случае успеха отобразит ее в адресное пространство соответствующего процесса. Размер страницы фиксирован архитектурой процессора, и для x86 ее размер составляет 4096 байт.</para>
      <para>Если случается ситуация, когда свободных страниц больше нет, но существует файл подкачки, ядро может убрать одну из наиболее долго не использовавшихся страниц в файл подкачки, и освободившуюся физическую страницу отдать запросившему память процессу. Если же нет ни незанятого пространства в файле подкачки, ни свободных страниц RAM, то развитие событий может быть следующим: либо запросивший память процесс прерван и “убит” системой, либо какой-то другой из процессов (это определяется специфическими алгоритмами) будет “убит” ядром, и освободившаяся память будет передана запросившему память процессу.</para>
      <para>На самом деле большинством действий занимается одна из подсистем процессора, называемая MMU – Memory Management Unit, и в действительности ядро просто полагается на его работу и вмешивается в нее только для проведения операций пейджинга (подгрузки/выгрузки страниц в SWAP-файл), или когда возникает ошибка доступа к странице.</para>
      <para>Ограничение адресного пространства в 4GB не означает, что система не сможет адресовать более этого объема памяти. На платформе x86 ядро Linux может использовать до 64GB, а ограничение в 4GB накладывается лишь на размер адресного пространства процесса.</para>
   </section>
   <section xml:id="system_5_shared_memory">
      <title>System V shared memory</title>
      <para>Linux поддерживает стандартную для всех UNIX-подобных операционных систем организацию разделяемой памяти. Пользовательские приложения могут создавать сегменты разделяемой памяти, которые могут быть присоединены к некоторому фрагменту адресного пространства процесса. Любой процесс, имеющий достаточные права доступа, может присоединиться к сегменту разделяемой памяти, и отобразить его в свое адресное пространство, начиная с некоторого адреса.</para>
      <para>Если в приведенной схеме любой из процессов изменит содержимое памяти в области, занимаемой отображением одного из сегментов, то же самое изменение произойдет в адресном пространстве другого процесса, поскольку соответствующий сегмент существует в одном экземпляре и отображен в адресное пространство обоих процессов.</para>
      <para>Кроме System V IPC ядро Linux также поддерживает другие объекты IPC, в частности семафоры и очереди сообщений. Каждый объект System V IPC идентифицируется уникальным ключом. Просмотреть список всех объектов IPC можно командой ipcs. Команда ipcrm позволяет удалять объекты IPC, которые по каким-либо причинам остались не освобожденными после завершения создавшего их процесса – например, такая ситуация может возникнуть после аварийного завершения работы СУБД Oracle, Informix или DB2.</para>
      <para>Соответственно, перед перезапуском процесса системный администратор с помощью команды ipcrm должен освободить неиспользуемые объекты IPC, поскольку стартующее приложение не сможет их повторно создать и не будет корректно работать.</para>
      <para>Для каждого объекта IPC система устанавливает права доступа, как если бы это был файл (т.е. для каждого объекта IPC можно устанавливать набор прав ugo/rwx, но в отличие от обычных файлов сменить права доступа для IPC-объектов можно только вызывая специализированные функции, предназначенные для работы с такими объектами.</para>
      <mediaobject>
         <imageobject>
            <imagedata fileref="images/System_V_shared_memory.png" format="PNG" align="center" width="90%"/>
         </imageobject>
         <textobject>
            <phrase>System V shared memory</phrase>
         </textobject>
         <caption>
            <para><emphasis role="strong">System V shared memory.</emphasis></para>
         </caption>
      </mediaobject>
      <screen><prompt>$</prompt> <userinput>ipcs</userinput>

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status
0x00000000 0          oracle    640        4194304    10
0x00000000 32769      oracle    640        20971520   10
0x00000000 65538      oracle    640        29360128   10
0x0d3c24a0 98307      oracle    640        29360128   50
0x00000000 13697028   root      777        49152      1
0x00000000 13729797   root      777        16384      1
0x000004d2 13795334   dalth     666        1008       2
0x00000000 14286866   root      644        790528     2          dest
0x00000000 21823507   dalth     600        393216     2          dest
0x00000000 21921814   root      644        122880     2          dest
0x00000000 14516249   root      644        151552     1          dest

------ Semaphore Arrays --------
key        semid      owner      perms      nsems
0x0b4f657c 262147     oracle    640        154
0x000004d2 458756     dalth     666        1

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages</screen>
      <para>Поддержка System V IPC позволяет сравнительно легко переносить на Linux приложения, написанные для других UNIX-систем.</para>
   </section>
   <section xml:id="file_system">
      <title>Файловая система</title>
      <section xml:id="vfs">
         <title>Виртуальная файловая система</title>
         <para>VFS и драйверы файловых систем являются одной из важнейших составляющих ядра. Для того, чтобы получить доступ к файлам, хранящимся на каком-либо устройстве хранения данных, необходимо, чтобы в ядро был загружен драйвер соответствующей файловой системы, и файловая система была смонтирована. Драйвера всех файловых систем поддерживают набор стандартных функций: открыть файл по имени, записать данные в файл, прочитать данные из файла, закрыть файл, удалить файл и т.д.</para>
         <para>Уточним, что драйвера файловых систем не занимаются кэшированием, этим занимается VFS.</para>
         <para>При первоначальной загрузке драйвер файловой системы регистрирует в VFS имя файловой системы и те функции, которые предназначены для выполнения стандартных файловых операций. Впоследствии при обращении к файлу на какой-либо файловой системе VFS будет переадресовывать обращение на соответствующую функцию, если таковая была зарегистрирована драйвером. Посмотреть список обслуживаемых ядром файловых систем можно в файле <filename>/proc/filesystems</filename>:</para>
         <screen><prompt>$</prompt> <userinput>cat /proc/filesystems</userinput>
nodev   sysfs
nodev   rootfs
nodev   bdev
nodev   proc
nodev   sockfs
nodev   usbfs
nodev   usbdevfs
nodev   futexfs
nodev   tmpfs
nodev   pipefs
nodev   eventpollfs
nodev   devpts
ext2
nodev   ramfs
nodev   hugetlbfs
iso9660
nodev   devfs
nodev   mqueue
ext3
nodev   rpc_pipefs
nodev   nfsd
nodev   smbfs</screen>
         <para>Операция монтирования предназначена для того, чтобы сделать доступной файловую систему, расположенную на каком-либо блочном устройстве. Суть операции монтирования заключается в том, что ядро ассоциирует некоторый каталог (называемый точкой монтирования) с блочным устройством и драйвером файловой системы. Для этого оно передает ссылку на блочное устройство драйверу файловой системы, и в случае, если драйвер успешно проидентифицировал эту файловую систему, ядро заносит в специальную таблицу монтирования информацию о том, что все файлы и каталоги, чей полный путь начинается с указанной точки монтирования, обслуживаются соответствующим драйвером файловой системы и расположены на указанном блочном устройстве.</para>
         <para>Некоторые файловые системы не нуждаются в блочном устройстве, поскольку хранят свои данные исключительно в памяти, например файловая система procfs, через файлы которой можно получить доступ к различным системным параметрам и таблицам.</para>
         <para>Очень часто при монтировании файловой системы системный администратор имеет возможность задать опции монтирования. Опции монтирования – это специальные параметры, которые влияют на работу драйвера файловой системы, когда он работает с файловой системой на соответствующем блочном устройстве – например, с помощью опций монтирования можно управлять режимом кэширования данных, преобразованиями имен файлов и данных, включать и отключать поддержку ACL и т.д.</para>
         <para>Посмотреть таблицу примонтированных файловых систем можно через файл <filename>/proc/mounts</filename>:</para>
         <screen><prompt>$</prompt> <userinput>cat /proc/mounts</userinput>
rootfs / rootfs rw 0 0
/dev/root / ext3 rw 0 0
none /dev devfs rw 0 0
/proc /proc proc rw,nodiratime 0 0
/sys /sys sysfs rw 0 0
none /dev/pts devpts rw 0 0
usbdevfs /proc/bus/usb usbdevfs rw 0 0
/dev/chimera/var /var ext3 rw 0 0
/dev/chimera/temp /tmp ext3 rw 0 0
/dev/chimera/usr /usr ext3 rw 0 0
/dev/chimera/home /home ext3 rw 0 0
/dev/chimera/opt /opt ext3 rw 0 0
none /dev/shm tmpfs rw 0 0</screen>
         <para>Виртуальная файловая система Linux различает несколько типов файлов: каталоги, обычные файлы, именованные каналы, символьные ссылки, сокеты и специальные файлы. Каждая из этих разновидностей обрабатывается своим собственным образом:</para>
         <orderedlist>
            <listitem>
               <para>Обычные файлы могут быть прочитаны, записаны, удалены или отображены в память.</para>
            </listitem>
            <listitem>
               <para>Каталог можно представить как список имен файлов, и для этого списка определены операции добавления элемента в список, удаление элемента из списка, переименование элемента списка.</para>
            </listitem>
            <listitem>
               <para>Именованные каналы являются просто буферами – в него можно записать некоторый объем данных, и прочесть их в том же порядке, в каком они были записаны.</para>
            </listitem>
            <listitem>
               <para>Сокеты являются вариантом именованных каналов, но если у именованного канала буфер только один, то есть нельзя определить какой процесс записал данные в канал, то у сокетов может быть несколько клиентов, один из которых осуществляет управление сокетом и может обмениваться данными с любым из остальных клиентов, а те в свою очередь могут обмениваться данными с диспетчером канала – то есть сокет поддерживает множество независимых буферов, по одному на каждую пару сервер+клиент</para>
            </listitem>
            <listitem>
               <para>Специальные файлы предназначены для того, чтобы осуществлять прямой доступ к устройствам. Подробнее о специальных файлах будет говориться в главе <xref linkend="secrets_of_dev"/></para>
            </listitem>
            <listitem>
               <para>Символьные ссылки являются “ярлыками”, которые могут содержать имя другого файла – и тогда операции чтения, записи и открытия/закрытия файла автоматически переадресовываются к файлу, на который указывает символьная ссылка, но в отличие от “ярлыков” Windows (shortcuts), символьные ссылки (symbolic links) не требуют специальных функций при работе – все программы (кроме тех, которые специально предназначены для работы с ними) видят их как обычные файлы, и также их открывают, читают и записывают данные и т.д.</para>
            </listitem>
         </orderedlist>
         <para>В некоторых файловых системах, которые изначально проектировались для UNIX-подобных систем, есть возможность создавать кроме символьных ссылок еще и жесткие ссылки. Фактически, жесткая ссылка – это второе имя для файла. Жесткие ссылки возможно создавать только в пределах одной файловой системы.</para>
         <para>Из-за того, что в VFS присутствует понятие кэширования, перед отключением системы необходимо делать обязательный сброс изменений на диск. Сброс кэша на диск осуществляется в момент размонтирования файловой системы. Кроме того, с помощью команды sync можно в любой момент принудительно сбросить на диск все закэшированные изменения в файловой системе (например, системные администраторы часто делают sync перед загрузкой нового драйвера). Размонтировать файловую систему можно только тогда, когда ни один процесс не удерживает в открытом состоянии файлов с этой файловой системы, а также не находится ни один процесс не имеет рабочим каталогом каталога с размонтируемой файловой системы. При невыполнении этого условия размонтировать файловую систему не удастся:</para>
         <screen><prompt>$</prompt> <userinput>umount /home/ftp/pub/linux/fedora/cd1</userinput>
umount: /home/ftp/pub/linux/fedora/cd1: device is busy
umount: /home/ftp/pub/linux/fedora/cd1: device is busy</screen>
         <para>Некоторые файловые системы поддерживают специальные опции, позволяющие принудительно синхронизировать файловую систему при каждой операции чтения или записи. Обычно опции, влияющие на синхронизацию файловой системы, содержат в своем названии слово sync, например приведенная ниже команда инструктирует операционную систему примонтировать некоторый раздел в режиме принудительной синхронизации:</para>
         <screen><prompt>$</prompt> <userinput>mount -t ext3 -o sync,dirsync /dev/hda9 /home</userinput></screen>
         <para>Следует учесть, что принудительная синхронизация – это удар по производительности операций записи для файловой системы, смонтированной в таком режиме, поэтому использовать такой его следует осторожно.</para>
      </section>
      <section xml:id="privileges">
         <title>Права доступа</title>
         <para>Кроме стандартных наборов прав доступа к файлам некоторые файловые системы Linux поддерживают т.н. POSIX ACL – списки контроля доступа POSIX. Эта возможность позволяет гибко управлять доступом к файлу, не ограничиваясь “классическим” набором ugo/rwx. Для того, чтобы использовать на файловой системе POSIX ACL, необходимо смонтировать файловую систему с опцией acl:</para>
         <screen><prompt>$</prompt> <userinput>mount -t ext3 -o acl /dev/inferno/opt /opt</userinput></screen>
         <para>Возможно также настроить соответствующий параметр для файловой системы, чтобы она поддерживала POSIX ACL по умолчанию:</para>
         <screen><prompt>$</prompt> <userinput>tune2fs -o acl /dev/inferno/opt</userinput></screen>
         <para>После установки соответствующей опции можно приступать к работе с POSIX ACL. Для работы с ними существует две базовых утилиты: getfacl для получения списка дополнительных атрибутов доступа, и setfacl для установки расширенных атрибутов контроля доступа. Если в выводе команды <command>ls</command> вы видите символ “+” рядом со списком стандартных прав доступа, это означает, что для файла также установлены расширенные атрибуты контроля доступа:</para>
         <screen><prompt>$</prompt> <userinput>ls -l /home/dalth/.bash_???????</userinput>
-rw-r-----+ 1 dalth dalth 20034 Окт 11 22:48 /home/dalth/.bash_history
-rw-r--r--  1 dalth dalth   191 Авг 23 21:51 /home/dalth/.bash_profile</screen>
         <para>Для просмотра значений расширенных атрибутов можно воспользоваться утилитой getfacl. Жирным шрифтом выделен дополнительный атрибут контроля доступа, позволяющий пользователю kiki получить доступ на чтение к файлу <filename>.bash_history</filename>:</para>
         <screen><prompt>$</prompt> <userinput>getfacl .bash_history</userinput>
# file: .bash_history
# owner: dalth
# group: dalth
user::rw-
user:kiki:r--
group::---
mask::r--
other::---</screen>
         <para>Добавим пользователю oracle права на чтение и запись файла <filename>.bash_history</filename> с помощью команды <command>setfacl</command>, и затем отберем дополнительные права на доступ к указанному файлу у пользователя kiki:</para>
         <screen><prompt>$</prompt> <userinput>setfacl -m u:oracle:rw .bash_history</userinput>
<prompt>$</prompt> <userinput>setfacl -x u:kiki .bash_history</userinput>
<prompt>$</prompt> <userinput>getfacl .bash_history</userinput>
# file: .bash_history
# owner: dalth
# group: dalth
user::rw-
user:oracle:rw-
group::---
mask::rw-
other::---</screen>
         <para>Последним шагом сбросим все расширенные атрибуты с файла с файла <filename>.bash_history</filename>:</para>
         <screen><prompt>$</prompt> <userinput>setfacl -b .bash_history</userinput>
<prompt>$</prompt> <userinput>ls -l .bash_history</userinput>
<prompt>$</prompt> <userinput>getfacl .bash_history</userinput>
-rw-------  1 dalth dalth 20034 Окт 11 22:48 .bash_history</screen>
         <para>Расширенные атрибуты позволяют гибко контролировать доступ к файловых объектам, обходя стратегию ugo/rwx пришедшую из “классического UNIX”. Права доступ на файловые объекты могут быть выданы не только пользователю, но и группе.</para>
         <para>К сожалению, далеко не все утилиты и файловые системы поддерживают ACL, поэтому при резервном копировании или восстановлении файлов необходимо проверять корректность установки расширенных атрибутов и правильность их переноса.</para>
      </section>
      <section xml:id="journal_file_system">
         <title>Журналируемые файловые системы</title>
         <para>Для обеспечения сохранности данных и обеспечения целостности файловых систем при неожиданных сбоях были разработаны журналируемые файловые системы. Как правило, у этих файловых систем существует специальная область данных, называемая журналом. Все изменения, которые необходимо произвести с файловой системой, сначала записываются в журнал, и уже из журнала попадают в основную часть файловой системы.</para>
         <para>В большинстве случаев журналируются только метаданные файловых систем (служебная информация, обеспечивающая целостность структуры файловой системы – например, изменения в каталогах или служебных таблицах размещения файлов). Некоторые файловые системы позволяют журналировать не только метаданные, но и данные файлов – такой шаг позволяет повысить надежность, но уменьшает скорость записи данных на файловую систему, поскольку каждый блок данных записывается на диск дважды – сначала в журнал, и затем из журнала в основную область файловой системы.</para>
         <para>В большинстве случаев, журналируемые файловые системы способны решить проблемы с надежностью при неожиданных сбоях без тех потерь производительности, к которым может привести использование опции sync при монтировании.</para>
         <para>В частности, к журналируемым файловым системам, например, относятся EXT3, ReiserFS, XFS, JFS и некоторые другие.</para>
      </section>
      <section xml:id="mapped_memory_files">
         <info>
            <title>Отображаемые в память файлы</title>
         </info>
         <para>Объединение кэширования файлов и разделяемой памяти позволяет реализовать такое действие, как отображение файла в память. Для простоты можно представить, что файл загружается в кэш, и страницы кэша отображаются в адресное пространство процесса, и в результате любое изменение в том фрагменте адресного пространства, которое занято отображением файла, автоматически попадает в закэшированные данные файла. Когда файл закрывается, закэшированные изменения сбрасываются на диск, изменяя сам файл. Кроме того, в свободное время ядро также постепенно сбрасывает изменившиеся кэшированные данные на диск.</para>
         <mediaobject>
            <imageobject>
               <imagedata fileref="images/mapped_memory_files.png" format="PNG" align="center" width="90%"/>
            </imageobject>
            <textobject>
               <phrase>Files mapped in memory </phrase>
            </textobject>
         </mediaobject>
         <para>На самом деле, механизм отображения файлов в память куда “хитрее” – при обращении по записи к странице, которая является отображением некоторого файла, ядро перехватывает обращение, производит запись в файл (в подавляющем большинстве случаев эта операция попадает в кэш). При обращении по чтению к такой странице ядро опять же перехватывает обращение и производит чтение из файла – в большинстве случаев это чтение производится из кэша. Для наших же целей проще будет считать, что страницы кэша отображены в память процесса.</para>
         <para>Такая методика часто используется для загрузки разделяемых библиотек, когда выполняемый код библиотек и исполняемого кода программы хранится в кэше и через отображение файла в память становится виден в адресном пространстве процесса:</para>
         <screen><prompt>$</prompt> <userinput>cat /proc/1/maps</userinput>
08048000-08050000 r-xp 00000000 03:01 75813      /sbin/init
08050000-08051000 rw-p 00008000 03:01 75813      /sbin/init
08051000-08072000 rw-p 08051000 00:00 0 
40015000-40016000 rw-p 40015000 00:00 0 
4c8ee000-4c903000 r-xp 00000000 03:01 92869      /lib/ld-2.3.3.so
4c903000-4c904000 r--p 00014000 03:01 92869      /lib/ld-2.3.3.so
4c904000-4c905000 rw-p 00015000 03:01 92869      /lib/ld-2.3.3.so
4c907000-4ca1c000 r-xp 00000000 03:01 92857      /lib/tls/libc-2.3.3.so
4ca1c000-4ca1e000 r--p 00115000 03:01 92857      /lib/tls/libc-2.3.3.so
4ca1e000-4ca20000 rw-p 00117000 03:01 92857      /lib/tls/libc-2.3.3.so
4ca20000-4ca22000 rw-p 4ca20000 00:00 0 
4d201000-4d20f000 r-xp 00000000 03:01 92965      /lib/libselinux.so.1
4d20f000-4d211000 rw-p 0000d000 03:01 92965      /lib/libselinux.so.1
bfffd000-c0000000 rw-p bfffd000 00:00 0
ffffe000-fffff000 ---p 00000000 00:00 0</screen>
         <para>На самом деле, драйверы любого устройства и любой файловой системы могут по-своему реализовывать операцию mmap, но большинство драйверов файловых систем полагаются в этом на VFS.</para>
      </section>
      <section xml:id="special_file_systems">
         <info>
            <title>Специальные файловые системы</title>
         </info>
         <para>Некоторые типы файловых систем являются специальными и предназначаются для выполнения или реализации специфических задач операционной системы. К таким файловым системам относятся файловые системы procfs и sysfs, предоставляющие доступ к различным параметрам системы и системным объектам, “живущим” в ядре.</para>
         <para>Файловая система sysfs в основном предоставляет доступ к объектам ядра и отображает взаимосвязи между ними. Файловая система procfs предоставляет доступ к различным параметрам ядра и драйверов и к пользовательским процессам, позволяя тем самым реализовать такие команды как ps или sysctl. Большинство файлов в sysfs двоичные, в procfs – текстовые.</para>
         <para>Драйверы файловых системы ramfs, tmpfs и shmfs очень похожи, и после монтирования файловой системы такого типа на ней можно создавать файлы, хранящиеся в памяти и отличаются в основном небольшими особенностями работы (например, страницы, используемые ramfs под данные файлов, не вытесняются в swap-файл в отличие от shmfs и tmpfs). В ядре 2.6 shmfs была заменена на tmpfs.</para>
      </section>
      <section xml:id="network_file_systems">
         <info>
            <title>Сетевые файловые системы</title>
         </info>
         <para>Сетевые файловые системы предназначены для получения доступа к файловым системам других компьютеров с использованием сетевых протоколов.</para>
         <para>Наиболее часто используются сетевые файловые системы NCPFS (для доступа к серверам Novell NetWare), SMBFS (для доступа к серверам Windows) и NFS (для доступа к файловым системам других UNIX-систем).</para>
         <para>Как правило, процедура монтирования сетевых файловых систем схожа с процедурой монтирования обычных файловых систем на блочных устройствах с тем отличием, что вместо блочного устройства указывается адрес сервера, чья файловая система монтируется, и имя монтируемого ресурса. Для примера рассмотрим процедуры монтирования ресурсов, доступных по SMB и по NFS:</para>
         <screen><prompt>$</prompt> <userinput>mount -t smbfs -o username=usr,workgroup=tst //server/share_name /mnt/smb_target</userinput>
Password: <userinput>********</userinput>
<prompt>$</prompt> <userinput>mount -t nfs -o timeout=4 server:/export/home /mnt/nfs_target</userinput></screen>
         <para>В данном примере опция <option>-t</option> команды mount указывает тип файловой системы, опция -o позволяет задать дополнительные параметры для монтирования – для SMB мы задаем, например, имя пользователя, с правами которого производится подключение к серверу и имя рабочей группы или домена, для NFS мы указываем таймаут, по истечении которого операция ввода/вывода считается неудавшейся. Вместо блочного устройства мы указываем адрес сервера, ресурс которого хотим использовать, и имя ресурса на сервере. Последним параметром идет точка монтирования.</para>
      </section>
      <section xml:id="create_file_systems">
         <info>
            <title>Создание файловых систем</title>
         </info>
         <para>Для создания файловых систем в Linux используется команда mkfs:</para>
         <screen><prompt>$</prompt> <userinput>mkfs -t ext3 /dev/hda6</userinput></screen>
         <para>На самом деле, mkfs является просто “оберткой” к реальным программам создания файловых систем, которые обычно именуются как <command>mkfs.<replaceable>&lt;имя_ФС&gt;</replaceable></command>, например <command>mksf.ext2</command> или <command>mkfs.reiserfs</command>.</para>
         <para>В большинстве случаев программы группы mkfs просто инициализируют специальную область раздела, называемую суперблоком файловой системы. Суперблок содержит ссылки на все значимые элементы файловой системы (например,ссылку на оглавление корневого каталога, ссылку список свободных блоков, ссылку на список файлов и т.д.)</para>
         <para>Наличие суперблока (который практически всегда содержит в своем теле некоторое характерное значение) позволяет производить монтирование файловых систем без указания их типа. К сожалению, некоторые файловые системы вследствие своей архитектуры не содержат суперблока (в частности, FAT и большинство ее разновидностей) и для блочных устройств, содержащих такие файловые системы, автоматическое определение типа файловой системы затруднено.</para>
      </section>
   </section>
   <section xml:id="static_and_dynamic_programs">
      <info>
         <title>Статически и динамически собранные программы</title>
      </info>
      <para>В Linux исполняемые файлы можно условно разделить на две группы – те, которые содержат в себе весь код, необходимые для работы, и те, которым необходимы разделяемые библиотеки. Первые называют статически собранными бинарными файлами, вторые называют динамически собранными исполняемыми файлами.</para>
      <para>Статически собранные программы характеризуются тем, что могут корректно функционировать в любых условиях, и не зависят от наличия или отсутствия разделяемых библиотек, что может оказаться полезным в ситуациях, когда возникают конфликты версий разделяемых библиотек, или когда системные библиотеки повреждены или недоступны (например во время восстановления операционной системы после серьезного сбоя). К недостаткам таких исполняемых файлов следует отнести то, что они имеют значительный размер и для обновления программы необходимо полностью заменить ее исполняемый файл – например, если несколько статически собранных программ, которые работают с архивами ZIP, содержат ошибку, то для исправления ошибки необходимо заменить все эти программы, что может быть затруднено (например, будет трудно точно установить, какие именно программы содержат ошибочный код и нуждаются в обновлении). Кроме того, статически собранные программы не умеют совместно использовать совпадающие участки кода,
         что ведет к излишнему расходу системных ресурсов. </para>
      <para>Динамически собранные исполняемые файлы для корректной работы требуют наличия файлов разделяемых библиотек, и соответственно при их отсутствии/повреждении не могут корректно функционировать, но зато для обновления программы и исправления ошибки часто оказывается достаточным просто заменить соответствующую разделяемую библиотеку, после чего ошибка исчезает во всех программах, которые эту библиотеку используют динамически. Динамически связанные программы также значительно меньше по объему, чем статически связанные, и код разделяемых библиотек может использоваться одновременно многими программами – что позволяет экономить системные ресурсы.</para>
      <para>Подавляющее большинство программ в современных дистрибутивах Linux являются динамически собранными. Определить тип исполняемого файла (статический ли он либо с динамическим связыванием) можно, например, с помощью команды <command>ldd</command>:</para>
      <screen><prompt>$</prompt> <userinput>ldd /bin/su</userinput>
linux-gate.so.1 =>  (0xffffe000)
libpam.so.0 => /lib/libpam.so.0 (0x4ce08000)
libpam_misc.so.0 => /lib/libpam_misc.so.0 (0x4cb3c000)
libcrypt.so.1 => /lib/libcrypt.so.1 (0x4e3a2000)
libdl.so.2 => /lib/libdl.so.2 (0x4ca49000)
libc.so.6 => /lib/tls/libc.so.6 (0x4c907000)
/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x4c8ee000)
<prompt>$</prompt> <userinput>ldd /sbin/devlabel</userinput>
not a dynamic executable</screen>
      <para>В данном случае мы видим, что исполняемый файл <filename>/bin/su</filename> использует динамическое связывание, а исполняемый файл <filename>/sbin/devlabel</filename> собран статическим образом.</para>
   </section>
   <section xml:id="glibc">
      <info>
         <title>Системная библиотека GNU libc</title>
      </info>
      <para>Основная системная библиотека, которая так или иначе используется практически всеми программами, называется glibc (GNU libc). Основными задачами glibc являются обеспечение взаимодействия между ядром и пользовательскими процессами, поддержка локализации и многие другие распространенные действия.</para>
      <para>На нижнем уровне прикладные процессы могут обратиться к функциям ядра посредством системных вызовов (syscall). Фактически syscall – это вызов прерывания 80h  с установленными параметрами, описывающими параметры для этого системного вызова. Те функции glibc, которые должны обратиться к ядру, в большинстве случаев просто устанавливают параметры для соответствующего системного вызова и вызывают int80h.</para>
      <para>Большинство программ используют динамически загружаемую библиотеку glibc, но некоторые приложения, которые должны работать вне зависимости от наличия файловой системы, где расположена динамически загружаемая реализация libc, используют статическое связывание, когда весь программный код, необходимый для их работы, содержится в исполняемом файле программы. В основном к таким программам относятся утилиты, используемые при загрузке системы совместно с initrd – например, статические варианты утилит <command>insmod</command>, <command>lvm</command> или <command>devlabel</command>, а также командные оболочки для первичной зарузки или восстановления системы – например sash – standalone shell, часто используемый при восстановлении системы после серьезного сбоя или nash, используемый при выполнении сценариев загрузки после монтирования initrd, но до монтирования корневой файловой системы, когда разделяемая версия glibc еще недоступна.</para>
   </section>
   <section xml:id="ld_shared_libs_so_and_more">
      <info>
         <title>LD, Shared Library, SO и много страшных слов</title>
      </info>
      <para>Существует набор базовых действий, которые практически любая программа выполняет одинаково – открытие файла, чтение и запись данных и тому подобное. Разделяемые библиотеки предназначены для того, чтобы предоставить прикладным программам готовые интерфейсы функций для выполнения каких-либо более-менее стандартных действий. Разделяемая библиотека, как понятно из названия, может использоваться множеством программ. В настоящий момент стандартным форматом для разделяемых библиотек в Linux является ELF (Executable Linked Format).</para>
      <para>Каждый файл ELF имеет заголовок, в котором описывается, какие секции содержит этот файл. Секции объединяют однотипные данные, и их детальное описание можно прочитать в справочном руководстве (<command>man elf</command>). Мы же выделим следующую информацию: каждая библиотека содержит список имен переменных и функций, которые она содержит и предоставляет другим (экспортирует) и список переменных и функций, которые необходимо взять в других библиотеках, а также секции инициализации и деинициализации. Экспортируемые и импортируемые объекты (переменные и функции) называют символами библиотеки.</para>
      <para>Большинство исполняемых файлов программ также имеют формат ELF, и на самом деле отличаются от библиотек в основном тем, что не имеют экспортируемых функций. Загрузчик ELF (он же dl, dynamic linker и dynamic loader) умеет загружать в память код ELF-файла, анализировать его структуру для определения списков экспортируемых и импортируемых символов и загружать необходимые для работы программы библиотеки.</para>
      <para>Когда пользователь пытается запустить какую–либо программу, первым начинает работу загрузчик ELF. Он загружает в память процесса бинарный файл и выделяет, какие символы и из каких библиотек необходимо догрузить в память. После дозагрузки каждой библиотеки загрузчик связывает символы (проставляет реальные адреса) из загруженной библиотеки и повторяет цикл анализа на предмет того, какую библиотеку нужно загрузить. Когда все нужные библиотеки загружены, загрузчик передает управление коду инициализации каждой из загруженных библиотек в порядке, обратном загрузке, после чего передает управление коду программы. По завершении программы загрузчик снова “проходится” по всем библиотекам и вызывает их функции деинициализации. Если на этапе загрузки какой – либо библиотеке возникает ошибка, загрузчик сообщит об этом пользователю. Наиболее типичные ошибки dl – это не найденный файл библиотеки или неразрешимый символ (символ не был найден в библиотеке, в которой ожидался).</para>
      <para>Вполне естественно, что загрузчик ищет библиотеки не по всей файловой системе, а только в определенных каталогах. Это каталоги <filename>/lib</filename>, <filename>/usr/lib</filename> и те, которые были перечислены системным администратором в файле <filename>/etc/ld.so.conf</filename>. Уточним, что этот файл на самом деле используется только системной утилитой <command>ldconfig</command>, сам же загрузчик использует кэш-файл <filename>/etc/ld.so.cache</filename>. Обновить этот кэш-файл можно путем простого запуска <command>ldconfig</command> без параметров. Следствием этого является то, что если вы установили в систему новые библиотеки, не мешает вызвать <command>ldconfig</command>.</para>
      <para>В некоторых дистрибутивах есть возможность включать в <filename>ld.so.conf</filename> дополнительные файлы без его изменения. Для этого в <filename>ld.so.conf</filename> включается специальная строка вида:</para>
      <programlisting>include ld.so.conf.d/*.conf</programlisting>
      <para>Это приводит к тому, что каталоги, перечисленные в файлах с расширением <filename>conf</filename>, расположенных  в каталоге <filename>/etc/ld.so.conf.d</filename> будут использованы для поиска разделяемых библиотек:</para>
      <screen><prompt>$</prompt> <userinput>cat /etc/ld.so.conf</userinput>
include ld.so.conf.d/*.conf
/usr/lib/mysql
/usr/X11R6/lib
/usr/lib/qt-3.3/lib
<prompt>$</prompt> <userinput>ls /etc/ld.so.conf.d/</userinput>
oracle
<prompt>$</prompt> <userinput>cat /etc/ld.so.conf.d/oracle</userinput>
/opt/oracle/9i/lib</screen>
      <para>Нередко возникает ситуация, когда пользователю необходимо запустить какую-либо программу, которая не находится в каталогах, описанных в <filename>/etc/ld.so.conf</filename>. В таких ситуациях можно воспользоваться специальным “люком”, оставленным разработчиками dl специально для таких случаев: дело в том, что кроме загрузки библиотек с использованием данных из <filename>ld.so.cache</filename> загрузчик проверяет факт наличия библиотеки с указанным именем в каталогах, перечисленных в переменной среды <envar>LD_LIBRARY_PATH</envar>.</para>
      <para>Разработчики часто используют еще одну возможность ld: если файл некоторой разделяемой библиотеки указан в переменной <envar>LD_PRELOAD</envar>, эта библиотека принудительно загружается и ее символы считаются более “приоритетными” и перекрывают одноименные символы, если таковые существуют в других библиотеках, загружаемых ld при запуске на выполнение бинарного файла ELF.</para>
      <para>Попробуем рассмотреть примеры использования указанных возможностей dl: пусть есть некоторый программный продукт, в состав которого кроме собственно исполняемых программ входят разделяемые библиотеки (например, таковы практически все продукты, разработанные с помощью Borland Kylix). Если мы установим такой пакет, например, в <filename>/opt/program</filename>, его исполняемые файлы в <filename>/opt/program/bin</filename> а разделяемые библиотеки в <filename>/opt/program/lib</filename>, то программа, скорее всего, не будет запускаться, поскольку не сможет загрузить необходимых библиотек. Для того, чтобы программы пакета начали запускаться, мы должны “объяснить” ld где именно искать библиотеки. Рассмотрим возможные способы, которыми мы можем воздействовать на ld чтобы добиться нужного нам результата.</para>
      <para>Первый способ – указать каталог с библиотеками перед запуском программы и уже затем запустить программу (ld воспользуется значением переменной для того, чтобы попытаться найти библиотеки по указанному пути):</para>
      <screen><prompt>$</prompt> <userinput>export LD_LIBRARY_PATH=/opt/program/lib</userinput>
<prompt>$</prompt> <userinput>/opt/program/bin/filename</userinput></screen>
      <para>Второй способ – добавить каталог <filename>/opt/program/lib</filename> в файл <filename>/etc/ld.so.conf</filename> и запустить <command>ldconfig</command>, решив проблему с невозможностью нахождения этих библиотек для всех программ сразу:</para>
      <screen><prompt>$</prompt> <userinput>su -</userinput>
<prompt>#</prompt> <userinput>echo /opt/program/lib >>/etc/ld.so.conf</userinput>
<prompt>#</prompt> <userinput>ldconfig</userinput>
<prompt>#</prompt> <userinput>exit</userinput>
<prompt>$</prompt> <userinput>/opr/program/bin/filename</userinput></screen>
      <para>Можно также воспользоваться возможностью принудительной загрузки тех библиотек, которые необходимы программе для запуска:</para>
      <screen><prompt>$</prompt> <userinput>export LD_PRELOAD=/opt/program/lib/*$ /opr/program/bin/filename</userinput></screen>
      <para>Большая часть кода разделяемых библиотек находится в кэше и становится доступна процессам через отображение файла в память. Это отображение делается с правами доступа “только чтение”, что защищает код библиотек от переписывания его неправильно работающими или просто злонамеренными программами.</para>
   </section>
   <section xml:id="processes_information">
      <info>
         <title>Информация о процессах и файловая система <filename>/proc</filename></title>
      </info>
      <para>Ядро и его подсистемы очень важны, но большинство пользы приносят прикладные задачи, поэтому мониторинг состояния задач (процессов) – очень важная часть работы системного администратора. В Linux получить информацию о процессах можно через файлы и каталоги файловой системы procfs, как правило монтируемой к каталогу <filename>/proc</filename>.</para>
      <para>Каждому процессу сопоставляется в <filename>/proc</filename> отдельный каталог, имя которого совпадает со значением PID процесса. Файлы в этом каталоге предоставляют информацию о соответствующем процессе. Таблица приводит список файлов и их назначение:</para>
      <informaltable frame="all" pgwide="1">
         <tgroup cols="3">
            <thead>
               <row>
                  <entry>
                     <para>Имя файла</para>
                  </entry>
                  <entry>
                     <para>Формат</para>
                  </entry>
                  <entry>
                     <para>Назначение</para>
                  </entry>
               </row>
            </thead>
            <tbody>
               <row>
                  <entry>
                     <para><filename>cmdline</filename></para>
                  </entry>
                  <entry>
                     <para>строка, разделенная символами \0</para>
                  </entry>
                  <entry>
                     <para>Представляет командную строку, которой был запущен процесс. Параметры командной строки отделяются друг от друга символами \0</para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para><filename>environ</filename></para>
                  </entry>
                  <entry>
                     <para>строка, разделенная символами \0</para>
                  </entry>
                  <entry>
                     <para>Представляет список переменных окружения для указанного процесса</para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para><filename>exe</filename></para>
                  </entry>
                  <entry>
                     <para>символьная ссылка</para>
                  </entry>
                  <entry>
                     <para>Ссылается на исполняемый файл процесса</para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para><filename>maps</filename></para>
                  </entry>
                  <entry>
                     <para>несколько строк</para>
                  </entry>
                  <entry>
                     <para>Список отображенных в память процесса файлов</para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para><filename>mem</filename></para>
                  </entry>
                  <entry>
                     <para>бинарный</para>
                  </entry>
                  <entry>
                     <para>Прямой доступ к адресному пространству процесса</para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para><filename>mounts</filename></para>
                  </entry>
                  <entry>
                     <para>несколько строк</para>
                  </entry>
                  <entry>
                     <para>Список примонтированных файловых систем, доступных процессу</para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para><filename>stat</filename></para>
                  </entry>
                  <entry>
                     <para>строка числовых значений</para>
                  </entry>
                  <entry>
                     <para>Статистика активности процесса</para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para><filename>statm</filename></para>
                  </entry>
                  <entry>
                     <para>строка числовых значений</para>
                  </entry>
                  <entry>
                     <para>Статистика по использованию памяти процессом</para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para><filename>cwd</filename></para>
                  </entry>
                  <entry>
                     <para>символьная ссылка</para>
                  </entry>
                  <entry>
                     <para>Ссылается на каталог, который является текущим для процесса</para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para><filename>fd/*</filename></para>
                  </entry>
                  <entry>
                     <para>символьные ссылки</para>
                  </entry>
                  <entry>
                     <para>Имена файлов подкаталога fd соответсвуют открытым процессом дескрипторам файлов. Символьные ссылки указывают на соответствующие файлы</para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para><filename>root</filename></para>
                  </entry>
                  <entry>
                     <para>символьная ссылка</para>
                  </entry>
                  <entry>
                     <para>Ссылается на каталог, который процесс считает корневым</para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para><filename>status</filename></para>
                  </entry>
                  <entry>
                     <para>несколько строк</para>
                  </entry>
                  <entry>
                     <para>Описание состояния процесса</para>
                  </entry>
               </row>
            </tbody>
         </tgroup>
      </informaltable>
      <para>Все указанные данные полностью соответствуют тому, что показала бы программа <command>ps</command>, будучи запущеной в тот момент, когда просматривается соответствующий файл, поскольку утилита <command>ps</command> на самом деле просто читает данные из соответствующих файлов в <filename>/proc</filename>.</para>
   </section>
   <section xml:id="sysctl">
      <info>
         <title>Интерфейс sysctl</title>
      </info>
      <para>Ядро содержит очень много параметров, от которых зависит его производительность и которые могут изменять алгоритмы его работы. Для того, чтобы иметь возможность узнавать и изменять эти параметры, в UNIX был разработан интерфейс <command>sysctl</command>.</para>
      <para>Виртуальная файловая система procfs содержит каталог <filename>sys</filename> с деревом подкаталогов и файлов. Содержимое каждого из этих файлов можно прочесть, например, командой <command>cat</command>, или записать в такой файл новое значение командой <command>echo</command>:</para>
      <screen><prompt>$</prompt> <userinput>cat /proc/sys/kernel/shmmax</userinput>
33554432
<prompt>$</prompt> <userinput>echo 67108864 &gt;/proc/sys/kernel/shmmax</userinput>
<prompt>$</prompt> <userinput>cat /proc/sys/kernel/shmmax</userinput>
67108864</screen>
      <para>Команда <command>sysctl</command> предназначена для того, чтобы избежать необходимости использовать прямой доступ к этим файлам, и предоставить возможность автоматизации установки таких параметров при загрузке системы. На самом же деле, команда <command>sysctl</command> просто читает или записывает значения в файлы из каталога <filename>/proc/sys</filename>, т.е. если системный администратор устанавливает с помощью команды <command>sysctl</command> значение некоторого параметра, фактически он просто записывает это значение в соответствующий файл. Существует однозначное соответствие между именем параметра и именем файла, через который его можно изменить:  если посмотреть вывод <command>sysctl -a</command>, можно увидеть, что параметры в большинстве своем именуются несколькими мнемоническими аббревиатурами, разделенными точками:</para>
      <screen>$<userinput>sysctl -a | grep mem</userinput>
net.ipv4.tcp_rmem = 4096        87380   174760
net.ipv4.tcp_wmem = 4096        16384   131072
net.ipv4.tcp_mem = 24576        32768   49152
net.ipv4.igmp_max_memberships = 20
net.core.optmem_max = 10240
net.core.rmem_default = 108544
net.core.wmem_default = 108544</screen>
      <para>Если в имени параметра заменить точки на символ разделителя пути (символ “/”), и к началу получившейся строки добавить <filename>/proc/sys/</filename> – то мы получим имя файла, через который можно изменить или прочесть значение соответствующего параметра.</para>
      <para>Если системному администратору необходимо при каждой загрузке изменять некоторые параметры через интерфейс sysctl, то список параметров и их значений можно записать в конфигурационный файл <filename>/etc/sysctl.conf</filename>, который прочитывается при каждой загрузке системы.</para>
   </section>
   <section xml:id="create_processes">
      <info>
         <title>Создание процессов</title>
      </info>
      <para>Linux на самом деле поддерживает только один внутренний механизм создания процессов – механизм fork+exec. Любой процесс, который хочет создать еще один процесс, должен сначала создать свою копию с помощью системного вызова fork, после чего порожденный процесс, который является полной копией предыдущего за исключением нескольких параметров, таких как PID (Process ID) и PPID (Parent Process ID) использует системный вызов exec для того, чтобы загрузить в свое адресное пространство код новой программы и начать его выполнение. Соответственно, все процессы организуют дерево, когда у каждого процесса есть родительский процесс (исключение составляет процесс init, запущеный ядром на этапе загрузки).</para>
      <para>Когда процесс завершается, код его завершения возвращается родительскому процессу. До тех пор, пока код завершения процесса не будет прочитан родительским процессом, запись об этом процессе продолжает существовать в таблице процессов в ядре. Такой процесс (уже завершившийся, но еще числящийся в таблице процессов) называют процессом – зомби (zombie process). Завершить zombie process может родительский процесс, прочтя код его завершения. Если у вас в системе появилось множество зомби – процессов, это скорее всего означает ошибку в программе, породившей этот процесс. Удалить процесс – зомби можно только удалив его родительский процесс.</para>
      <para>Нередко бывает, что родительский процесс завершается раньше, чем дочерний, и тогда для дочернего процесса объявляется родительским процесс init, и поэтому в системе никогда не бывает процессов-”сирот”, т.е. тех, кто не имеет родителя и чей код завершения некому прочесть.</para>
   </section>
   <section xml:id="secrets_of_dev" xreflabel="Секреты /dev">
      <info>
         <title>Секреты <filename>/dev</filename></title>
      </info>
      <para>Ядро Linux реализует поддержку двух типов устройств – символьных и блочных. Основное их отличие в том, что для блочных устройств операции ввода вывода осуществляются не отдельными байтами (символами), а блоками фиксированного размера.</para>
      <para>В Linux вся работа с устройствами ведется через специальные файлы, которые обычно расположены в каталоге <filename>/dev</filename>. Специальные файлы не содержат данных, а просто служат точками, через которые можно обратиться к драйверу соответствующего устройства. У каждого специального файла есть три характеристики – тип устройства (character или block), старший номер устройства (major number) и младший номер (minor number). Для примера, посмотрим на содержимое каталога <filename>/dev</filename>:</para>
      <screen><prompt>$</prompt> <userinput>ls -lL /dev/hd* /dev/ttyS*</userinput>
brw-------  1 root  root  3,  0 Окт  1 20:16 /dev/hda
brw-------  1 root  root  3,  1 Окт  1 20:16 /dev/hda1
brw-------  1 root  root  3,  2 Окт  1 20:16 /dev/hda2
brw-------  1 dalth disk 22,  0 Янв  1  1970 /dev/hdc
crw-------  1 root  root  4, 64 Янв  1  1970 /dev/ttyS0
crw-------  1 root  root  4, 65 Янв  1  1970 /dev/ttyS1
crw-------  1 root  root  4, 66 Янв  1  1970 /dev/ttyS2</screen>
      <para>Как видно, в листинге присутствует описание семи устройств, четырех блочных и трех символьных. Для каждого файла можно увидеть его тип (первая буква в списке прав доступа), пользователя-владельца, группу-владельца, major number, minor number, дату модификации и имя файла.</para>
      <para>Для поддержки работы с устройствами в ядре хранятся две таблицы, одна для списка символьных устройств, другая для списка блочных устройств. Каждая строка таблицы сопоставлена какой-то разновидности устройств соответствующего типа – например, для типа “символьные устройства” можно выделить следующие разновидности: COM-порты, LPT-порты, PS/2-мыши, USB-мыши и т.д., для типа “блочные устройства” можно выделить SCSI-диски, IDE-диски, SCSI-CD-приводы, виртуальные диски которыми представляются RAID-контролеры и т.п.</para>
      <para>Каждая ячейка в этих системных таблицах сопоставляется конкретному экземпляру устройства. Таким образом, с точки зрения ядра каждое устройство оказывается однозначно проидентифицировано тремя параметрами – типом устройства (блочное или символьное) и двумя числами – номерами строки и номером столбца таблицы, в которой хранится ссылка на драйвер этого устройства.</para>
      <para>Пример таблицы символьных и устройств</para>
      <informaltable frame="all">
         <tgroup cols="11">
            <thead>
               <row>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para>0</para>
                  </entry>
                  <entry>
                     <para>1</para>
                  </entry>
                  <entry>
                     <para>...</para>
                  </entry>
                  <entry>
                     <para>63</para>
                  </entry>
                  <entry>
                     <para>64</para>
                  </entry>
                  <entry>
                     <para>65</para>
                  </entry>
                  <entry>
                     <para>66</para>
                  </entry>
                  <entry>
                     <para>...</para>
                  </entry>
                  <entry>
                     <para>175</para>
                  </entry>
                  <entry>
                     <para>...</para>
                  </entry>
               </row>
            </thead>
            <tbody>
               <row>
                  <entry>
                     <para>4</para>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para>COM1</para>
                  </entry>
                  <entry>
                     <para>COM2</para>
                  </entry>
                  <entry>
                     <para>COM3</para>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para>6</para>
                  </entry>
                  <entry>
                     <para>LPT1</para>
                  </entry>
                  <entry>
                     <para>LPT2</para>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para>10</para>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para>Мышь PS/2</para>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para>Диспетчер томов LVM</para>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para>Слот AGP</para>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para>14</para>
                  </entry>
                  <entry>
                     <para>Микшер первой зв. карты</para>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para>195</para>
                  </entry>
                  <entry>
                     <para>Первая видеокарта NVidia</para>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
               </row>
            </tbody>
         </tgroup>
      </informaltable>
      <para>Пример таблицы блочных устройств</para>
      <informaltable frame="all">
         <tgroup cols="10">
            <thead>
               <row>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para>0</para>
                  </entry>
                  <entry>
                     <para>1</para>
                  </entry>
                  <entry>
                     <para>2</para>
                  </entry>
                  <entry>
                     <para>...</para>
                  </entry>
                  <entry>
                     <para>16</para>
                  </entry>
                  <entry>
                     <para>...</para>
                  </entry>
                  <entry>
                     <para>64</para>
                  </entry>
                  <entry>
                     <para>65</para>
                  </entry>
                  <entry>
                     <para>...</para>
                  </entry>
               </row>
            </thead>
            <tbody>
               <row>
                  <entry>
                     <para>3</para>
                  </entry>
                  <entry>
                     <para>IDE Primary Master</para>
                  </entry>
                  <entry>
                     <para> Раздел 1 на IDE Primary Master</para>
                  </entry>
                  <entry>
                     <para>Раздел 2 на IDE Primary Master</para>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para>Раздел  16 на IDE Primary Master</para>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para>IDE Primary Slave</para>
                  </entry>
                  <entry>
                     <para>Раздел 1 на IDE Primary Slave</para>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para>13</para>
                  </entry>
                  <entry>
                     <para>SCSI диск 1</para>
                  </entry>
                  <entry>
                     <para>Раздел 1 на SCSI-диске 1</para>
                  </entry>
                  <entry>
                     <para>Раздел 2 на SCSI-диске 1</para>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para>SCSI диск 2</para>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para>SCSI диск 4</para>
                  </entry>
                  <entry>
                     <para>Раздел 1 на SCSI-диске 4</para>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
               </row>
            </tbody>
         </tgroup>
      </informaltable>
      <para>При попытке обращения к такому специальному файлу ядро переадресует обращение через нужный драйвер на устройство в соответствии с теми данными, которые указаны в таблице устройств, причем конкретная таблица устройств будет выбрана в зависимости от типа устройства, строка из таблицы будет выбрана по major number, и столбец будет выбран по minor number. Если мы посмотрим на примеры наших таблиц, то увидим, что обращение на специальный файл <filename>/dev/ttyS1</filename>, который представляет символьное устройство со старшим номером 4 и младшим номером 65 будет адресовано на последовательный порт COM2, а обращение к файлу <filename>/dev/hda2</filename> (блочное устройство со старшим номером 3 и младшим номером 2) будет адресовано на 2-й раздел жесткого диска IDE, работающего в режиме primary master.</para>
      <section>
         <title>Статическая организация каталога <filename>/dev</filename></title>
         <para>В настоящее время существует два подхода к организации <filename>/dev</filename> – статическая организация и динамическая организация. В первом случае в каталоге <filename>/dev</filename> заранее создаются специальные файлы для всех возможных устройств вне зависимости от того, загружен драйвер соответствующего устройства или нет. Во втором случае специальные файлы в <filename>/dev</filename> создаются по мере инициализации устройств и загрузки драйверов, и удаляются при выгрузке соответствующего драйвера или удалении устройства.</para>
         <para>Процесс работы со статическим <filename>/dev</filename> особых проблем не вызывает – системный администратор при необходимости просто создает отсутствующие файлы командой <command>mknod</command> или <command>MAKEDEV</command>. В том случае, когда какая-либо программа обращается к устройству, чей драйвер не загружен (или загружен, но ни одного соответствующего устройства не было обнаружено), операционная система возвращает ошибку при попытке открытия файла такого “неверного” устройства. Ниже приведен пример создания специального файла, соответствующего блочному устройству с мажором 8 и минором 33 и попытка его использования (отметим, что этот специальный файл соответствует разделу на жестком диске, который не существует на тестовой машине, где выполнялись эти команды):</para>
         <screen><prompt>#</prompt> <userinput>cd /dev</userinput>
<prompt>#</prompt> <userinput>ls -l /dev/hda33</userinput> 
ls: /dev/hda33: No such file or directory
<prompt>#</prompt> <userinput>mknod hda33 b 8 33</userinput>
<prompt>#</prompt> <userinput>ls -l hda33</userinput>
brw-r--r--  1 root root 8, 33 Окт 11 09:27 hda33
<prompt>#</prompt> <userinput>dd if=hda33 of=/dev/null</userinput> 
dd: opening `hda33': No such device or address</screen>
         <para>Сообщение No such device or address как раз и означает, что записи для данного устройства в таблице блочных устройств не существует.</para>
         <para>Ядро Linux совместно с некоторыми системными утилитами поддерживает такую интересную возможность, как загрузка драйверов “по требованию”. Реализуется это следующим образом – в момент, когда какая-либо программа пытается открыть специальный файл, не связанный ни с каким драйвером, ядро делает попытку подобрать соответствующий драйвер самостоятельно. Необходимый драйвер для каждого специального файла определяется в файле <filename>/etc/modules.conf</filename> путем задания специального алиаса (alias) для модуля. Для активизации автоматической загрузки драйвера какого-либо символьного устройства в большинстве случаев достаточно просто записать в /etc/modules.conf строку следующего вида:</para>
         <programlisting>alias char-major-<replaceable>X</replaceable>-<replaceable>Y</replaceable> <replaceable>имя_драйвера</replaceable></programlisting>
         <para>Для блочных устройств соответствующая запись слегка меняет свою форму:</para>
         <programlisting>alias block-major-<replaceable>X</replaceable>-<replaceable>Y</replaceable> <replaceable>имя_драйвера</replaceable></programlisting>
         <para>X и Y – это major и minor специального файла, попытка открыть который должна активизировать автоматическую загрузку драйвера. Владельцы видеокарт на чипе nVidia могут увидеть этот подход в действии – программа инсталляции драйвера nVidia автоматически прописывает в <filename>modules.conf</filename> запись для загрузки «по требованию» той части драйвера, которая работает в режиме ядра.</para>
         <para>Вместо X или Y может также быть подставлен символ “*” , означающий “любое число”. Например, пусть в modules.conf будет написан следующий текст:</para>
         <programlisting>alias char-major-81-* bttv</programlisting>
         <para>Тогда при обращении к любому символьному устройству с major number равным 81 и которое не ассоциировано ни с каким драйвером, система попытается загрузить драйвер bttv (драйвер TV-тюнера на основе чипа bt848).</para>
         <para>Эта возможность обеспечивает Linux возможность плавной загрузки и эффективного использования ресурсов – драйвер не загружается, пока в нем не возникнет необходимости. К сожалению, за простоту этой схемы приходится платить большим количеством специальных файлов в <filename>/dev</filename>.</para>
      </section>
      <section>
         <title>Что такое DevFS</title>
         <para>Для того, чтобы избавить администратора от ручного создания специальных файлов и для уменьшения количества файлов в <filename>/dev</filename> был реализован второй способ организации <filename>/dev</filename> – динамическое создание специальных файлов процессе загрузки драйверов. Реализовано это было следующим образом:</para>
         <para>Ядро монтирует к каталогу <filename>/dev</filename> специальную файловую систему, называемую devfs – эта файловая система хранится целиком в оперативной памяти и не занимает никакого места на диске. Когда какой-либо драйвер в процессе загрузки или работы обнаруживает обслуживаемое им устройство, он регистрирует это устройство и сообщает о нем драйверу devfs. Драйвер devfs создает специальный файл, который виден прикладным программам и может быть корректно открыт. При выгрузке же драйвер устройства сообщает devfs о том, что соответствующее устройство уже не активно, и драйвер devfs удаляет запись о соответствующем специальном файле из файловой системы devfs.</para>
         <para>Файловая система devfs отличается тем, что как правило специальный файл для устройства создается с длинным путем – например, для раздела на scsi-диске путь может выглядеть примерно так: <filename>/dev/scsi/host1/bus1/target3/lun4/partition2</filename>.</para>
         <para>Эта особенность является весьма важным плюсом devfs, поскольку она позволяет адресовать дисковые устройства путем указания логического пути их подключения и избежать смены имен SCSI-дисков в некоторых случаях (об этих случаях будет рассказано позднее).</para>
         <para>Для того, чтобы организовать более прозрачную структуру каталогов и файлов устройств, используется специальный демон devfsd. Он взаимодействует с драйвером devfs и ядром и в процессе активизации и деактивизации устройств он создает и удаляет символьные ссылки вида <filename>/dev/disks/disc0</filename> или <filename>/dev/hda1</filename>.</para>
         <para>Надо отметить, что схема динамического <filename>/dev</filename> в некотором смысле близка к той организации каталога <filename>/dev</filename>, которая используется некоторыми коммерческими UNIX-системами (например, в  Solaris), когда есть виртуальная файловая система <filename>/devices</filename>, и на ее файлы создаются ссылки из <filename>/dev</filename>, только в Linux роль программы <command>cfgadm</command> играет демон devfsd, и все изменения в состав <filename>/dev</filename> вносятся автоматически.</para>
         <para>С помощью devfsd файловая система devfs также реализует автоматическую загрузку модулей, но в этом случае выбор модуля идет не через комбинацию type/major/minor, а путем указания имени запрошенного файла – когда приложение пытается открыть несуществующий файл устройства, devfs передает имя запрошенного файла демону devfsd, и последний загружает необходимые модули, например такой код в файле <filename>modules.devfs</filename>:</para>
         <programlisting>alias /dev/nvidia* nvidia</programlisting>
         <para>Приведет к тому, что при попытке обращения к любому файлу, чей полный путь начинается строкой <filename>/dev/nvidia</filename>, будет произведена попытка загрузить драйвер <filename>nvidia.o</filename> (для ядра 2.6 <filename>nvidia.ko</filename>)</para>
         <para>В принципе, на сегодняшний день выбор того, каким именно образом необходимо организовывать <filename>/dev</filename>, остается за пользователем и создателем дистрибутива. Например, в Mandrake Linux используется devfs, а в RedHat, Fedora и SUSE каталог <filename>/dev</filename> организован статическим образом, а опытные пользователи часто меняют способ организации <filename>/dev</filename> в зависимости от своих предпочтений.</para>
      </section>
      <section>
         <title>Немного о UDEV</title>
         <para>В современных дистрибутивах и ядрах поддержка devfs/devfsd отключена, и на смену этой паре пришел специальный демон, называемый udev. В отличие от devsfd, который требовал поддержки со стороны ядра, udev такой поддержки не требует. При инициализации устройства ядро подает сигнал через файловую систему sysfs, и демон udevd, получив сигнал об этом событии, самостоятельно создает соответствующий специальный файл устройства в каталоге <filename>/dev</filename> в соответствии с правилами, описанными в его конфигурационных файлах. При необходимости в этих файлах можно указать например вызов некоторой внешней программы, создание символьной ссылки и так далее.</para>
         <para>Например, если некоторое устройство после подключения перед началом работы требует дополнительной настройки с использованием внешних программ, можно создать соответствующее правило для udev, в котором будет указано какую программу вызвать и какие параметры ей необходимо передать – в частности, это может потребоваться для data-кабелей к некоторым мобильным телефонам Nokia, для устройств которым для корректной работы требуется firmware, или для сохранения или восстановления текущих настроек устройства.</para>
         <para>Тем не менее, несмотря на внешние отличия между статической организацией <filename>/dev</filename>, devfs и udev, следует помнить что это всего лишь способ заполнения каталога <filename>/dev</filename>, и во всех случаях в конечном итоге на файловой системе создаются те же самые файлы символьных и блочных устройств.</para>
      </section>
   </section>
   <section>
      <title>Блочные устройства</title>
      <para>Любое устройство, подключенное к компьютеру, имеет свое назначение, и блочные устройства в большинстве своем предназначаются для хранения информации. Как организована работа с блочными устройствами в Linux?</para>
      <para>Во-первых, следует определиться с типами блочных устройств. Их следует поделить на две категории: к первой отнесем логические (виртуальные) устройства (loop-устройства, software RAID-устройства, устройства Volume Management, поддержка различных таблиц разделов), ко второй категории – физические устройства (SCSI диски и CD-ROM'ы, IDE-диски, USB-storage, RAM-диск).</para>
      <para>Виртуальные устройства являются на самом деле просто оберткой, дополнительным слоем. В реальности драйверы логических устройств не работают с периферийными устройствами напрямую, они лишь переадресовывают запросы на драйверы других логических или физических устройств.</para>
      <para>Драйверы физических устройств работают совместно с драйверами контроллеров, позволяя производить доступ к соответствующим устройствам на блочном уровне и предоставляя тем самым фактически прямой доступ к носителю – но, поскольку в большинстве случаев дисковые устройства имеют значительный объем, они часто делятся на разделы. Раздел является постоянным непрерывным фрагментом дискового пространства, местоположение которого на жестком диске записано в специальной области диска – таблице разделов.</para>
      <para>Существует множество различных форматов разбиения диска на разделы – например, DOS partition table, BSD disklabels, UnixWare slices и многие другие. Как правило, во всех случаях соответствующая спецификация предусматривает возможность перечисления ограниченного количества разделов путем указания номеров первой и последней дорожек, занимаемых каждым из разделов. Каждый раздел видится как отдельное блочное устройство.</para>
      <para>По традиции имена блочных устройств, соответствующих IDE-дискам и созданным на них разделам начинаются с hd и имеют вид <filename>/dev/hd<replaceable>&lt;N&gt;</replaceable>[<replaceable>&lt;M&gt;</replaceable>]</filename> где N – это буква, зависящая от контроллера и канала IDE, к которому подключено устройство, и режима устройства (master/slave). M – это некоторое число от 1 до 63 (фактически номер раздела на диске). Если число не указано, подразумевается весь диск. SCSI-дискам в <filename>/dev</filename> присваиваются имена <filename>sda</filename>, <filename>sdb</filename>, <filename>sdc</filename> и т.д. Ниже приводится небольшая таблица соответствия устройств и имен специальных файлов для IDE-дисков:</para>
      <informaltable frame="all">
         <tgroup cols="5">
            <thead>
               <row>
                  <entry>
                     <para>Контроллер</para>
                  </entry>
                  <entry>
                     <para>Канал</para>
                  </entry>
                  <entry>
                     <para>Режим</para>
                  </entry>
                  <entry>
                     <para/>
                  </entry>
                  <entry>
                     <para>Имя файла</para>
                  </entry>
               </row>
            </thead>
            <tbody>
               <row>
                  <entry>
                     <para>1</para>
                  </entry>
                  <entry>
                     <para>1</para>
                  </entry>
                  <entry>
                     <para>master</para>
                  </entry>
                  <entry>
                     <para>primary master</para>
                  </entry>
                  <entry>
                     <para><filename>hda</filename></para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para>1</para>
                  </entry>
                  <entry>
                     <para>1</para>
                  </entry>
                  <entry>
                     <para>slave</para>
                  </entry>
                  <entry>
                     <para>primary slave</para>
                  </entry>
                  <entry>
                     <para><filename>hdb</filename></para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para>1</para>
                  </entry>
                  <entry>
                     <para>2</para>
                  </entry>
                  <entry>
                     <para>master</para>
                  </entry>
                  <entry>
                     <para>secondary master</para>
                  </entry>
                  <entry>
                     <para><filename>hdc</filename></para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para>1</para>
                  </entry>
                  <entry>
                     <para>2</para>
                  </entry>
                  <entry>
                     <para>slave</para>
                  </entry>
                  <entry>
                     <para>secondary slave</para>
                  </entry>
                  <entry>
                     <para><filename>hdd</filename></para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para>2</para>
                  </entry>
                  <entry>
                     <para>1</para>
                  </entry>
                  <entry>
                     <para>master</para>
                  </entry>
                  <entry>
                     <para>tertiary master</para>
                  </entry>
                  <entry>
                     <para><filename>hde</filename></para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para>2</para>
                  </entry>
                  <entry>
                     <para>1</para>
                  </entry>
                  <entry>
                     <para>slave</para>
                  </entry>
                  <entry>
                     <para>tertiary slave</para>
                  </entry>
                  <entry>
                     <para><filename>hdf</filename></para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para>2</para>
                  </entry>
                  <entry>
                     <para>2</para>
                  </entry>
                  <entry>
                     <para>master</para>
                  </entry>
                  <entry>
                     <para>quaternary master</para>
                  </entry>
                  <entry>
                     <para><filename>hdg</filename></para>
                  </entry>
               </row>
               <row>
                  <entry>
                     <para>2</para>
                  </entry>
                  <entry>
                     <para>2</para>
                  </entry>
                  <entry>
                     <para>slave</para>
                  </entry>
                  <entry>
                     <para>quaternary slave</para>
                  </entry>
                  <entry>
                     <para><filename>hdh</filename></para>
                  </entry>
               </row>
            </tbody>
         </tgroup>
      </informaltable>
      <para>Когда драйвер блочного устройства, поддерживающего разбиение на разделы,  в процессе загрузки или работы обнаруживает обслуживаемое им устройство, он считывает с него таблицу разделов, определяет ее разновидность  и составляет таблицу разделов, запоминая начало и конец каждого из разделов. Впоследствии, если какая-либо программа производит обращение не непосредственно к физическому устройству, а к разделу на этом устройстве, драйвер с использованием построенной таблицы разделов определяет реальный адрес блока, над которым нужно произвести запрошенную операцию ввода/вывода.</para>
      <para>Особой разновидностью раздела можно назвать расширенный (extended) раздел DOS. Расширенный разделы DOS может быть разбит на произвольное количество вложенных разделов, но в настоящий момент без использования LVM ядро Linux поддерживает до 63 разделов на IDE-диске и до 15 разделов на SCSI-диске. Такое ограничение связано с распределением мажоров и миноров блочных устройств.</para>
      <para>Когда используется разбиение диска на разделы с использованием таблицы разделов DOS, следует помнить, что на жестком диске может быть не более 4 первичных разделов. Если администратору нужно, чтобы на жестком диске было более 4 разделов, необходимо объявить один из первичных разделов как расширенный раздел. Первичные разделы при использовании таблицы разделов DOS нумеруются от 1 до 4, логические разделы нумеруются начиная с 5, вне зависимости от количества первичных разделов. Только один из первичных разделов может быть объявлен расширенным.</para>
      <para>Рассмотрим вывод команды fdisk, которая обычно используется в Linux для разбиения диска на разделы:</para>
      <screen><prompt>#</prompt> <userinput>fdisk /dev/hda -l</userinput>
         Disk /dev/hda: 6442 MB, 6442450944 bytes
16 heads, 63 sectors/track, 12483 cylinders
Units = cylinders of 1008 * 512 = 516096 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/hda1   *           1         203      102280+  83  Linux
/dev/hda2             204        2032      921816   83  Linux
/dev/hda3            2033        3072      524160   82  Linux swap
/dev/hda4            3073       12483     4743144    f  W95 Ext'd (LBA)
/dev/hda5            3073        4088      512032+  83  Linux
/dev/hda6            4089       12483     4231048+  83  Linux</screen>
      <para>Как видно, на жестком диске IDE созданы 6 разделов, из них 4 первичных (разделы с номерами от 1 до 4) и два логических раздела с номерами 5 и 6, созданных внутри extended-раздела hda4.</para>
      <para>Таблица разделов диска не может быть изменена в том случае, если хотя-бы один из разделов этого диска используется. В этом случае ядро продолжает использовать “старую” разметку (с которой оно работало до изменения), а изменения записываются на диск и вступают в силу после перезагрузки компьютера.</para>
      <para>Если нет возможности запустить программу <command>fdisk</command>, то для получения данных о разметке блочных устройств на разделы и о состоянии блочных устройств, доступных в настоящий момент, можно использовать некоторые файлы из файловой системы <filename>/proc</filename>:</para>
      <screen><prompt>$</prompt> <userinput>cat /proc/partitions</userinput>
major minor  #blocks  name
   3     0   78150744 hda
   3     1    1084356 hda1
   3     2   77063805 hda2
 253     0    1048576 dm-0
 253     1    1048576 dm-1
 253     2   10485760 dm-2
 253     3   10485760 dm-3
 253     4    1048576 dm-4
 253     5   41943040 dm-5
 253     6     360448 dm-6
 253     7     258048 dm-7
 253     8     258048 dm-8
 253     9     258048 dm-9
 253    10      53248 dm-10
   7     0     651884 loop0
   7     1     650198 loop1
   7     2     653336 loop2
   7     3     198962 loop3</screen>
      <para>Например, эти данные могут быть использованы для восстановления таблицы разделов, если системный администратор по ошибке ее исправил.</para>
      <para>Интересной особенностью таблицы разделов диска является то, что она не всегда изменяема. Это приводит к тому, что во многих случаях невозможно изменить размер какого-либо раздела или внести какие-либо другие изменения в таблицу разделов без перезагрузки – т.е. системный администратор может делать любые изменения, но они вступят в силу только после перезагрузки системы.</para>
      <section>
         <title>Распределение мажоров и миноров IDE дисков</title>
         <para>IDE-диски в настоящее время наиболее часто используются в офисных и домашних компьютерах, поэтому знать особенности распределения мажоров и миноров для этих типов устройств достаточно важно. IDE-устройства отличаются низкой ценой и неплохой скоростью передачи данных, но у этой шины есть архитектурные недостатки – например, все устройства работают со скоростью самого медленного из них, на один шлейф (на один канал) можно подключить только 2 устройства.</para>
         <para>Всем устройствам, находящимся на одном канале IDE, присвоен один мажор. В настоящий момент ядро Linux выделяет для каждого устройства 64 минора, из которых первый минор зарезервирован для всего диска, и 63 минора остается для идентификации разделов. Таким образом, для IDE-дисков мажор идентифицирует канал, а по минору можно определить номер устройства на канале (режим master/slave) и номер раздела. Более детально это можно увидеть в следующей таблице:</para>
         <table frame="all">
            <title>Распределение номеров устройств для IDE-дисков</title>
            <tgroup cols="6">
               <thead>
                  <row>
                     <entry>Канал</entry>
                     <entry>Устройство</entry>
                     <entry>Раздел</entry>
                     <entry>Major number</entry>
                     <entry>Minor number</entry>
                     <entry>Имя в <filename>/dev</filename></entry>
                  </row>
               </thead>
               <tbody>
                  <row>
                     <entry morerows="12">1</entry>
                     <entry morerows="6">1</entry>
                     <entry>Весь диск</entry>
                     <entry morerows="12">3</entry>
                     <entry>0</entry>
                     <entry><filename>/dev/hda</filename></entry>
                  </row>
                  <row>
                     <entry>Раздел 1</entry>
                     <entry>1</entry>
                     <entry><filename>/dev/hda1</filename></entry>
                  </row>
                  <row>
                     <entry>Раздел 2</entry>
                     <entry>2</entry>
                     <entry><filename>/dev/hda2</filename></entry>
                  </row>
                  <row>
                     <entry>Раздел 3</entry>
                     <entry>3</entry>
                     <entry><filename>/dev/hda3</filename></entry>
                  </row>
                  <row>
                     <entry>Раздел 4</entry>
                     <entry>4</entry>
                     <entry><filename>/dev/hda4</filename></entry>
                  </row>
                  <row>
                     <entry>...</entry>
                     <entry>...</entry>
                     <entry>...</entry>
                  </row>
                  <row>
                     <entry>Раздел 63</entry>
                     <entry>63</entry>
                     <entry><filename>/dev/hda63</filename></entry>
                  </row>
                  <row>
                     <entry morerows="5">2</entry>
                     <entry>Весь диск</entry>
                     <entry>64</entry>
                     <entry><filename>/dev/hdb</filename></entry>
                  </row>
                  <row>
                     <entry>Раздел 1</entry>
                     <entry>65</entry>
                     <entry><filename>/dev/hdb1</filename></entry>
                  </row>
                  <row>
                     <entry>Раздел 2</entry>
                     <entry>66</entry>
                     <entry><filename>/dev/hdb2</filename></entry>
                  </row>
                  <row>
                     <entry>Раздел 3</entry>
                     <entry>67</entry>
                     <entry><filename>/dev/hdb3</filename></entry>
                  </row>
                  <row>
                     <entry>...</entry>
                     <entry>...</entry>
                     <entry>...</entry>
                  </row>
                  <row>
                     <entry>Раздел 63</entry>
                     <entry>127</entry>
                     <entry><filename>/dev/hdb63</filename></entry>
                  </row>
                  <row>
                     <entry morerows="3">2</entry>
                     <entry morerows="1">1</entry>
                     <entry>Весь диск</entry>
                     <entry morerows="3">22</entry>
                     <entry>0</entry>
                     <entry><filename>/dev/hdc</filename></entry>
                  </row>
                  <row>
                     <entry>Разделы</entry>
                     <entry>1-63</entry>
                     <entry><filename>/dev/hdc[1..63]</filename></entry>
                  </row>
                  <row>
                     <entry morerows="1">2</entry>
                     <entry>Весь диск</entry>
                     <entry>64</entry>
                     <entry><filename>/dev/hdd</filename></entry>
                  </row>
                  <row>
                     <entry>Разделы</entry>
                     <entry>65-127</entry>
                     <entry><filename>/dev/hdd[1..63]</filename></entry>
                  </row>
               </tbody>
            </tgroup>
         </table>
         <para>По таблице становится видно, что на каждый 64-й минор происходит смена физического диска. Драйвер IDE в текущей версии ядра Linux поддерживает до четырех каналов IDE – т.е. до 8 устройств, по два устройства на канал..</para>
         <para>Рекомендации, которую можно дать владельцам компьютеров с интерфейсом IDE: устройства по возможности рекомендуется держать на разных каналах. Если нет свободных каналов, то “быстрые” устройства лучше подключать на один канал, медленные – на другой.</para>
      </section>
      <section>
         <title>Распределение мажоров и миноров для SCSI-дисков</title>
         <para>Шина SCSI свободна от некоторых недостатков IDE, например количество устройств на одном канале может быть 15 (на самом деле 16, но одним устройством считается сам контроллер), все SCSI устройства работают на своей максимальной скорости, и ограничены только возможностями шины и контроллера – но SCSI-устройства и дороже, и поэтому шина SCSI используется в основном на серверах и рабочих станциях. Для SCSI-дисков ситуация немного меняется – мажоры не привязаны к контроллерам (т.е. один major number может использоваться дисками с разных хост-адаптеров). На каждом SCSI-диске система поддерживает до 16 разделов, а нумерация дисков производится в порядке их подключения по схеме, аналогичной IDE-дискам – но только переход на следующий диск происходит на каждом 16-м миноре (т.е. разделы на SCSI-дисках нумеруются от 1 до 15). Увидеть это можно в следующей таблице и листинге <filename>/dev</filename>:</para>
         <table>
            <title>Распределение номеров устройств для SCSI-дисков</title>
            <tgroup cols="5">
               <thead>
                  <row>
                     <entry>Номер диска в порядке подключения</entry>
                     <entry>Major number</entry>
                     <entry>Minor number</entry>
                     <entry>Раздел</entry>
                     <entry>Имя файла</entry>
                  </row>
               </thead>
               <tbody>
                  <row>
                     <entry morerows="7">1</entry>
                     <entry morerows="7">8</entry>
                     <entry>0</entry>
                     <entry>Весь диск</entry>
                     <entry><filename>sda</filename></entry>
                  </row>
                  <row>
                     <entry>1</entry>
                     <entry>Первый первичный</entry>
                     <entry><filename>sda1</filename></entry>
                  </row>
                  <row>
                     <entry>2</entry>
                     <entry>Второй первичный</entry>
                     <entry><filename>sda2</filename></entry>
                  </row>
                  <row>
                     <entry>3</entry>
                     <entry>Третий первичный</entry>
                     <entry><filename>sda3</filename></entry>
                  </row>
                  <row>
                     <entry>4</entry>
                     <entry>Четвертый первичный</entry>
                     <entry><filename>sda4</filename></entry>
                  </row>
                  <row>
                     <entry>5</entry>
                     <entry>Первый логический</entry>
                     <entry><filename>sda5</filename></entry>
                  </row>
                  <row>
                     <entry>...</entry>
                     <entry>...</entry>
                     <entry>...</entry>
                  </row>
                  <row>
                     <entry>15</entry>
                     <entry>Одиннадцатый логический</entry>
                     <entry><filename>sda15</filename></entry>
                  </row>
                  <row>
                     <entry morerows="7">2</entry>
                     <entry morerows="7">8</entry>
                     <entry>16</entry>
                     <entry>Весь диск</entry>
                     <entry><filename>sdb</filename></entry>
                  </row>
                  <row>
                     <entry>17</entry>
                     <entry>Первый первичный</entry>
                     <entry><filename>sdb1</filename></entry>
                  </row>
                  <row>
                     <entry>18</entry>
                     <entry>Второй первичный</entry>
                     <entry><filename>sdb2</filename></entry>
                  </row>
                  <row>
                     <entry>19</entry>
                     <entry>Третий первичный</entry>
                     <entry><filename>sdb3</filename></entry>
                  </row>
                  <row>
                     <entry>20</entry>
                     <entry>Четвертый первичный</entry>
                     <entry><filename>sdb4</filename></entry>
                  </row>
                  <row>
                     <entry>21</entry>
                     <entry>Первый логический</entry>
                     <entry><filename>sdb5</filename></entry>
                  </row>
                  <row>
                     <entry>...</entry>
                     <entry>...</entry>
                     <entry>...</entry>
                  </row>
                  <row>
                     <entry>31</entry>
                     <entry>Одиннадцатый логический</entry>
                     <entry><filename>sdb15</filename></entry>
                  </row>
               </tbody>
            </tgroup>
         </table>
         <para>В текущей версии ядро Linux поддерживает до 4096 SCSI-дисков – и для абсолютного большинства  компьютеров этого должно быть достаточно. Очень важной особенностью SCSI-дисков является то, что мажор устройства, соответствующего физическому диску, не зависит от контроллера. В результате, если у вас есть 3 диска SCSI, то они всегда именуются <filename>sda</filename>, <filename>sdb</filename> и <filename>sdc</filename>, и если вы выключите компьютер и отключите первый диск, то после перезагрузки второй диск (который ранее назывался <filename>sdb</filename>) станет называться <filename>sda</filename>, а третий диск (который назывался <filename>sdc</filename>) станет называться <filename>sdb</filename>, поэтому при работе со SCSI-устройствами можно использовать devfs (которая позволяет адресовать диски через путь их подключения), либо использовать специализированные средства управления дисковым пространством, которые помечают носители и впоследствии правильно их идентифицируют
            даже после переименования устройств – например, средства md (software RAID) или LVM. Надо заметить, что в свете удаления devfs из основной ветви ядра, использование LVM стало фактически обязательным на серверах.</para>
      </section>
      <section>
         <title>Устройства SATA и переход с IDE на PATA</title>
         <para>SATA, «осовремененная» версия интерфейса IDE, по своей структуре приблизилась к подсистеме SCSI. Поэтому в целях унификации подсистемы ввода-вывода в ядре Linux поддержка SATA была реализована через интерфейс SCSI, соответственно SATA-диски и контроллеры видятся ядром (и пользователем) как SCSI-устройства.</para>
         <para>В новейших ядрах линейки 2.6 также появилась возможность работы с IDE-дисками через подсистему SCSI., и в новых дистрибутивах, таких как Fedora 7, даже обычные Parallel ATA (они же IDE) диски и контроллеры представляются как SCSI-устройства, что привело к унификации подсистемы дискового ввода-вывода, и теперь все диски и CD/DVD приводы для пользователя представляются как <filename>/dev/sdX</filename> или <filename>/dev/scdX</filename>. Драйверы для обычных контроллеров IDE, которые работают по новой схеме, начинаются с префикса pata, например: pata_via – это драйвер IDE-контроллеров с чипсетом VIA, а pata_piix –  это дарйвера для IDE-контроллеров Intel, работающие  через подсистему SCSI.</para>
         <para>А говоря проще, это означает следующее – если у вас новый дистрибутив или имеются SATA-диски, вы можете смело работать со всеми дисками как со SCSI-устройствами.</para>
      </section>
      <section>
         <title>Logical Volume Manager</title>
         <para>Использование таблиц разделов для управления дисковым пространством – достаточно часто используемое решение. К сожалению, оно не свободно от определенных недостатков – например, нет возможности расширить раздел или уменьшить его размер, нет возможности создать один раздела на нескольких дисках и т.д. Решить эту задачу призван LVM (Logical Volume Manager).</para>
         <para>LVM работает следующим образом: пользователь может пометить какие-либо блочные устройства как разделы, используемые LVM. Каждое из таких помеченых блочных устройств (их называют физическими томам,и или physical volumes) может быть присоединено к какой либо группе логических томов (logical volume groups). Внутри групп логических томов могут создаваться уже собственно логические тома (logical volumes). Дисковое пространство любого физического тома из некоторой группы может быть выделено любому логическому тому из этой группы. Реализовано это через так называемые “экстенты” (extents) дискового пространства. Физические тома LVM разбиваются на экстенты, после чего из экстентов и составляются логические тома. Именно за счет этого можно динамически менять конфигурацию дискового пространства – экстент может быть удален из одного тома, и добавлен к другому. Каждый объект LVM – будь то логический том, физический том или группа томов, имеет свой уникальный идентификатор.</para>
         <para>Осуществляется это комплексно драйвером device mapper и специализированными программами из пакета lvm2. Эти программы читают файлы конфигурации и служебную информацию из заголовков физических томов, и на основании этой информации сообщают драйверу инструкции о том, из каких фрагментов каких блочных устройств каким именно образом должны быть скомбинированы логические тома, после чего драйвер для каждого логического тома создает отдельное блочное устройство. При обращении к такому блочному устройству device mapper определяет, на основании ранее переданных параметров к какому блоку какого блочного устройства на самом деле должен быть переадресован запрос, и запрашивает соответствующее блочное устройство для окончательного выполнения операции, после чего возвращает результат выполнения операции (прочитанные данные, сообщение об ошибке, код завершения операции) обратившейся программе.</para>
         <para>Использование LVM позволяет гибко управлять распределением дискового пространства и избежать ограничений, связанных с классическим распределением дискового пространства путем создания разделов на жестких дисках. Единственное правило, которое я бы советовал соблюдать при использовании LVM – не создавать корневой раздел системы на логическом томе LVM: инициализации тома LVM, на котором находится корневая файловая система, необходимо вмешательство некоторых утилит, которые находятся на еще не смонтированной корневой файловой системы. Это решаемая проблема, но она потребует некоторого опыта.</para>
         <para>Ниже идет пример создания и инициализации физического тома, группы томов и примеры нескольких операций с логическими томами. На первом фрагменте протокола продемонстрирована инициализация таблицы разделов для использования LVM. Порядок действий для использования LVM в общем случае следующий: один или несколько разделов жесткого диска с помощью <command>fdisk</command> помечаются как разделы LVM. Затем эти разделы инициализируются и передаются в группы томов, после чего их дисковое пространство можно использовать для создания логических томов:</para>
         <screen><prompt>#</prompt> <userinput>fdisk /dev/hdb</userinput>

            The number of cylinders for this disk is set to 79408.
There is nothing wrong with that, but this is larger than 1024,
and could in certain setups cause problems with:
1) software that runs at boot time (e.g., old versions of LILO)
2) booting and partitioning software from other OSs
   (e.g., DOS FDISK, OS/2 FDISK)

Command (m for help): <userinput>p</userinput>

Disk /dev/hdb: 40.9 GB, 40982151168 bytes
16 heads, 63 sectors/track, 79408 cylinders
Units = cylinders of 1008 * 512 = 516096 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/hdb1               1       79408    40021600+  8e  Linux LVM

Command (m for help): <userinput>w</userinput>
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.</screen>
         <para>В приведенном выше выводе <command>fdisk</command> видно, что на IDE-диске primary slave создан один раздел типа LVM (код типа раздела 0x8E). В следующем листинге показан процесс инициализации физического тома и создания группы томов aurora, в которую включается инициализированный командой pvcreate физический том <filename>/dev/hdb1</filename>:</para>
         <screen><prompt>#</prompt> <userinput>pvcreate /dev/hdb1</userinput> 
  No physical volume label read from /dev/hdb1
  Physical volume "/dev/hdb1" successfully created
<prompt>#</prompt> vgcreate aurora /dev/hdb1
  Volume group "aurora" successfully created</screen>
         <para>Третий фрагмент демонстрирует создание нескольких томов и изменение размеров томов, проделанное с помощью LVM. В этом примере создается логический том размеров в 20GB, затем размер этого тома увеличивается до 30GB, создается еще один логический том, и после этого оба созданных логических тома удаляются.</para>
         <screen><prompt>#</prompt> <userinput>lvcreate -L 20G -n ftpdata aurora</userinput>
  Logical volume "ftpdata" created
<prompt>#</prompt> <userinput>lvscan</userinput>
  ACTIVE           '/dev/aurora/ftpdata' [20,00 GB] next free (default)
<prompt>#</prompt> <userinput>lvresize -L +10G /dev/aurora/ftpdata</userinput> 
  Extending logical volume ftpdata to 30,00 GB
  Logical volume ftpdata successfully resized
<prompt>#</prompt> <userinput>lvscan</userinput>
  ACTIVE           '/dev/aurora/ftpdata' [30,00 GB] next free (default)
<prompt>#</prompt> <userinput>lvcreate -L 8G -n home_dirs aurora</userinput>
  Logical volume "home_dirs" created
<prompt>#</prompt> <userinput>lvscan</userinput>
  ACTIVE           '/dev/aurora/ftpdata' [30,00 GB] next free (default)
  ACTIVE           '/dev/aurora/home_dirs' [8,00 GB] next free (default)
<prompt>#</prompt> <userinput>lvremove /dev/aurora/ftpdata</userinput> 
Do you really want to remove active logical volume "ftpdata"? [y/n]: <userinput>y</userinput>
  Logical volume "ftpdata" successfully removed
<prompt>#</prompt> <userinput>lvremove /dev/aurora/home_dirs</userinput> 
Do you really want to remove active logical volume "home_dirs"? [y/n]: <userinput>y</userinput>
  Logical volume "home_dirs" successfully removed</screen>
         <para>Еще один фрагмент демонстрирует удаление группы томов и очистку физического тома:</para>
         <screen><prompt>#</prompt> <userinput>vgremove aurora</userinput>
  Volume group "aurora" successfully removed
<prompt>#</prompt> <userinput>pvremove /dev/hdb1</userinput>
  Labels on physical volume "/dev/hdb1" successfully wiped</screen>
         <para>Каждый логический том LVM имеет свой собственный minor number, а major number для всех томов LVM равен 253. Для доступа к томам LVM можно создавать блочные устройства с помощью команды <command>mknod</command>, а можно воспользоваться возможностями, предоставляемыми утилитой <command>devlabel</command>. Эта утилита создает символьные ссылки и каталоги внутри подкаталога <filename>/dev</filename>, причем для каждой группы томов в <filename>/dev</filename> создается каталог с именем этой группы, а логические тома представляются символьными ссылками из этих каталогов на блочные устройства, обслуживаемые драйвером device mapper, и тогда любой том LVM можно адресовать следующим путем: <filename>/dev/<replaceable>&lt;имя_группы&gt;</replaceable>/<replaceable>&lt;имя_тома&gt;</replaceable></filename>. На листинге ниже показан пример того, как можно распределить дисковое пространство с помощью LVM:</para>
         <screen><prompt>#</prompt> <userinput>ls -la /dev/chimera</userinput>
lr-xr-xr-x  1 root root 23 Окт  8 13:53 opt -&gt; /dev/mapper/chimera-opt
lr-xr-xr-x  1 root root 24 Окт  8 13:53 swap -&gt; /dev/mapper/chimera-swap
lr-xr-xr-x  1 root root 24 Окт  8 13:53 temp -&gt; /dev/mapper/chimera-temp
lr-xr-xr-x  1 root root 23 Окт  8 13:53 usr -&gt; /dev/mapper/chimera-usr
lr-xr-xr-x  1 root root 23 Окт  8 13:53 var -&gt; /dev/mapper/chimera-var
<prompt>#</prompt> <userinput>lvscan</userinput>
  ACTIVE          '/dev/chimera/swap' [1,00 GB] next free (default)
  ACTIVE          '/dev/chimera/temp' [1,00 GB] next free (default)
  ACTIVE          '/dev/chimera/usr' [10,00 GB] next free (default)
  ACTIVE          '/dev/chimera/opt' [10,00 GB] next free (default)
  ACTIVE          '/dev/chimera/var' [1,00 GB] next free (default)
<prompt>#</prompt> <userinput>mount | grep chimera</userinput>
/dev/mapper/chimera-var on /var type ext3 (rw)
/dev/mapper/chimera-temp on /tmp type ext3 (rw)
/dev/mapper/chimera-usr on /usr type ext3 (rw)
/dev/mapper/chimera-opt on /opt type ext3 (rw)</screen>
         <para>Таким образом, возможности LVM позволяют системному администратору максимально эффективно использовать дисковое пространство, оперативно реагируя на меняющиеся условия эксплуатации. Еще одной интересной возможностью LVM является так называемый multipath I/O. В случае активации соответствующей опции  в ядре device mapper знает о том, что физический том с некоторым UUID может быть доступен через несколько контроллеров, и в случае отказа одного контроллера динамически происходит переключение ввода-вывода на другой. Опытные системные администраторы также оценят такую возможность, как создание снимка (snapshot) логического тома: при создании снимка создается моментальная копия логического тома, которая начинает «жить» независимо от того тома, на основе которого она была создана:</para>
         <screen><prompt>#</prompt> <userinput>sync</userinput>
<prompt>#</prompt> <userinput>lvcreate -s -L 10G -n home_snapshot /dev/chimera/home</userinput>
<prompt>#</prompt> <userinput>dd if=/dev/chimera/home_snapshot of=/dev/st0</userinput>
<prompt>#</prompt> <userinput>lvremove /dev/chimera/home_snapshot</userinput></screen>
         <para>В приведенном примере системный администратор вызовом команды sync сбрасывает все закэшированные операции на диск, создает снимок тома home из группы томов chimera, на котором «живет» файловая система <filename>/home</filename>, и этот снимок называет home_snapshot, при этом на удержание копии измененных данных выделяется 10 гигабайт дискового пространства. Каждый раз, когда будет переписываться какой-либо блок логического тома home, первоначальная версия изменяемого блока будет копироваться в те 10GB дискового пространства, которые мы выделили под снимок тома, и мы можем считать содержимое тома home_snapshot неизменным, и скопировать его на ленту. В процессе чтения, если читаемый блок не изменялся с момента создания снимка, то он читается из исходного тома (home), если же  блок менялся с момента создания снимка, то используется его копия, хранимая в зарезервированном при создании снимка пространстве. После окончания копирования мы удаляем снимок командой
               <command>lvremove</command>.</para>
      </section>
      <section>
         <title>Sotware RAID</title>
         <para>Ядро Linux содержит средства для организации software raid (программных RAID-устройств). Эта возможность поддерживается драйвером устройств md. В отличие от device mapper, драйвер md умеет работать в “самостоятельном” режиме, получая конфигурацию из параметров, которые пользователь указал ядру при загрузке системы, что позволяет организовывать загрузку системы с RAID-устройств. Все устройства md имеют мажор 254 и миноры от 0 и до 16383.</para>
         <para>В отличие от LVM, основной задачей которого является динамическое распределение дискового пространства (деление разделов на фрагменты и построение из фрагментов новых блочных устройств), задачей подсистемы RAID является построение новых блочных устройств путем объединения существующих.</para>
         <para>Каждое из устройств, входящих в создаваемый дисковый массив, может определенным образом помечаться. Впоследствии эти метки (их также называют array superblocks) используются для повторной сборки массива. В частности, например, суперблок массива содержит его уникальный идентификатор, который можно использовать при сборке ранее созданного массива после перезагрузки. Если программный RAID-массив был помечен в процессе создания (т.е. на нем был создан суперблок массива), это дает возможность автоматической сборки массива вне зависимости от того, поменялся или нет порядок следования устройств. Например, такая необходимость может возникнуть в ситуации, когда порядок нумерации блочных устройств изменился – например, один из SCSI-дисков, участвовавших в построении массива, был удален.</para>
         <para>Естественно, суперблок не является обязательным – то есть можно создавать массивы без суперблока, но управления ими может быть затруднено вследствие необходимости «руками» контролировать корректность указания устройств при переконфигурации массива.</para>
         <para>Из интересных особенностей драйвера md стоит отметить то, что он поддерживает разбиение md-устройств на разделы, при этом минорные номера присваиваются разделам аналогично тому, как они присваиваются разделам на дисках IDE, т.е на каждом RAID-устройстве можно создать до 63 разделов. Определить минор раздела, созданного на RAID-устройстве, можно с помощью вычисления значения следующего выражения: 64 * N + M, где N – это номер массива (номер RAID-устройства) из диапазона 0...255, а M – это номер раздела из диапазона 1...63.</para>
         <para>Следует сказать, что по умолчанию в большинстве дистрибутивов специальные файлы для разделов на md-устройствах не создаются, и их необходимо создать вручную командой mknod. В настоящий момент оптимальным, наверное, следует считать комбинирование использования LVM и md, что позволяет достигнуть надежности за счет дублирования данных средствами md, и гибкости распределения дискового пространства за счет возможностей LVM.</para>
         <para>Драйвер md хорошо подходит для создания RAID-устройств уровней 0, 1 или 0+1, но не будет являться оптимальным вариантом в случае использования, например RAID уровня 5 (чередование данных по устройствам с вычислением контрольной суммы и кодом исправления ошибок), поскольку это создаст значительную нагрузку на процессор при большом объеме передаваемых данных. Возможно, что в таких случаях стоит подумать о приобретении аппаратного контроллера RAID – например, HP NetRaid (сделан на основе AMI MegaRAID) или Compaq Smart Array (сейчас называется HP Smart Array).</para>
         <para>На листинге демонстрируется пример создания, активизации и остановки программных RAID-устройств уровня 0 и уровня 1 средствами драйвера md и системной утилиты mdadm. Утилита mdadm имеет конфигурационный файл <filename>/etc/mdadm.conf</filename>, но для того, чтобы проделать некоторые тесты и демонстрационные примеры нет необходимости его изменять.</para>
         <para>В первом примере будем считать, что на жестком диске <filename>hdb</filename> создано два раздела, с которыми мы и будем экспериментировать. Для начала необходимо произвести инициализацию md-устройства. Соответственно, для успешной необходимо указать тип RAID-массива, специальный файл md-устройства, которое мы хотим инициализировать, и список блочных устройств, на которых будет располагаться получившийся массив:</para>
         <screen><prompt>#</prompt> <userinput>mdadm --create \
&gt;                           /dev/md0 --level=0 \
&gt;                           --raid-devices=2 /dev/hdb1 /dev/hdb2</userinput>
mdadm: array /dev/md0 started.
<prompt>#</prompt> <userinput>mdadm -Q /dev/md0</userinput>
/dev/md/d0: 983.25MiB raid0 2 devices, 0 spares.
<prompt>#</prompt> <userinput>mdadm –S /dev/md0</userinput>
<prompt>#</prompt> <userinput>mdadm --create \
&gt;                           /dev/md0 --level=1 \
&gt;                           --raid-devices=2 /dev/hdb1 /dev/hdb2</userinput>
mdadm: array /dev/md0 started.
<prompt>#</prompt> <userinput>mdadm -Q /dev/md0</userinput>
/dev/md0: 491.63MiB raid1 2 devices, 0 spares.
<prompt>#</prompt> <userinput>mdadm –S /dev/md0</userinput>
<prompt>#</prompt> <userinput>mdadm –assemble /dev/md0 /dev/hdb1 /dev/hdb2</userinput>
mdadm: /dev/md0 has been started with 2 drives.</screen>
         <para>Последняя команда демонстрирует активизацию массива путем указания имени md-устройства и нескольких блочных устройств, на которых оно базируется. Все остальные параметры (размеры блоков, разновидность RAID и т.д.) утилита mdadm извлекла из суперблока массива. Как уже отмечалось, суперблок массива содержит еще и уникальный идентификатор массива, что дает возможность проидентифицировать каждое исходное блочное устройство на предмет его принадлежности к какому-либо массиву. Ниже приведен пример вывода утилиты mdadm, демонстрирующий как можно получить некоторые полезные данные о массиве, а строка, содержащая UID массива выделена жирным текстом:</para>
         <screen><prompt>#</prompt> <userinput>mdadm -Q -D /dev/md0</userinput>
/dev/md0:
        Version : 00.90.01
  Creation Time : Fri Oct  8 14:29:21 2004
     Raid Level : raid1
     Array Size : 102336 (99.94 MiB 104.79 MB)
    Device Size : 102336 (99.94 MiB 104.79 MB)
   Raid Devices : 2
  Total Devices : 2
Preferred Minor : 0
    Persistence : Superblock is persistent

    Update Time : Fri Oct  8 14:32:22 2004
          State : clean, no-errors
 Active Devices : 2
Working Devices : 2
 Failed Devices : 0
  Spare Devices : 0

    Number   Major   Minor   RaidDevice State
       0     253       24        0      active sync   /dev/hdb1
       1     253       25        1      active sync   /dev/hdb2
           <emphasis role="bold">UUID : 8696ffc0:52547452:ba369881:d1b252d0</emphasis>
         Events : 0.3</screen>
         <para>Впоследствии этот идентификатор может быть использован в файле конфигурации для утилиты mdadm. В конфигурационном файле <filename>/etc/mdadm.conf</filename> можно указать список устройств и правила их построения, после чего описанные в нем md-устройства будут автоматически собираться и разбираться без указания списка исходных устройств:</para>
         <screen><prompt>#</prompt> <userinput>cat /etc/mdadm.conf</userinput>
MAILADDR root
ARRAY /dev/md0 UUID=8696ffc0:52547452:ba369881:d1b252d0
DEVICE /dev/hdb*</screen>
         <para>В листинге видно, что устройство массив md0 имеет указанный идентификатор, а также указано, что для построения массивов могут быть использованы все раделы диска hdb. В этом примере если системный администратор напишет команду <command>mdadm –assemble /dev/md0</command>, то <command>mdadm</command> просканирует все файлы устройств с именами, совпадающими с шаблоном <filename>/dev/hdb*</filename> и подключит к массиву md0 те из них, на которых будет найдена суперблок массива с тем идентификатором, который указан в параметре ARRAY для устройства <filename>/dev/md0</filename>.</para>
         <para>Системный администратор, который хочет расположить корневую файловую систему на md-устройстве, должен указать ядру при загрузке какие именно физические блочные устройства должны входить в md-устройство, на котором содержится корневая файловая система. Обычно это делается путем загрузки ядра командной строкой с опциями следующего вида:</para>
         <screen>linux md0=0,/dev/hdb1,/dev/hdb2 root=/dev/md0</screen>
         <para>Данный пример приведен скорее как иллюстративный, поскольку в зависимости от опций, использованных при создании RAID-устройства, на котором расположена корневая файловая система, командная строка ядра может меняться. В современных дистрибутивах при необходимости инициализации md-устройств для загрузки системы, как правило код и утилиты инициализации устройства помещаются в initrd.</para>
         <para>Суперблок массива записывается не в начале блочного устройства, а ближе к его середине или концу. Сделано это было для того, чтобы можно было создать RAID-массив с boot-сектором, который сможет быть прочитан не только ядром Linux с драйвером md, но и базовым загрузчиком BIOS, вследствие чего можно объединить в RAID-массив не разделы жестких дисков, а непосредственно физические диски. Тогда загрузчик, установленный в начало RAID-устройства, окажется установленным в начало жесткого диска, после чего можно использовать при загрузке ядра следующую командную строку:</para>
         <screen>linux md0=d0,/dev/hda,/dev/hdb root=/dev/md_d0p1</screen>
         <para>Драйвер md также поддерживает возможность задания hotswap-устройств для массивов, т.е. резервных устройств, которые могут быть активизированы в при сбое одного из основных устройств в массиве.</para>
         <para>Поддержка устройств software RAID в Linux дает возможность создавать серверы с высокой отказоустойчивостью и быстродействием.</para>
      </section>
      <section>
         <title>Device mapper</title>
         <para>В ядрах линейки 2.6 появилась еще одна подсистема по некоторым функциям аналогичная подсистеме MD, и называемая device-mapper. Это модульная компонентная подсистема, позволяющая с помощью специальных команд создать одно блочное устройство из нескольких кусков других блочных устройств,  а также определить правила, по которым производится запись на эти «нижележащие» блочные устройства.</para>
         <para>LVM работает именно через подсистему device mapper, и на самом деле все утилиты LVM на самом деле просто передают инструкции о том из каких фрагментов каких блочных устройств состоит какой том LVM в драйвер device mapper, в каком порядке осуществляется запись и чтение данных, и впоследствии при записи на том LVM или чтении с него, работа на самом деле ведется с устройствами, обслуживаемыми драйвером device mapper, который и делает всю работу.</para>
         <para>Данная многоуровневая архитектура позволяет значительно упростить и таким образом значительно повысить стабильность работы системы, поскольку реализация нескольких небольших узкофункциональных компонентов в общей сложности содержит меньше ошибок, чем реализация всех этих функций в одной подсистеме.</para>
      </section>
      <section>
         <title>Host-RAID, или дешевых RAID-контроллеров не бывает</title>
         <para>Сегодня даже для дешевых современных материнских плат фирмы-производители часто декларируют «аппаратную поддержку RAID» и у многих пользователей этот факт вызывает недоумение – как же так, мой Linux не умеет работать с RAID?!</para>
         <para>На самом деле все проще – задекларированная и разрекламированная поддержка RAID-массивов на материнских платах для офисных и домашних компьютеров – это миф.</para>
         <para>Вся поддержка RAID в таких «контроллерах» на самом деле представляют собой просто небольшое расширение в BIOS и без специальных драйверов в 32/64-битных операционных системах такие контроллера не работают, а все функции RAID для них выполняются драйвером. Если в Windows для каждого из таких контроллеров фирма-производитель пишет драйвер, то в Linux ситуация немного иная.</para>
         <para>Для реализации возможности работы с такими псевдо-RAID контроллерами (иногда называемыми fake-RAID) была разработана утилита dmraid. При запуске она сканирует жесткие диски в поисках специальных блоков (функционально аналогичных суперблокам уже знакомых нам md-устройств), записываемых такими fake-RAID контроллерами, и если ей удалось распознать формат этого специального блока, то dmraid инструктирует подсистему device-mapper о том, в каком порядке следует считывать блоки с жестких дисков.</para>
         <para>После этого device-mapper создает блочное устройство, при записи или чтение данных с которого данные автоматически читаются и пишутся так, как сделал бы это драйвер от производителя материнской платы или контроллера.</para>
      </section>
   </section>
   <section>
      <title>Сетевая подсистема</title>
      <para>Ключевым (с нашей точки зрения) объектом сетевой подсистемы Linux является интерфейс. Сетевой интерфейс в Linux – это абстрактный именованный объект, используемый для передачи данных через некоторую линию связи без привязки к ее (линии связи) реализации. Конечно, сказано мудрено – но попробуем объяснить «на пальцах».</para>
      <para>Например, если в системе существует интерфейс eth0, то в большинстве случаев на современных компьютерах он сопоставлен Ethernet-адаптеру, встроенному в материнскую плату. Интерфейс с именем ppp0 отвечает за некоторое соединение «точка-точка» с другим компьютером. Интерфейс с именем lo является виртуальным и представляет как бы замкнутый сам на себя (вход непосредственно подключен к выходу) сетевой адаптер.</para>
      <para>Основная задача интерфейса – абстрагироваться от физической составляющей канала. То есть программы и система будут использовать один и тот же метод «отправить пакет» для отправки данных через любой интерфейс – хоть lo, хоть ethX, хоть pppY, и точно так же использовать один и тот же метод «принять пакет» – то есть создается унифицированный API передачи данных, независимый от носителя.</para>
      <para>Для того, чтобы ознакомиться с интерфейсами, можно воспользоваться командой ifconfig:</para>
      <screen><prompt>$</prompt> <userinput>ifconfig -a</userinput>
eth0      Link encap:Ethernet  HWaddr 00:11:2F:A8:DE:A4
          inet addr:172.23.2.114  Bcast:172.23.2.255  Mask:255.255.255.0
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
          Interrupt:11 Base address:0x4000

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:60 errors:0 dropped:0 overruns:0 frame:0
          TX packets:60 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:4707 (4.5 KiB)  TX bytes:4707 (4.5 KiB)</screen>
      <para>В данном случае мы видим в системе два активных интерфейса, eth0 и lo, а также некоторую информацию об их состоянии, настройках и параметрах и состоянии аппаратуры для интерфейса eth0. В частности, поле Link encap характеризует тип интерфейса, HWAddr – аппаратный адрес устройства (например, MAC-адрес для Ethernet), MTU – максимальный размер передаваемого пакета. Также могут представлять интерес поля статистики – они сообщают, какой объем данных был передан и получен через соответствующий интерфейс.</para>
      <para>Наиболее часто встречающиеся типы интерфейсов:</para>
      <orderedlist>
         <listitem>
            <para>eth (Ethernet) – обычно соответствует отдельному сетевому адаптеру</para>
         </listitem>
         <listitem>
            <para>ppp (Point-To-Point) – соединение точка-точка, например при коммутируемом доступе, но очень часто используется и при организации VPN</para>
         </listitem>
         <listitem>
            <para>slip (Serial Line IP) – соединение точка-точка, устаревший протокол</para>
         </listitem>
         <listitem>
            <para>wl (Wireless) – беспроводной интерфейс, обычно сопоставлен соответствующему адаптеру</para>
         </listitem>
         <listitem>
            <para>lo (Loopback) – интерфейс-«петля», то есть что послал, то и получил – используется для общения между сетевыми приложениями в рамках одного компьютера</para>
         </listitem>
      </orderedlist>
      <para>Команда ifconfig может также использоваться для остановки или активации интерфейса, а также изменения его параметров, связанных с протоколом IP:</para>
      <screen><prompt>#</prompt> <userinput>ifconfig eth0 down</userinput>
<prompt>#</prompt> <userinput>ifconfig eth0 up</userinput>
<prompt>#</prompt> <userinput>ifconfig eth0 inet 192.168.2.210 netmask 255.255.255.0</userinput>
<prompt>#</prompt> <userinput>ifconfig eth0 mtu 296</userinput></screen>
      <para>Для управления параметрами других протоколов используются другие команды – например, ipx_config для управления параметрами, связанными с протоколом IPX. Рассмотрим также картинку, на которой приведена приблизительная схема взаимодействия различных драйверов и сетевых подсистем ядра:</para>
      <mediaobject>
         <imageobject>
            <imagedata fileref="images/Gentoo_doc-1.5_html_5d185b61.gif" align="center" format="GIF" width="90%"/>
         </imageobject>
      </mediaobject>
      <para>Предположим, что приложение пытается отправить пакет. Перед отправкой через системные вызовы группы socket (bind, connect и пр.)  приложение настраивает специальный файловый дескриптор. После окончания настройки каждый записанный в этот дескриптор пакет должен быть отправлен по сети получателю. Как движется пакет в нашей системе? Прежде всего, пакет попадает в драйвер протокола. Этот драйвер определяет через какой интерфейс должна производиться отправка, дописывает к пакету необходимые заголовки и отдает пакет на обработку соответствующему интерфейсу (точнее, ставит пакет в очередь, связанную с этим интерфейсом).</para>
      <para>Что драйвер сделает с пакетом, это уже его дело. Например, драйвер интерфейса loopback этот пакет вынет из очереди и сразу поставит в очередь «принятых», откуда его впоследствии заберет драйвер протокола (левая цепочка на схеме). Драйвер интерфейса eth0 допишет к пакету заголовки Ethernet и передаст пакет драйверу сетевого адаптера, и уже тот непосредственно проинструктирует сетевой адаптер, откуда взять и как отправить пакет (правая цепочка). В средней же цепочке мы видим схему работы PPP, когда пакет помещается в очередь интерфейса ppp0, откуда его заберет демон pppd. Демон допишет в пакет нужные заголовки, и через символьный специальный файл <filename>/dev/ttyS0</filename> передаст пакет драйверу COM-порта, а тот непосредственно будет работать с аппаратурой. Соответственно, при приемке данных цепочки проходятся в обратном порядке.</para>
   </section>
   <section>
      <title>Маршрутизация IP и форвардинг</title>
      <para>Маршрутизация транзитных IP-пакетов (не предназначенных для этого компьютера), или IP-форвардинг, является опциональной возможностью IP-стека Linux. По умолчанию функция форвардинга не активируется, и система не пересылает транзитные пакеты через свои интерфейсы, а только обрабатывает адресованные ей пакеты. Включение форвардинга IP-пакетов производится через параметр <parameter>net.ipv4.ip_forward</parameter> интерфейса <command>sysctl</command>. Если значение этого параметра равно 0, то форвардинг отключен, если же значение параметра не равно 0, форвардинг включен:</para>
      <screen><prompt>$</prompt> <userinput>sysctl net.ipv4.ip_forward</userinput>
net.ipv4.ip_forward = 0</screen>
      <para>Кроме того, возможно разрешать или запрещать участие в форвардинге для каждого интерфейса индивидуально:</para>
      <screen><prompt>$</prompt> <userinput>sysctl -a | grep forward | grep v4</userinput>
net.ipv4.conf.vmnet1.mc_forwarding = 0
net.ipv4.conf.vmnet1.forwarding = 0
net.ipv4.conf.eth0.mc_forwarding = 0
net.ipv4.conf.eth0.forwarding = 0
net.ipv4.conf.lo.mc_forwarding = 0
net.ipv4.conf.lo.forwarding = 0
net.ipv4.conf.default.mc_forwarding = 0
net.ipv4.conf.default.forwarding = 0
net.ipv4.conf.all.mc_forwarding = 0
net.ipv4.conf.all.forwarding = 0
net.ipv4.ip_forward = 0</screen>
      <para>По умолчанию форвардинг включается и выключается для всех интерфейсов одновременно, но для отдельных интерфейсов возможно сменить флаг участия в форвардинге. Изменять параметры форвардинга может только системный администратор или пользователь, который имеет право записи в необходимые файлы интерфейса <command>sysctl</command>. Следующий листинг демонстрирует включение форвардинга через все интерфейсы путем вызова программы <command>sysctl</command>:</para>
      <screen><prompt>#</prompt> <userinput>sysctl -w net.ipv4.ip_forward=1</userinput>
net.ipv4.ip_forward = 1
<prompt>#</prompt> <userinput>sysctl -a | grep forward | sort</userinput>
net.ipv4.conf.all.forwarding = 1
net.ipv4.conf.all.mc_forwarding = 0
net.ipv4.conf.default.forwarding = 1
net.ipv4.conf.default.mc_forwarding = 0
net.ipv4.conf.eth0.forwarding = 1
net.ipv4.conf.eth0.mc_forwarding = 0
net.ipv4.conf.lo.forwarding = 1
net.ipv4.conf.lo.mc_forwarding = 0
net.ipv4.conf.vmnet1.forwarding = 1
net.ipv4.conf.vmnet1.mc_forwarding = 0
net.ipv4.ip_forward = 1</screen>
      <para>В процессе маршрутизации для выбора интерфейса и следующего узла для доставки пакета (next hop) ядро использует таблицу маршрутизации. Эта таблица представляет список критериев, в соответствии с которыми выбирается следующий узел. В частности, в таблице маршрутизации фигурируют следующие условия: адрес сети получателя пакета, маска подсети получателя пакета, IP-адрес следующего узла, метрика маршрута и служебные поля (например, тип и возраст записи). Таблица маршрутизации используется не только в IP-форвардинге, но и даже при простой отсылке IP-пакета для выбора интерфейса, через который будет производиться отсылка пакета.</para>
      <para>Запись о сети с адресом 0.0.0.0 и маской подсети 0.0.0.0 называют маршрутом по умолчанию, или default route. Узел, чей адрес указан в поле gateway для маршрута по умолчанию, называют маршрутизатором по умолчанию, или default gateway или default router. В системе может быть произвольное количество маршрутов по умолчанию, но они должны быть как минимум с разными метриками. Для просмотра таблицы маршрутизации можно воспользоваться командой route. Эта команда позволяет оперировать с таблицей маршрутов, добавляя и удаляя из нее записи.</para>
      <screen><prompt>#</prompt> <userinput>route -n</userinput>
Kernel IP routing table
Destination   Gateway      Genmask         Flags Metric Ref  Use Iface
10.80.1.113   0.0.0.0      255.255.255.255 UH    0      0      0 ppp0
127.0.0.0     0.0.0.0      255.0.0.0       U     0      0      0 lo
0.0.0.0       10.80.1.113  0.0.0.0         UG    0      0      0 ppp0
<prompt>#</prompt> <userinput>route del default</userinput>
<prompt>#</prompt> <userinput>route -n</userinput>
Kernel IP routing table
Destination   Gateway      Genmask         Flags Metric Ref  Use Iface
10.80.1.113   0.0.0.0      255.255.255.255 UH    0      0      0 ppp0
127.0.0.0     0.0.0.0      255.0.0.0       U     0      0      0 lo
<prompt>#</prompt> <userinput>route add default dev ppp0</userinput></screen>
      <para>В данном выводе таблица упорядочена по маске подсети, что соответствует порядку ее просмотра ядром. Столбцы Destination и Genmask содержат адрес и маску сети получателя пакета, столбец Metric фактически указывает приоритет маршрута (маршрут с меньшей метрикой более приоритетен), поле Gateway указывает IP-адрес следующего узла для передачи пакета. Некоторые типы интерфейсов (в частности, интерфейсы типа точка-точка, или point-to-point) подразумевают, что на принимающем конце линии связи всегда находится не более одного узла, и поэтому в этой ситуации IP-адрес следующего узла можно не указывать. В данном случае мы видим, что в приведенном примере некоторые узлы доступны через интерфейс ppp0 типа точка-точка. В частности, именно из-за этого свойства приведенная выше таблица оказывается эквивалентна следующей ниже. Жирным шрифтом помечена измененная строка, демонстрирующая “точечную” природу PPP-соединения:</para>
      <screen><prompt>#</prompt> <userinput>route -n</userinput>
Kernel IP routing table
Destination   Gateway     Genmask         Flags Metric Ref    Use Iface
10.80.1.113   0.0.0.0     255.255.255.255 UH    0      0        0 ppp0
127.0.0.0     0.0.0.0     255.0.0.0       U     0      0        0 lo
0.0.0.0       0.0.0.0     0.0.0.0         U     0      0        0 ppp0</screen>
      <para>Специфика использования протокола PPP (обычно используемого при модемых соединениях) такова, что любой PPP-интерфейс является интерфейсом типа точка-точка, более того – PPP и расшифровывается как Point-to-Point Protocol. Также интерфейсами точка-точка являются интерфейсы SLIP (Serial Line IP) и практически все разновидности туннельных интерфейсов.</para>
      <para>При деактивизации интерфейса из таблицы маршрутизации автоматически исключаются все маршруты, для которых в поле Iface был указан отключившийся интерфейс. Для некоторых типов интерфейсов при активизации в таблице маршрутизации также создаются служебные записи о маршрутах, которые нельзя удалить.</para>
      <para>В большинстве случаев таблица маршрутизации имеет не слишком большой размер, но в некоторых ситуациях (в частности, на шлюзовых машинах в больших сетях) таблица может иметь весьма значительный размер и изменяется не “вручную” с помощью команды route, а специальными программами – демонами поддержки протоколов динамической маршрутизации. С некоторыми упрощениями алгоритм работы этих демонов можно описать следующим образом: демон “слушает” приходящие пакеты для обслуживаемых протоколов динамической маршрутизации, и по получении (или неполучении) такого пакета отдает ядру команду на изменение таблицы маршрутизации.</para>
      <para>Следует также заметить, что команда route в режиме вывода таблицы маршрутизации фактически просто фильтрует и форматирует данные, содержащиеся в специальном файле, называемом /proc/net/route, используемом для доступа к таблице маршрутизации, ведущейся ядром.</para>
   </section>
   <section>
      <title>Фильтры пакетов</title>
      <para>Возможность инсталляции фильтров пакетов является очень интересной возможностью, предоставляемой стеком TCP/IP ядра Linux. Не углубляясь в детали просто отметим, что IP-стек Linux позволяет различным модулям установить “ловушки” (hooks) для пакетов. При этом каждый пакет, попадающий в такую ловушку, передается для обработки драйверу, установившему эту ловушку. Драйвер, в свою очередь, может проанализировать пакет, проделать какие-либо действия с пакетом, после чего вернуть код обработки, инструктируя таким образом ядро о том, что следует делать с пакетом дальше – вернуть ли отправителю сообщение об ошибке, прервать ли обработку и уничтожить пакет, либо продолжать обработку пакета обычным образом.</para>
      <para>В настоящее время для фильтрации пакетов наиболее часто используются средства iptables. <command>iptables</command> – это название утилиты, которая позволяет настроить множество драйверов сетевой подсистемы NETFILTER ядра Linux, позволяющих осуществить анализ, произвести преобразование, или изменить обработку IP-пакетов. Основным объектом в iptables является цепочка правил (chain). Каждое правило в цепочке содержит набор условий совпадения (condition matches) и действие (action). Цепочки сгруппированы в таблицы (tables).</para>
      <para>Действий есть две разновидности – прерывающие обработку пакета в цепочке, например действия DROP или ACCEPT, и не прерывающие обработку пакета цепочкой – например, LOG или MARK.</para>
      <para>Цепочки используются для проверки пакетов – то есть пакет поочередно последовательно сравнивается с каждым из правил цепочки, и если он удовлетворяет всем условиям в правиле, к пакету применяется действие, указанное в этом правиле. Если действие является прерывающем, то на этом обработка пакета этой цепочкой заканчивается, если действие не прерывающее, то пакет продолжает проверяться этой же цепочкой.</para>
      <para>Стандартные цепочки также содержат специальное неявное действие по умолчанию, называемое политикой цепочки (chain policy). Действие, указанное как политика цепочки, применяется ко всем пакетам, которые не попали ни под одно правило с “прерывающим” действием.</para>
      <section>
         <title>Стандартные таблицы и цепочки</title>
         <para>Подсистема пакетного фильтра содержит три таблицы, в каждой из которых содержатся несколько цепочек (наборов правил). Кроме того, администратор может создавать собственные цепочки правил. Ниже перечисляются стандартные таблицы и цепочки:</para>
         <informaltable frame="all">
            <tgroup cols="4">
               <thead>
                  <row>
                     <entry>
                        <para>Таблица</para>
                     </entry>
                     <entry>
                        <para>Назначение</para>
                     </entry>
                     <entry>
                        <para>Цепочки</para>
                     </entry>
                     <entry>
                        <para>Назначение</para>
                     </entry>
                  </row>
               </thead>
               <tbody>
                  <row>
                     <entry morerows="4">mangle</entry>
                     <entry morerows="4">Модификация пакетов</entry>
                     <entry>PREROUTING</entry>
                     <entry>Модификация всех пришедших пакетов</entry>
                  </row>
                  <row>
                     <entry>INPUT</entry>
                     <entry>Модификация пакетов, пришедших на адрес компьютера</entry>
                  </row>
                  <row>
                     <entry>FORWARD</entry>
                     <entry>Модификация пакетов, которые должны быть отмаршрутизированы (пересланы на другой хост)</entry>
                  </row>
                  <row>
                     <entry>OUTPUT</entry>
                     <entry>Модификация пакетов, сгенерированных процессами данного хоста</entry>
                  </row>
                  <row>
                     <entry>POSTROUTING</entry>
                     <entry>Модификация всех переданных пакетов</entry>
                  </row>
                  <row>
                     <entry morerows="2">filter</entry>
                     <entry morerows="2">Фильтрация пакетов – принятие решения об их дальнейшей обработке или отказе от обработки)</entry>
                     <entry>INPUT</entry>
                     <entry>Фильтрация адресованных этому компьютеру пакетов</entry>
                  </row>
                  <row>
                     <entry>OUTPUT</entry>
                     <entry>Фильтрация сгенерированных этим компьютером пакетов</entry>
                  </row>
                  <row>
                     <entry>FORWARD</entry>
                     <entry>Фильтрация маршрутизируемых (транзитных) пакетов</entry>
                  </row>
                  <row>
                     <entry morerows="2">nat</entry>
                     <entry morerows="2">Трансляция адресов</entry>
                     <entry>PREROUTING</entry>
                     <entry>Трансляция адресов всех принимаемых пакетов</entry>
                  </row>
                  <row>
                     <entry>FORWARD</entry>
                     <entry>Трансляция адресов транзитных пакетов</entry>
                  </row>
                  <row>
                     <entry>POSTROUTING</entry>
                     <entry>Трансляция адресов всех передаваемых пакетов</entry>
                  </row>
               </tbody>
            </tgroup>
         </informaltable>
         <para>Таблица nat обладает “двойственным” действием, т.е. если вы включите преобразование для входящих пакетов, исходящие пакеты также будут модифицироваться, и наоборот. Таблицы mangle и nat изменяют пакеты, но mangle не ведет список изменений, т.е. является “однонаправленной” таблицей.</para>
      </section>
      <section>
         <title>Порядок применения стандартных таблиц и цепочек</title>
         <para>Рассмотрим, какой путь проходит пакет в цепочках и таблицах iptables. Для входящих пакетов (адресованных компьютеру, на котором активизирована поддержка iptables) верна следующая последовательность применения цепочек:</para>
         <orderedlist>
            <listitem>
               <para>mangle.PREROUTING</para>
            </listitem>
            <listitem>
               <para>nat.PREROUTING</para>
            </listitem>
            <listitem>
               <para>mangle.INPUT</para>
            </listitem>
            <listitem>
               <para>filter.INPUT</para>
            </listitem>
         </orderedlist>
         <para>Для пакетов, отправляемых с компьютера, реализуется следующая цепочка обработки:</para>
         <orderedlist>
            <listitem>
               <para>filter.OUTPUT</para>
            </listitem>
            <listitem>
               <para>mangle.OUTPUT</para>
            </listitem>
            <listitem>
               <para>nat.POSTROUTING</para>
            </listitem>
            <listitem>
               <para>mangle.POSTROUTING</para>
            </listitem>
         </orderedlist>
         <para>Пакеты, являющиеся транзитными (маршрутизируемыми), т.е. не адресованные фильтрующему компьютеру и не сгенерированные фильтрующим компьютером, проходят по следующей последовательности цепочек и таблиц:</para>
         <orderedlist>
            <listitem>
               <para>mangle.PREROUTING</para>
            </listitem>
            <listitem>
               <para>nat.PREROUTING</para>
            </listitem>
            <listitem>
               <para>mangle.FORWARD</para>
            </listitem>
            <listitem>
               <para>filter.FORWARD</para>
            </listitem>
            <listitem>
               <para>nat.FORWARD</para>
            </listitem>
            <listitem>
               <para>nat.POSTROUTING</para>
            </listitem>
            <listitem>
               <para>mangle.POSTROUTING</para>
            </listitem>
         </orderedlist>
      </section>
      <section>
         <title>Стандартные действия</title>
         <para>Каждое правило в любой цепочке может ссылаться на одно из стандартных или дополнительных действий, либо на какую-либо пользовательскую цепочку. Основное различие между стандартными и дополнительными действиями в том, что стандартные действия могут указываться в правилах любых цепочек любых таблиц, а дополнительные действия можно указывать только для некоторых цепочек некоторых таблиц. Перечислим стандартные действия:</para>
         <informaltable frame="all">
            <tgroup cols="2">
               <thead>
                  <row>
                     <entry>
                        <para>ACCEPT</para>
                     </entry>
                     <entry>
                        <para>Прервать проверку пакета цепочкой и перейти к следующей в порядке обработки пакета стандартной цепочке</para>
                     </entry>
                  </row>
               </thead>
               <tbody>
                  <row>
                     <entry>
                        <para>DROP</para>
                     </entry>
                     <entry>
                        <para>Прервать обработку пакета, сам пакет удалить</para>
                     </entry>
                  </row>
                  <row>
                     <entry>
                        <para>RETURN</para>
                     </entry>
                     <entry>
                        <para>Прервать проверку пакета цепочкой и вернуться к проверке вышестоящей цепочкой, а если действие встретилось в одно из стандартных цепочек, поступить с пакетом так, как предписано в политике цепочки (chain policy)</para>
                     </entry>
                  </row>
                  <row>
                     <entry>
                        <para>QUEUE</para>
                     </entry>
                     <entry>
                        <para>Передать пакет некоторому процессу для дальнейшей обработки</para>
                     </entry>
                  </row>
               </tbody>
            </tgroup>
         </informaltable>
         <para>Интересной особенностью также является то, что существуют так называемые target extensions, которые реализованы как модули и также могут использоваться для указания проводимого над пакетом действия. В частности, к таким действиям, например, относятся действия LOG – запротоколировать факт получения пакета, MASQUERADE – подменить IP-адрес отправителя пакета, MARK – пометить пакет и многие другие. Некоторые действия могут встречаться не во всех цепочках, а только в некоторых цепочках некоторых таблиц.</para>
         <para>Еще одним специфическим действием можно назвать переход к пользовательской цепочке. При этом, если пакет в процессе обработки попадает под действие правила, у которого в качестве действия указан переход к другой цепочке, то пакет начинает проверяться ее правилами. Это часто используется, чтобы сходным образом обрабатывать некоторые виды пакетов.</para>
      </section>
      <section>
         <title>Условия отбора</title>
         <para>Условия отбора делятся на две группы – стандартные условия, которые применимы ко всем пакетам, и расширенные условия, называемые также match extensions. Расширенные условия могут применяться не для всех пакетов, а только для некоторых из них – например, дополниетельные условия для протокола UDP включают в себя адреса портов отправителя и получателя, а для ICMP – тип и код ICMP-сообщения.</para>
      </section>
      <section>
         <title>Примеры конфигураций iptables</title>
         <para>Попробуем рассмотреть несколько простых примеров, достаточно часто используемых в реальных конфигурациях. Стоит заметить, что самостоятельная конфигурация пакетного фильтра требует некоторых (точнее, достаточно значительных) знаний сетевых протоколов, поскольку в конфигурации необходимо задавать множество критериев, которые сильно зависят от ситуации и от используемых сервисов.</para>
         <para>Пример 1: простейшая конфигурация iptables для домашнего компьютера, подключенного к Internet. В этой конфигурации мы запретим все входящие соединения, а также все исходящие пакеты UDP кроме тех, которые необходимы для нормальной работы в Internet с использованием PPP-соединения. В этой конфигурации мы разрешаем передачу всех пакетов в рамках локальной машины, разрешаем исходящие TCP-пакеты, разрешаем входящие пакеты TCP для уже установленных соединений, и разрешаем передачу и прием UDP-пакетов для службы DNS и пакетов автоматической конфигурации соединения PPP (пакетов DHCP). Кроме того, следует разрешить прием управляющих пакетов ICMP и отправку запросов и прием ответов PING:</para>
         <screen><prompt>#</prompt> <userinput>iptables -P INPUT DROP</userinput>
<prompt>#</prompt> <userinput>iptables -A INPUT -j ACCEPT -i lo</userinput>
<prompt>#</prompt> <userinput>iptables -A INPUT -j ACCEP -p tcp ! --syn</userinput>
<prompt>#</prompt> <userinput>iptables -A INPUT -j ACCEPT -p udp --source-port 53</userinput>
<prompt>#</prompt> <userinput>iptables -A INPUT -j ACCEPT -p udp --source-port 67 --destination-port 68</userinput>
<prompt>#</prompt> <userinput>iptables -A INPUT -j ACCEPT -p icmp --icmp-type destination-unreachable</userinput>
<prompt>#</prompt> <userinput>iptables -A INPUT -j ACCEPT -p icmp --icmp-type time-exceeded</userinput>
<prompt>#</prompt> <userinput>iptables -A INPUT -j ACCEPT -p icmp --icmp-type parameter-problem</userinput>
<prompt>#</prompt> <userinput>iptables -A INPUT -j ACCEPT -p icmp --icmp-type echo-reply</userinput>
<prompt>#</prompt> <userinput>iptables -P OUTPUT DROP</userinput>
<prompt>#</prompt> <userinput>iptables -A OUTPUT -j ACCEPT -p tcp</userinput>
<prompt>#</prompt> <userinput>iptables -A OUTPUT -j ACCEPT -p udp --destination-port 53</userinput>
<prompt>#</prompt> <userinput>iptables -A OUTPUT -j ACCEPT -p udp --destination-port 67 --source-port 68</userinput>
<prompt>#</prompt> <userinput>iptables -A OUTPUT -j ACCEPT -p icmp --icmp-type echo-request</userinput></screen>
         <para>Пример 2: то же самое, что в примере 1, но все “отбитые” пакеты протоколируются. Для того, чтобы добиться такого эффекта, нужно создать дополнительную цепочку, которая будет протоколировать и удалять пакеты. Эту цепочку мы назовем KILLER – вполне обоснованно, не так ли? Кроме того, мы исправим политики стандартных цепочек так, чтобы запрещенные пакеты не удалялись, а “забрасывались” в созданную нами цепочку KILLER, а нашей основной цели (сначала протоколировать, потом удалить пакет) можно добиться просто указав два действия – сначала LOG, затем DROP. Поскольку действие LOG не является прерывающим обработку, мы получим требуемый нам эффект:</para>
         <screen><prompt>#</prompt> <userinput>iptables -N KILLER</userinput>
<prompt>#</prompt> <userinput>iptables -A KILLER -j LOG</userinput>
<prompt>#</prompt> <userinput>iptables -A KILLER -j DROP</userinput>
<prompt>#</prompt> <userinput>iptables -P INPUT KILLER</userinput>
<prompt>#</prompt> <userinput>iptables -A INPUT -j ACCEPT -i lo</userinput>
<prompt>#</prompt> <userinput>iptables -A INPUT -j ACCEP -p tcp ! --syn</userinput>
<prompt>#</prompt> <userinput>iptables -A INPUT -j ACCEPT -p udp --source-port 53</userinput>
<prompt>#</prompt> <userinput>iptables -A INPUT -j ACCEPT -p udp --source-port 67 --destination-port 68</userinput>
<prompt>#</prompt> <userinput>iptables -A INPUT -j ACCEPT -p icmp --icmp-type destination-unreachable</userinput>
<prompt>#</prompt> <userinput>iptables -A INPUT -j ACCEPT -p icmp --icmp-type time-exceeded</userinput>
<prompt>#</prompt> <userinput>iptables -A INPUT -j ACCEPT -p icmp --icmp-type parameter-problem</userinput>
<prompt>#</prompt> <userinput>iptables -A INPUT -j ACCEPT -p icmp --icmp-type echo-reply</userinput>
<prompt>#</prompt> <userinput>iptables -P OUTPUT KILLER</userinput>
<prompt>#</prompt> <userinput>iptables -A OUTPUT -j ACCEPT -p tcp</userinput>
<prompt>#</prompt> <userinput>iptables -A OUTPUT -j ACCEPT -p udp --destination-port 53</userinput>
<prompt>#</prompt> <userinput>iptables -A OUTPUT -j ACCEPT -p udp --destination-port 67 --source-port 68</userinput>
<prompt>#</prompt> <userinput>iptables -A OUTPUT -j ACCEPT -p icmp --icmp-type echo-request</userinput></screen>
         <para>Пример 3: маскарад пакетов. Маскарадом называют преобразование IP-адресов проходящих пакетов так, чтобы они выглядели как отправленные с системы-маршрутизатора, а не с какого-либо узла “за” маршрутизатором. Достигается это путем изменения IP-адреса (и, возможно, номера порта) в “транзитных” пакетах. Собственно преобразование задается путем указания действий SNAT – замена адреса отправителя, DNAT – замена адреса получателя, или MASQUERADE – функционально аналогично SNAT, но без указания конкретного IP-адреса (IP-адресом для замены назначается IP-адрес интерфейса через который уходит пакет, со всеми отсюда вытекающими – например, если интерфейс меняет IP-адрес или просто деактивируется все «маскированные» через него соединения сбрасываются). Предположим, что наш “внешний” интерфейс имеет адрес 193.267.14.6, а внутренняя сеть имеет адрес 192.168.0.0/24. Тогда для того, чтобы дать всем компьютерам нашей сети доступ по протоколу TCP “наружу”, мы должны подать примерно
            следующую команду:</para>
         <screen><prompt>#</prompt> <userinput>iptables -A POSTROUTING -t nat -j SNAT -o ppp0 \
&gt;   --to-source 193.267.14.6 -p tcp \
&gt;   --source 192.168.0.0/24 \
&gt;   --destination ! 192.168.0.0/24</userinput></screen>
         <para>Если у нас внешний адрес динамический, а не статический (мы работаем по dialup-соединению), то мы можем использовать динамический маскарад без привязки к внешнему адресу – ну или с использованием динамической привязки, кому как больше нравится:</para>
         <screen><prompt>#</prompt> <userinput>iptables -A POSTROUTING -t nat -j MASQUERADE -o ppp0 \
&gt;   --source 192.168.0.0/24 \
&gt;   --destination ! 192.168.0.0/24</userinput></screen>
         <para>Действие SNAT более эффективно, MASQUERADE проще в использовании, но обладает рядом существенных недостатков (не вдаваясь в подробности, просто заметим, что на системе с несколькими интерфейсами и сложной таблицей маршрутизации проблемы почти наверняка будут). Особое внимание нужно обратить на указание <parameter>-o ppp0</parameter>, то есть действие применяется ТОЛЬКО для пакетов, отправляемых через интерфейс ppp0. Еще вы можете увидеть, что мы указываем это правило только один раз, и обратного к нему правила не строим – об этом позаботится функция connection tracking (отслеживание состояния соединений), и обратная замена адресов в отправляемых в ответ на наши запросы пакетах будет произведена системой автоматически.</para>
         <para>Пример 4: “проброс” пакетов во внутреннюю сеть. Обычно это используется, если мы хотим перебросить пакеты, пришедшие на адрес маршрутизатора, на какую-либо из машин внутренней сети (например, так можно предоставить доступ ко внутреннему WWW-серверу). Достигается это использованием действия DNAT (destination NAT). В нашем случае мы перебрасываем все TCP-пакеты, пришедшие на интерфейс маршрутизатора ppp0 на порт 80, на порт 85 компьютера с адресом 192.168.0.6:</para>
         <screen><prompt>#</prompt> <userinput>iptables -A PREROUTING -t nat -j DNAT -i ppp0 \
&gt;   --to-destination 192.168.0.6:85 -p tcp --destination-ports 80</userinput></screen>
         <para>Конечно, приведенными примерами возможности iptables не исчерпываются, скорее даже наоборот – это лишь малая часть того, что умеет эта подсистема. Приведенные же примеры демонстрируют наиболее простые случаи, позволяющие составить некоторое представление об iptables и возможностях этой технологии.</para>
         <para>В системах, основанных на RedHat Linux и его вариациях, есть специальный стартовый сценарий загрузки, также называемый iptables. Расположен он как правило в каталоге /etc/rc.d/init.d/. Этот сценарий при загрузке системы инсталлирует правила, созданные администратором, и его можно использовать для сохранения конфигурации iptables. В процессе конфигурации системный администратор задает конфигурацию подсистемы iptables, используя утилиту <filename>/sbin/iptables</filename>, а после окончания настройки дает команду /etc/rc.d/init.d/iptables save, после чего текущая конфигурация сохраняется в файл <filename>/etc/sysconfig/iptables</filename>. Существует также множество “фронтендов” для настройки iptables, которые могут использоваться начинающими пользователями и не слишком опытными администраторами, но “ручной” способ настройки все-таки предпочтительней, поскольку позволяет очень точно настроить подсистему iptables.</para>
      </section>
   </section>
   <section>
      <title>Управление пользователями, NSS и PAM</title>
      <para>Linux – система многопользовательская. По умолчанию, большинство дистрибутивов используют «классический» набор файлов в которых хранится информация о пользователях и группах: <filename>/etc/passwd</filename>, <filename>/etc/group</filename>, <filename>/etc/shadow</filename>, <filename>/etc/gshadow</filename>. Во многих ситуациях этого вполне достаточно, но иногда возникает необходимость в интеграции Linux в более или менее чужеродное, либо просто распределенное окружение, и именно в этот момент к нам на помощь приходят такая интересная подсистема, как NSS – Name Service Switch. Основная задача NSS – создать модульное окружение для управления пользователями. Реализовано это посредством загружаемых библиотек. Основные вызовы NSS реализованы в библиотеке libc, а libc в свою очередь загружает и вызывает бакэнды NSS:</para>
      <mediaobject>
         <imageobject>
            <imagedata fileref="images/Gentoo_doc-1.5_html_6affefb5.gif" align="center" format="GIF" width="90%"/>
         </imageobject>
      </mediaobject>
      <para>При инициализации программы, так или иначе связанной с NSS, загружаются основная библиотека <filename>libc.so</filename>, которая считывает конфигурацию из файла <filename>/etc/nsswitch.conf</filename>, после чего также загружаются те библиотеки NSS, которые указаны в этом файле.</para>
      <para>Впоследствии при работе программы, если программе требуется работать с именованными сущностями, соответствующие вызовы функций glibc будут обращаться к функциям NSS и использовать в те источники данных, которые указаны в <filename>nsswitch.conf</filename>.</para>
      <para>В частности, через NSS можно разрешать (определять) имена и идентификаторы протоколов, номера портов служб (сервисов), имена и идентификаторы пользователей и групп, IP-адреса и имена компьютеров и некоторые другие данные.</para>
      <para>Пример файла <filename>nsswitch.conf</filename>:</para>
      <screen><prompt>$</prompt> <userinput>cat /etc/nsswitch.conf</userinput>
passwd:     files ldap
shadow:     files ldap
group:      files ldap
hosts:      files dns 
bootparams: nisplus [NOTFOUND=return] files 
ethers:     files 
netmasks:   files 
networks:   files 
protocols:  files 
rpc:        files 
services:   files 
netgroup:   nisplus 
publickey:  nisplus 
automount:  files nisplus 
aliases:    files nisplus</screen>
      <para>В данном примере указано, что для определения имен пользователей и групп используются сначала текстовые файлы и затем LDAP, для определения имен компьютеров и IP-адресов используются сначала текстовые файлы и затем DNS, для определения алиасов и настроек автоматического монтирования каталогов используются сначала текстовые файлы и затем служба NIS+.</para>
      <para>Библиотеки бакэндов системы NSS хранятся в файлах <filename>libnss_<replaceable>XXX</replaceable>.so</filename>, где XXX – это имя бакэнда. Например <filename>libnss_files.so</filename> – это бакэнд NSS использующий в качестве источника данных текстовые файлы, <filename>libnss_db.so</filename> – бакэнд использующий файлы BerkleyDB, <filename>libnss_ldap.so</filename> – бакэнд позволяющий хранить данные в каталоге LDAP. Как правило, каждый бакэнд имеет свои дополнительные конфигурационные файлы.</para>
      <para>Как следствие, если у вас возникла необходимость использовать вашу Linux-систему в сетевом или чужеродном окружении и обеспечить ее интеграцию с ним, вы можете воспользоваться NSS и получить доступ к информации через соответствующий бакэнд – например, для интеграции в среду Solaris, вы можете воспользоваться бакэндом NIS/NIS+, для интеграции в ActiveDirectory – бакэндом LDAP.</para>
      <para>При этом модульность NSS позволяет вам объединять различные источники данных – например, использовать текстовые файлы и DNS для определения имен компьютеров, NIS для определения имен протоколов и сервисов, и текстовые файлы и LDAP для определения имен и идентификаторов пользователей и групп.</para>
      <para>Подсистема PAM (Pluggable Authentification Modules) идейно очень схожа с NSS, но отличается от нее назначением. Основная задачам PAM – аутентификация пользователей (проверка паролей, прав доступ, ограничений и так далее). Как и NSS, PAM состоит из набора основных библиотек и бакэндов, причем необходимые бакэнды, порядок их вызова и некоторые опциональные параметры определяются в конфигурационных файлах PAM, обычно они расположены в каталоге <filename>/etc/pam.d</filename>. Главным отличием PAM от NSS (кроме естественно назначения) является то, что PAM является не составной и неотъемлемой частью libc, а отдельным множеством библиотек.</para>
      <para>Основная часть стандартных утилит UNIX для управления пользователями и группами и получения информации о них, в большинстве дистрибутивов Linux общего назначения, адаптирована и собрана с поддержкой NSS и PAM. К таким утилитам относятся <command>passwd</command>, <command>chsh</command>, <command>chfn</command>, <command>id</command>, <command>who</command> и другие. NSS также используется даже такими утилитами как <command>ls</command>, <command>find</command>, <command>ps</command> – то есть всеми теми программами, которые отображают имя пользователя. Соответственно, если программа запрашивает у пользователя пароль – скорее всего она использует и NSS, и PAM (например XDM или GDM). Большинство программ в чьи функции входит обработка почты также используют NSS. Соответственно, можно уверенно говорить что подсистемы NSS и PAM и базовые знания об их предназначении на сегодняшний день являются необходимыми для администратора Linux-систем.</para>
   </section>
   <section>
      <title>X11 и все-все-все</title>
      <para>Большинство нынешних дистрибутивов по умолчанию устанавливают для пользователя графическую среду X11 (X11 Windows System), под управлением которой и выполняются все графические приложения. Как «внутри» устроена X11? Прежде всего, X11 – это распределенная модульная среда, состоящая из двух основных компонентов: X-сервера и X-клиента.</para>
      <section>
         <title>Клиент-серверная архитектура X11</title>
         <para>X-сервер – это программа, которая организует работу с устройствами ввода/вывода, производит отрисовку видимых элементов, запущена у пользователя и предоставляет свои ресурсы (те же самые устройства ввода-вывода) для X-клиентов. X-сервер загружает драйверы устройств (например видеокарты, мыши или клавиатуры), он же управляет переключением раскладок клавиатуры и т.п. Кроме того, X-сервер частично берет на себя функции работы со шрифтами. Задача использования аппаратного ускорения для отрисовки также является прерогативой X-сервера.</para>
         <para>В современных дистрибутивах как правило используется открытый свободно распространяемый X-сервер называющийся Xorg. Его конфигурационный файл называется xorg.conf и расположен в каталоге <filename>/etc/X11</filename>. В конфигурационном файле описываются все устройства ввода, которые будет использовать X-сервер, настройки клавиатуры, драйвер видеокарты и многое другое. Более подробную информацию можно получить из справочного руководства (<command>man Xorg</command>, <command>man xorg.conf</command>).</para>
         <para>X-клиент – это собственно пользовательская программа – браузер, почтовый клиент, видеоплеер, клиент мгновенных сообщений, игры, графические редакторы и просмотрщики и т.д.</para>
         <para>Когда пользователь запускает графическое приложение, оно соединяется с X-сервером по стандартному протоколу X11, получает от X-сервера события о перемещении мыши, нажатиях кнопок клавиатуры и соответственно на них реагирует. Когда необходимо провести отрисовку, X-клиент отправляет соответствующие инструкции X-серверу, и уже X-сервер производит непосредственную отрисовку используя драйвер видеокарты. Команды протокола X11 могут передаваться как через разделяемую память или локальное соединение (если X-клиент и X-сервер запущены на одном компьютере), так и по сети – при этом X-клиент и X-сервер могут быть запущены на разных компьютерах.</para>
         <para>X-сервер никаким образом не отвечает за внешний вид окна X-клиента – он отрисовывает все в точности так, как это указал клиент, более того – сам по себе X-сервер он не отрисовывает ни обрамлений окон, ни каких либо управляющих элементов, не обрабатывает никаких горячих клавиш – то есть он занимается только отрисовкой картинки присланной X-клиентом, а также чтением данных из устройств ввода и передачей соответствующих событий X-клиенту.</para>
         <para>Обрамление окон, иконки рабочего стола, панели и кнопки – это все отрисовывается X-клиентами. Рассмотрим пример окна некоторого приложения (в нашем случае файлового менеджера Nautilus из состава среды GNOME):</para>
         <para>
            <!-- FIXME!! отсутсвует картинка!!! -->
         </para>
         <para>На этой картинке на самом деле показан результат работы двух X-клиентов: собственно файлового менеджера nautilus (именно он управляет отрисовкой меню, строки статуса, панелей, иконок и так далее). Второй X-клиент – менеджер окон (window manager) под названием metacity нарисовал рамку окна и кнопки на этой рамке. При этом горячие клавиши для закрытия окна, сворачивания, перемещения и других операций с окном отрабатывает именно metacity, а горячие клавиши копирования файла, перехода по каталогам, навигации по меню, подсвечивание иконок и тому подобное отрабатывает уже сам nautilus.</para>
      </section>
      <section>
         <title>Графическая среда пользователя</title>
         <para>Графической средой мы будем называть набор программ, для пользователя для выполнения им повседневных функций. Каждая из этих программ как правило является самостоятельным X-клиентом и может работать сама по себе, даже без своих «коллег по окружению», но будучи собранными вместе, они начинают предоставлять пользователю цельный и органичный интерфейс. Достигается это обычно следующим образом:</para>
         <orderedlist>
            <listitem>
               <para>Все программы данного графического окружения используют одну и ту же библиотеку для отрисовки своих элементов управления</para>
            </listitem>
            <listitem>
               <para>В графическое окружение включается какой-либо менеджер окон</para>
            </listitem>
            <listitem>
               <para>Все программы для данного окружения разрабатываются с соблюдением определенных общих требований</para>
            </listitem>
            <listitem>
               <para>В состав окружение включаются самостоятельные программы для выполнения базовых функций – текстовые и табличные процессоры, графический редактор, браузер, IM-клиент и другие</para>
            </listitem>
            <listitem>
               <para>В состав окружения включаются служебные программы, предоставляющие пользователю возможность вызова других программ – например, приложение которое отрисовывает панель, на которой размещается кнопка для вызова меню со списком установленных программ и список окон</para>
            </listitem>
            <listitem>
               <para>В состав окружения включают утилиты для настройки оборудования и дополнительных функций</para>
            </listitem>
         </orderedlist>
         <para>В результате внешний вид окружения становится единообразным, а тот факт что оно состоит из множества небольших программ делает графическую среду гибкой в настройке и стабильной в работе. В то же время обширный набор программ для различных функций делает повзволяет графическому окружению удовлетворить большинство потребностей пользователя, а привычная вам картина GNOME или KDE, которую вы видите на экране в процессе работы, является результатом совместной работы множества X-клиентов соответствующего окружения... Или нескольких окружений одновременно.</para>
         <para>Наиболее распространенные графические среды в Linux – это GNOME и KDE. И та и другая среда имеют свою библиотеку для отрисовки элементов управления внутри окна (для GNOME это GTK, для KDE это Qt), включают в свой состав почтовый клиент, браузер, мультимедиа-проигрыватель, клиент мгновенных сообщений и графический редактор, файловый менеджер (он же по совместительству отрисовывает иконки на рабочем стол и отвечает за фон рабочего стола), программу которая отрисовывает боковые панели и набор маленьких программ-апплетов, которые встраиваются при необходимости в панели, игры, программы управления для настройки окружения и менеджер окон.</para>
         <para>Некоторые X-клиенты не входят в состав какого-либо окружения – например, браузеры Firefox и Opera, медиапроигрыватель Mplayer, офисный пакет OpenOffice.Org. Самое главное что следует запомнить – что графическое окружение, или графическая среда – это всего лишь набор программ, а не одна большая программа вида «все-в-одном», и вы можете, работая в основном в одном окружении, абсолютно спокойно использовать программы другого.</para>
      </section>
      <section>
         <title>Внутри X11. Упрощенная схема</title>
         <para>X11 – система многослойная, но внутренне логичная и понятная. Схематически ее можно изобразить следующим образом:</para>
         <mediaobject>
            <imageobject>
               <imagedata fileref="images/Gentoo_doc-1.5_html_58a8057c.gif" align="center" format="GIF" width="90%"/>
            </imageobject>
         </mediaobject>
         <para>Когда приложение отрисовывает что-либо, оно обращается к своей базовой библиотеке, она в свою очередь переадресовывает вызов (или уже цепочку вызовов) в библиотеку libX11, которая использую X11 Core Protocol передает команды на X-сервер. X-сервер интерпретирует команды и передает их на отрисовку драйверам устройств вывода. Воздействие же пользователя на устройства ввода считываются X-сервером через драйвера устройств ввода, через X11 Core Protocol передаются X-клиенту, libX11 переводит команды протокола в события и передает события в тулкит, и уже тулкит передает события программе для того чтобы та на них отреагировала.</para>
         <para>То как приложение выглядит – то есть внешний  вид строк ввода, полос скроллинга, панелей и кнопок – за все это отвечает библиотека-тулкит (toolkit). Два наиболее распространенных на сегодняшний день тулкита, Qt и GTK, примерно равны по возможностям – они обеспечивают достаточную переносимость приложений (есть реализации GTK и Qt для основных платформ), поддержку «тем» внешнего вида, предоставляют программисту объектно-ориентированный интерфейс и некоторый набор служебных функций и возможностей.</para>
         <para>Базовая библиотека X11 (libX11, или Xlib) позволяет программе абстрагироваться и «не связываться» с низкоуровневыми функциями протокола X11, и таким образом обеспечивает сетевую прозрачность X11, то есть позволяет программам работать как с локальным X-сервером, так и с запущеным на другом компьютере, причем делается это незаметно для программы.</para>
      </section>
      <section>
         <title>Внутри X11. Растровые шрифты и их отображение</title>
         <para>С момента разработки в среде X11 отображение шрифтов управлял X-сервер. Приложение, когда ему необходимо вывести некоторый текст, просто инструктировало X-сервер «отобрази вот этот текст вот таким шрифтом в указанном месте». В ответ на это X-сервер выбирал из своей базы шрифтов наиболее подходящий, и использовал его для выполнения инструкций клиента, причем изначально эти шрифты были растровыми, то есть фактически содержали наборы заранее отрисованых глифов (символов).</para>
         <para>Эта технология, называемая X Core Fonts, поддерживается в X11 и сейчас, поэтому в наборе пакетов любого дистрибутива всегда можно встретить наборы широко распространенных семейств растровых шрифтов – fixed, hevetica, times, courier. При этом каждый шрифт представляется множеством файлов, для различных сочетаний размера, ширины и начертания – например, если шрифт имеет десять вариантов размеров (от 8 до 18), две ширины (обычный и жирный) и два начертания (стандартное и курсив), то он будет представляться 40 файлами – по одному файлу для каждого из сочетаний размера, начертания и ширины.</para>
         <para>Поскольку количество файлов получается очень большим, чтобы не устанавливать все эти шрифты на все компьютеры где запущены X-серверы, в систему X11 был введен такой объект как сервер шрифтов (font server). Системный администратор может настроить и запустить один сервер шрифтов для всей локальной сети, и указать X-серверу при запуске использовать шрифты с соответствующего сервера, что позволяет поддерживать на всех серверах один и тот же набор шрифтов с минимальными усилиями и избежать ситуации когда шрифт есть на одном компьютере, но его нет на другом.</para>
         <para>В большинстве дистрибутивов Linux сервер шрифтов включен в поставку X11 по умолчанию, и называется xfs. Его конфигурационный файл как правило находится в каталоге <filename>/etc/X11/fs</filename>. В конфигурационном файле сервера шрифтов перечисляются каталоги с растровыми шрифтами, а в конфигурационном файле X-сервера указано, что основным источником шрифтов является сервер шрифтов,запущеный на этом же компьютере.</para>
         <para>В новейшей версии проекта Xorg сервер шрифтов уже считается «устаревшей» технологией и по умолчанию не используется (хотя и входит в поставку). При необходимости его (сервер шрифтов) можно запустить и использовать.</para>
         <para>Методика наличия предопределенных растеризованых глифов в шрифте позволяла добиться достаточно качественного отображения шрифта в большинстве случаев, но в то же время такие эта методика имеет определенные недостатки – как известно, растровые шрифты очень плохо «вращаются» на угол не кратный 90 градусам, и плохо масштабируются, а с появлением устройств высокой четкости (LCD-мониторов) возникла необходимость еще и отрисовывать шрифты в «сглаженном» виде, с мягкими переходами цвета, чего растровые шрифты также предоставить не могли.</para>
         <para>Наиболее распространенное приложение, использующее методику X Core Fonts – это графический эмулятор терминала xterm, который есть в составе всех дистрибутивов, или простейший менеджер графического входа в систему XDM.</para>
      </section>
      <section>
         <title>Внутри X11. FreeType и XFT</title>
         <para>Для устранения этого недостатка растровых шрифтов была разработана специальные библиотеки XFT и FreeType, которые обеспечивают отображение векторных шрифтов и реализацию таких возможностей как сглаживание шрифтов, их поворот на произвольный угол и хинтинг (подгонку символов шрифта друг к другу оптимальным для данного шрифта способом). Поскольку данная методика плохо согласовывалась с уже сложившейся шрифтовой архитектурой X11, отображение векторных шрифтов было возложено на X-клиента.</para>
         <para>При этом схема отображения шрифта меняется: X-клиент не передает на X-сервер запрос на вывод текста указанным шрифтом, а самостоятельно отрисовывает необходимы глифы шрифта использую функции FreeType и XFT, и передает на X-сервер уже сформированную картинку, которую X-сервер и отображает. Вполне логично, что при использовании этой методики X-клиент должен иметь доступ к оригиналу векторного шрифта (обычно это файл) – поэтому современные дистрибутивы также содержат еще и наборы векторных шрифтов PostScript и TrueType.</para>
         <para>Новые версии тулкитов GTK и QT используют именно эту методику, но поскольку существуют еще и устаревшие тулкиты, такие как Motif или Xview (OpenLook) и значительное количество приложений на них основанных, да и с точки зрения необходимой полосы пропускания сети технология поддержки растровых шрифтов имеет явное преимущество пред XFT и FreeType, поддержка технологии растровых шрифтов по-прежнему входит в X11 и будет оставаться в ней еще долго.</para>
      </section>
      <section>
         <title>Внутри X11. Расширения</title>
         <para>Протокол X11 не является замершим в своем развитии, но его развития ведется не путем изменения самого протокола, а путем внесения в протокол расширений – то есть дополнительных опциональных наборов команд и инструкций. Например, для поддержки непрямоугольных окон было введено расширение XShape, для поддержки проигрывания видеороликов введено расширение XVideo, для поддержки OpenGL было введено расширение GLX и так далее.</para>
      </section>
      <section>
         <title>Внутри X11. Полезные утилиты</title>
         <para>В штатную поставку X11 входит множество полезных программ, позволяющих получать служебную информацию об ваших настройках среды X11. Перечислим некоторые из них:</para>
         <para><command>xterm</command> – эмулятор терминала</para>
         <para><command>xfontsel</command> – интерактивный просмотр растровых шрифтов</para>
         <para><command>xdpyinfo</command> – вывод информации о ваших настройках среды X11 и задействованных расширениях</para>
         <para><command>xwininfo</command> – просмотр информации об указанном окне (положение, размер, класс окна и т.п.)</para>
         <para><command>xwd</command> – моментальный «снимок» окна</para>
         <para><command>xwud</command> – показ результатов работы xwd</para>
         <para><command>xhost</command> – управление контролем доступа X-клиентов к X-серверу</para>
      </section>
      <section>
         <title>Внутри X11. Менеджер окон</title>
         <para>Существует особая разновидность X-клиентов, называемых менеджерами окон. Их основная функция – обеспечивать управление другими окнами – перемещением, изменением размеров, сворачиванием и разворачиванием окон, отрисовкой обрамлений окон, управление передачей фокуса от окна к окну а также управление Z-порядком размещения окон. Соответственно, в один момент времени для одного экрана может быть использован только один менеджер окон.</para>
         <para>GNOME и KDE имеют свои собственные менеджеры окон – это metacity и kwin. Менеджеры окон являются взаимозаменяемыми – то есть вы можете выбрать и использовать тот из них, который вам больше нравится или кажется более удобным. Еще один распространенный (то есть наличествующий почти на всех UNIX-системах) менеджер окон – это twm. Крайне простой и примитивный, он тем не менее предоставляет пользователю базовые функции управления окнами и доступ к меню приложений.</para>
         <para>Не следует путать или отождествлять графическую среду и менеджер окон – в большинстве графических сред для Linux менеджер окон является заменяемым по желании пользователя компонентом, в отличие от Windows или MacOS, в которых менеджер окон фактически монолитно склеен с остальными частями графической подсистемы.</para>
      </section>
      <section>
         <title>Внутри X11. Composite, XGL и Compiz</title>
         <para>Современные версии X-сервера Xorg поддерживают специфическое расширение, называемое Composite. Вкратце его назначение описывается следующим образом: в процессе прорисовки вывода X-клиента, X-сервер рисует не непосредственно в видеопамять (то есть не на экран), а в промежуточный внеэкранный буфер (off-screen buffer), а специализированная программа, называемая Composite manager, подключается к этому буферу, при необходимости изменяет изображение и выводит в видеопамять уже измененное изображение. Такая технология позволяет получить эффекты прозрачности, искажения, плавного «всплытия» окон и многие другие без внесения каких-либо изменений в код X-клиентов или X-сервера. С другой стороны, преобразования изображений лучше реализовывать с использованием аппаратного ускорения, предоставляемого видеокартой.</para>
         <para>XGL – это одновременно X-сервер и X-клиент. Как и обыкновенный X-сервер, XGL позволяет подключаться к себе X-клиентам, отсылает им события от устройств ввода и принимает от них команды отрисовки, отрисовку же принятых команд XGL производит с помощью OpenGL. Кроме того, как X-сервер XGL реализует поддержку расширения Composite. Как следствие, пользователь получает следующий «слоеный пирог»: внутри реального X-сервера, от которого требуется только поддержка OpenGL, запускается XGL. Все остальные программы Window manager, Composite manager и обычные X-клиенты подключаются к XGL. Поскольку назвать «элегантной» такую многоуровневую конструкцию нельзя, функции XGL были перенесены в основной X-сервер, а в интерфейс драйверов видеокарт была заложена возможность поддержки расширения Composite.</para>
         <para>Наиболее развитые на данные момент драйверы имеют видеокарты NVidia, ATI и Intel. Драйверы видеокарт Intel пишутся сообществом разработчиков Xorg, по открытым фирмой-производителем спецификациям, и поэтому поддерживают Composite и аппаратное ускорение прорисовки трехмерной и двумерной графики, поэтому владельцы этих карт могут использовать Composite manager и расширение Composite в сочетании с поддержкой OpenGL. Спецификации на видеокарты фирм ATI и NVidia закрыты (недоступны разработчикам Xorg), и поэтому открытые драйвера отличаются усеченной функциональностью и слабой поддержкой аппаратного ускорения. Закрытые («проприетарные») драйверы видеокарт NVidia, предоставляемые производителем, обеспечивают поддержку аппаратного ускорения при выводе двумерной и трехмерной графики и предоставляют поддержку Composite. Драйверы для новейших видеокарт ATI следует признать крайне некачественными – в настоящий момент далеко не во всех версиях этих драйверов возможно одновременно
            задействовать аппаратную поддержку OpenGL и поддержку Composite.</para>
         <para>Поддержка функции <function>GLX_texture_from_pixmap</function> была реализована в проприетарных драйверах видеокарт ATI версии 8.42, но эти драйвера этой и более новой версий поддерживают не весь спектр видеокарт производства этой фирмы.</para>
         <para>Compiz – это Composite manager, которые в процессе работы использует библиотеки OpenGL и аппаратное ускорение, предоставляемое видеоадаптером. Сопоставляя вышесказанное о драйверах для различных видеокарт, можно сделать вывод что владельцы видеокарт NVidia и Intel могут использовать восзможности и эффекты, реализованные в Compiz, без сколь-нибудь трудностей, а владельцам видеокарт ATI не поддерживаемых новыми версиями драйверов, если они хотят использовать Compiz, необходимо прибегнуть в многоуровневой архитектуре с XGL.</para>
      </section>
   </section>
   <section>
      <title>Локализация</title>
      <para>Широкое распространение UNIX-систем привело к необходимости введения системы локализации – поддержки предпочитаемых пользователем стандартов на запись даты и времени, формата чисел, языка сообщения программ, обозначений национальной валюты и так далее.</para>
      <para>В Linux стандартом на методику локализации является спецификация i18n. Не вдаваясь в подробности, мы попытаемся получить некоторое представление о том как это выглядит для пользователя.</para>
      <para>Как конечные пользователи, мы можем ознакомиться с текущими настройками своей локали используя команду <command>locale</command>:</para>
      <screen><prompt>$</prompt> <userinput>locale</userinput> 
LANG=ru_RU.UTF-8 
LC_CTYPE="ru_RU.UTF-8" 
LC_NUMERIC="ru_RU.UTF-8" 
LC_TIME="ru_RU.UTF-8" 
LC_COLLATE="ru_RU.UTF-8" 
LC_MONETARY="ru_RU.UTF-8" 
LC_MESSAGES=en_US 
LC_PAPER="ru_RU.UTF-8" 
LC_NAME="ru_RU.UTF-8" 
LC_ADDRESS="ru_RU.UTF-8" 
LC_TELEPHONE="ru_RU.UTF-8" 
LC_MEASUREMENT="ru_RU.UTF-8" 
LC_IDENTIFICATION="ru_RU.UTF-8"</screen>
      <para>На самом деле, программа <command>locale</command> в корректно настроенной системе просто выведет вам значение соответствующих переменных окружения. Каждая из этих переменных отвечает за свой собственный аспект локализации, перечислим наиболее важные:</para>
      <para><envar>LANG</envar> – локаль по умолчанию, ее значение для различных аспектов может быть перекрыто путем установки отдельных переменных в нужное вам значение</para>
      <para><envar>LC_CTYPE</envar> – отвечает за классификацию символов и различия в их регистре</para>
      <para><envar>LC_NUMERIC</envar> – отвечает за представление и форматирование чисел</para>
      <para><envar>LC_TIME</envar> – отвечает за формат даты</para>
      <para><envar>LC_COLLATE</envar> – определяет настройки сравнения строк и символов, влияет на сортировку</para>
      <para><envar>LC_MONETARY</envar> – отвечает за представление национальной валюты</para>
      <para><envar>LC_MESSAGES</envar> – определяет язык сообщений и интерфейса</para>
      <para>В примере мы видим что локалью по умолчанию через переменную <envar>LANG</envar> выбрана локаль ru_RU.UTF-8 (русский язык, соответствие российским стандартам, кодировка символов UTF-8), а в качестве языка интерфейса назначен английский язык в варианте используемом в США. Фактически это означает что все программы будут иметь английский интерфейс, но показывать дату, валюту, десятичную точку и сортировать строки они должны так как это принято в России.</para>
      <para>В отличие от мира Windows, где язык сообщений программы как правило жестко забит в ресурсах, а ресурсы включены в исполняемый файл, в UNIX и Linux сообщения как правило содержатся в отдельных файлах и программа загружает текстовые строки для сообщений интерфейса основываясь на значениях переменных <envar>LANG</envar> и <envar>LC_MESSAGES</envar>. Это дает возможность обеспечить работу пользователей из разных стран на привычных им языках, не прибегая к установке нескольких копий операционной системы или нескольких экземпляров программы, каждый для своего языка.</para>
      <para>Системному администратору Linux достаточно обеспечить наличие файлов сообщений нужной локали для используемых пользователем программ, и правильно установить переменные окружения, после чего пользователь оказывается в привычной для него языковой обстановке и работать с привычными форматами даты, валюты, в привычных единицах измерения и т.д.</para>
      <para>Более того – можно установить значение некоторых переменных окружения в нужные значения непосредственно перед запуском программы – и тогда эта программа примет будет использовать указанные настройки локали только для этого запуска, например:</para>
      <screen><prompt>$</prompt> <userinput>LC_MESSAGES=ru_RU.UTF-8 ls -l something</userinput> 
ls: невозможно получить доступ к something: Нет такого файла или каталога 
<prompt>$</prompt> <userinput>LC_MESSAGES=en_US.UTF-8 ls -l something</userinput> 
ls: cannot access something: No such file or directory 
<prompt>$</prompt> <userinput>LC_MESSAGES=fr_CA.UTF-8 ls -l something</userinput> 
ls: ne peut accéder something: Aucun fichier ou répertoire de ce type</screen>
      <para>Таким образом, в Linux-системе возможно обеспечить одновременную работу пользоваетелей в разных языковых окружениях, изменяя только изменение значений переменных окружения. В системах RedHat/Fedora общесистемные настройки локали хранятся в файле <filename>/etc/sysconfig/i18n</filename>, а пользователь может самостоятельно перекрыть их путем записи соответствующих значений в файле <filename>~/.i18n</filename>:</para>
      <screen><prompt>$</prompt> <userinput>cat /etc/sysconfig/i18n</userinput>
LANG="ru_RU.UTF-8" 
SYSFONT="latarcyrheb-sun16" 
<prompt>$</prompt> <userinput>cat /homed/viking/.i18n</userinput>
LC_MESSAGES="en_US"</screen>
      <para>В данном примере системная локаль ru_RU.UTF-8, но пользователь viking предпочитает работать в англоязычном интерфейсе, что и записал в своем персональном файле настроек локали.</para>
   </section>
   <section>
      <title>Менеджер пакетов и зависимости</title>
      <para>Современные дистрибутивы Linux (да и все представили семейства операционных систем UNIX) — это модульные системы. Они состоят из множества программ, которые взаимодействуют между собой. Разделяемые библиотеки, в свою очередь, используются множеством программ. Данная идеология означает, что один некоторые компоненты системы не могут работать без наличия других компонентов — например, программам графической среды GNOME требуются библиотеки тулкита GTK, компонентам KDE нужна библиотека Qt и так далее.</para>
      <para>Менеджер пакетов — это приложение, которое поддерживает базу данных установленных программных пакетов и их зависимостей, что позволяет сохранить работоспособность системы в процессе установки, удаления или обновления программ и библиотек.</para>
      <para>Файл программного пакета, устанавливаемый пакетным менеджером, состоит из двух условных частей — архива с бинарными файлами программ и спецификации пакета, в которой перечислены зависимости пакета и предоставляемые им библиотеки и инетрфейсы. Соответственно, когда пользователь пытается установить пакет, пакетный менеджер читает оглавление (спецификацию) пакета, и если какая-либо из зависимостей не удовлетворена —  например, в системе отсутствует разделяемая библиотека нужной версии, которую используют программы и библиотеки из устанавливаемого пакета, то пакетный менеджер выдаст соответствующее сообщение  и откажется устанавливать пакет, что в принципе верно, поскольку программы из этого пакета все равно не смогут работать корректно пока зависимость не будет удовлетворена.</para>
      <para>При удалении или обновлении пакета пакетный менеджер проверит по базе установленных пакетов не нарушатся ли зависимости при соответствующем действии, то есть если в результате удаления или обновления пакета будет удалена или кардинально изменена версия используемой каким-либо приложением библиотеки или программы, пакетный менеджер не станет выполнять удаление или обновление и выдаст сообщение об ошибке.</para>
      <para>Система зависимостей не всегда «прозрачна» и понятна пользователю, поэтому для решения этой проблемы была выработана концепция репозитория — базы данных собранных для данного дистрибутива пакетов. В этой базе перечисляются доступные в репозитории пакеты и их оглавления. Клиентские программы загружают эту базу и с ее помощью определяют какие пакеты кроме указанных пользователем должны быть установлены или обновлены для удовлетворения зависимостей.</para>
      <section>
         <title>Менеджер пакетов RPM</title>
         <para>В большинстве инсталляций современных популярных дистрибутивов Linux в качестве менеджера пакетов используется разработка фирмы RedHat, программа <command>rpm</command>. Ее главными возможностями являются установка, обновление и удаление пакетов с соблюдением зависимостей, верификация пакетов и предоставление информации о пакетах и файлах, входящих в состав пакетов. Для своей работы rpm использует собственную базу данных, расположенную обычно в каталоге <filename>/var/db/rpm</filename>. Более подробную информацию можно узнать в справочной системе, воспользовавшись командой man rpm.</para>
         <para>Нет особого смысла в том, чтобы рассказывать о базовом функционале rpm, поскольку он подробно описан в документации, и просто кратко пробежимся по ним, и более подробно рассмотрим лишь некоторые редко используемые, но часто необходимые его возможности:</para>
         <screen><prompt>#</prompt> <userinput>rpm -i zisofs-tools-1.0.8-2.fc8.i386.rpm</userinput>
<prompt>#</prompt> <userinput>rpm -U zisofs-tools-1.0.8-2.fc8.i386.rpm</userinput>
<prompt>#</prompt> <userinput>rpm -F zisofs-tools-1.0.8-2.fc8.i386.rpm</userinput>
<prompt>#</prompt> <userinput>rpm -e zisofs-tools</userinput></screen>
         <para>Данные вызовы иллюстрируют примеры установки, обновления или удаления пакета. Следует помнить, что при установке или обновлении пакета надо указывать имя файла, а при удалении пакета — только имя пакета. Устанавливать и удалять можно и по несколько пакетов сразу, при этом достаточно перечислить в командной строке несколько файлов или пакетов.</para>
         <para>Ключ <option>-i</option> означает установку пакета.</para>
         <para>Ключ <option>-U</option> означает установки или обновление пакета, то есть если в системе уже установлен этот же пакет, но более старой версии, то будет выполнено обновление. Если пакет не был установлен — то он будет установлен.</para>
         <para>Ключ <option>-F</option> означает обновление пакета. Если в системе установлен пакет более старой версии, то будет произведено обновление. Если пакет не был установлен, то никаких действий производиться не будет.</para>
         <para>Ключ <option>-e</option> означает удаление пакета. Пакет может быть удален только в том случае, когда он и все файлы, входящие в его состав, не используется никаким другим из установленных пакетов. Если же это условие нарушен, то пользователь получит примерно такое сообщение:</para>
         <para>В качестве имени файла можно также использовать и ссылку:</para>
         <screen><prompt>#</prompt> <userinput>rpm -U ftp://localhost/fedora/zisofs-tools-1.0.8-2.fc8.i386.rpm</userinput></screen>
      </section>
      <section>
         <title>Конфликты зависимостей</title>
         <para>Рассмотрим пример следующей команды:</para>
         <screen><prompt>#</prompt> <userinput>rpm -e exiv2-libs</userinput> 
error: Failed dependencies: 
  libexiv2.so.0 is needed by (installed) libkexiv2-0.1.6-1.fc8.i386 
  libexiv2.so.0 is needed by (installed) exiv2-0.15-5.fc8.i386 
  exiv2-libs = 0.15-5.fc8 is needed by (installed) exiv2-0.15-5.fc8.i386</screen>
         <para>В данном случае мы попытались удалить пакет, который используется другими пакетами, и rpm в после проверки отказался удалять пакет exiv2-libs. Аналогичное сообщение можно увидеть, если устанавливать пакет, для работы которого нужен какой-либо другой пакет, не установленный в системе.</para>
         <para>Чтобы деинсталировать пакет, в нашем примере, есть два пути: деинсталировать его принудительно, или деинсталировать также те пакеты, которые ссылаются на пакет exiv2-libs:</para>
         <screen><prompt>#</prompt> <userinput>rpm -e exiv2-libs exiv2 libkexiv2</userinput> 
error: Failed dependencies: 
   libkexiv2.so.3 is needed by (installed) digikam-0.9.2-5.fc8.i386 
   libkexiv2.so.3 is needed by (installed) kipi-plugins-0.1.4-4.fc8.i386 
<prompt>#</prompt> <userinput>rpm -e exiv2-libs exiv2 libkexiv2 digikam kipi-plugins</userinput></screen>
         <para>В данном примере было произведено удаление пакета exiv2-libs и тех пакетов, от которых он зависит, причем удалось это только со второй попытки. Аналогичная ситуация возникает и в случае установки пакета:</para>
         <screen><prompt>#</prompt> <userinput>rpm -i exiv2-0.15-5.fc8.i386.rpm</userinput> 
error: Failed dependencies: 
        exiv2-libs = 0.15-5.fc8 is needed by exiv2-0.15-5.fc8.i386 
        libexiv2.so.0 is needed by exiv2-0.15-5.fc8.i386 
<prompt>#</prompt> <userinput>rpm -i exiv2-0.15-5.fc8.i386.rpm exiv2-libs-0.15-5.fc8.i386.rpm</userinput></screen>
         <para>В этом примере при попытке установить пакет exiv2 утилита <command>rpm</command> сообщила, что ей нужен пакет exiv2-libs, и со второй попытки была произведена удачная установка пакета exiv2 и пакета exiv2-libs, нужного для его работы. Иногда встречаются ситуации, когда два пакета ссылаются друг на друга. Решается эта проблема аналогично — при вызове rpm достаточно просто указать одновременно оба пакета.</para>
      </section>
      <section>
         <title>Дополнительные возможности rpm</title>
         <para>Первой такой возможностью является возможность верификации пакета. Если вызвать команду <command>rpm</command> с ключом <option>-V</option>, то она проверит все файлы указанного пакета, и сообщит о том, какие файлы были изменены с момента установки пакета. Эта возможность очень удобна для того, чтобы проверять целостность системы после сбоя, или для того, чтобы выяснить какие файлы необходимо сохранить перед выполнением обновления пакета или системы:</para>
         <screen><prompt>#</prompt> <userinput>rpm -V httpd</userinput>
S.5....T c /etc/httpd/conf/httpd.conf</screen>
         <para>Данный пример иллюстрирует проверку пакета httpd. В выводе команды rpm сообщается, что на компьютере где была вызвана эта команда изменялся только один файл из состава пакета httpd, и этот файл отличается от исходной версии по трем критериям — размеру (S), контрольной сумме (5) и времени модификации (T). Соответственно, при миграции или обновлении сервера следует сохранить резервную копию этого файла.</para>
         <para>Еще одной полезной возможностью является возможность узнать, какой пакет нуждается в некотором файле или библиотеке. Эта информация может использоваться для того, чтобы предсказать, на какие программы или библиотеки повлияет обновление или удаление пакета или файла:</para>
         <screen><prompt>#</prompt> <userinput>rpm -q --whatrequires grep</userinput> 
tcsh-6.14-15 
MAKEDEV-3.23-1.2 
sysreport-1.4.3-10 
krb5-libs-1.6.2-9.fc8 
sgml-common-0.6.3-21.fc8 
mysql-5.0.45-4.fc8 
xml-common-0.6.3-21.fc8 
docbook-dtds-1.0-32.fc8 
nfs-utils-1.1.0-6.fc8 
autoconf-2.61-9.fc8 
mkinitrd-6.0.19-4.fc8 
zsh-4.3.4-4.fc8 
zsh-4.3.4-4.fc8 
microcode_ctl-1.17-1.38.fc8 
prelink-0.4.0-1 
irda-utils-0.9.18-3.fc8 
krb5-workstation-1.6.2-9.fc8 
logwatch-7.3.6-9.fc8 
hal-0.5.10-1.fc8 
rpm-build-4.4.2.2-7.fc8 
autofs-5.0.2-20 
bind-chroot-9.5.0-20.b1.fc8</screen>
      </section>
   </section>
</article>
