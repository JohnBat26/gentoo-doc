<!-- text cutted to splited xml files -->
<article>
<sect1><title>Linux не для идиотов: сборник рассказов и рецептов</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://myfotomx.com/dalth/linuxbook.odt">http://myfotomx.com/dalth/linuxbook.odt</ulink>
</para>
<para>Автор: Артем Капитула (no-dashi, dalth &amp; viking).</para>
<para>Скачано с <ulink url="http://myfotomx.com/dalth">http://myfotomx.com/dalth</ulink>: 15.07.07</para>
<para>C версии: 1.1</para><sect2><title>Предисловие</title>
<para>Я много лет работал с Linux, и, общаясь со многими единомышленниками, сделал один странный вывод: нам катастрофически не хватает документации. Причем не инструкций вида «сделайте так и вот так» и не справочных руководств, а некоторого «мостика» между новичком, который видел только графическую оболочку подобную GNOME или KDE, и профессионалом, который может скомпилировать необходимый ему драйвер, даже если этот драйвер упорно сопротивляется.</para>
<para>Соответственно, я попытался сделать попытку написать книжку (хотя на книгу этот материал не тянет, скорей на методичку), которая позволила бы сравнительно просто перейти с пользовательского уровня знакомства с Linux на более высокий уровень, не проходя по типичным ошибкам, и за сравнительно короткое время.</para>
<para>Некоторое время я использовал фрагменты этой книги также как часть учебного курса в Челябинском Государственном университете (ЧелГУ) для того, чтобы мои студенты могли ориентироваться в системе несколько лучше, чем на уровне команд ls/ps/exit. Конечно, если честно – как учебное пособие эта маленькая книга непригодна, но, как мне кажется, она неплохо подходит как дополнительная литература.</para>
<para>Если у вас есть пожелания и дополнения – пишите мне почтой на <ulink url="mailto:dalt74@gmail.com?subject=По%20поводу:%20%22Линукс%20не%20для%20идиотов%22%20">dalt74@gmail.com,</ulink> я постараюсь учесть ваши замечания в следующей редакции. Большое спасибо всем тем кто участвовал в рецензировании и помогал советами и замечаниями.</para>
<para/>
<para>Искренне ваш, Артем Капитула (no-dashi, dalth &amp; viking)</para>
<para/>
<para>P.S. если вы будете распечатывать или выкладывать это пособие – пожалуйста, указывайте ссылку на автора и оригинальный источник, договорились?</para>
<para/>
<para>P.P.S. пока что есть следующий to-do list: основы DNS, базовые настройки серверов и рабочих станций под типичные нужды. Ориентировочный срок следующей редакции – через три месяца.</para></sect2><sect2><title>Ядро и модули</title>
<para>Ядро Linux является единственным процессом, имеющим непосредственный доступ к аппаратуре – все остальные процессы обращаются к устройствам только через ядро. В ядре Linux можно выделить несколько важных подсистем: подсистему управления памятью; планировщик задач; подсистему VFS – виртуальную файловую систему и драйверы.</para>
<para>Подсистема управления памятью управляет распределением оперативной памяти между задачами, а также обслуживает файл подкачки, планировщик задач управляет разделением процессорного времени между задачами (процессами и нитями), подсистема VFS предназначена для обслуживания файловых операций.</para>
<para>Драйверы предназначены для управления устройствами и поддержки различных протоколов. Существует две разновидности драйверов – статически подключенные в ядро драйверы и загружаемые модули; первые всегда загружены, вторые могут быть загружены при необходимости и выгружены, когда необходимость в них отпала. Каждый модуль и само ядро содержат сигнатуру версии – специальную метку, которая описывает версию ядра и некоторые опции, использованные при компиляции ядра. Кроме того, ядра версии 2.6 могут поддерживать цифровую подпись модулей. Это было сделано для повышения надежности системы – по умолчанию ядро не будет загружать и использовать драйверы, предназначенные для другой версии ядра, или собранные с другими опциями, поскольку это может привести к возникновению проблем. Версию ядра можно узнать с помощью команды uname:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[dalth@inferno dalth]$ uname -r</para>
<para>2.6.8.1</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>В принципе, утилиты для работы с модулями поддерживают возможность загрузки модулей, собранных для другого ядра – но пользоваться этой возможностью следует с крайней осторожностью, поскольку это может привести к непредсказуемым последствиями – от ошибок ядра (kernel panic) и вплоть до странных потерь данных и непонятных ошибок, взявшихся на пустом месте.</para>
<para>В большинстве дистрибутивов образ ядра располагается в каталоге /boot, а загружаемые модули ядра располагаются в /lib/modules/&lt;версия_ядра&gt;, там же располагается таблица зависимостей модулей, поскольку некоторые модули могут нуждаться для своей работы в других модулях (например, драйвер поддержки SCSI-дисков нуждается в драйвере поддержки SCSI – как следствие этого, если объекты какого-либо модуля используются другим драйвером, такой модуль невозможно выгрузить). Следующий листинг демонстрирует достаточно типичное содержание каталога модулей для ядер линейки 2.6:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@viking dev]# ls -l /lib/modules/2.6.8.1/</para>
<para>total 616</para>
<para>lrwxrwxrwx   1 root root     18 Авг 27 15:36 build -&gt; /usr/src/linux</para>
<para>drwxr-xr-x  10 root root   4096 Окт  1 13:55 kernel</para>
<para>-rw-r--r--   1 root root 108680 Окт  1 13:56 modules.alias</para>
<para>-rw-r--r--   1 root root     69 Окт  1 13:56 modules.ccwmap</para>
<para>-rw-r--r--   1 root root 153967 Окт  1 13:56 modules.dep</para>
<para>-rw-r--r--   1 root root     73 Окт  1 13:56 modules.ieee1394map</para>
<para>-rw-r--r--   1 root root    357 Окт  1 13:56 modules.inputmap</para>
<para>-rw-r--r--   1 root root  16658 Окт  1 13:56 modules.isapnpmap</para>
<para>http://www.eclipse.org/downloads/download.php?file=/eclipse/downloads/drops/R-3.3.1.1-200710231652/eclipse-SDK-3.3.1.1-linux-gtk-x86_64.tar.gz&amp;url=http://ftp-stud.fht-esslingen.de/pub/Mirrors/eclipse/eclipse/downloads/drops/R-3.3.1.1-200710231652/eclipse-SDK-3.3.1.1-linux-gtk-x86_64.tar.gz&amp;mirror_id=17-rw-r--r--   1 root root  85093 Окт  1 13:56 modules.pcimap</para>
<para>-rw-r--r--   1 root root  68078 Окт  1 13:56 modules.symbols</para>
<para>-rw-r--r--   1 root root 150781 Окт  1 13:56 modules.usbmap</para>
<para>lrwxrwxrwx   1 root root     18 Окт  1 13:22 source -&gt; /usr/src/linux</para>
<para>[root@viking dev]# find /lib/modules/2.6.8.1/kernel -type f | head -20</para>
<para>/lib/modules/2.6.8.1/kernel/arch/i386/kernel/cpuid.ko</para>
<para>/lib/modules/2.6.8.1/kernel/arch/i386/kernel/microcode.ko</para>
<para>/lib/modules/2.6.8.1/kernel/arch/i386/kernel/msr.ko</para>
<para>/lib/modules/2.6.8.1/kernel/crypto/blowfish.ko</para>
<para>/lib/modules/2.6.8.1/kernel/crypto/deflate.ko</para>
<para>/lib/modules/2.6.8.1/kernel/crypto/md5.ko</para>
<para>/lib/modules/2.6.8.1/kernel/crypto/twofish.ko</para>
<para>/lib/modules/2.6.8.1/kernel/drivers/acpi/fan.ko</para>
<para>/lib/modules/2.6.8.1/kernel/drivers/acpi/processor.ko</para>
<para>/lib/modules/2.6.8.1/kernel/drivers/acpi/thermal.ko</para>
<para>/lib/modules/2.6.8.1/kernel/drivers/base/firmware_class.ko</para>
<para>/lib/modules/2.6.8.1/kernel/drivers/block/cryptoloop.ko</para>
<para>/lib/modules/2.6.8.1/kernel/drivers/block/loop.ko</para>
<para>/lib/modules/2.6.8.1/kernel/drivers/block/nbd.ko</para>
<para>/lib/modules/2.6.8.1/kernel/drivers/block/paride/epat.ko</para>
<para>/lib/modules/2.6.8.1/kernel/drivers/block/paride/paride.ko</para>
<para>/lib/modules/2.6.8.1/kernel/drivers/block/paride/pd.ko</para>
<para>/lib/modules/2.6.8.1/kernel/drivers/block/paride/pg.ko</para>
<para>/lib/modules/2.6.8.1/kernel/drivers/bluetooth/bcm203x.ko</para>
<para>/lib/modules/2.6.8.1/kernel/drivers/bluetooth/bfusb.ko</para>
<para>[root@viking dev]# </para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Бинарные файлы модулей содержатся в подкаталоге kernel, и имеют расширение “.o” для ядер линейки 2.4 и расширение “.ko” для ядер линейки 2.6. В файлах modules.***map перечисляются символы (функции и переменные), экспортируемые модулями.</para>
<para>Часто в одном каталоге с модулями содержатся ссылки на каталоги, в которых хранились исходные тексты ядра и в котором производилась сборка ядра (это ссылки source и build, соответственно). Эти ссылки, как правило, используются для того, чтобы скомпилировать модули или программы, которые зависят от версии ядра (например, эти ссылки используются при инсталляции модуля поддержки видеокарт nvidia).</para>
<para>Учет взаимосвязей между загруженными модулями производится с помощью счетчика ссылок – модуль увеличивает свой счетчик ссылок как только какой-либо его объект начинает использоваться другими драйверами. Когда объекты модуля освобождаются, счетчик ссылок уменьшается. Модуль может быть выгружен, если число ссылок на него станет равно 0. В ядрах версии 2.6 существует возможность произвести принудительную выгрузку модуля даже если он используется, но этим пользоваться без крайней необходимости не рекомендуется, поскольку очень возможно возникновение ошибок.</para>
<para>Ядро содержит множество переменных и функций, которые используются различными драйверами, и соответственно, если какой-либо драйвер должен обратиться к такому объекту, он должен знать его адрес. Некоторые драйверы также содержат переменные и функции, которые должны быть доступны другим драйверам, и адреса таких объектов тоже размещаются в специальной таблице. При загрузке модуля ядро и программа загрузки модулей устанавливает адреса всех объектов, в которых нуждается загружаемый модуль, и только после этого модуль может начать инициализацию.</para>
<para>Загрузка модулей и их выгрузка осуществляются утилитами modprobe, insmod и rmmod. Программы modinfo и depmod предназначены для получения служебной информации о загружаемых модулях. В процессе своей работы эти утилиты опираются на конфигурационные файлы /etc/modprobe.conf (для ядер 2.6.X) или modules.conf (для ядер 2.4.X).</para></sect2><sect2><title>Загрузка операционной системы</title>
<para>Для компьютеров архитектуры x86 последовательность загрузки хорошо описана в специализированной литературе, но мы все-таки кратко ее повторим. После включения компьютера первым загружается BIOS. Он тестирует аппаратуру и инициализирует устройства. После этого BIOS прочитывает начальный сектор загрузочного жесткого диска (MBR), убеждается что он содержит код первичного загрузчика, и передает управление прочитанному коду. Кроме кода первичного загрузчика, начальный сектор также может содержать таблицу разделов жесткого диска.</para>
<para>В задачи первичного загрузчика входит чтение основного кода загрузчика операционной системы и передача управления ему, после чего основная часть загрузчика может считать конфигурационный файл, загрузить ядро операционной системы, установить параметры для ядра и передать ядру управление. Ядро инициализирует драйверы, проверяет параметры и, опираясь на параметры, пытается смонтировать корневую файловую систему, после чего (если не было проинструктировано об ином) запускает программу /sbin/init. Дальнейшая работа init подробно описана во множестве книг и статей.</para>
<para>В настоящий момент в мире Linux наиболее распространен загрузчик GRUB. Этот загрузчик состоит из нескольких частей – первичного загрузчика, собственно основного кода который организует интерфейс пользователя, и набора мини-драйверов различных файловых систем, позволяющих прочесть необходимые файлы с файловой системы в момент когда операционная система еще недоступна. Каждая из этих компонент работает на одном из двух этапов загрузки. Рассмотрим эти этапы:</para>
<para>Этап 0 – здесь срабатывает первичный загрузчик GRUB. Он компактен и умещается в один блок жесткого диска, что позволяет при желании разместить его в MBR. В задачи кода stage_0 входит прочтение кода необходимого на следующем этапе (собственно кода загрузчика и мини-драйвера файловой системы где расположены основные файлы загрузчика), и передача управления прочитанному коду.</para>
<para>Этап 1 – это на этом этапе первичным загрузчиком в память уже загружен основной код загрузчика, а также мини-драйвер файловой системы, на которой расположены конфигурационные файлы загрузчика, ядро и необходимые драйверы. Основной код, используя функции мини-драйвера, прочитывает конфигурационный файл и организует диалог с пользователем. В зависимости от выбора пользователя, используя мини-драйвер файловой системы, с диска прочитываются файлы ядра и необходимых драйверов, после чего управление передается ядру. Как вариант, пользователь может отказаться от загрузки Linux и инструктировать GRUB прочесть загрузочный сектор некоторого раздела жесткого диска и передать управление ему.</para>
<para>Первичный загрузчик из состава GRUB может быть расположен как в MBR, так и в загрузочном секторе какого-либо раздела жесткого диска – или даже храниться в файле и быть вызван из другого загрузчика (например NTLOADER).</para>
<para>Нередко случаются ситуации, когда корневая файловая система располагается на устройстве, чей драйвер скомпилирован в виде модуля, или драйвер корневой файловой системы скомпилирован в виде модуля. Получается замкнутый круг – чтобы смонтировать корневую файловую систему систему, необходимо прочесть драйвер, а чтобы прочесть драйвер – нужно смонтировать корневую файловую систему. Чтобы разорвать этот порочный круг, в Linux была введен поддержка initrd – INITial RamDisk.</para>
<para>Initial ramdisk – это файл, который прочитывается загрузчиком ОС и загружается в память вместе с ядром. Ядро интерпретирует фрагмент памяти, куда загружен этот файл, как блочное устройство с помощью специального драйвера, статически вкомпилированного в ядро. После инициализации статически скомпилированных драйверов ядро монтирует файловую систему, хранящуюся в initrd и загружает с нее драйверы и запускает программы, необходимые для монтирования корневой файловой системы.</para>
<para>Обычно файл с образом ядра хранится в каталоге /boot и называется vmlinuz-&lt;версия&gt;, там же располагается файл initrd-&lt;версия&gt;.img, содержащий образ файловой системы initrd. Для каждой версии ядра необходим свой образ initrd, в который включены модули для этой версии ядра. В большинстве случаев образ initrd поставляется в бинарном пакете вместе с ядром, или автоматически создается в процессе построения ядра из исходных текстов в момент выполнения команды make install, если же возникает ситуация, когда необходимо повторно собрать образ initrd (например, в сервере сменили SCSI-контроллер), можно воспользоваться специальной командой mkinitrd, позволяющей произвести повторную генерацию initrd:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@viking dalth]# mkinitrd /tmp/initrd-2.4.8.1.img 2.6.8.1</para>
<para>[root@viking dalth]# cp /tmp/initrd-2.4.8.1.img /boot</para>
<para>[root@viking dalth]# reboot</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Для Linux существует два основных загрузчика – LILO и GRUB. Второй является более поздней разработкой и немного удобней в использовании, а LILO используется по историческим или личным причинам (например, он нравится системному администратору), либо в некоторых случаях, когда требуются специфичные для LILO функции. Для более подробной справки лучше обратиться к справочному руководству (man grub, man lilo).</para>
<para>Из интересных особенностей GRUB и LILO следует отметить то, что и оба этих загрузчика, и ядро оперируют термином корневой файловой системы – но если с точки зрения ядра эта та файловая система, которая содержит программу /sbin/init, то с точки зрения обоих загрузчиков корневой файловой системой является та, которая содержит образ ядра и файл initrd.</para></sect2><sect2><title>Организация памяти</title>
<para>Подсистема виртуальной памяти управляет распределением оперативной памяти между задачами (процессами). Каждая задача считает, что ей выделен непрерывный участок памяти максимального размера, поддерживаемого на соответствующей архитектуре (для архитектуры x86 это 4GB). Из них последний гигабайт резервируется для себя ядром, часть отдается под код программы и разделяемые библиотеки (оба этих фрагмента ядром защищаются), а оставшееся пространство отдается собственно программе под ее данные – но это только то, как видит это все программа.</para>
<para>На самом же деле программа занимает только тот объем памяти, с которым она реально работает. Большинство памяти существует только “на бумаге”, т.е. будет предоставлена программе в тот момент, когда она обратится в эту область. Ядро распределяет память страницами фиксированного размера. Процедура, когда страница оперативной памяти объявляется частью адресного пространства процесса, называется отображением этой страницы в адресное пространство процесса.</para>
<para>Соответственно, ядро отображает реально используемые страницы в виртуальное адресное пространство процесса. Когда процесс обращается к некоторой странице своего адресного пространства, ядро проверяет, имеет ли он право на доступ к этой странице, и если проверка пройдена и доступ получен, то ядро переадресовывает обращение на реальный адрес этой страницы. Если это первое обращение к странице, ядро попытается найти свободную страницу и в случае успеха отобразит ее в адресное пространство соответствующего процесса. Размер страницы фиксирован архитектурой процессора, и для x86 ее размер составляет 4096 байт.</para>
<para>Если случается ситуация, когда свободных страниц больше нет, но существует файл подкачки, ядро может убрать одну из наиболее долго не использовавшихся страниц в файл подкачки, и освободившуюся физическую страницу отдать запросившему память процессу. Если же нет ни незанятого пространства в файле подкачки, ни свободных страниц RAM, то развитие событий может быть следующим: либо запросивший память процесс прерван и “убит” системой, либо какой-то другой из процессов (это определяется специфическими алгоритмами) будет “убит” ядром, и освободившаяся память будет передана запросившему память процессу.</para>
<para>На самом деле большинством действий занимается одна из подсистем процессора, называемая MMU – Memory Management Unit, и в действительности ядро просто полагается на его работу и вмешивается в нее только для проведения операций пейджинга (подгрузки/выгрузки страниц в SWAP-файл), или когда возникает ошибка доступа к странице.</para>
<para>Ограничение адресного пространства в 4GB не означает, что система не сможет адресовать более этого объема памяти. На платформе x86 ядро Linux может использовать до 64GB, а ограничение в 4GB накладывается лишь на размер адресного пространства процесса.</para></sect2><sect2><title>System V shared memory</title>
<para>Linux поддерживает стандартную для всех UNIX-подобных операционных систем организацию разделяемой памяти. Пользовательские приложения могут создавать сегменты разделяемой памяти, которые могут быть присоединены к некоторому фрагменту адресного пространства процесса. Любой процесс, имеющий достаточные права доступа, может присоединиться к сегменту разделяемой памяти, и отобразить его в свое адресное пространство, начиная с некоторого адреса.</para>
<para>
<para>Адресное пространство процесса 1</para>
<para>Адресное пространство процесса 2</para>
<para>SHM - cегмент 1</para>
<para>SHM - cегмент 2</para>
<para/>
<para>Отображение cегмента 1</para>
<para/>
<para>Отображение cегмента 2</para>
<para/>
<para/>
<para>Отображение cегмента 1</para>
<para>Отображение cегмента 2</para>
<para/>
<para/>
<para/>
<para/>
</para>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para>Если в приведенной схеме любой из процессов изменит содержимое памяти в области, занимаемой отображением одного из сегментов, то же самое изменение произойдет в адресном пространстве другого процесса, поскольку соответствующий сегмент существует в одном экземпляре и отображен в адресное пространство обоих процессов.</para>
<para>Кроме System V IPC ядро Linux также поддерживает другие объекты IPC, в частности семафоры и очереди сообщений. Каждый объект System V IPC идентифицируется уникальным ключом. Просмотреть список всех объектов IPC можно командой ipcs. Команда ipcrm позволяет удалять объекты IPC, которые по каким-либо причинам остались не освобожденными после завершения создавшего их процесса – например, такая ситуация может возникнуть после аварийного завершения работы СУБД Oracle, Informix или DB2.</para>
<para>Соответственно, перед перезапуском процесса системный администратор с помощью команды ipcrm должен освободить неиспользуемые объекты IPC, поскольку стартующее приложение не сможет их повторно создать и не будет корректно работать.</para>
<para>Для каждого объекта IPC система устанавливает права доступа, как если бы это был файл (т.е. для каждого объекта IPC можно устанавливать набор прав ugo/rwx, но в отличие от обычных файлов сменить права доступа для IPC-объектов можно только вызывая специализированные функции, предназначенные для работы с такими объектами.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[dalth@viking dalth]$ ipcs</para>
<para/>
<para>------ Shared Memory Segments --------</para>
<para>key        shmid      owner      perms      bytes      nattch     status      </para>
<para>0x00000000 0          oracle    640        4194304    10                      </para>
<para>0x00000000 32769      oracle    640        20971520   10                      </para>
<para>0x00000000 65538      oracle    640        29360128   10                      </para>
<para>0x0d3c24a0 98307      oracle    640        29360128   50                      </para>
<para>0x00000000 13697028   root      777        49152      1                       </para>
<para>0x00000000 13729797   root      777        16384      1                       </para>
<para>0x000004d2 13795334   dalth     666        1008       2                       </para>
<para>0x00000000 14286866   root      644        790528     2          dest         </para>
<para>0x00000000 21823507   dalth     600        393216     2          dest         </para>
<para>0x00000000 21921814   root      644        122880     2          dest         </para>
<para>0x00000000 14516249   root      644        151552     1          dest         </para>
<para/>
<para>------ Semaphore Arrays --------</para>
<para>key        semid      owner      perms      nsems     </para>
<para>0x0b4f657c 262147     oracle    640        154       </para>
<para>0x000004d2 458756     dalth     666        1         </para>
<para/>
<para>------ Message Queues --------</para>
<para>key        msqid      owner      perms      used-bytes   messages    </para>
<para/>
<para>[dalth@viking dalth]$ </para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Поддержка System V IPC позволяет сравнительно легко переносить на Linux приложения, написанные для других UNIX-систем.</para></sect2><sect2><title>Файловая система</title>
<para>VFS и драйверы файловых систем являются одной из важнейших составляющих ядра. Для того, чтобы получить доступ к файлам, хранящимся на каком-либо устройстве хранения данных, необходимо, чтобы в ядро был загружен драйвер соответствующей файловой системы, и файловая система была смонтирована. Драйвера всех файловых систем поддерживают набор стандартных функций: открыть файл по имени, записать данные в файл, прочитать данные из файла, закрыть файл, удалить файл и т.д.</para>
<para>Уточним, что драйвера файловых систем не занимаются кэшированием, этим занимается VFS.</para>
<para>При первоначальной загрузке драйвер файловой системы регистрирует в VFS имя файловой системы и те функции, которые предназначены для выполнения стандартных файловых операций. Впоследствии при обращении к файлу на какой-либо файловой системе VFS будет переадресовывать обращение на соответствующую функцию, если таковая была зарегистрирована драйвером. Посмотреть список обслуживаемых ядром файловых систем можно в файле /proc/filesystems:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[dalth@viking proc]$ cat /proc/filesystems </para>
<para>nodev   sysfs</para>
<para>nodev   rootfs</para>
<para>nodev   bdev</para>
<para>nodev   proc</para>
<para>nodev   sockfs</para>
<para>nodev   usbfs</para>
<para>nodev   usbdevfs</para>
<para>nodev   futexfs</para>
<para>nodev   tmpfs</para>
<para>nodev   pipefs</para>
<para>nodev   eventpollfs</para>
<para>nodev   devpts</para>
<para>        ext2</para>
<para>nodev   ramfs</para>
<para>nodev   hugetlbfs</para>
<para>        iso9660</para>
<para>nodev   devfs</para>
<para>nodev   mqueue</para>
<para>        ext3</para>
<para>nodev   rpc_pipefs</para>
<para>nodev   nfsd</para>
<para>nodev   smbfs</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Операция монтирования предназначена для того, чтобы сделать доступной файловую систему, расположенную на каком-либо блочном устройстве. Суть операции монтирования заключается в том, что ядро ассоциирует некоторый каталог (называемый точкой монтирования) с блочным устройством и драйвером файловой системы. Для этого оно передает ссылку на блочное устройство драйверу файловой системы, и в случае, если драйвер успешно проидентифицировал эту файловую систему, ядро заносит в специальную таблицу монтирования информацию о том, что все файлы и каталоги, чей полный путь начинается с указанной точки монтирования, обслуживаются соответствующим драйвером файловой системы и расположены на указанном блочном устройстве.</para>
<para>Некоторые файловые системы не нуждаются в блочном устройстве, поскольку хранят свои данные исключительно в памяти, например файловая система procfs, через файлы которой можно получить доступ к различным системным параметрам и таблицам.</para>
<para>Очень часто при монтировании файловой системы системный администратор имеет возможность задать опции монтирования. Опции монтирования – это специальные параметры, которые влияют на работу драйвера файловой системы, когда он работает с файловой системой на соответствующем блочном устройстве – например, с помощью опций монтирования можно управлять режимом кэширования данных, преобразованиями имен файлов и данных, включать и отключать поддержку ACL и т.д.</para>
<para>Посмотреть таблицу примонтированных файловых систем можно через файл /proc/mounts:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[dalth@viking proc]$ cat /proc/mounts</para>
<para>rootfs / rootfs rw 0 0</para>
<para>/dev/root / ext3 rw 0 0</para>
<para>none /dev devfs rw 0 0</para>
<para>/proc /proc proc rw,nodiratime 0 0</para>
<para>/sys /sys sysfs rw 0 0</para>
<para>none /dev/pts devpts rw 0 0</para>
<para>usbdevfs /proc/bus/usb usbdevfs rw 0 0</para>
<para>/dev/chimera/var /var ext3 rw 0 0</para>
<para>/dev/chimera/temp /tmp ext3 rw 0 0</para>
<para>/dev/chimera/usr /usr ext3 rw 0 0</para>
<para>/dev/chimera/home /home ext3 rw 0 0</para>
<para>/dev/chimera/opt /opt ext3 rw 0 0</para>
<para>none /dev/shm tmpfs rw 0 0</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Виртуальная файловая система Linux различает несколько типов файлов: каталоги, обычные файлы, именованные каналы, символьные ссылки, сокеты и специальные файлы. Каждая из этих разновидностей обрабатывается своим собственным образом:</para>
<orderedlist>
<listitem>
<para>Обычные файлы могут быть прочитаны, записаны, удалены или отображены в память.</para>
</listitem>
<listitem>
<para>Каталог можно представить как список имен файлов, и для этого списка определены операции добавления элемента в список, удаление элемента из списка, переименование элемента списка.</para>
</listitem>
<listitem>
<para>Именованные каналы являются просто буферами – в него можно записать некоторый объем данных, и прочесть их в том же порядке, в каком они были записаны.</para>
</listitem>
<listitem>
<para>Сокеты являются вариантом именованных каналов, но если у именованного канала буфер только один, то есть нельзя определить какой процесс записал данные в канал, то у сокетов может быть несколько клиентов, один из которых осуществляет управление сокетом и может обмениваться данными с любым из остальных клиентов, а те в свою очередь могут обмениваться данными с диспетчером канала – то есть сокет поддерживает множество независимых буферов, по одному на каждую пару сервер+клиент</para>
</listitem>
<listitem>
<para>Специальные файлы предназначены для того, чтобы осуществлять прямой доступ к устройствам. Подробнее о специальных файлах будет говориться в главе Секреты /dev</para>
</listitem>
<listitem>
<para>Символьные ссылки являются “ярлыками”, которые могут содержать имя другого файла – и тогда операции чтения, записи и открытия/закрытия файла автоматически переадресовываются к файлу, на который указывает символьная ссылка, но в отличие от “ярлыков” Windows (shortcuts), символьные ссылки (symbolic links) не требуют специальных функций при работе – все программы (кроме тех, которые специально предназначены для работы с ними) видят их как обычные файлы, и также их открывают, читают и записывают данные и т.д.</para>
</listitem>
</orderedlist>
<para>В некоторых файловых системах, которые изначально проектировались для UNIX-подобных систем, есть возможность создавать кроме символьных ссылок еще и жесткие ссылки. Фактически, жесткая ссылка – это второе имя для файла. Жесткие ссылки возможно создавать только в пределах одной файловой системы.</para>
<para>Из-за того, что в VFS присутствует понятие кэширования, перед отключением системы необходимо делать обязательный сброс изменений на диск. Сброс кэша на диск осуществляется в момент размонтирования файловой системы. Кроме того, с помощью команды sync можно в любой момент принудительно сбросить на диск все закэшированные изменения в файловой системе (например, системные администраторы часто делают sync перед загрузкой нового драйвера). Размонтировать файловую систему можно только тогда, когда ни один процесс не удерживает в открытом состоянии файлов с этой файловой системы, а также не находится ни один процесс не имеет рабочим каталогом каталога с размонтируемой файловой системы. При невыполнении этого условия размонтировать файловую систему не удастся:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@viking dalth]# umount /home/ftp/pub/linux/fedora/cd1</para>
<para>umount: /home/ftp/pub/linux/fedora/cd1: device is busy</para>
<para>umount: /home/ftp/pub/linux/fedora/cd1: device is busy</para>
<para>[root@viking dalth]# </para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Некоторые файловые системы поддерживают специальные опции, позволяющие принудительно синхронизировать файловую систему при каждой операции чтения или записи. Обычно опции, влияющие на синхронизацию файловой системы, содержат в своем названии слово sync, например приведенная ниже команда инструктирует операционную систему примонтировать некоторый раздел в режиме принудительной синхронизации:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@viking dalth]# mount -t ext3 -o sync,dirsync /dev/hda9 /home</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Следует учесть, что принудительная синхронизация – это удар по производительности операций записи для файловой системы, смонтированной в таком режиме, поэтому использовать такой его следует осторожно.</para></sect2><sect2><title>Права доступа</title>
<para>Кроме стандартных наборов прав доступа к файлам некоторые файловые системы Linux поддерживают т.н. POSIX ACL – списки контроля доступа POSIX. Эта возможность позволяет гибко управлять доступом к файлу, не ограничиваясь “классическим” набором ugo/rwx. Для того, чтобы использовать на файловой системе POSIX ACL, необходимо смонтировать файловую систему с опцией acl:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@inferno root]# mount -t ext3 -o acl /dev/inferno/opt /opt</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Возможно также настроить соответствующий параметр для файловой системы, чтобы она поддерживала POSIX ACL по умолчанию:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@inferno root]# tune2fs -o acl /dev/inferno/opt</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>После установки соответствующей опции можно приступать к работе с POSIX ACL. Для работы с ними существует две базовых утилиты: getfacl для получения списка дополнительных атрибутов доступа, и setfacl для установки расширенных атрибутов контроля доступа. Если в выводе команды ls вы видите символ “+” рядом со списком стандартных прав доступа, это означает, что для файла также установлены расширенные атрибуты контроля доступа:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@inferno root]# ls -l /home/dalth/.bash_???????</para>
<para>-rw-r-----+ 1 dalth dalth 20034 Окт 11 22:48 /home/dalth/.bash_history</para>
<para>-rw-r--r--  1 dalth dalth   191 Авг 23 21:51 /home/dalth/.bash_profile</para>
<para>[root@inferno root]#</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Для просмотра значений расширенных атрибутов можно воспользоваться утилитой getfacl. Жирным шрифтом выделен дополнительный атрибут контроля доступа, позволяющий пользователю kiki получить доступ на чтение к файлу .bash_history:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@inferno dalth]# getfacl .bash_history </para>
<para># file: .bash_history</para>
<para># owner: dalth</para>
<para># group: dalth</para>
<para>user::rw-</para>
<para>user:kiki:r--</para>
<para>group::---</para>
<para>mask::r--</para>
<para>other::---</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Добавим пользователю oracle права на чтение и запись файла .bash_history с помощью команды setfacl, и затем отберем дополнительные права на доступ к указанному файлу у пользователя kiki:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@inferno dalth]# setfacl -m u:oracle:rw .bash_history </para>
<para>[root@inferno dalth]# setfacl -x u:kiki .bash_history </para>
<para>[root@inferno dalth]# getfacl .bash_history </para>
<para># file: .bash_history</para>
<para># owner: dalth</para>
<para># group: dalth</para>
<para>user::rw-</para>
<para>user:oracle:rw-</para>
<para>group::---</para>
<para>mask::rw-</para>
<para>other::---</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Последним шагом сбросим все расширенные атрибуты с файла с файла .bash_history:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@inferno dalth]# setfacl -b .bash_history </para>
<para>[root@inferno dalth]# ls -l .bash_history </para>
<para>-rw-------  1 dalth dalth 20034 Окт 11 22:48 .bash_history</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Расширенные атрибуты позволяют гибко контролировать доступ к файловых объектам, обходя стратегию ugo/rwx пришедшую из “классического UNIX”. Права доступ на файловые объекты могут быть выданы не только пользователю, но и группе.</para>
<para>К сожалению, далеко не все утилиты и файловые системы поддерживают ACL, поэтому при резервном копировании или восстановлении файлов необходимо проверять корректность установки расширенных атрибутов и правильность их переноса.</para></sect2><sect2><title>Журналируемые файловые системы</title>
<para>Для обеспечения сохранности данных и обеспечения целостности файловых систем при неожиданных сбоях были разработаны журналируемые файловые системы. Как правило, у этих файловых систем существует специальная область данных, называемая журналом. Все изменения, которые необходимо произвести с файловой системой, сначала записываются в журнал, и уже из журнала попадают в основную часть файловой системы.</para>
<para>В большинстве случаев журналируются только метаданные файловых систем (служебная информация, обеспечивающая целостность структуры файловой системы – например, изменения в каталогах или служебных таблицах размещения файлов). Некоторые файловые системы позволяют журналировать не только метаданные, но и данные файлов – такой шаг позволяет повысить надежность, но уменьшает скорость записи данных на файловую систему, поскольку каждый блок данных записывается на диск дважды – сначала в журнал, и затем из журнала в основную область файловой системы..</para>
<para>В большинстве случаев, журналируемые файловые системы способны решить проблемы с надежностью при неожиданных сбоях без тех потерь производительности, к которым может привести использование опции sync при монтировании.</para>
<para>В частности, к журналируемым файловым системам, например, относятся EXT3, ReiserFS, XFS, JFS и некоторые другие.</para></sect2><sect2><title>Отображенные в память файлы</title>
<para>Объединение кэширования файлов и разделяемой памяти позволяет реализовать такое действие, как отображение файла в память. Для простоты можно представить, что файл загружается в кэш, и страницы кэша отображаются в адресное пространство процесса, и в результате любое изменение в том фрагменте адресного пространства, которое занято отображением файла, автоматически попадает в закэшированные данные файла. Когда файл закрывается, закэшированные изменения сбрасываются на диск, изменяя сам файл. Кроме того, в свободное время ядро также постепенно сбрасывает изменившиеся кэшированные данные на диск.</para>
<para/>
<para>
<para>Файловая система</para>
<para>Адресное пространство процесса 2</para>
<para>Кэш файла 1</para>
<para>Кэш файла 2</para>
<para/>
<para>Отображение файла 1</para>
<para/>
<para>Отображение файла 2</para>
<para/>
<para/>
<para>Файл 1</para>
<para>Файл 2</para>
<para/>
<para/>
<para/>
<para/>
</para>
<para/>
<para/>
<para/>
<para/>
<para/>
<para>На самом деле, механизм отображения файлов в память куда “хитрее” - при обращении по записи к странице, которая является отображением некоторого файла, ядро перехватывает обращение, производит запись в файл (в подавляющем большинстве случаев эта операция попадает в кэш). При обращении по чтению к такой странице ядро опять же перехватывает обращение и производит чтение из файла – в большинстве случаев это чтение производится из кэша. Для наших же целей проще будет считать, что страницы кэша отображены в память процесса.</para>
<para/>
<para>Такая методика часто используется для загрузки разделяемых библиотек, когда выполняемый код библиотек и исполняемого кода программы хранится в кэше и через отображение файла в память становится виден в адресном пространстве процесса:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[dalth@viking dalth]$ cat /proc/1/maps </para>
<para>08048000-08050000 r-xp 00000000 03:01 75813      /sbin/init</para>
<para>08050000-08051000 rw-p 00008000 03:01 75813      /sbin/init</para>
<para>08051000-08072000 rw-p 08051000 00:00 0 </para>
<para>40015000-40016000 rw-p 40015000 00:00 0 </para>
<para>4c8ee000-4c903000 r-xp 00000000 03:01 92869      /lib/ld-2.3.3.so</para>
<para>4c903000-4c904000 r--p 00014000 03:01 92869      /lib/ld-2.3.3.so</para>
<para>4c904000-4c905000 rw-p 00015000 03:01 92869      /lib/ld-2.3.3.so</para>
<para>4c907000-4ca1c000 r-xp 00000000 03:01 92857      /lib/tls/libc-2.3.3.so</para>
<para>4ca1c000-4ca1e000 r--p 00115000 03:01 92857      /lib/tls/libc-2.3.3.so</para>
<para>4ca1e000-4ca20000 rw-p 00117000 03:01 92857      /lib/tls/libc-2.3.3.so</para>
<para>4ca20000-4ca22000 rw-p 4ca20000 00:00 0 </para>
<para>4d201000-4d20f000 r-xp 00000000 03:01 92965      /lib/libselinux.so.1</para>
<para>4d20f000-4d211000 rw-p 0000d000 03:01 92965      /lib/libselinux.so.1</para>
<para>bfffd000-c0000000 rw-p bfffd000 00:00 0 </para>
<para>ffffe000-fffff000 ---p 00000000 00:00 0 </para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>На самом деле, драйверы любого устройства и любой файловой системы могут по-своему реализовывать операцию mmap, но большинство драйверов файловых систем полагаются в этом на VFS.</para></sect2><sect2><title>Специальные файловые системы</title>
<para>Некоторые типы файловых систем являются специальными и предназначаются для выполнения или реализации специфических задач операционной системы. К таким файловым системам относятся файловые системы procfs и sysfs, предоставляющие доступ к различным параметрам системы и системным объектам, “живущим” в ядре.</para>
<para>Файловая система sysfs в основном предоставляет доступ к объектам ядра и отображает взаимосвязи между ними. Файловая система procfs предоставляет доступ к различным параметрам ядра и драйверов и к пользовательским процессам, позволяя тем самым реализовать такие команды как ps или sysctl. Большинство файлов в sysfs двоичные, в procfs – текстовые.</para>
<para>Драйверы файловых системы ramfs, tmpfs и shmfs очень похожи, и после монтирования файловой системы такого типа на ней можно создавать файлы, хранящиеся в памяти и отличаются в основном небольшими особенностями работы (например, страницы, используемые ramfs под данные файлов, не вытесняются в swap-файл в отличие от shmfs и tmpfs). В ядре 2.6 shmfs была заменена на tmpfs.</para></sect2><sect2><title>Сетевые файловые системы</title>
<para>Сетевые файловые системы предназначены для получения доступа к файловым системам других компьютеров с использованием сетевых протоколов.</para>
<para>Наиболее часто используются сетевые файловые системы NCPFS (для доступа к серверам Novell NetWare), SMBFS (для доступа к серверам Windows) и NFS (для доступа к файловым системам других UNIX-систем).</para>
<para>Как правило, процедура монтирования сетевых файловых систем схожа с процедурой монтирования обычных файловых систем на блочных устройствах с тем отличием, что вместо блочного устройства указывается адрес сервера, чья файловая система монтируется, и имя монтируемого ресурса. Для примера рассмотрим процедуры монтирования ресурсов, доступных по SMB и по NFS:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para># mount -t smbfs -o username=usr,workgroup=tst //server/share_name /mnt/smb_target</para>
<para>Password: ********</para>
<para># mount -t nfs -o timeout=4 server:/export/home /mnt/nfs_target</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>В данном примере опция -t команды mount указывает тип файловой системы, опция -o позволяет задать дополнительные параметры для монтирования – для SMB мы задаем, например, имя пользователя, с правами которого производится подключение к серверу и имя рабочей группы или домена, для NFS мы указываем таймаут, по истечении которого операция ввода/вывода считается неудавшейся. Вместо блочного устройства мы указываем адрес сервера, ресурс которого хотим использовать, и имя ресурса на сервере. Последним параметром идет точка монтирования.</para></sect2><sect2><title>Создание файловых систем</title>
<para>Для создания файловых систем в Linux используется команда mkfs:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@inefrno root]# mkfs -t ext3 /dev/hda6</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>На самом деле, mkfs является просто “оберткой” к реальным программам создания файловых систем, которые обычно именуются как mkfs.&lt;имя_ФС&gt;, например mksf.ext2 или mkfs.reiserfs.</para>
<para>В большинстве случаев программы группы mkfs просто инициализируют специальную область раздела, называемую суперблоком файловой системы. Суперблок содержит ссылки на все значимые элементы файловой системы (например, ссылку на оглавление корневого каталога, ссылку список свободных блоков, ссылку на список файлов и т.д.)</para>
<para>Наличие суперблока (который практически всегда содержит в своем теле некоторое характерное значение) позволяет производить монтирование файловых систем без указания их типа. К сожалению, некоторые файловые системы вследствие своей архитектуры не содержат суперблока (в частности, FAT и большинство ее разновидностей) и для блочных устройств, содержащих такие файловые системы, автоматическое определение типа файловой системы затруднено.</para></sect2><sect2><title>Интерфейс sysctl</title>
<para>Ядро содержит очень много параметров, от которых зависит его производительность и которые могут изменять алгоритмы его работы. Для того, чтобы иметь возможность узнавать и изменять эти параметры, в UNIX был разработан интерфейс sysctl.</para>
<para>Виртуальная файловая система procfs содержит каталог sys с деревом подкаталогов и файлов. Содержимое каждого из этих файлов можно прочесть, например, командой cat, или записать в такой файл новое значение командой echo:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@inferno root]# cat /proc/sys/kernel/shmmax</para>
<para>33554432</para>
<para>[root@inferno root]# echo 67108864 &gt;/proc/sys/kernel/shmmax </para>
<para>[root@inferno root]# cat /proc/sys/kernel/shmmax</para>
<para>67108864</para>
<para>[root@inferno root]#</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Команда sysctl предназначена для того, чтобы избежать необходимости использовать прямой доступ к этим файлам, и предоставить возможность автоматизации установки таких параметров при загрузке системы. На самом же деле, команда sysctl просто читает или записывает значения в файлы из каталога /proc/sys, т.е. если системный администратор устанавливает с помощью команды sysctl значение некоторого параметра, фактически он просто записывает это значение в соответствующий файл. Существует однозначное соответствие между именем параметра и именем файла, через который его можно изменить:  если посмотреть вывод sysctl -a, можно увидеть, что параметры в большинстве своем именуются несколькими мнемоническими аббревиатурами, разделенными точками:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@inferno root]# sysctl -a | grep mem</para>
<para>net.ipv4.tcp_rmem = 4096        87380   174760</para>
<para>net.ipv4.tcp_wmem = 4096        16384   131072</para>
<para>net.ipv4.tcp_mem = 24576        32768   49152</para>
<para>net.ipv4.igmp_max_memberships = 20</para>
<para>net.core.optmem_max = 10240</para>
<para>net.core.rmem_default = 108544</para>
<para>net.core.wmem_default = 108544</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Если в имени параметра заменить точки на символ разделителя пути (символ “/”), и к началу получившейся строки добавить /proc/sys/ - то мы получим имя файла, через который можно изменить или прочесть значение соответствующего параметра.</para>
<para>Если системному администратору необходимо при каждой загрузке изменять некоторые параметры через интерфейс sysctl, то список параметров и их значений можно записать в конфигурационный файл /etc/sysctl.conf, который прочитывается при каждой загрузке системы.</para></sect2><sect2><title>Статически и динамически собранные программы</title>
<para>В Linux исполняемые файлы можно условно поделить на две группы – те, которые содержат в себе весь код, необходимые для работы, и те, которым необходимы разделяемые библиотеки. Первые называют статически собранными бинарными файлами, вторые называют динамически собранными исполняемыми файлами.</para>
<para>Статически собранные программы характеризуются тем, что могут корректно функционировать в любых условиях, и не зависят от наличия или отсутствия разделяемых библиотек, что может оказаться полезным в ситуациях, когда возникают конфликты версий разделяемых библиотек, или когда системные библиотеки повреждены или недоступны (например во время восстановления операционной системы после серьезного сбоя). К недостаткам таких исполняемых файлов следует отнести то, что они имеют значительный размер и для обновления программы необходимо полностью заменить ее исполняемый файл – например, если несколько статически собранных программ, которые работают с архивами ZIP, содержат ошибку, то для исправления ошибки необходимо заменить все эти программы, что может быть затруднено (например, будет трудно точно установить, какие именно программы содержат ошибочный код и нуждаются в обновлении). Кроме того, статически собранные программы не умеют совместно использовать совпадающие участки кода, что ведет к излишнему расходу системных ресурсов.</para>
<para>Динамически собранные исполняемые файлы для корректной работы требуют наличия файлов разделяемых библиотек, и соответственно при их отсутствии/повреждении не могут корректно функционировать, но зато для обновления программы и исправления ошибки часто оказывается достаточным просто заменить соответствующую разделяемую библиотеку, после чего ошибка исчезает во всех программах, которые эту библиотеку используют динамически. Динамически связанные программы также значительно меньше по объему, чем статически связанные, и код разделяемых библиотек может использоваться одновременно многими программами – что позволяет экономить системные ресурсы.</para>
<para>Подавляющее большинство программ в современных дистрибутивах Linux являются динамически собранными. Определить тип исполняемого фала (статический ли он либо с динамическим связыванием) можно, например, с помощью команды ldd:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[dalth@viking dalth]$ ldd /bin/su</para>
<para>        linux-gate.so.1 =&gt;  (0xffffe000)</para>
<para>        libpam.so.0 =&gt; /lib/libpam.so.0 (0x4ce08000)</para>
<para>        libpam_misc.so.0 =&gt; /lib/libpam_misc.so.0 (0x4cb3c000)</para>
<para>        libcrypt.so.1 =&gt; /lib/libcrypt.so.1 (0x4e3a2000)</para>
<para>        libdl.so.2 =&gt; /lib/libdl.so.2 (0x4ca49000)</para>
<para>        libc.so.6 =&gt; /lib/tls/libc.so.6 (0x4c907000)</para>
<para>        /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x4c8ee000)</para>
<para>[dalth@viking dalth]$ ldd /sbin/devlabel </para>
<para>        not a dynamic executable</para>
<para>[dalth@viking dalth]$</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>В данном случае мы видим, что исполняемый файл /bin/su использует динамическое связывание, а исполняемый файл /sbin/devlabel собран статическим образом.</para></sect2><sect2><title>Системная библиотека GNU libc</title>
<para>Основная системная библиотека, которая так или иначе используется практически всеми программами, называется glibc (GNU libc). Основными задачами glibc являются обеспечение взаимодействия между ядром и пользовательскими процессами, поддержка локализации и многие другие распространенные действия.</para>
<para>На нижнем уровне прикладные процессы могут обратиться к функциям ядра посредством системных вызовов (syscall). Фактически syscall – это вызов прерывания 80h  с установленными параметрами, описывающими параметры для этого системного вызова. Те функции glibc, которые должны обратиться к ядру, в большинстве случаев просто устанавливают параметры для соответствующего системного вызова и вызывают int80h.</para>
<para>Большинство программ используют динамически загружаемую библиотеку glibc, но некоторые приложения, которые должны работать вне зависимости от наличия файловой системы, где расположена динамически загружаемая реализация libc, используют статическое связывание, когда весь программный код, необходимый для их работы, содержится в исполняемом файле программы. В основном к таким программам относятся утилиты, используемые при загрузке системы совместно с initrd – например, статические варианты утилит insmod, lvm или devlabel, а также командные оболочки для первичной зарузки или восстановления системы – например sash – standalone shell, часто используемый при восстановлении системы после серьезного сбоя или nash, используемый при выполнении сценариев загрузки после монтирования initrd, но до монтирования корневой файловой системы, когда разделяемая версия glibc еще недоступна.</para></sect2><sect2><title>LD, Shared Library, SO и много страшных слов</title>
<para>Существует набор базовых действий, которые практически любая программа выполняет одинаково – открытие файла, чтение и запись данных и тому подобное. Разделяемые библиотеки предназначены для того, чтобы предоставить прикладным программам готовые интерфейсы функций для выполнения каких-либо более-менее стандартных действий. Разделяемая библиотека, как понятно из названия, может использоваться множеством программ. В настоящий момент стандартным форматом для разделяемых библиотек в Linux является ELF (Executable Linked Format).</para>
<para>Каждый файл ELF имеет заголовок, в котором описывается, какие секции содержит этот файл. Секции объединяют однотипные данные, и их детальное описание можно прочитать в справочном руководстве [man elf]. Мы же выделим следующую информацию: каждая библиотека содержит список имен переменных и функций, которые она содержит и предоставляет другим (экспортирует) и список переменных и функций, которые необходимо взять в других библиотеках, а также секции инициализации и деинициализации. Экспортируемые и импортируемые объекты (переменные и функции) называют символами библиотеки.</para>
<para>Большинство исполняемых файлов программ также имеют формат ELF, и на самом деле отличаются от библиотек в основном тем, что не имеют экспортируемых функций. Загрузчик ELF (он же dl, dynamic linker и dynamic loader) умеет загружать в память код ELF-файла, анализировать его структуру для определения списков экспортируемых и импортируемых символов и загружать необходимые для работы программы библиотеки.</para>
<para>Когда пользователь пытается запустить какую–либо программу, первым начинает работу загрузчик ELF. Он загружает в память процесса бинарный файл и выделяет, какие символы и из каких библиотек необходимо догрузить в память. После дозагрузки каждой библиотеки загрузчик связывает символы (проставляет реальные адреса) из загруженной библиотеки и повторяет цикл анализа на предмет того, какую библиотеку нужно загрузить. Когда все нужные библиотеки загружены, загрузчик передает управление коду инициализации каждой из загруженных библиотек в порядке, обратном загрузке, после чего передает управление коду программы. По завершении программы загрузчик снова “проходится” по всем библиотекам и вызывает их функции деинициализации. Если на этапе загрузки какой – либо библиотеке возникает ошибка, загрузчик сообщит об этом пользователю. Наиболее типичные ошибки dl – это не найденный файл библиотеки или неразрешимый символ (символ не был найден в библиотеке, в которой ожидался).</para>
<para>Вполне естественно, что загрузчик ищет библиотеки не по всей файловой системе, а только в определенных каталогах. Это каталоги /lib, /usr/lib и те, которые были перечислены системным администратором в файле /etc/ld.so.conf. Уточним, что этот файл на самом деле используется только системной утилитой ldconfig, сам же загрузчик использует кэш-файл /etc/ld.so.cache. Обновить этот кэш-файл можно путем простого запуска ldconfig без параметров. Следствием этого является то, что если вы установили в систему новые библиотеки, не мешает вызвать ldconfig.</para>
<para>В некоторых дистрибутивах есть возможность включать в ld.so.conf дополнительные файлы без его изменения. Для этого в ld.so.conf включается специальная строка вида:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>include ld.so.conf.d/*.conf</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Это приводит к тому, что каталоги, перечисленные в файлах с расширением conf, расположенных  в каталоге /etc/ld.so.conf.d будут использованы для поиска разделяемых библиотек:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@viking dalth]# cat /etc/ld.so.conf</para>
<para>include ld.so.conf.d/*.conf</para>
<para>/usr/lib/mysql</para>
<para>/usr/X11R6/lib</para>
<para>/usr/lib/qt-3.3/lib</para>
<para>[root@viking dalth]# ls /etc/ld.so.conf.d/</para>
<para>oracle</para>
<para>[root@viking dalth]# cat /etc/ld.so.conf.d/oracle </para>
<para>/opt/oracle/9i/lib</para>
<para>[root@viking dalth]#</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Нередко возникает ситуация, когда пользователю необходимо запустить какую-либо программу, которая не находится в каталогах, описанных в /etc/ld.so.conf. В таких ситуациях можно воспользоваться специальным “люком”, оставленным разработчиками dl специально для таких случаев: дело в том, что кроме загрузки библиотек с использованием данных из ld.so.cache загрузчик проверяет факт наличия библиотеки с указанным именем в каталогах, перечисленных в переменной среды LD_LIBRARY_PATH.</para>
<para>Разработчики часто используют еще одну возможность ld: если файл некоторой разделяемой библиотеки указан в переменной LD_PRELOAD, эта библиотека принудительно загружается и ее символы считаются более “приоритетными” и перекрывают одноименные символы, если таковые существуют в других библиотеках, загружаемых ld при запуске на выполнение бинарного файла ELF.</para>
<para>Попробуем рассмотреть примеры использования указанных возможностей dl: пусть есть некоторый программный продукт, в состав которого кроме собственно исполняемых программ входят разделяемые библиотеки (например, таковы практически все продукты, разработанные с помощью Borland Kylix). Если мы установим такой пакет, например, в /opt/program, его исполняемые файлы в /opt/program/bin а разделяемые библиотеки в /opt/program/lib, то программа, скорее всего, не будет запускаться, поскольку не сможет загрузить необходимых библиотек. Для того, чтобы программы пакета начали запускаться, мы должны “объяснить” ld где именно искать библиотеки. Рассмотрим возможные способы, которыми мы можем воздействовать на ld чтобы добиться нужного нам результата.</para>
<para>Первый способ – указать каталог с библиотеками перед запуском программы и уже затем запустить программу (ld воспользуется значением переменной для того, чтобы попытаться найти библиотеки по указанному пути):</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>$ export LD_LIBRARY_PATH=/opt/program/lib$ /opt/program/bin/filename</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Второй способ – добавить каталог /opt/program/lib в файл /etc/ld.so.conf и запустить ldconfig, решив проблему с невозможностью нахождения этих библиотек для всех программ сразу:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>$ su -</para>
<para># echo /opt/program/lib &gt;&gt;/etc/ld.so.conf# ldconfig# exit$ /opr/program/bin/filename</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Можно также воспользоваться возможностью принудительной загрузки тех библиотек, которые необходимы программе для запуска:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>$ export LD_PRELOAD=/opt/program/lib/*$ /opr/program/bin/filename</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Большая часть кода разделяемых библиотек находится в кэше и становится доступна процессам через отображение файла в память. Это отображение делается с правами доступа “только чтение”, что защищает код библиотек от переписывания его неправильно работающими или просто злонамеренными программами.</para></sect2><sect2><title>Информация о процессах и файловая систем /proc</title>
<para>Ядро и его подсистемы очень важны, но большинство пользы приносят прикладные задачи, поэтому мониторинг состояния задач (процессов) – очень важная часть работы системного администратора. В Linux получить информацию о процессах можно через файлы и каталоги файловой системы procfs, как правило монтируемой к каталогу /proc.</para>
<para>Каждому процессу сопоставляется в /proc отдельный каталог, имя которого совпадает со значением PID процесса. Файлы в этом каталоге предоставляют информацию о соответствующем процессе. Таблица приводит список файлов и их назначение:</para>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry>
<para>Имя файла</para>
</entry>
<entry>
<para>Формат</para>
</entry>
<entry>
<para>Назначение</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>cmdline</para>
</entry>
<entry>
<para>строка, разделенная символами \0</para>
</entry>
<entry>
<para>Представляет командную строку, которой был запущен процесс. параметры командной строки отделяются друг от друга символами \0</para>
</entry>
</row>
<row>
<entry>
<para>environ</para>
</entry>
<entry>
<para>строка, разделенная символами \0</para>
</entry>
<entry>
<para>Представляет список переменных окружения для указанного процесса</para>
</entry>
</row>
<row>
<entry>
<para>exe</para>
</entry>
<entry>
<para>символьная ссылка</para>
</entry>
<entry>
<para>Ссылается на исполняемый файл процесса</para>
</entry>
</row>
<row>
<entry>
<para>maps</para>
</entry>
<entry>
<para>несколько строк</para>
</entry>
<entry>
<para>Список отображенных в память процесса файлов</para>
</entry>
</row>
<row>
<entry>
<para>mem</para>
</entry>
<entry>
<para>бинарный</para>
</entry>
<entry>
<para>Прямой доступ к адресному пространству процесса</para>
</entry>
</row>
<row>
<entry>
<para>mounts</para>
</entry>
<entry>
<para>несколько строк</para>
</entry>
<entry>
<para>Список примонтированных файловых систем, доступных процессу</para>
</entry>
</row>
<row>
<entry>
<para>stat</para>
</entry>
<entry>
<para>строка числовых значений</para>
</entry>
<entry>
<para>Статистика активности процесса</para>
</entry>
</row>
<row>
<entry>
<para>statm</para>
</entry>
<entry>
<para>строка числовых значений</para>
</entry>
<entry>
<para>Статистика по использованию памяти процессом</para>
</entry>
</row>
<row>
<entry>
<para>cwd</para>
</entry>
<entry>
<para>символьная ссылка</para>
</entry>
<entry>
<para>Ссылается на каталог, который является текущим для процесса</para>
</entry>
</row>
<row>
<entry>
<para>fd/*</para>
</entry>
<entry>
<para>символьные ссылки</para>
</entry>
<entry>
<para>Имена файлов подкаталога fd соответсвуют открытым процессом дескрипторам файлов. Символьные ссылки указывают на соответствующие файлы</para>
</entry>
</row>
<row>
<entry>
<para>root</para>
</entry>
<entry>
<para>символьная ссылка</para>
</entry>
<entry>
<para>Ссылается на каталог, который процесс считает корневым</para>
</entry>
</row>
<row>
<entry>
<para>status</para>
</entry>
<entry>
<para>несколько строк</para>
</entry>
<entry>
<para>Описание состояния процесса</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Все указанные данные полностью соответствуют тому, что показала бы программа ps, будучи запущенной в тот момент, когда просматривается соответствующий файл, поскольку утилита ps на самом деле просто читает данные из соответствующих файлов в /proc.</para></sect2><sect2><title>Создание процессов</title>
<para>Linux на самом деле поддерживает только один внутренний механизм создания процессов – механизм fork+exec. Любой процесс, который хочет создать еще один процесс, должен сначала создать свою копию с помощью системного вызова fork, после чего порожденный процесс, который является полной копией предыдущего за исключением нескольких параметров, таких как PID (Process ID) и PPID (Parent Process ID) использует системный вызов exec для того, чтобы загрузить в свое адресное пространство код новой программы и начать его выполнение. Соответственно, все процессы организуют дерево, когда у каждого процесса есть родительский процесс (исключение составляет процесс init, запущеный ядром на этапе загрузки).</para>
<para>Когда процесс завершается, код его завершения возвращается родительскому процессу. До тех пор, пока код завершения процесса не будет прочитан родительским процессом, запись об этом процессе продолжает существовать в таблице процессов в ядре. Такой процесс (уже завершившийся, но еще числящийся в таблице процессов) называют процессом – зомби (zombie process). Завершить zombie process может родительский процесс, прочтя код его завершения. Если у вас в системе появилось множество зомби – процессов, это скорее всего означает ошибку в программе, породившей этот процесс. Удалить процесс – зомби можно только удалив его родительский процесс.</para>
<para>Нередко бывает, что родительский процесс завершается раньше, чем дочерний, и тогда для дочернего процесса объявляется родительским процесс init, и поэтому в системе никогда не бывает процессов-”сирот”, т.е. тех, кто не имеет родителя и чей код завершения некому прочесть.</para></sect2><sect2><title>Секреты /dev</title>
<para>Ядро Linux реализует поддержку двух типов устройств – символьных и блочных. Основное их отличие в том, что для блочных устройств операции ввода вывода осуществляются не отдельными байтами (символами), а блоками фиксированного размера.</para>
<para>В Linux вся работа с устройствами ведется через специальные файлы, которые обычно расположены в каталоге /dev. Специальные файлы не содержат данных, а просто служат точками, через которые можно обратиться к драйверу соответствующего устройства. У каждого специального файла есть три характеристики – тип устройства (character или block), старший номер устройства (major number) и младший номер (minor number). Для примера, посмотрим на содержимое каталога /dev:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[dalth@viking proc]$ ls -lL /dev/hd* /dev/ttyS*</para>
<para>brw-------  1 root  root  3,  0 Окт  1 20:16 /dev/hda</para>
<para>brw-------  1 root  root  3,  1 Окт  1 20:16 /dev/hda1</para>
<para>brw-------  1 root  root  3,  2 Окт  1 20:16 /dev/hda2</para>
<para>brw-------  1 dalth disk 22,  0 Янв  1  1970 /dev/hdc</para>
<para>crw-------  1 root  root  4, 64 Янв  1  1970 /dev/ttyS0</para>
<para>crw-------  1 root  root  4, 65 Янв  1  1970 /dev/ttyS1</para>
<para>crw-------  1 root  root  4, 66 Янв  1  1970 /dev/ttyS2</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Как видно, в листинге присутствует описание семи устройств, четырех блочных и трех символьных. Для каждого файла можно увидеть его тип (первая буква в списке прав доступа), пользователя-владельца, группу-владельца, major number, minor number, дату модификации и имя файла.</para>
<para>Для поддержки работы с устройствами в ядре хранятся две таблицы, одна для списка символьных устройств, другая для списка блочных устройств. Каждая строка таблицы сопоставлена какой-то разновидности устройств соответствующего типа – например, для типа “символьные устройства” можно выделить следующие разновидности: COM-порты, LPT-порты, PS/2-мыши, USB-мыши и т.д., для типа “блочные устройства” можно выделить SCSI-диски, IDE-диски, SCSI-CD-приводы, виртуальные диски которыми представляются RAID-контролеры и т.п.</para>
<para>Каждая ячейка в этих системных таблицах сопоставляется конкретному экземпляру устройства. Таким образом, с точки зрения ядра каждое устройство оказывается однозначно проидентифицировано тремя параметрами – типом устройства (блочное или символьное) и двумя числами – номерами строки и номером столбца таблицы, в которой хранится ссылка на драйвер этого устройства.</para>
<para/>
<para/>
<para>Пример таблицы символьных и устройств</para>
<informaltable frame="all">
<tgroup cols="11">
<thead>
<row>
<entry>
<para/>
</entry>
<entry>
<para>0</para>
</entry>
<entry>
<para>1</para>
</entry>
<entry>
<para>...</para>
</entry>
<entry>
<para>63</para>
</entry>
<entry>
<para>64</para>
</entry>
<entry>
<para>65</para>
</entry>
<entry>
<para>66</para>
</entry>
<entry>
<para>...</para>
</entry>
<entry>
<para>175</para>
</entry>
<entry>
<para>...</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>4</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>COM1</para>
</entry>
<entry>
<para>COM2</para>
</entry>
<entry>
<para>COM3</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
</row>
<row>
<entry>
<para>6</para>
</entry>
<entry>
<para>LPT1</para>
</entry>
<entry>
<para>LPT2</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
</row>
<row>
<entry>
<para>10</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>Мышь PS/2</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>Диспетчер томов LVM</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>Слот AGP</para>
</entry>
<entry>
<para/>
</entry>
</row>
<row>
<entry>
<para>14</para>
</entry>
<entry>
<para>Микшер первой зв. карты</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
</row>
<row>
<entry>
<para>195</para>
</entry>
<entry>
<para>Первая видеокарта NVidia</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Пример таблицы блочных устройств</para>
<informaltable frame="all">
<tgroup cols="10">
<thead>
<row>
<entry>
<para/>
</entry>
<entry>
<para>0</para>
</entry>
<entry>
<para>1</para>
</entry>
<entry>
<para>2</para>
</entry>
<entry>
<para>...</para>
</entry>
<entry>
<para>16</para>
</entry>
<entry>
<para>...</para>
</entry>
<entry>
<para>64</para>
</entry>
<entry>
<para>65</para>
</entry>
<entry>
<para>...</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>3</para>
</entry>
<entry>
<para>IDE Primary Master</para>
</entry>
<entry>
<para> Раздел 1 на IDE Primary Master</para>
</entry>
<entry>
<para>Раздел 2 на IDE Primary Master</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>Раздел  16 на IDE Primary Master</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>IDE Primary Slave</para>
</entry>
<entry>
<para>Раздел 1 на IDE Primary Slave</para>
</entry>
<entry>
<para/>
</entry>
</row>
<row>
<entry>
<para>13</para>
</entry>
<entry>
<para>SCSI диск 1</para>
</entry>
<entry>
<para>Раздел 1 на SCSI-диске 1</para>
</entry>
<entry>
<para>Раздел 2 на SCSI-диске 1</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>SCSI диск 2</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>SCSI диск 4</para>
</entry>
<entry>
<para>Раздел 1 на SCSI-диске 4</para>
</entry>
<entry>
<para/>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>При попытке обращения к такому специальному файлу ядро переадресует обращение через нужный драйвер на устройство в соответствии с теми данными, которые указаны в таблице устройств, причем конкретная таблица устройств будет выбрана в зависимости от типа устройства, строка из таблицы будет выбрана по major number, и столбец будет выбран по minor number. Если мы посмотрим на примеры наших таблиц, то увидим, что обращение на специальный файл /dev/ttyS1, который представляет символьное устройство со старшим номером 4 и младшим номером 65 будет адресовано на последовательный порт COM2, а обращение к файлу /dev/hda2 (блочное устройство со старшим номером 3 и младшим номером 2) будет адресовано на 2-й раздел жесткого диска IDE, работающего в режиме primary master.</para></sect2><sect2><title>Статическая организация каталога /dev</title>
<para>В настоящее время существует два подхода к организации /dev – статическая организация и динамическая организация. В первом случае в каталоге /dev заранее создаются специальные файлы для всех возможных устройств вне зависимости от того, загружен драйвер соответствующего устройства или нет. Во втором случае специальные файлы в /dev создаются по мере инициализации устройств и загрузки драйверов, и удаляются при выгрузке соответствующего драйвера или удалении устройства.</para>
<para>Процесс работы со статическим /dev особых проблем не вызывает – системный администратор при необходимости просто создает отсутствующие файлы командой mknod или MAKEDEV. В том случае, когда какая-либо программа обращается к устройству, чей драйвер не загружен (или загружен, но ни одного соответствующего устройства не было обнаружено), операционная система возвращает ошибку при попытке открытия файла такого “неверного” устройства. Ниже приведен пример создания специального файла, соответствующего блочному устройству с мажором 8 и минором 33 и попытка его использования (отметим, что этот специальный файл соответствует разделу на жестком диске, который не существует на тестовой машине, где выполнялись эти команды):</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@viking root]# cd /dev</para>
<para>[root@viking dev]# ls -l /dev/hda33 </para>
<para>ls: /dev/hda33: No such file or directory</para>
<para>[root@viking dev]# </para>
<para>[root@viking dev]# mknod hda33 b 8 33</para>
<para>[root@viking dev]# </para>
<para>[root@viking dev]# ls -l hda33</para>
<para>brw-r--r--  1 root root 8, 33 Окт 11 09:27 hda33</para>
<para>[root@viking dev]# </para>
<para>[root@viking dev]# dd if=hda33 of=/dev/null </para>
<para>dd: opening `hda33': No such device or address</para>
<para>[root@viking dev]# </para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Сообщение No such device or address как раз и означает, что записи для данного устройства в таблице блочных устройств не существует.</para>
<para>Ядро Linux совместно с некоторыми системными утилитами поддерживает такую интересную возможность, как загрузка драйверов “по требованию”. Реализуется это следующим образом – в момент, когда какая-либо программа пытается открыть специальный файл, не связанный ни с каким драйвером, ядро делает попытку подобрать соответствующий драйвер самостоятельно. Необходимый драйвер для каждого специального файла определяется в файле /etc/modules.conf путем задания специального алиаса (alias) для модуля. Для активизации автоматической загрузки драйвера какого-либо символьного устройства в большинстве случаев достаточно просто записать в /etc/modules.conf строку следующего вида:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>alias char-major-X-Y имя_драйвера</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Для блочных устройств соответствующая запись слегка меняет свою форму:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>alias block-major-X-Y имя_драйвера</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>X и Y – это major и minor специального файла, попытка открыть который должна активизировать автоматическую загрузку драйвера. Владельцы видеокарт на чипе nVidia могут увидеть этот подход в действии – программа инсталляции драйвера nVidia автоматически прописывает в modules.conf запись для загрузки «по требованию» той части драйвера, которая работает в режиме ядра.</para>
<para>Вместо X или Y может также быть подставлен символ “*” , означающий “любое число”. Например, пусть в modules.conf будет написан следующий текст:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>alias char-major-81-* bttv</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Тогда при обращении к любому символьному устройству с major number равным 81 и которое не ассоциировано ни с каким драйвером, система попытается загрузить драйвер bttv (драйвер TV-тюнера на основе чипа bt848).</para>
<para>Эта возможность обеспечивает Linux возможность плавной загрузки и эффективного использования ресурсов – драйвер не загружается, пока в нем не возникнет необходимости. К сожалению, за простоту этой схемы приходится платить большим количеством специальных файлов в /dev.</para></sect2><sect2><title>Что такое DevFS</title>
<para>Для того, чтобы избавить администратора от ручного создания специальных файлов и для уменьшения количества файлов в /dev был реализован второй способ организации /dev – динамическое создание специальных файлов процессе загрузки драйверов. Реализовано это было следующим образом:</para>
<para>Ядро монтирует к каталогу /dev специальную файловую систему, называемую devfs – эта файловая система хранится целиком в оперативной памяти и не занимает никакого места на диске. Когда какой-либо драйвер в процессе загрузки или работы обнаруживает обслуживаемое им устройство, он регистрирует это устройство и сообщает о нем драйверу devfs. Драйвер devfs создает специальный файл, который виден прикладным программам и может быть корректно открыт. При выгрузке же драйвер устройства сообщает devfs о том, что соответствующее устройство уже не активно, и драйвер devfs удаляет запись о соответствующем специальном файле из файловой системы devfs.</para>
<para>Файловая система devfs отличается тем, что как правило специальный файл для устройства создается с длинным путем – например, для раздела на scsi-диске путь может выглядеть примерно так: /dev/scsi/host1/bus1/target3/lun4/partition2</para>
<para>Эта особенность является весьма важным плюсом devfs, поскольку она позволяет адресовать дисковые устройства путем указания логического пути их подключения и избежать смены имен SCSI-дисков в некоторых случаях (об этих случаях будет рассказано позднее).</para>
<para>Для того, чтобы организовать более прозрачную структуру каталогов и файлов устройств, используется специальный демон devfsd. Он взаимодействует с драйвером devfs и ядром и в процессе активизации и деактивизации устройств он создает и удаляет символьные ссылки вида /dev/disks/disc0 или /dev/hda1.</para>
<para>Надо отметить, что схема динамического /dev в некотором смысле близка к той организации каталога /dev, которая используется некоторыми коммерческими UNIX-системами (например, в  Solaris), когда есть виртуальная файловая система /devices, и на ее файлы создаются ссылки из /dev, только в Linux роль программы cfgadm играет демон devfsd, и все изменения в состав /dev вносятся автоматически.</para>
<para>С помощью devfsd файловая система devfs также реализует автоматическую загрузку модулей, но в этом случае выбор модуля идет не через комбинацию type/major/minor, а путем указания имени запрошенного файла – когда приложение пытается открыть несуществующий файл устройства, devfs передает имя запрошенного файла демону devfsd, и последний загружает необходимые модули, например такой код в файле modules.devfs:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>alias /dev/nvidia* nvidia</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Приведет к тому, что при попытке обращения к любому файлу, чей полный путь начинается строкой /dev/nvidia, будет произведена попытка загрузить драйвер nvidia.o (для ядра 2.6 nvidia.ko)</para>
<para>В принципе, на сегодняшний день выбор того, каким именно образом необходимо организовывать /dev, остается за пользователем и создателем дистрибутива. Например, в Mandrake Linux используется devfs, а в RedHat, Fedora и SUSE каталог /dev организован статическим образом, а опытные пользователи часто меняют способ организации /dev в зависимости от своих предпочтений.</para></sect2><sect2><title>Немного о UDEV</title>
<para>В современных дистрибутивах и ядрах поддержка devfs/devfsd отключена, и на смену этой паре пришел специальный демон, называемый udev. В отличие от devsfd, который требовал поддержки со стороны ядра, udev такой поддержки не требует. При инициализации устройства ядро подает сигнал через файловую систему sysfs, и демон udevd, получив сигнал об этом событии, самостоятельно создает соответствующий специальный файл устройства в каталоге /dev в соответствии с правилами, описанными в его конфигурационных файлах. При необходимости в этих файлах можно указать например вызов некоторой внешней программы, создание символьной ссылки и так далее.</para>
<para>Например, если некоторое устройство после подключения перед началом работы требует дополнительной настройки с использованием внешних программ, можно создать соответствующее правило для udev, в котором будет указано какую программу вызвать и какие параметры ей необходимо передать – в частности, это может потребоваться для data-кабелей к некоторым мобильным телефонам Nokia, для устройств которым для корректной работы требуется firmware, или для сохранения или восстановления текущих настроек устройства.</para>
<para>Тем не менее, несмотря на внешние отличия между статической организацией /dev, devfs и udev, следует помнить что это всего лишь способ заполнения каталога /dev, и во всех случаях в конечном итоге на файловой системе создаются те же самые файлы символьных и блочных устройств.</para></sect2><sect2><title>Блочные устройства</title>
<para>Любое устройство, подключенное к компьютеру, имеет свое назначение, и блочные устройства в большинстве своем предназначаются для хранения информации. Как организована работа с блочными устройствами в Linux?</para>
<para>Во-первых, следует определиться с типами блочных устройств. Их следует поделить на две категории: к первой отнесем логические (виртуальные) устройства (loop-устройства, software RAID-устройства, устройства Volume Management, поддержка различных таблиц разделов), ко второй категории - физические устройства (SCSI диски и CD-ROM'ы, IDE-диски, USB-storage, RAM-диск).</para>
<para>Виртуальные устройства являются на самом деле просто оберткой, дополнительным слоем. В реальности драйверы логических устройств не работают с периферийными устройствами напрямую, они лишь переадресовывают запросы на драйверы других логических или физических устройств.</para>
<para>Драйверы физических устройств работают совместно с драйверами контроллеров, позволяя производить доступ к соответствующим устройствам на блочном уровне и предоставляя тем самым фактически прямой доступ к носителю – но, поскольку в большинстве случаев дисковые устройства имеют значительный объем, они часто делятся на разделы. Раздел является постоянным непрерывным фрагментом дискового пространства, местоположение которого на жестком диске записано в специальной области диска – таблице разделов.</para>
<para>Существует множество различных форматов разбиения диска на разделы – например, DOS partition table, BSD disklabels, UnixWare slices и многие другие. Как правило, во всех случаях соответствующая спецификация предусматривает возможность перечисления ограниченного количества разделов путем указания номеров первой и последней дорожек, занимаемых каждым из разделов. Каждый раздел видится как отдельное блочное устройство.</para>
<para>По традиции имена блочных устройств, соответствующих IDE-дискам и созданным на них разделам начинаются с hd и имеют вид /dev/hd&lt;N&gt;[&lt;M&gt;] где N – это буква, зависящая от контроллера и канала IDE, к которому подключено устройство, и режима устройства (master/slave). M – это некоторое число от 1 до 63 (фактически номер раздела на диске). Если число не указано, подразумевается весь диск. SCSI-дискам в /dev присваиваются имена sda, sdb, sdc и т.д. Ниже приводится небольшая таблица соответствия устройств и имен специальных файлов для IDE-дисков:</para>
<para/>
<informaltable frame="all">
<tgroup cols="5">
<thead>
<row>
<entry>
<para>Контроллер</para>
</entry>
<entry>
<para>Канал</para>
</entry>
<entry>
<para>Режим</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>Имя файла</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>1</para>
</entry>
<entry>
<para>1</para>
</entry>
<entry>
<para>master</para>
</entry>
<entry>
<para>primary master</para>
</entry>
<entry>
<para>hda</para>
</entry>
</row>
<row>
<entry>
<para>1</para>
</entry>
<entry>
<para>1</para>
</entry>
<entry>
<para>slave</para>
</entry>
<entry>
<para>primary slave</para>
</entry>
<entry>
<para>hdb</para>
</entry>
</row>
<row>
<entry>
<para>1</para>
</entry>
<entry>
<para>2</para>
</entry>
<entry>
<para>master</para>
</entry>
<entry>
<para>secondary master</para>
</entry>
<entry>
<para>hdc</para>
</entry>
</row>
<row>
<entry>
<para>1</para>
</entry>
<entry>
<para>2</para>
</entry>
<entry>
<para>slave</para>
</entry>
<entry>
<para>secondary slave</para>
</entry>
<entry>
<para>hdd</para>
</entry>
</row>
<row>
<entry>
<para>2</para>
</entry>
<entry>
<para>1</para>
</entry>
<entry>
<para>master</para>
</entry>
<entry>
<para>tertiary master</para>
</entry>
<entry>
<para>hde</para>
</entry>
</row>
<row>
<entry>
<para>2</para>
</entry>
<entry>
<para>1</para>
</entry>
<entry>
<para>slave</para>
</entry>
<entry>
<para>tertiary slave</para>
</entry>
<entry>
<para>hdf</para>
</entry>
</row>
<row>
<entry>
<para>2</para>
</entry>
<entry>
<para>2</para>
</entry>
<entry>
<para>master</para>
</entry>
<entry>
<para>quaternary master</para>
</entry>
<entry>
<para>hdg</para>
</entry>
</row>
<row>
<entry>
<para>2</para>
</entry>
<entry>
<para>2</para>
</entry>
<entry>
<para>slave</para>
</entry>
<entry>
<para>quaternary slave</para>
</entry>
<entry>
<para>hdh</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Когда драйвер блочного устройства, поддерживающего разбиение на разделы,  в процессе загрузки или работы обнаруживает обслуживаемое им устройство, он считывает с него таблицу разделов, определяет ее разновидность  и составляет таблицу разделов, запоминая начало и конец каждого из разделов. Впоследствии, если какая-либо программа производит обращение не непосредственно к физическому устройству, а к разделу на этом устройстве, драйвер с использованием построенной таблицы разделов определяет реальный адрес блока, над которым нужно произвести запрошенную операцию ввода/вывода.</para>
<para>Особой разновидностью раздела можно назвать расширенный (extended) раздел DOS. Расширенный разделы DOS может быть разбит на произвольное количество вложенных разделов, но в настоящий момент без использования LVM ядро Linux поддерживает до 63 разделов на IDE-диске и до 15 разделов на SCSI-диске. Такое ограничение связано с распределением мажоров и миноров блочных устройств.</para>
<para>Когда используется разбиение диска на разделы с использованием таблицы разделов DOS, следует помнить, что на жестком диске может быть не более 4 первичных разделов. Если администратору нужно, чтобы на жестком диске было более 4 разделов, необходимо объявить один из первичных разделов как расширенный раздел. Первичные разделы при использовании таблицы разделов DOS нумеруются от 1 до 4, логические разделы нумеруются начиная с 5, вне зависимости от количества первичных разделов. Только один из первичных разделов может быть объявлен расширенным.</para>
<para>Рассмотрим вывод команды fdisk, которая обычно используется в Linux для разбиения диска на разделы:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@stend root]# fdisk /dev/hda -l</para>
<para/>
<para>Disk /dev/hda: 6442 MB, 6442450944 bytes</para>
<para>16 heads, 63 sectors/track, 12483 cylinders</para>
<para>Units = cylinders of 1008 * 512 = 516096 bytes</para>
<para/>
<para>   Device Boot      Start         End      Blocks   Id  System</para>
<para>/dev/hda1   *           1         203      102280+  83  Linux</para>
<para>/dev/hda2             204        2032      921816   83  Linux</para>
<para>/dev/hda3            2033        3072      524160   82  Linux swap</para>
<para>/dev/hda4            3073       12483     4743144    f  W95 Ext'd (LBA)</para>
<para>/dev/hda5            3073        4088      512032+  83  Linux</para>
<para>/dev/hda6            4089       12483     4231048+  83  Linux</para>
<para/>
<para>[root@stend root]# </para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Как видно, на жестком диске IDE созданы 6 разделов, из них 4 первичных (разделы с номерами от 1 до 4) и два логических раздела с номерами 5 и 6, созданных внутри extended-раздела hda4.</para>
<para>Таблица разделов диска не может быть изменена в том случае, если хотя-бы один из разделов этого диска используется. В этом случае ядро продолжает использовать “старую” разметку (с которой оно работало до изменения), а изменения записываются на диск и вступают в силу после перезагрузки компьютера.</para>
<para>Если нет возможности запустить программу fdisk, то для получения данных о разметке блочных устройств на разделы и о состоянии блочных устройств, доступных в настоящий момент, можно использовать некоторые файлы из файловой системы /proc:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[dalth@viking dalth]$ cat /proc/partitions </para>
<para>major minor  #blocks  name</para>
<para/>
<para>   3     0   78150744 hda</para>
<para>   3     1    1084356 hda1</para>
<para>   3     2   77063805 hda2</para>
<para> 253     0    1048576 dm-0</para>
<para> 253     1    1048576 dm-1</para>
<para> 253     2   10485760 dm-2</para>
<para> 253     3   10485760 dm-3</para>
<para> 253     4    1048576 dm-4</para>
<para> 253     5   41943040 dm-5</para>
<para> 253     6     360448 dm-6</para>
<para> 253     7     258048 dm-7</para>
<para> 253     8     258048 dm-8</para>
<para> 253     9     258048 dm-9</para>
<para> 253    10      53248 dm-10</para>
<para>   7     0     651884 loop0</para>
<para>   7     1     650198 loop1</para>
<para>   7     2     653336 loop2</para>
<para>   7     3     198962 loop3</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Например, эти данные могут быть использованы для восстановления таблицы разделов, если системный администратор по ошибке ее исправил.</para>
<para>Интересной особенностью таблицы разделов диска является то, что она не всегда изменяема. Это приводит к тому, что во многих случаях невозможно изменить размер какого-либо раздела или внести какие-либо другие изменения в таблицу разделов без перезагрузки – т.е. системный администратор может делать любые изменения, но они вступят в силу только после перезагрузки системы.</para><sect3><title>Распределение мажоров и миноров IDE дисков</title>
<para>IDE-диски в настоящее время наиболее часто используются в офисных и домашних компьютерах, поэтому знать особенности распределения мажоров и миноров для этих типов устройств достаточно важно. IDE-устройства отличаются низкой ценой и неплохой скоростью передачи данных, но у этой шины есть архитектурные недостатки – например, все устройства работают со скоростью самого медленного из них, на один шлейф (на один канал) можно подключить только 2 устройства.</para>
<para>Всем устройствам, находящимся на одном канале IDE, присвоен один мажор. В настоящий момент ядро Linux выделяет для каждого устройства 64 минора, из которых первый минор зарезервирован для всего диска, и 63 минора остается для идентификации разделов. Таким образом, для IDE-дисков мажор идентифицирует канал, а по минору можно определить номер устройства на канале (режим master/slave) и номер раздела. Более детально это можно увидеть в следующей таблице:</para>
<informaltable frame="all">
<tgroup cols="1.4181818181818182">
<thead>
<row>
<entry namest="c1" nameend="c6">
<para>Распределение номеров устройств для IDE-дисков</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>Канал</para>
</entry>
<entry>
<para>Устройство</para>
</entry>
<entry>
<para>Раздел</para>
</entry>
<entry>
<para>Major number</para>
</entry>
<entry>
<para>Minor number</para>
</entry>
<entry>
<para>  Имя в /dev</para>
</entry>
</row>
<row>
<entry>
<para>1</para>
</entry>
<entry namest="c2" nameend="c3">
<entry>
<para>1</para>
</entry>
<entry>
<entry>
<para>Весь диск</para>
</entry>
<entry>
<para>Раздел 1</para>
</entry>
<entry>
<para>Раздел 2</para>
</entry>
<entry>
<para>Раздел 3</para>
</entry>
<entry>
<para>Раздел 4</para>
</entry>
<entry>
<para>...</para>
</entry>
<entry>
<para>Раздел 63</para>
</entry>
</entry>
<entry>
<para>2</para>
</entry>
<entry>
<entry>
<para>Весь диск</para>
</entry>
<entry>
<para>Раздел 1</para>
</entry>
<entry>
<para>Раздел 2</para>
</entry>
<entry>
<para>Раздел 3</para>
</entry>
<entry>
<para>...</para>
</entry>
<entry>
<para>Раздел 63</para>
</entry>
</entry>
</entry>
<entry>
<para>3</para>
</entry>
<entry namest="c5" nameend="c6">
<entry>
<para>0</para>
</entry>
<entry>
<para>  /dev/hda</para>
</entry>
<entry>
<entry>
<para>1</para>
</entry>
<entry>
<para>2</para>
</entry>
<entry>
<para>3</para>
</entry>
<entry>
<para>4</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>63</para>
</entry>
</entry>
<entry>
<entry>
<para>  /dev/hda1</para>
</entry>
<entry>
<para>  /dev/hda2</para>
</entry>
<entry>
<para>  /dev/hda3</para>
</entry>
<entry>
<para>  /dev/hda4</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>  /dev/hda63</para>
</entry>
</entry>
<entry>
<para>64</para>
</entry>
<entry>
<para>  /dev/hdb</para>
</entry>
<entry>
<entry>
<para>65</para>
</entry>
<entry>
<para>66</para>
</entry>
<entry>
<para>67</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>127</para>
</entry>
</entry>
<entry>
<entry>
<para>  /dev/hdb1</para>
</entry>
<entry>
<para>  /dev/hdb2</para>
</entry>
<entry>
<para>  /dev/hdb3</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>  /dev/hdb63</para>
</entry>
</entry>
</entry>
</row>
<row>
<entry>
<para>2</para>
</entry>
<entry namest="c2" nameend="c3">
<entry>
<para>1</para>
</entry>
<entry>
<entry>
<para>Весь диск</para>
</entry>
<entry>
<para>Разделы</para>
</entry>
</entry>
<entry>
<para>2</para>
</entry>
<entry>
<entry>
<para>Весь диск</para>
</entry>
<entry>
<para>Разделы</para>
</entry>
</entry>
</entry>
<entry>
<para>22</para>
</entry>
<entry namest="c5" nameend="c6">
<entry>
<para>0</para>
</entry>
<entry>
<para>  /dev/hdc</para>
</entry>
<entry>
<para>1-63</para>
</entry>
<entry>
<para>   /dev/hdc[1..63]</para>
</entry>
<entry>
<para>64</para>
</entry>
<entry>
<para>  /dev/hdd</para>
</entry>
<entry>
<para>65-127</para>
</entry>
<entry>
<para>  /dev/hdd[1..63]</para>
</entry>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>По таблице становится видно, что на каждый 64-й минор происходит смена физического диска. Драйвер IDE в текущей версии ядра Linux поддерживает до четырех каналов IDE – т.е. до 8 устройств, по два устройства на канал..</para>
<para>Рекомендации, которую можно дать владельцам компьютеров с интерфейсом IDE: устройства по возможности рекомендуется держать на разных каналах. Если нет свободных каналов, то “быстрые” устройства лучше подключать на один канал, медленные – на другой.</para></sect3><sect3><title>Распределение мажоров и миноров для SCSI-дисков</title>
<para>Шина SCSI свободна от некоторых недостатков IDE, например количество устройств на одном канале может быть 15 (на самом деле 16, но одним устройством считается сам контроллер), все SCSI устройства работают на своей максимальной скорости, и ограничены только возможностями шины и контроллера – но SCSI-устройства и дороже, и поэтому шина SCSI используется в основном на серверах и рабочих станциях. Для SCSI-дисков ситуация немного меняется – мажоры не привязаны к контроллерам (т.е. один major number может использоваться дисками с разных хост-адаптеров). На каждом SCSI-диске система поддерживает до 16 разделов, а нумерация дисков производится в порядке их подключения по схеме, аналогичной IDE-дискам – но только переход на следующий диск происходит на каждом 16-м миноре (т.е. разделы на SCSI-дисках нумеруются от1 до 15). Увидеть это можно в следующей таблице и листинге /dev:</para>
<informaltable frame="all">
<tgroup cols="3">
<thead>
<row>
<entry namest="c1" nameend="c5">
<para>Распределение номеров устройств для SCSI-дисков</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>Номер диска в порядке подключения</para>
</entry>
<entry>
<para>Major number</para>
</entry>
<entry>
<para>Minor number</para>
</entry>
<entry>
<para>Раздел</para>
</entry>
<entry>
<para>Имя файла</para>
</entry>
</row>
<row>
<entry>
<para>1</para>
</entry>
<entry>
<para>8</para>
</entry>
<entry namest="c3" nameend="c5">
<entry>
<para>0</para>
</entry>
<entry>
<para>Весь диск</para>
</entry>
<entry>
<para>sda</para>
</entry>
<entry>
<para>1</para>
</entry>
<entry>
<para>Первый первичный</para>
</entry>
<entry>
<para>sda1</para>
</entry>
<entry>
<para>2</para>
</entry>
<entry>
<para>Второй первичный</para>
</entry>
<entry>
<para>sda2</para>
</entry>
<entry>
<para>3</para>
</entry>
<entry>
<para>Третий первичный</para>
</entry>
<entry>
<para>sda3</para>
</entry>
<entry>
<para>4</para>
</entry>
<entry>
<para>Четвертый первичный</para>
</entry>
<entry>
<para>sda4</para>
</entry>
<entry>
<para>5</para>
</entry>
<entry>
<para>Первый логический</para>
</entry>
<entry>
<para>sda5</para>
</entry>
<entry>
<para>...</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>15</para>
</entry>
<entry>
<para>Одиннадцатый логический</para>
</entry>
<entry>
<para>sda15</para>
</entry>
</entry>
</row>
<row>
<entry>
<para>2</para>
</entry>
<entry>
<para>8</para>
</entry>
<entry namest="c3" nameend="c5">
<entry>
<para>16</para>
</entry>
<entry>
<para>Весь диск</para>
</entry>
<entry>
<para>sdb</para>
</entry>
<entry>
<para>17</para>
</entry>
<entry>
<para>Первый первичный</para>
</entry>
<entry>
<para>sdb1</para>
</entry>
<entry>
<para>18</para>
</entry>
<entry>
<para>Второй первичный</para>
</entry>
<entry>
<para>sdb2</para>
</entry>
<entry>
<para>19</para>
</entry>
<entry>
<para>Третий первичный</para>
</entry>
<entry>
<para>sdb3</para>
</entry>
<entry>
<para>20</para>
</entry>
<entry>
<para>Четвертый первичный</para>
</entry>
<entry>
<para>sdb4</para>
</entry>
<entry>
<para>21</para>
</entry>
<entry>
<para>Первый логический</para>
</entry>
<entry>
<para>sdb5</para>
</entry>
<entry>
<para>...</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>31</para>
</entry>
<entry>
<para>Одиннадцатый логический</para>
</entry>
<entry>
<para>sdb15</para>
</entry>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>В текущей версии ядро Linux поддерживает до 4096 SCSI-дисков – и для абсолютного большинства  компьютеров этого должно быть достаточно. Очень важной особенностью SCSI-дисков является то, что мажор устройства, соответствующего физическому диску, не зависит от контроллера. В результате, если у вас есть 3 диска SCSI, то они всегда именуются sda, sdb и sdc, и если вы выключите компьютер и отключите первый диск, то после перезагрузки второй диск (который ранее назывался sdb) станет называться sda, а третий диск (который назывался sdc) станет называться sdb, поэтому при работе со SCSI-устройствами можно использовать devfs (которая позволяет адресовать диски через путь их подключения), либо использовать специализированные средства управления дисковым пространством, которые помечают носители и впоследствии правильно их идентифицируют даже после переименования устройств - например, средства md (software RAID) или LVM. Надо заметить, что в свете удаления devfs из основной ветви ядра, использование LVM стало фактически обязательным на серверах.</para></sect3><sect3><title>Устройства SATA и переход с IDE на PATA</title>
<para>SATA, «осовремененная» версия интерфейса IDE, по своей структуре приблизилась к подсистеме SCSI. Поэтому в целях унификации подсистемы ввода-вывода в ядре Linux поддержка SATA была реализована через интерфейс SCSI., соответственно SATA-диски и контроллеры видятся ядром (и пользователем) как SCSI-устройства.</para>
<para>В новейших ядрах линейки 2.6 также появилась возможность работы с IDE-дисками через подсистему SCSI., и в новых дистрибутивах, таких как Fedora 7, даже обычные Parallel ATA (они же IDE) диски и контроллеры представляются как SCSI-устройства, что привело к унификации подсистемы дискового ввода-вывода, и теперь все диски и CD/DVD приводы для пользователя представляются как /dev/sdX или /dev/scdX. Драйверы для обычных контроллеров IDE, которые работают по новой схеме, начинаются с префикса pata, например: pata_via – это драйвер IDE-контроллеров с чипсетом VIA, а pata_piix -  это дарйвера для IDE-контроллеров Intel, работающие  через подсистему SCSI.</para>
<para>А говоря проще, это означает следующее – если у вас новый дистрибутив или имеются SATA-диски, вы можете смело работать со всеми дисками как со SCSI-устройствами.</para></sect3><sect3><title>Logical Volume Manager</title>
<para>Использование таблиц разделов для управления дисковым пространством – достаточно часто используемое решение. К сожалению, оно не свободно от определенных недостатков – например, нет возможности расширить раздел или уменьшить его размер, нет возможности создать один раздела на нескольких дисках и т.д. Решить эту задачу призван LVM (Logical Volume Manager).</para>
<para>LVM работает следующим образом: пользователь может пометить какие-либо блочные устройства как разделы, используемые LVM. Каждое из таких помеченых блочных устройств (их называют физическими томам,и или physical volumes) может быть присоединено к какой либо группе логических томов (logical volume groups). Внутри групп логических томов могут создаваться уже собственно логические тома (logical volumes). Дисковое пространство любого физического тома из некоторой группы может быть выделено любому логическому тому из этой группы. Реализовано это через так называемые “экстенты” (extents) дискового пространства. Физические тома LVM разбиваются на экстенты, после чего из экстентов и составляются логические тома. Именно за счет этого можно динамически менять конфигурацию дискового пространства – экстент может быть удален из одного тома, и добавлен к другому. Каждый объект LVM – будь то логический том, физический том или группа томов, имеет свой уникальный идентификатор.</para>
<para>Осуществляется это комплексно драйвером device mapper и специализированными программами из пакета lvm2. Эти программы читают файлы конфигурации и служебную информацию из заголовков физических томов, и на основании этой информации сообщают драйверу инструкции о том, из каких фрагментов каких блочных устройств каким именно образом должны быть скомбинированы логические тома, после чего драйвер для каждого логического тома создает отдельное блочное устройство. При обращении к такому блочному устройству device mapper определяет, на основании ранее переданных параметров к какому блоку какого блочного устройства на самом деле должен быть переадресован запрос, и запрашивает соответствующее блочное устройство для окончательного выполнения операции, после чего возвращает результат выполнения операции (прочитанные данные, сообщение об ошибке, код завершения операции) обратившейся программе.</para>
<para>Использование LVM позволяет гибко управлять распределением дискового пространства и избежать ограничений, связанных с классическим распределением дискового пространства путем создания разделов на жестких дисках. Единственное правило, которое я бы советовал соблюдать при использовании LVM – не создавать корневой раздел системы на логическом томе LVM: инициализации тома LVM, на котором находится корневая файловая система, необходимо вмешательство некоторых утилит, которые находятся на еще не смонтированной корневой файловой системы. Это решаемая проблема, но она потребует некоторого опыта.</para>
<para>Ниже идет пример создания и инициализации физического тома, группы томов и примеры нескольких операций с логическими томами. На первом фрагменте протокола продемонстрирована инициализация таблицы разделов для использования LVM. Порядок действий для использования LVM в общем случае следующий: один или несколько разделов жесткого диска с помощью fdisk помечаются как разделы LVM. Затем эти разделы инициализируются и передаются в группы томов, после чего их дисковое пространство можно использовать для создания логических томов:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@inferno dalth]# fdisk /dev/hdb</para>
<para/>
<para>The number of cylinders for this disk is set to 79408.</para>
<para>There is nothing wrong with that, but this is larger than 1024,</para>
<para>and could in certain setups cause problems with:</para>
<para>1) software that runs at boot time (e.g., old versions of LILO)</para>
<para>2) booting and partitioning software from other OSs</para>
<para>   (e.g., DOS FDISK, OS/2 FDISK)</para>
<para/>
<para>Command (m for help): p</para>
<para/>
<para>Disk /dev/hdb: 40.9 GB, 40982151168 bytes</para>
<para>16 heads, 63 sectors/track, 79408 cylinders</para>
<para>Units = cylinders of 1008 * 512 = 516096 bytes</para>
<para/>
<para>   Device Boot      Start         End      Blocks   Id  System</para>
<para>/dev/hdb1               1       79408    40021600+  8e  Linux LVM</para>
<para/>
<para>Command (m for help): w</para>
<para>The partition table has been altered!</para>
<para/>
<para>Calling ioctl() to re-read partition table.</para>
<para>Syncing disks.</para>
<para>[root@inferno dalth]#</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>В приведенном выше выводе fdisk видно, что на IDE-диске primary slave создан один раздел типа LVM (код типа раздела 0x8E). В следующем листинге показан процесс инициализации физического тома и создания группы томов aurora, в которую включается инициализированный командой pvcreate физический том /dev/hdb1:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@inferno dalth]# pvcreate /dev/hdb1 </para>
<para>  No physical volume label read from /dev/hdb1</para>
<para>  Physical volume "/dev/hdb1" successfully created</para>
<para>[root@inferno dalth]# vgcreate aurora /dev/hdb1</para>
<para>  Volume group "aurora" successfully created</para>
<para>[root@inferno dalth]#</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Третий фрагмент демонстрирует создание нескольких томов и изменение размеров томов, проделанное с помощью LVM. В этом примере создается логический том размеров в 20GB, затем размер этого тома увеличивается до 30GB, создается еще один логический том, и после этого оба созданных логических тома удаляются.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@inferno dalth]# </para>
<para>[root@inferno dalth]# lvcreate -L 20G -n ftpdata aurora</para>
<para>  Logical volume "ftpdata" created</para>
<para>[root@inferno dalth]# </para>
<para>[root@inferno dalth]# lvscan</para>
<para>  ACTIVE           '/dev/aurora/ftpdata' [20,00 GB] next free (default)</para>
<para>[root@inferno dalth]# </para>
<para>[root@inferno dalth]# lvresize -L +10G /dev/aurora/ftpdata </para>
<para>  Extending logical volume ftpdata to 30,00 GB</para>
<para>  Logical volume ftpdata successfully resized</para>
<para>[root@inferno dalth]# </para>
<para>[root@inferno dalth]# lvscan</para>
<para>  ACTIVE           '/dev/aurora/ftpdata' [30,00 GB] next free (default)</para>
<para>[root@inferno dalth]# lvcreate -L 8G -n home_dirs aurora</para>
<para>  Logical volume "home_dirs" created</para>
<para>[root@inferno dalth]# </para>
<para>[root@inferno dalth]# lvscan</para>
<para>  ACTIVE           '/dev/aurora/ftpdata' [30,00 GB] next free (default)</para>
<para>  ACTIVE           '/dev/aurora/home_dirs' [8,00 GB] next free (default)</para>
<para>[root@inferno dalth]# </para>
<para>[root@inferno dalth]# lvremove /dev/aurora/ftpdata </para>
<para>Do you really want to remove active logical volume "ftpdata"? [y/n]: y</para>
<para>  Logical volume "ftpdata" successfully removed</para>
<para>[root@inferno dalth]# </para>
<para>[root@inferno dalth]# lvremove /dev/aurora/home_dirs </para>
<para>Do you really want to remove active logical volume "home_dirs"? [y/n]: y</para>
<para>  Logical volume "home_dirs" successfully removed</para>
<para>[root@inferno dalth]#</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Еще один фрагмент демонстрирует удаление группы томов и очистку физического тома:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@inferno dalth]# vgremove aurora</para>
<para>  Volume group "aurora" successfully removed</para>
<para>[root@inferno dalth]# pvremove /dev/hdb1</para>
<para>  Labels on physical volume "/dev/hdb1" successfully wiped</para>
<para>[root@inferno dalth]#</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Каждый логический том LVM имеет свой собственный minor number, а major number для всех томов LVM равен 253. Для доступа к томам LVM можно создавать блочные устройства с помощью команды mknod, а можно воспользоваться возможностями, предоставляемыми утилитой devlabel. Эта утилита создает символьные ссылки и каталоги внутри подкаталога /dev, причем для каждой группы томов в /dev создается каталог с именем этой группы, а логические тома представляются символьными ссылками из этих каталогов на блочные устройства, обслуживаемые драйвером device mapper, и тогда любой том LVM можно адресовать следующим путем: /dev/&lt;имя_группы&gt;/&lt;имя_тома&gt;. На листинге ниже показан пример того, как можно распределить дисковое пространство с помощью LVM:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@viking root]#</para>
<para>[root@viking root]# ls -la /dev/chimera</para>
<para>lr-xr-xr-x  1 root root 23 Окт  8 13:53 opt -&gt; /dev/mapper/chimera-opt</para>
<para>lr-xr-xr-x  1 root root 24 Окт  8 13:53 swap -&gt; /dev/mapper/chimera-swap</para>
<para>lr-xr-xr-x  1 root root 24 Окт  8 13:53 temp -&gt; /dev/mapper/chimera-temp</para>
<para>lr-xr-xr-x  1 root root 23 Окт  8 13:53 usr -&gt; /dev/mapper/chimera-usr</para>
<para>lr-xr-xr-x  1 root root 23 Окт  8 13:53 var -&gt; /dev/mapper/chimera-var</para>
<para>[root@viking root]#</para>
<para>[root@viking root]# lvscan</para>
<para>  ACTIVE          '/dev/chimera/swap' [1,00 GB] next free (default)</para>
<para>  ACTIVE          '/dev/chimera/temp' [1,00 GB] next free (default)</para>
<para>  ACTIVE          '/dev/chimera/usr' [10,00 GB] next free (default)</para>
<para>  ACTIVE          '/dev/chimera/opt' [10,00 GB] next free (default)</para>
<para>  ACTIVE          '/dev/chimera/var' [1,00 GB] next free (default)</para>
<para>[root@viking root]#</para>
<para>[root@viking root]# mount | grep chimera</para>
<para>/dev/mapper/chimera-var on /var type ext3 (rw)</para>
<para>/dev/mapper/chimera-temp on /tmp type ext3 (rw)</para>
<para>/dev/mapper/chimera-usr on /usr type ext3 (rw)</para>
<para>/dev/mapper/chimera-opt on /opt type ext3 (rw)</para>
<para>[root@viking root]#</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Таким образом, возможности LVM позволяют системному администратору максимально эффективно использовать дисковое пространство, оперативно реагируя на меняющиеся условия эксплуатации. Еще одной интересной возможностью LVM является так называемый multipath I/O. В случае активации соответствующей опции  в ядре device mapper знает о том, что физический том с некоторым UUID может быть доступен через несколько контроллеров, и в случае отказа одного контроллера динамически происходит переключение ввода-вывода на другой. Опытные системные администраторы также оценят такую возможность, как создание снимка (snapshot) логического тома: при создании снимка создается моментальная копия логического тома, которая начинает «жить» независимо от того тома, на основе которого она была создана:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para># xfs_freeze /home</para>
<para># lvcreate -s -L 10G -n home_snapshot /dev/chimera/home</para>
<para># xfs_freeze -u /home</para>
<para># dd if=/dev/chimera/home_snapshot of=/dev/st0</para>
<para># lvremove /dev/chimera/home_snapshot</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>В приведенном примере системный администратор «замораживает» файловую систему XFS, при этом драйвер XFS сбрасывает все закэшированные операции на диск, и после этого блокирует все процессы, которые пытаются писать на «замороженную» файловую систему. Затем системный администратор создает снимок тома home из группы томов chimera, на котором «живет» файловая система /home, и этот снимок называет home_snapshot, при этом на удержание копии измененных данных выделяется 10 гигабайт дискового пространства. После создания снимка файловая система /home размораживается, но каждый раз, когда будет переписываться какой-либо блок логического тома home, первоначальная версия изменяемого блока будет копироваться в те 10GB дискового пространства, которые мы выделили под снимок тома, и мы можем считать содержимое тома home_snapshot неизменным, и скопировать его на ленту. В процессе чтения, если читаемый блок не изменялся с момента создания снимка, то он читается из исходного тома (home), если же  блок менялся с момента создания снимка, то используется его копия, хранимая в зарезервированном при создании снимка пространстве. После окончания копирования мы удаляем снимок командой lvremove.</para></sect3><sect3><title>Sotware RAID</title>
<para>Ядро Linux содержит средства для организации software raid (программных RAID-устройств). Эта возможность поддерживается драйвером устройств md. В отличие от device mapper, драйвер md умеет работать в “самостоятельном” режиме, получая конфигурацию из параметров, которые пользователь указал ядру при загрузке системы, что позволяет организовывать загрузку системы с RAID-устройств. Все устройства md имеют мажор 254 и миноры от 0 и до 16383.</para>
<para>В отличие от LVM, основной задачей которого является динамическое распределение дискового пространства (деление разделов на фрагменты и построение из фрагментов новых блочных устройств), задачей подсистемы RAID является построение новых блочных устройств путем объединения существующих.</para>
<para>Каждое из устройств, входящих в создаваемый дисковый массив, может определенным образом помечаться. Впоследствии эти метки (их также называют array superblocks) используются для повторной сборки массива. В частности, например, суперблок массива содержит его уникальный идентификатор, который можно использовать при сборке ранее созданного массива после перезагрузки. Если программный RAID-массив был помечен в процессе создания (т.е. на нем был создан суперблок массива), это дает возможность автоматической сборки массива вне зависимости от того, поменялся или нет порядок следования устройств. Например, такая необходимость может возникнуть в ситуации, когда порядок нумерации блочных устройств изменился – например, один из SCSI-дисков, участвовавших в построении массива, был удален.</para>
<para>Естественно, суперблок не является обязательным – то есть можно создавать массивы без суперблока, но управления ими может быть затруднено вследствие необходимости «руками» контролировать корректность указания устройств при переконфигурации массива.</para>
<para>Из интересных особенностей драйвера md стоит отметить то, что он поддерживает разбиение md-устройств на разделы, при этом минорные номера присваиваются разделам аналогично тому, как они присваиваются разделам на дисках IDE, т.е на каждом RAID-устройстве можно создать до 63 разделов. Определить минор раздела, созданного на RAID-устройстве, можно с помощью вычисления значения следующего выражения: 64 * N + M, где N – это номер массива (номер RAID-устройства) из диапазона 0 ... 255, а M – это номер раздела из диапазона 1 ... 63.</para>
<para>Следует сказать, что по умолчанию в большинстве дистрибутивов специальные файлы для разделов на md-устройствах не создаются, и их необходимо создать вручную командой mknod. В настоящий момент оптимальным, наверное, следует считать комбинирование использования LVM и md, что позволяет достигнуть надежности за счет дублирования данных средствами md, и гибкости распределения дискового пространства за счет возможностей LVM.</para>
<para>Драйвер md хорошо подходит для создания RAID-устройств уровней 0, 1 или 0+1, но не будет являться оптимальным вариантом в случае использования, например RAID уровня 5 (чередование данных по устройствам с вычислением контрольной суммы и кодом исправления ошибок), поскольку это создаст значительную нагрузку на процессор при большом объеме передаваемых данных. Возможно, что в таких случаях стоит подумать о приобретении аппаратного контроллера RAID - например, HP NetRaid (сделан на основе AMI MegaRAID) или Compaq Smart Array (сейчас называется HP Smart Array).</para>
<para>На листинге демонстрируется пример создания, активизации и остановки программных RAID-устройств уровня 0 и уровня 1 средствами драйвера md и системной утилиты mdadm. Утилита mdadm имеет конфигурационный файл /etc/mdadm.conf, но для того, чтобы проделать некоторые тесты и демонстрационные примеры нет необходимости его изменять.</para>
<para>В первом примере будем считать, что на жестком диске hdb создано два раздела, с которыми мы и будем экспериментировать. Для начала необходимо произвести инициализацию md-устройства. Соответственно, для успешной необходимо указать тип RAID-массива, специальный файл md-устройства, которое мы хотим инициализировать, и список блочных устройств, на которых будет располагаться получившийся массив:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@inferno dalth]# </para>
<para>[root@inferno dalth]# mdadm --create \</para>
<para>&gt;                           /dev/md0 --level=0 \</para>
<para>&gt;                           --raid-devices=2 /dev/hdb1 /dev/hdb2</para>
<para>mdadm: array /dev/md0 started.</para>
<para>[root@inferno dalth]# </para>
<para>[root@inferno dalth]# mdadm -Q /dev/md0</para>
<para>/dev/md/d0: 983.25MiB raid0 2 devices, 0 spares.</para>
<para>[root@inferno dalth]# </para>
<para>[root@inferno dalth]# mdadm –S /dev/md0</para>
<para>[root@inferno dalth]# </para>
<para>[root@inferno dalth]# mdadm --create \</para>
<para>&gt;                           /dev/md0 --level=1 \</para>
<para>&gt;                           --raid-devices=2 /dev/hdb1 /dev/hdb2</para>
<para>mdadm: array /dev/md0 started.</para>
<para>[root@inferno dalth]# </para>
<para>[root@inferno dalth]# mdadm -Q /dev/md0</para>
<para>/dev/md0: 491.63MiB raid1 2 devices, 0 spares.</para>
<para>[root@inferno dalth]# </para>
<para>[root@inferno dalth]# mdadm –S /dev/md0</para>
<para>[root@inferno dalth]# </para>
<para>[root@inferno dalth]# mdadm –assemble /dev/md0 /dev/hdb1 /dev/hdb2</para>
<para>mdadm: /dev/md0 has been started with 2 drives.</para>
<para>[root@inferno dalth]#</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Последняя команда демонстрирует активизацию массива путем указания имени md-устройства и нескольких блочных устройств, на которых оно базируется. Все остальные параметры (размеры блоков, разновидность RAID и т.д.) утилита mdadm извлекла из суперблока массива. Как уже отмечалось, суперблок массива содержит еще и уникальный идентификатор массива, что дает возможность проидентифицировать каждое исходное блочное устройство на предмет его принадлежности к какому-либо массиву. Ниже приведен пример вывода утилиты mdadm, демонстрирующий как можно получить некоторые полезные данные о массиве, а строка, содержащая UID массива выделена жирным текстом:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@viking root]# mdadm -Q -D /dev/md0</para>
<para>/dev/md0:</para>
<para>        Version : 00.90.01</para>
<para>  Creation Time : Fri Oct  8 14:29:21 2004</para>
<para>     Raid Level : raid1</para>
<para>     Array Size : 102336 (99.94 MiB 104.79 MB)</para>
<para>    Device Size : 102336 (99.94 MiB 104.79 MB)</para>
<para>   Raid Devices : 2</para>
<para>  Total Devices : 2</para>
<para>Preferred Minor : 0</para>
<para>    Persistence : Superblock is persistent</para>
<para/>
<para>    Update Time : Fri Oct  8 14:32:22 2004</para>
<para>          State : clean, no-errors</para>
<para> Active Devices : 2</para>
<para>Working Devices : 2</para>
<para> Failed Devices : 0</para>
<para>  Spare Devices : 0</para>
<para/>
<para>    Number   Major   Minor   RaidDevice State</para>
<para>       0     253       24        0      active sync   /dev/hdb1</para>
<para>       1     253       25        1      active sync   /dev/hdb2</para>
<para>           UUID : 8696ffc0:52547452:ba369881:d1b252d0</para>
<para>         Events : 0.3</para>
<para>[root@viking root]#</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Впоследствии этот идентификатор может быть использован в файле конфигурации для утилиты mdadm. В конфигурационном файле /etc/mdadm.conf можно указать список устройств и правила их построения, после чего описанные в нем md-устройства будут автоматически собираться и разбираться без указания списка исходных устройств:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@viking root]# cat /etc/mdadm.conf</para>
<para>MAILADDR root</para>
<para>ARRAY /dev/md0 UUID=8696ffc0:52547452:ba369881:d1b252d0</para>
<para>DEVICE /dev/hdb*</para>
<para>[root@viking root]#</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>В листинге видно, что устройство массив md0 имеет указанный идентификатор, а также указано, что для построения массивов могут быть использованы все раделы диска hdb. В этом примере если системный администратор напишет команду mdadm –assemble /dev/md0, то mdadm просканирует все файлы устройств с именами, совпадающими с шаблоном /dev/hdb* и подключит к массиву md0 те из них, на которых будет найдена суперблок массива с тем идентификатором, который указан в параметре ARRAY для устройства /dev/md0.</para>
<para>Системный администратор, который хочет расположить корневую файловую систему на md-устройстве, должен указать ядру при загрузке какие именно физические блочные устройства должны входить в md-устройство, на котором содержится корневая файловая система. Обычно это делается путем загрузки ядра командной строкой с опциями следующего вида:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>linux md0=0,/dev/hdb1,/dev/hdb2 root=/dev/md0</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Данный пример приведен скорее как иллюстративный, поскольку в зависимости от опций, использованных при создании RAID-устройства, на котором расположена корневая файловая система, командная строка ядра может меняться. В современных дистрибутивах при необходимости инициализации md-устройств для загрузки системы, как правило код и утилиты инициализации устройства помещаются в initrd.</para>
<para>Суперблок массива записывается не в начале блочного устройства, а ближе к его середине или концу. Сделано это было для того, чтобы можно было создать RAID-массив с boot-сектором, который сможет быть прочитан не только ядром Linux с драйвером md, но и базовым загрузчиком BIOS, вследствие чего можно объединить в RAID-массив не разделы жестких дисков, а непосредственно физические диски. Тогда загрузчик, установленный в начало RAID-устройства, окажется установленным в начало жесткого диска, после чего можно использовать при загрузке ядра следующую командную строку:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>linux md0=d0,/dev/hda,/dev/hdb root=/dev/md_d0p1</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Драйвер md также поддерживает возможность задания hotswap-устройств для массивов, т.е. резервных устройств, которые могут быть активизированы в при сбое одного из основных устройств в массиве.</para>
<para>Поддержка устройств software RAID в Linux дает возможность создавать серверы с высокой отказоустойчивостью и быстродействием.</para></sect3><sect3><title>Device mapper</title>
<para>В ядрах линейки 2.6 появилась еще одна подсистема по некоторым функциям аналогичная подсистеме MD, и называемая device-mapper. Это модульная компонентная подсистема, позволяющая с помощью специальных команд создать одно блочное устройство из нескольких кусков других блочных устройств,  а также определить правила, по которым производится запись на эти «нижележащие» блочные устройства.</para>
<para>LVM работает именно через подсистему device mapper, и на самом деле все утилиты LVM на самом деле просто передают инструкции о том из каких фрагментов каких блочных устройств состоит какой том LVM в драйвер device mapper, в каком порядке осуществляется запись и чтение данных, и впоследствии при записи на том LVM или чтении с него, работа на самом деле ведется с устройствами, обслуживаемыми драйвером device mapper, который и делает всю работу.</para>
<para>Данная многоуровневая архитектура позволяет значительно упростить и таким образом значительно повысить стабильность работы системы, поскольку реализация нескольких небольших узкофункциональных компонентов в общей сложности содержит меньше ошибок, чем реализация всех этих функций в одной подсистеме.</para></sect3><sect3><title>Host-RAID, или дешевых RAID-контроллеров не бывает</title>
<para>Сегодня даже для дешевых современных материнских плат фирмы-производители часто декларируют «аппаратную поддержку RAID» и у многих пользователей этот факт вызывает недоумение – как же так, мой Linux не умеет работать с RAID?! На самом деле все проще – задекларированная и разрекламированная поддержка RAID-массивов на материнских платах для офисных и домашних компьютеров – это миф.</para>
<para>Вся поддержка RAID в таких «контроллерах» на самом деле представляют собой просто небольшое расширение в BIOS и без специальных драйверов в 32/64-битных операционных системах не работают, а все функции RAID для них выполняются драйвером. Если в Windows для каждого из таких контроллеров фирма-производитель пишет драйвер, то в Linux ситуация немного иная.</para>
<para>Для реализации возможности работы с такими псевдо-RAID контроллерами (иногда называемыми fake-RAID) была разработана утилита dmraid. При запуске она сканирует жесткие диски в поисках специальных блоков (функционально аналогичных суперблокам уже знакомых нам md-устройств), записываемых такими fake-RAID контроллерами, и если ей удалось распознать формат этого специального блока, то dmraid инструктирует подсистему device-mapper о том, в каком порядке следует считывать блоки с жестких дисков.</para>
<para>После этого device-mapper создает блочное устройство, при записи или чтение данных с которого данные автоматически читаются и пишутся так, как сделал бы это драйвер от производителя материнской платы или контроллера.</para></sect3></sect2><sect2><title>Сетевая подсистема</title>
<para>Ключевым (с нашей точки зрения) объектом сетевой подсистемы Linux является интерфейс. Сетевой интерфейс в Linux – это абстрактный именованный объект, используемый для передачи данных через некоторую линию связи без привязки к ее (линии связи) реализации. Конечно, сказано мудрено – но попробуем объяснить «на пальцах».</para>
<para>Например, если в системе существует интерфейс eth0, то в большинстве случаев на современных компьютерах он сопоставлен Ethernet-адаптеру, встроенному в материнскую плату. Интерфейс с именем ppp0 отвечает за некоторое соединение «точка-точка» с другим компьютером. Интерфейс с именем lo является виртуальным и представляет как бы замкнутый сам на себя (вход непосредственно подключен к выходу) сетевой адаптер.</para>
<para>Основная задача интерфейса – абстрагироваться от физической составляющей канала. То есть программы и система будут использовать один и тот же метод «отправить пакет» для отправки данных через любой интерфейс – хоть lo, хоть ethX, хоть pppY, и точно так же использовать один и тот же метод «принять пакет» - то есть создается унифицированный API передачи данных, независимый от носителя.</para>
<para>Для того, чтобы ознакомиться с интерфейсами, можно воспользоваться командой ifconfig:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>$ ifconfig -a</para>
<para>eth0      Link encap:Ethernet  HWaddr 00:11:2F:A8:DE:A4</para>
<para>          inet addr:172.23.2.114  Bcast:172.23.2.255  Mask:255.255.255.0</para>
<para>          UP BROADCAST MULTICAST  MTU:1500  Metric:1</para>
<para>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</para>
<para>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</para>
<para>          collisions:0 txqueuelen:1000</para>
<para>          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)</para>
<para>          Interrupt:11 Base address:0x4000</para>
<para/>
<para>lo        Link encap:Local Loopback</para>
<para>          inet addr:127.0.0.1  Mask:255.0.0.0</para>
<para>          UP LOOPBACK RUNNING  MTU:16436  Metric:1</para>
<para>          RX packets:60 errors:0 dropped:0 overruns:0 frame:0</para>
<para>          TX packets:60 errors:0 dropped:0 overruns:0 carrier:0</para>
<para>          collisions:0 txqueuelen:0</para>
<para>          RX bytes:4707 (4.5 KiB)  TX bytes:4707 (4.5 KiB)</para>
<para/>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>В данном случае мы видим в системе два активных интерфейса, eth0 и lo, а также некоторую информацию об их состоянии, настройках и параметрах и состоянии аппаратуры для интерфейса eth0. В частности, поле Link encap характеризует тип интерфейса, HWAddr – аппаратный адрес устройства (например, MAC-адрес для Ethernet), MTU – максимальный размер передаваемого пакета. Также могут представлять интерес поля статистики – они сообщают, какой объем данных был передан и получен через соответствующий интерфейс.</para>
<para>Наиболее часто встречающиеся типы интерфейсов:</para>
<orderedlist>
<listitem>
<para>eth (Ethernet) – обычно соответствует отдельному сетевому адаптеру</para>
</listitem>
<listitem>
<para>ppp (Point-To-Point) – соединение точка-точка, например при коммутируемом доступе, но очень часто используется и при организации VPN</para>
</listitem>
<listitem>
<para>slip (Serial Line IP) – соединение точка-точка, устаревший протокол</para>
</listitem>
<listitem>
<para>wl (Wireless) – беспроводной интерфейс, обычно сопоставлен соответствующему адаптеру</para>
</listitem>
<listitem>
<para>lo (Loopback) – интерфейс-«петля», то есть что послал, то и получил - используется для общения между сетевыми приложениями в рамках одного компьютера</para>
</listitem>
</orderedlist>
<para>Команда ifconfig может также использоваться для остановки или активации интерфейса, а также изменения его параметров, связанных с протоколом IP:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para># ifconfig eth0 down</para>
<para># ifconfig eth0 up</para>
<para># ifconfig eth0 inet 192.168.2.210 netmask 255.255.255.0</para>
<para># ifconfig eth0 mtu 296</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Для управления параметрами других протоколов используются другие команды – например, ipx_config для управления параметрами, связанными с протоколом IPX. Рассмотрим также картинку, на которой приведена приблизительная схема взаимодействия различных драйверов и сетевых подсистем ядра:</para>
<para>
<para>Интерфейс ppp0</para>
<para/>
<para>Приложение</para>
<para>Интерфейс eth0</para>
<para>Драйвер сетевой карты</para>
<para>Системный вызов socket, send, recv</para>
<para>Драйвер протокола</para>
<para>Демон поддержки PPP</para>
<para>/dev/ttyS0</para>
<para>Драйвер COM-порта</para>
<para>Интерфейс lo</para>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
</para>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para>Предположим, что приложение пытается отправить пакет. Перед отправкой через системные вызовы группы socket (bind, connect и пр.)  приложение настраивает специальный файловый дескриптор. После окончания настройки каждый записанный в этот дескриптор пакет должен быть отправлен по сети получателю. Как движется пакет в нашей системе? Прежде всего, пакет попадает в драйвер протокола. Этот драйвер определяет через какой интерфейс должна производиться отправка, дописывает к пакету необходимые заголовки и отдает пакет на обработку соответствующему интерфейсу (точнее, ставит пакет в очередь, связанную с этим интерфейсом).</para>
<para>Что драйвер сделает с пакетом, это уже его дело. Например, драйвер интерфейса loopback этот пакет вынет из очереди и сразу поставит в очередь «принятых», откуда его впоследствии заберет драйвер протокола (левая цепочка на схеме). Драйвер интерфейса eth0 допишет к пакету заголовки Ethernet и передаст пакет драйверу сетевого адаптера, и уже тот непосредственно проинструктирует сетевой адаптер, откуда взять и как отправить пакет (правая цепочка). В средней же цепочке мы видим схему работы PPP, когда пакет помещается в очередь интерфейса ppp0, откуда его заберет демон pppd. Демон допишет в пакет нужные заголовки, и через символьный специальный файл /dev/ttyS0 передаст пакет драйверу COM-порта, а тот непосредственно будет работать с аппаратурой. Соответственно, при приемке данных цепочки проходятся в обратном порядке.</para></sect2><sect2><title>Маршрутизация IP и форвардинг</title>
<para>Маршрутизация транзитных IP-пакетов (не предназначенных для этого компьютера), или IP-форвардинг, является опциональной возможностью IP-стека Linux. По умолчанию функция форвардинга не активируется, и система не пересылает транзитные пакеты через свои интерфейсы, а только обрабатывает адресованные ей пакеты. Включение форвардинга IP-пакетов производится через параметр net.ipv4.ip_forward интерфейса sysctl. Если значение этого параметра равно 0, то форвардинг отключен, если же значение параметра не равно 0, форвардинг включен:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[dalth@viking dalth]$ sysctl net.ipv4.ip_forward</para>
<para>net.ipv4.ip_forward = 0</para>
<para>[dalth@viking dalth]$ </para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Кроме того, возможно разрешать или запрещать участие в форвардинге для каждого интерфейса индивидуально:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[dalth@viking dalth]$ sysctl -a | grep forward | grep v4</para>
<para>net.ipv4.conf.vmnet1.mc_forwarding = 0</para>
<para>net.ipv4.conf.vmnet1.forwarding = 0</para>
<para>net.ipv4.conf.eth0.mc_forwarding = 0</para>
<para>net.ipv4.conf.eth0.forwarding = 0</para>
<para>net.ipv4.conf.lo.mc_forwarding = 0</para>
<para>net.ipv4.conf.lo.forwarding = 0</para>
<para>net.ipv4.conf.default.mc_forwarding = 0</para>
<para>net.ipv4.conf.default.forwarding = 0</para>
<para>net.ipv4.conf.all.mc_forwarding = 0</para>
<para>net.ipv4.conf.all.forwarding = 0</para>
<para>net.ipv4.ip_forward = 0</para>
<para>[dalth@viking dalth]$</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>По умолчанию форвардинг включается и выключается для всех интерфейсов одновременно, но для отдельных интерфейсов возможно сменить флаг участия в форвардинге. Изменять параметры форвардинга может только системный администратор или пользователь, который имеет право записи в необходимые файлы интерфейса sysctl. Следующий листинг демонстрирует включение форвардинга через все интерфейсы путем вызова программы sysctl:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@viking dalth]# sysctl -w net.ipv4.ip_forward=1</para>
<para>net.ipv4.ip_forward = 1</para>
<para>[root@viking dalth]# sysctl -a | grep forward | sort</para>
<para>net.ipv4.conf.all.forwarding = 1</para>
<para>net.ipv4.conf.all.mc_forwarding = 0</para>
<para>net.ipv4.conf.default.forwarding = 1</para>
<para>net.ipv4.conf.default.mc_forwarding = 0</para>
<para>net.ipv4.conf.eth0.forwarding = 1</para>
<para>net.ipv4.conf.eth0.mc_forwarding = 0</para>
<para>net.ipv4.conf.lo.forwarding = 1</para>
<para>net.ipv4.conf.lo.mc_forwarding = 0</para>
<para>net.ipv4.conf.vmnet1.forwarding = 1</para>
<para>net.ipv4.conf.vmnet1.mc_forwarding = 0</para>
<para>net.ipv4.ip_forward = 1</para>
<para>[root@viking dalth]#</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>В процессе маршрутизации для выбора интерфейса и следующего узла для доставки пакета (next hop) ядро использует таблицу маршрутизации. Эта таблица представляет список критериев, в соответствии с которыми выбирается следующий узел. В частности, в таблице маршрутизации фигурируют следующие условия: адрес сети получателя пакета, маска подсети получателя пакета, IP-адрес следующего узла, метрика маршрута и служебные поля (например, тип и возраст записи). Таблица маршрутизации используется не только в IP-форвардинге, но и даже при простой отсылке IP-пакета для выбора интерфейса, через который будет производиться отсылка пакета.</para>
<para>Запись о сети с адресом 0.0.0.0 и маской подсети 0.0.0.0 называют маршрутом по умолчанию, или default route. Узел, чей адрес указан в поле gateway для маршрута по умолчанию, называют маршрутизатором по умолчанию, или default gateway или default router. В системе может быть произвольное количество маршрутов по умолчанию, но они должны быть как минимум с разными метриками. Для просмотра таблицы маршрутизации можно воспользоваться командой route. Эта команда позволяет оперировать с таблицей маршрутов, добавляя и удаляя из нее записи.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@inferno dalth]# route -n</para>
<para>Kernel IP routing table</para>
<para>Destination   Gateway      Genmask         Flags Metric Ref  Use Iface</para>
<para>10.80.1.113   0.0.0.0      255.255.255.255 UH    0      0      0 ppp0</para>
<para>127.0.0.0     0.0.0.0      255.0.0.0       U     0      0      0 lo</para>
<para>0.0.0.0       10.80.1.113  0.0.0.0         UG    0      0      0 ppp0</para>
<para>[root@inferno dalth]# route del default</para>
<para>[root@inferno dalth]# route -n</para>
<para>Kernel IP routing table</para>
<para>Destination   Gateway      Genmask         Flags Metric Ref  Use Iface</para>
<para>10.80.1.113   0.0.0.0      255.255.255.255 UH    0      0      0 ppp0</para>
<para>127.0.0.0     0.0.0.0      255.0.0.0       U     0      0      0 lo</para>
<para>[root@inferno dalth]# route add default dev ppp0</para>
<para>[root@inferno dalth]# </para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>В данном выводе таблица упорядочена по маске подсети, что соответствует порядку ее просмотра ядром. Столбцы Destination и Genmask содержат адрес и маску сети получателя пакета, столбец Metric фактически указывает приоритет маршрута (маршрут с меньшей метрикой более приоритетен), поле Gateway указывает IP-адрес следующего узла для передачи пакета. Некоторые типы интерфейсов (в частности, интерфейсы типа точка-точка, или point-to-point) подразумевают, что на принимающем конце линии связи всегда находится не более одного узла, и поэтому в этой ситуации IP-адрес следующего узла можно не указывать. В данном случае мы видим, что в приведенном примере некоторые узлы доступны через интерфейс ppp0 типа точка-точка. В частности, именно из-за этого свойства приведенная выше таблица оказывается эквивалентна следующей ниже. Жирным шрифтом помечена измененная строка, демонстрирующая “точечную” природу PPP-соединения:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>[root@inferno dalth]# route -n</para>
<para>Kernel IP routing table</para>
<para>Destination   Gateway     Genmask         Flags Metric Ref    Use Iface</para>
<para>10.80.1.113   0.0.0.0     255.255.255.255 UH    0      0        0 ppp0</para>
<para>127.0.0.0     0.0.0.0     255.0.0.0        U     0      0        0 lo</para>
<para>0.0.0.0       0.0.0.0     0.0.0.0         U     0      0        0 ppp0</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Специфика использования протокола PPP (обычно используемого при модемых соединениях) такова, что любой PPP-интерфейс является интерфейсом типа точка-точка, более того – PPP и расшифровывается как Point-to-Point Protocol. Также интерфейсами точка-точка являются интерфейсы SLIP (Serial Line IP) и практически все разновидности туннельных интерфейсов.</para>
<para>При деактивизации интерфейса из таблицы маршрутизации автоматически исключаются все маршруты, для которых в поле Iface был указан отключившийся интерфейс. Для некоторых типов интерфейсов при активизации в таблице маршрутизации также создаются служебные записи о маршрутах, которые нельзя удалить.</para>
<para>В большинстве случаев таблица маршрутизации имеет не слишком большой размер, но в некоторых ситуациях (в частности, на шлюзовых машинах в больших сетях) таблица может иметь весьма значительный размер и изменяется не “вручную” с помощью команды route, а специальными программами – демонами поддержки протоколов динамической маршрутизации. С некоторыми упрощениями алгоритм работы этих демонов можно описать следующим образом: демон “слушает” приходящие пакеты для обслуживаемых протоколов динамической маршрутизации, и по получении (или неполучении) такого пакета отдает ядру команду на изменение таблицы маршрутизации.</para>
<para>Следует также заметить, что команда route в режиме вывода таблицы маршрутизации фактически просто фильтрует и форматирует данные, содержащиеся в специальном файле, называемом /proc/net/route, используемом для доступа к таблице маршрутизации, ведущейся ядром.</para></sect2><sect2><title>Фильтры пакетов</title>
<para>Возможность инсталляции фильтров пакетов является очень интересной возможностью, предоставляемой стеком TCP/IP ядра Linux. Не углубляясь в детали просто отметим, что IP-стек Linux позволяет различным модулям установить “ловушки” (hooks) для пакетов. При этом каждый пакет, попадающий в такую ловушку, передается для обработки драйверу, установившему эту ловушку. Драйвер, в свою очередь, может проанализировать пакет, проделать какие-либо действия с пакетом, после чего вернуть код обработки, инструктируя таким образом ядро о том, что следует делать с пакетом дальше – вернуть ли отправителю сообщение об ошибке, прервать ли обработку и уничтожить пакет, либо продолжать обработку пакета обычным образом.</para>
<para>В настоящее время для фильтрации пакетов наиболее часто используются средства iptables. iptables – это название утилиты, которая позволяет настроить множество драйверов сетевой подсистемы NETFILTER ядра Linux, позволяющих осуществить анализ, произвести преобразование, или изменить обработку IP-пакетов. Основным объектом в iptables является цепочка правил (chain). Каждое правило в цепочке содержит набор условий совпадения (condition matches) и действие (action). Цепочки сгруппированы в таблицы (tables).</para>
<para>Действий есть две разновидности – прерывающие обработку пакета в цепочке, например действия DROP или ACCEPT, и не прерывающие обработку пакета цепочкой – например, LOG или MARK.</para>
<para>Цепочки используются для проверки пакетов – то есть пакет поочередно последовательно сравнивается с каждым из правил цепочки, и если он удовлетворяет всем условиям в правиле, к пакету применяется действие, указанное в этом правиле. Если действие является прерывающем, то на этом обработка пакета этой цепочкой заканчивается, если действие не прерывающее, то пакет продолжает проверяться этой же цепочкой.</para>
<para>Стандартные цепочки также содержат специальное неявное действие по умолчанию, называемое политикой цепочки (chain policy). Действие, указанное как политика цепочки, применяется ко всем пакетам, которые не попали ни под одно правило с “прерывающим” действием.</para><sect3><title>Стандартные таблицы и цепочки</title>
<para>Подсистема пакетного фильтра содержит три таблицы, в каждой из которых содержатся несколько цепочек (наборов правил). Кроме того, администратор может создавать собственные цепочки правил. Ниже перечисляются стандартные таблицы и цепочки:</para>
<informaltable frame="all">
<tgroup cols="2.3333333333333335">
<thead>
<row>
<entry>
<para>Таблица</para>
</entry>
<entry>
<para>Назначение</para>
</entry>
<entry>
<para>Цепочки</para>
</entry>
<entry>
<para>Назначение</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>mangle</para>
</entry>
<entry>
<para>Модификация пакетов</para>
</entry>
<entry namest="c3" nameend="c4">
<entry>
<para>PREROUTING</para>
</entry>
<entry>
<para>Модификация всех пришедших пакетов</para>
</entry>
<entry>
<para>INPUT</para>
</entry>
<entry>
<para>Модификация пакетов, пришедших на адрес компьютера</para>
</entry>
<entry>
<para>FORWARD</para>
</entry>
<entry>
<para>Модификация пакетов, которые должны быть отмаршрутизированы (пересланы на другой хост)</para>
</entry>
<entry>
<para>OUTPUT</para>
</entry>
<entry>
<para>Модификация пакетов, сгенерированных процессами данного хоста</para>
</entry>
<entry>
<para>POSTROUTING</para>
</entry>
<entry>
<para>Модификация всех переданных пакетов</para>
</entry>
</entry>
</row>
<row>
<entry>
<para>filter</para>
</entry>
<entry>
<para>Фильтрация пакетов – принятие решения об их дальнейшей обработке или отказе от обработки)</para>
</entry>
<entry namest="c3" nameend="c4">
<entry>
<para>INPUT</para>
</entry>
<entry>
<para>Фильтрация адресованных этому компьютеру пакетов</para>
</entry>
<entry>
<para>OUTPUT</para>
</entry>
<entry>
<para>Фильтрация сгенерированных этим компьютером пакетов</para>
</entry>
<entry>
<para>FORWARD</para>
</entry>
<entry>
<para>Фильтрация маршрутизируемых (транзитных) пакетов</para>
</entry>
</entry>
</row>
<row>
<entry>
<para>nat</para>
</entry>
<entry>
<para>Трансляция адресов</para>
</entry>
<entry namest="c3" nameend="c4">
<entry>
<para>PREROUTING</para>
</entry>
<entry>
<para>Трансляция адресов всех принимаемых пакетов</para>
</entry>
<entry>
<para>FORWARD</para>
</entry>
<entry>
<para>Трансляция адресов транзитных пакетов</para>
</entry>
<entry>
<para>POSTROUTING</para>
</entry>
<entry>
<para>Трансляция адресов всех передаваемых пакетов</para>
</entry>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Таблица nat обладает “двойственным” действием, т.е. если вы включите преобразование для входящих пакетов, исходящие пакеты также будут модифицироваться, и наоборот. Таблицы mangle и nat изменяют пакеты, но mangle не ведет список изменений, т.е. является “однонаправленной” таблицей.</para></sect3><sect3><title>Порядок применения стандартных таблиц и цепочек</title>
<para>Рассмотрим, какой путь проходит пакет в цепочках и таблицах iptables. Для входящих пакетов (адресованных компьютеру, на котором активизирована поддержка iptables) верна следующая последовательность применения цепочек:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>1. mangle.PREROUTING</para>
<para>2. nat.PREROUTING</para>
<para>3. mangle.INPUT</para>
<para>4. filter.INPUT</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Для пакетов, отправляемых с компьютера, реализуется следующая цепочка обработки:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>1. filter.OUTPUT</para>
<para>2. mangle.OUTPUT</para>
<para>3. nat.POSTROUTING</para>
<para>4. mangle.POSTROUTING</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Пакеты, являющиеся транзитными (маршрутизируемыми), т.е. не адресованные фильтрующему компьютеру и не сгенерированные фильтрующим компьютером, проходят по следующей последовательности цепочек и таблиц:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>1. mangle.PREROUTING</para>
<para>2. nat.PREROUTING</para>
<para>3. mangle.FORWARD</para>
<para>4. filter.FORWARD</para>
<para>5. nat.FORWARD</para>
<para>6. nat.POSTROUTING</para>
<para>7. mangle.POSTROUTING</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable></sect3><sect3><title>Стандартные действия</title>
<para>Каждое правило в любой цепочке может ссылаться на одно из стандартных или дополнительных действий, либо на какую-либо пользовательскую цепочку. Основное различие между стандартными и дополнительными действиями в том, что стандартные действия могут указываться в правилах любых цепочек любых таблиц, а дополнительные действия можно указывать только для некоторых цепочек некоторых таблиц. Перечислим стандартные действия:</para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>ACCEPT</para>
</entry>
<entry>
<para>Прервать проверку пакета цепочкой и перейти к следующей в порядке обработки пакета стандартной цепочке</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>DROP</para>
</entry>
<entry>
<para>Прервать обработку пакета, сам пакет удалить</para>
</entry>
</row>
<row>
<entry>
<para>RETURN</para>
</entry>
<entry>
<para>Прервать проверку пакета цепочкой и вернуться к проверке вышестоящей цепочкой, а если действие встретилось в одно из стандартных цепочек, поступить с пакетом так, как предписано в политике цепочки (chain policy)</para>
</entry>
</row>
<row>
<entry>
<para>QUEUE</para>
</entry>
<entry>
<para>Передать пакет некоторому процессу для дальнейшей обработки</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Интересной особенностью также является то, что существуют так называемые target extensions, которые реализованы как модули и также могут использоваться для указания проводимого над пакетом действия. В частности, к таким действиям, например, относятся действия LOG – запротоколировать факт получения пакета, MASQUERADE – подменить IP-адрес отправителя пакета, MARK – пометить пакет и многие другие. Некоторые действия могут встречаться не во всех цепочках, а только в некоторых цепочках некоторых таблиц.</para>
<para>Еще одним специфическим действием можно назвать переход к пользовательской цепочке. При этом, если пакет в процессе обработки попадает под действие правила, у которого в качестве действия указан переход к другой цепочке, то пакет начинает проверяться ее правилами. Это часто используется, чтобы сходным образом обрабатывать некоторые виды пакетов.</para></sect3><sect3><title>Условия отбора</title>
<para>Условия отбора делятся на две группы – стандартные условия, которые применимы ко всем пакетам, и расширенные условия, называемые также match extensions. Расширенные условия могут применяться не для всех пакетов, а только для некоторых из них – например, дополнительные условия для протокола UDP включают в себя адреса портов отправителя и получателя, а для ICMP – тип и код ICMP-сообщения.</para></sect3><sect3><title>Примеры конфигураций iptables</title>
<para>Попробуем рассмотреть несколько простых примеров, достаточно часто используемых в реальных конфигурациях. Стоит заметить, что самостоятельная конфигурация пакетного фильтра требует некоторых (точнее, достаточно значительных) знаний сетевых протоколов, поскольку в конфигурации необходимо задавать множество критериев, которые сильно зависят от ситуации и от используемых сервисов.</para>
<para/>
<para>Пример 1: простейшая конфигурация iptables для домашнего компьютера, подключенного к Internet. В этой конфигурации мы запретим все входящие соединения, а также все исходящие пакеты UDP кроме тех, которые необходимы для нормальной работы в Internet с использованием PPP-соединения. В этой конфигурации мы разрешаем передачу всех пакетов в рамках локальной машины, разрешаем исходящие TCP-пакеты, разрешаем входящие пакеты TCP для уже установленных соединений, и разрешаем передачу и прием UDP-пакетов для службы DNS и пакетов автоматической конфигурации соединения PPP (пакетов DHCP). Кроме того, следует разрешить прием управляющих пакетов ICMP и отправку запросов и прием ответов PING:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para># iptables -P INPUT DROP</para>
<para># iptables -A INPUT -j ACCEPT -i lo</para>
<para># iptables -A INPUT -j ACCEP -p tcp ! --syn</para>
<para># iptables -A INPUT -j ACCEPT -p udp --source-port 53</para>
<para># iptables -A INPUT -j ACCEPT -p udp --source-port 67 --destination-port 68</para>
<para># iptables -A INPUT -j ACCEPT -p icmp --icmp-type destination-unreachable</para>
<para># iptables -A INPUT -j ACCEPT -p icmp --icmp-type time-exceeded</para>
<para># iptables -A INPUT -j ACCEPT -p icmp --icmp-type parameter-problem</para>
<para># iptables -A INPUT -j ACCEPT -p icmp --icmp-type echo-reply</para>
<para># iptables -P OUTPUT DROP</para>
<para># iptables -A OUTPUT -j ACCEPT -p tcp</para>
<para># iptables -A OUTPUT -j ACCEPT -p udp --destination-port 53</para>
<para># iptables -A OUTPUT -j ACCEPT -p udp --destination-port 67 --source-port 68</para>
<para># iptables -A OUTPUT -j ACCEPT -p icmp --icmp-type echo-request</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para/>
<para>Пример 2: то же самое, что в примере 1, но все “отбитые” пакеты протоколируются. Для того, чтобы добиться такого эффекта, нужно создать дополнительную цепочку, которая будет протоколировать и удалять пакеты. Эту цепочку мы назовем KILLER – вполне обоснованно, не так ли? Кроме того, мы исправим политики стандартных цепочек так, чтобы запрещенные пакеты не удалялись, а “забрасывались” в созданную нами цепочку KILLER, а нашей основной цели (сначала протоколировать, потом удалить пакет) можно добиться просто указав два действия – сначала LOG, затем DROP. Поскольку действие LOG не является прерывающим обработку, мы получим требуемый нам эффект:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para># iptables -N KILLER</para>
<para># iptables -A KILLER -j LOG</para>
<para># iptables -A KILLER -j DROP</para>
<para># iptables -P INPUT KILLER</para>
<para># iptables -A INPUT -j ACCEPT -i lo</para>
<para># iptables -A INPUT -j ACCEP -p tcp ! --syn</para>
<para># iptables -A INPUT -j ACCEPT -p udp --source-port 53</para>
<para># iptables -A INPUT -j ACCEPT -p udp --source-port 67 --destination-port 68</para>
<para># iptables -A INPUT -j ACCEPT -p icmp --icmp-type destination-unreachable</para>
<para># iptables -A INPUT -j ACCEPT -p icmp --icmp-type time-exceeded</para>
<para># iptables -A INPUT -j ACCEPT -p icmp --icmp-type parameter-problem</para>
<para># iptables -A INPUT -j ACCEPT -p icmp --icmp-type echo-reply</para>
<para># iptables -P OUTPUT KILLER</para>
<para># iptables -A OUTPUT -j ACCEPT -p tcp</para>
<para># iptables -A OUTPUT -j ACCEPT -p udp --destination-port 53</para>
<para># iptables -A OUTPUT -j ACCEPT -p udp --destination-port 67 --source-port 68</para>
<para># iptables -A OUTPUT -j ACCEPT -p icmp --icmp-type echo-request</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para/>
<para>Пример 3: маскарад пакетов. Маскарадом называют преобразование IP-адресов проходящих пакетов так, чтобы они выглядели как отправленные с системы-маршрутизатора, а не с какого-либо узла “за” маршрутизатором. Достигается это путем изменения IP-адреса (и, возможно, номера порта) в “транзитных” пакетах. Собственно преобразование задается путем указания действий SNAT – замена адреса отправителя, DNAT – замена адреса получателя, или MASQUERADE – функционально аналогично SNAT, но без указания конкретного IP-адреса (IP-адресом для замены назначается IP-адрес интерфейса через который уходит пакет, со всеми отсюда вытекающими – например, если интерфейс меняет IP-адрес или просто деактивируется все «маскированные» через него соединения сбрасываются). Предположим, что наш “внешний” интерфейс имеет адрес 193.267.14.6, а внутренняя сеть имеет адрес 192.168.0.0/24. Тогда для того, чтобы дать всем компьютерам нашей сети доступ по протоколу TCP “наружу”, мы должны подать примерно следующую команду:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para># iptables -A POSTROUTING -t nat -j SNAT -o ppp0 \</para>
<para>&gt;   --to-source 193.267.14.6 -p tcp \</para>
<para>&gt;   --source 192.168.0.0/24 \</para>
<para>&gt;   --destination ! 192.168.0.0/24</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Если у нас внешний адрес динамический, а не статический (мы работаем по dialup – соединению), то мы можем использовать динамический маскарад без привязки к внешнему адресу – ну или с использованием динамической привязки, кому как больше нравится:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para># iptables -A POSTROUTING -t nat -j MASQUERADE -o ppp0 \</para>
<para>&gt;   --source 192.168.0.0/24 \</para>
<para>&gt;   --destination ! 192.168.0.0/24</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Действие SNAT более эффективно, MASQUERADE проще в использовании, но обладает рядом существенных недостатков (не вдаваясь в подробности, просто заметим, что на системе с несколькими интерфейсами и сложной таблицей маршрутизации проблемы почти наверняка будут). Особое внимание нужно обратить на указание -o ppp0, то есть действие применяется ТОЛЬКО для пакетов, отправляемых через интерфейс ppp0. Еще вы можете увидеть, что мы указываем это правило только один раз, и обратного к нему правила не строим - об этом позаботится функция connection tracking (отслеживание состояния соединений), и обратная замена адресов в отправляемых в ответ на наши запросы пакетах будет произведена системой автоматически.</para>
<para/>
<para>Пример 4: “проброс” пакетов во внутреннюю сеть. Обычно это используется, если мы хотим перебросить пакеты, пришедшие на адрес маршрутизатора, на какую-либо из машин внутренней сети (например, так можно предоставить доступ ко внутреннему WWW-серверу). Достигается это использованием действия DNAT (destination NAT). В нашем случае мы перебрасываем все TCP-пакеты, пришедшие на интерфейс маршрутизатора ppp0 на порт 80, на порт 85 компьютера с адресом 192.168.0.6:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para># iptables -A PREROUTING -t nat -j DNAT -i ppp0 \</para>
<para>&gt;   --to-destination 192.168.0.6:85 -p tcp --destination-ports 80</para>
</entry>
</row>
</thead>
</tgroup>
</informaltable>
<para>Конечно, приведенными примерами возможности iptables не исчерпываются, скорее даже наоборот – это лишь малая часть того, что умеет эта подсистема. Приведенные же примеры демонстрируют наиболее простые случаи, позволяющие составить некоторое представление об iptables и возможностях этой технологии.</para>
<para>В системах, основанных на RedHat Linux и его вариациях, есть специальный стартовый сценарий загрузки, также называемый iptables. Расположен он как правило в каталоге /etc/rc.d/init.d/. Этот сценарий при загрузке системы инсталлирует правила, созданные администратором, и его можно использовать для сохранения конфигурации iptables. В процессе конфигурации системный администратор задает конфигурацию подсистемы iptables, используя утилиту /sbin/iptables, а после окончания настройки дает команду /etc/rc.d/init.d/iptables save, после чего текущая конфигурация сохраняется в файл /etc/sysconfig/iptables. Существует также множество “фронтендов” для настройки iptables, которые могут использоваться начинающими пользователями и не слишком опытными администраторами, но “ручной” способ настройки все-таки предпочтительней, поскольку позволяет очень точно настроить подсистему iptables.</para></sect3></sect2><sect2><title>Управление пользователями, NSS и PAM</title>
<para>Linux – система многопользовательская. По умолчанию, большинство дистрибутивов используют «классический» набор файлов в которых хранится информация о пользователях и группах: /etc/passwd, /etc/group, /etc/shadow, /etc/gshadow. Во многих ситуациях этого вполне достаточно, но иногда возникает необходимость в интеграции Linux в более или менее чужеродное, либо просто распределенное окружение, и именно в этот момент к нам на помощь приходят такая интересная подсистема, как NSS – Name Service Switch. Основная задача NSS – создать модульное окружение для управления пользователями. Реализовано это посредством загружаемых библиотек. Основные вызовы NSS реализованы в библиотеке libc, а libc в свою очередь загружает и вызывает бакэнды</para>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para>NSS:</para>
<para/>
<para>
<para>Программа</para>
<para>Функции NSS (libc.so)</para>
<para>Бакэнд files</para>
<para>(libnss_files.so)</para>
<para>Бакэнд DNS</para>
<para>(libnss_dns.so)</para>
<para>Бакэнд LDAP</para>
<para>(libnss_ldap.so)</para>
<para>/etc/passwd</para>
<para>Сервер DNS</para>
<para>Сервер LDAP</para>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
</para>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para>При инициализации программы, так или иначе связанной с NSS, загружаются основная библиотека libc.so, которая считывает конфигурацию из файла /etc/nsswitch.conf, после чего также загружаются те библиотеки NSS, которые указаны в этом файле.</para>
<para>Впоследствии при работе программы, если программе требуется работать с именованными сущностями, соответствующие вызовы функций glibc будут обращаться к функциям NSS и использовать в те источники данных, которые указаны в nsswitch.conf.</para>
<para>В частности, через NSS можно разрешать (определять) имена и идентификаторы протоколов, номера портов служб (сервисов), имена и идентификаторы пользователей и групп, IP-адреса и имена компьютеров и некоторые другие данные.</para>
<para>Пример файла nsswitch.conf:</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>[viking@alpha etc]$ cat /etc/nsswitch.conf</para>
<para>passwd:     files ldap</para>
<para>shadow:     files ldap</para>
<para>group:      files ldap</para>
<para>hosts:      files dns </para>
<para>bootparams: nisplus [NOTFOUND=return] files </para>
<para>ethers:     files </para>
<para>netmasks:   files </para>
<para>networks:   files </para>
<para>protocols:  files </para>
<para>rpc:        files </para>
<para>services:   files </para>
<para>netgroup:   nisplus </para>
<para>publickey:  nisplus </para>
<para>automount:  files nisplus </para>
<para>aliases:    files nisplus </para>
<para>[viking@alpha etc]$</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>В данном примере указано, что для определения имен пользователей и групп используются сначала текстовые файлы и затем LDAP, для определения имен компьютеров и IP-адресов используются сначала текстовые файлы и затем DNS, для определения алиасов и настроек автоматического монтирования каталогов используются сначала текстовые файлы и затем служба NIS+.</para>
<para>Библиотеки бакэндов системы NSS хранятся в файлах libnss_XXX.so, где XXX – это имя бакэнда. Например libnss_files.so – это бакэнд NSS использующий в качестве источника данных текстовые файлы, libnss_db.so – бакэнд использующий файлы BerkleyDB, libnss_ldap.so – бакэнд позволяющий хранить данные в каталоге LDAP. Как правило, каждый бакэнд имеет свои дополнительные конфигурационные файлы.</para>
<para>Как следствие, если у вас возникла необходимость использовать вашу Linux-систему в сетевом или чужеродном окружении и обеспечить ее интеграцию с ним, вы можете воспользоваться NSS и получить доступ к информации через соответствующий бакэнд – например, для интеграции в среду Solaris, вы можете воспользоваться бакэндом NIS/NIS+, для интеграции в ActiveDirectory – бакэндом LDAP.</para>
<para>При этом модульность NSS позволяет вам объединять различные источники данных – например, использовать текстовые файлы и DNS для определения имен компьютеров, NIS для определения имен протоколов и сервисов, и текстовые файлы и LDAP для определения имен и идентификаторов пользователей и групп.</para>
<para>Подсистема PAM (Pluggable Authentification Modules) идейно очень схожа с NSS, но отличается от нее назначением. Основная задачам PAM – аутентификация пользователей (проверка паролей, прав доступ, ограничений и так далее). Как и NSS, PAM состоит из набора основных библиотек и бакэндов, причем необходимые бакэнды, порядок их вызова и некоторые опциональные параметры определяются в конфигурационных файлах PAM, обычно они расположены в каталоге /etc/pam.d. Главным отличием PAM от NSS (кроме естественно назначения) является то, что PAM является не составной и неотъемлемой частью libc, а отдельным множеством библиотек.</para>
<para>Основная часть стандартных утилит UNIX для управления пользователями и группами и получения информации о них, в большинстве дистрибутивов Linux общего назначения, адаптирована и собрана с поддержкой NSS и PAM. К таким утилитам относятся passwd, chsh, chfn, id, who и другие. NSS также используется даже такими утилитами как ls, find, ps – то есть всеми теми программами, которые отображают имя пользователя. Соответственно, если программа запрашивает у пользователя пароль – скорее всего она использует и NSS, и PAM (например XDM или GDM). Большинство программ в чьи функции входит обработка почты также используют NSS. Соответственно, можно уверенно говорить что подсистемы NSS и PAM и базовые знания об их предназначении на сегодняшний день являются необходимыми для администратора Linux-систем.</para></sect2><sect2><title>X11 и все-все-все</title>
<para>Большинство нынешних дистрибутивов по умолчанию устанавливают для пользователя графическую среду X11 (X11 Windows System), под управлением которой и выполняются все графические приложения. Как «внутри» устроена X11? Прежде всего, X11 – это распределенная модульная среда, состоящая из двух основных компонентов: X-сервера и X-клиента.</para><sect3><title>Клиент-серверная архитектура X11</title>
<para>X-сервер – это программа, которая организует работу с устройствами ввода/вывода, производит отрисовку видимых элементов, запущена у пользователя и предоставляет свои ресурсы (те же самые устройства ввода-вывода) для X-клиентов. X-сервер загружает драйверы устройств (например видеокарты, мыши или клавиатуры), он же управляет переключением раскладок клавиатуры и т.п. Кроме того, X-сервер частично берет на себя функции работы со шрифтами. Задача использования аппаратного ускорения для отрисовки также является прерогативой X-сервера.</para>
<para>В современных дистрибутивах как правило используется открытый свободно распространяемый X-сервер называющийся Xorg. Его конфигурационный файл называется xorg.conf и расположен в каталоге /etc/X11. В конфигурационном файле описываются все устройства ввода, которые будет использовать X-сервер, настройки клавиатуры, драйвер видеокарты и многое другое. Более подробную информацию можно получить из справочного руководства [man Xorg, man xorg.conf].</para>
<para>X-клиент – это собственно пользовательская программа – браузер, почтовый клиент, видеоплеер, клиент мгновенных сообщений, игры, графические редакторы и просмотрщики и т.д.</para>
<para>Когда пользователь запускает графическое приложение, оно соединяется с X-сервером по стандартному протоколу X11, получает от X-сервера события о перемещении мыши, нажатиях кнопок клавиатуры и соответственно на них реагирует. Когда необходимо провести отрисовку, X-клиент отправляет соответствующие инструкции X-серверу, и уже X-сервер производит непосредственную отрисовку используя драйвер видеокарты. Команды протокола X11 могут передаваться как через разделяемую память или локальное соединение (если X-клиент и X-сервер запущены на одном компьютере), так и по сети – при этом X-клиент и X-сервер могут быть запущены на разных компьютерах.</para>
<para>X-сервер никаким образом не отвечает за внешний вид окна X-клиента – он отрисовывает все в точности так, как это указал клиент, более того – сам по себе X-сервер он не отрисовывает ни обрамлений окон, ни каких либо управляющих элементов, не обрабатывает никаких горячих клавиш – то есть он занимается только отрисовкой картинки присланной X-клиентом, а также чтением данных из устройств ввода и передачей соответствующих событий X-клиенту.</para>
<para>Обрамление окон, иконки рабочего стола, панели и кнопки – это все отрисовывается X-клиентами. Рассмотрим пример окна некоторого приложения (в нашем случае файлового менеджера Nautilus из состава среды GNOME):</para>
<para/>
<para/>
<para>На этой картинке на самом деле показан результат работы двух X-клиентов: собственно файлового менеджера nautilus (именно он управляет отрисовкой меню, строки статуса, панелей, иконок и так далее). Второй X-клиент – менеджер окон (window manager) под названием metacity нарисовал рамку окна и кнопки на этой рамке. При этом горячие клавиши для закрытия окна, сворачивания, перемещения и других операций с окном отрабатывает именно metacity, а горячие клавиши копирования файла, перехода по каталогам, навигации по меню, подсвечивание иконок и тому подобное отрабатывает уже сам nautilus.</para></sect3><sect3><title>Графическая среда пользователя</title>
<para>Графической средой мы будем называть набор программ, для пользователя для выполнения им повседневных функций. Каждая из этих программ как правило является самостоятельным X-клиентом и может работать сама по себе, даже без своих «коллег по окружению», но будучи собранными вместе, они начинают предоставлять пользователю цельный и органичный интерфейс. Достигается это обычно следующим образом:</para>
<orderedlist>
<listitem>
<para>Все программы данного графического окружения используют одну и ту же библиотеку для отрисовки своих элементов управления</para>
</listitem>
<listitem>
<para>В графическое окружение включается какой-либо менеджер окон</para>
</listitem>
<listitem>
<para>Все программы для данного окружения разрабатываются с соблюдением определенных общих требований</para>
</listitem>
<listitem>
<para>В состав окружение включаются самостоятельные программы для выполнения базовых функций - текстовые и табличные процессоры, графический редактор, браузер, IM-клиент и другие</para>
</listitem>
<listitem>
<para>В состав окружения включаются служебные программы, предоставляющие пользователю возможность вызова других программ – например, приложение которое отрисовывает панель, на которой размещается кнопка для вызова меню со списком установленных программ и список окон</para>
</listitem>
<listitem>
<para>В состав окружения включают утилиты для настройки оборудования и дополнительных функций</para>
</listitem>
</orderedlist>
<para>В результате внешний вид окружения становится единообразным, а тот факт что оно состоит из множества небольших программ делает графическую среду гибкой в настройке и стабильной в работе. В то же время обширный набор программ для различных функций делает повзволяет графическому окружению удовлетворить большинство потребностей пользователя, а привычная вам картина GNOME или KDE, которую вы видите на экране в процессе работы, является результатом совместной работы множества X-клиентов соответствующего окружения... Или нескольких окружений одновременно.</para>
<para>Наиболее распространенные графические среды в Linux – это GNOME и KDE. И та и другая среда имеют свою библиотеку для отрисовки элементов управления внутри окна (для GNOME это GTK, для KDE это Qt), включают в свой состав почтовый клиент, браузер, мультимедиа-проигрыватель, клиент мгновенных сообщений и графический редактор, файловый менеджер (он же по совместительству отрисовывает иконки на рабочем стол и отвечает за фон рабочего стола), программу которая отрисовывает боковые панели и набор маленьких программ-апплетов, которые встраиваются при необходимости в панели, игры, программы управления для настройки окружения и менеджер окон.</para>
<para>Некоторые X-клиенты не входят в состав какого-либо окружения – например, браузеры Firefox и Opera, медиапроигрыватель Mplayer, офисный пакет OpenOffice.Org. Самое главное что следует запомнить – что графическое окружение, или графическая среда – это всего лишь набор программ, а не одна большая программа вида «все-в-одном», и вы можете, работая в основном в одном окружении, абсолютно спокойно использовать программы другого.</para></sect3><sect3><title>Внутри X11. Упрощенная схема</title>
<para>X11 – система многослойная, но внутренне логичная и понятная. Схематически ее можно изобразить следующим образом:</para>
<para>
<para>Приложение</para>
<para>Тулкит (базовая билиотека: Qt, GTK, etc.)</para>
<para>Базовая библиотека X11 (libX11)</para>
<para>X-сервер</para>
<para>Драйверы устройств ввода</para>
<para>Драйверы устройств вывода</para>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
</para>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para>Когда приложение отрисовывает что-либо, оно обращается к своей базовой библиотеке, она в свою очередь переадресовывает вызов (или уже цепочку вызовов) в библиотеку libX11, которая использую X11 Core Protocol передает команды на X-сервер. X-сервер интерпретирует команды и передает их на отрисовку драйверам устройств вывода. Воздействие же пользователя на устройства ввода считываются X-сервером через драйвера устройств ввода, через X11 Core Protocol передаются X-клиенту, libX11 переводит команды протокола в события и передает события в тулкит, и уже тулкит передает события программе для того чтобы та на них отреагировала.</para>
<para>То как приложение выглядит – то есть внешний  вид строк ввода, полос скроллинга, панелей и кнопок – за все это отвечает библиотека-тулкит. Два наиболее распространенных на сегодняшний день тулкита, Qt и GTK, примерно равны по возможностям – они обеспечивают переносимость приложений, поддержку «тем» внешнего вида, предоставляют программисту объектно-ориентированный интерфейс и некоторый набор служебных функций и возможностей.</para>
<para>Базовая библиотека X11 (libX11, или Xlib) позволяет программе абстрагироваться и не связываться с низкоуровневыми функциями протокола X11, и таким образом обеспечивает сетевую прозрачность X11, то есть позволяет программам работать как с локальным X-сервером, так и с находящимся на другом компьютере, причем делается это незаметно для программы.</para></sect3><sect3><title>Внутри X11. Растровые шрифты и их отображение</title>
<para>С момента разработки в среде X11 отображение шрифтов управлял X-сервер. Приложение, когда ему необходимо вывести некоторый текст, просто инструктировало X-сервер «отобрази вот этот текст вот таким шрифтом в указанном месте». В ответ на это X-сервер выбирал из своей базы шрифтов наиболее подходящий, и использовал его для выполнения инструкций клиента, причем изначально эти шрифты были растровыми, то есть фактически содержали наборы заранее отрисованных глифов (символов).</para>
<para>Эта технология, называемая X Core Fonts, поддерживается в X11 и сейчас, поэтому в наборе пакетов любого дистрибутива всегда можно встретить наборы широко распространенных семейств растровых шрифтов – fixed, hevetica, times, courier. При этом каждый шрифт представляется множеством файлов, для различных сочетаний размера, ширины и начертания – например, если шрифт имеет десять вариантов размеров (от 8 до 18), две ширины (обычный и жирный) и два начертания (стандартное и курсив), то он будет представляться 40 файлами – по одному файлу для каждого из сочетаний размера, начертания и ширины.</para>
<para>Поскольку количество файлов получается очень большим, чтобы не устанавливать все эти шрифты на все компьютеры где запущены X-серверы, в систему X11 был введен такой объект как сервер шрифтов (font server). Системный администратор может настроить и запустить один сервер шрифтов для всей локальной сети, и указать X-серверу при запуске использовать шрифты с соответствующего сервера, что позволяет поддерживать на всех серверах один и тот же набор шрифтов с минимальными усилиями и избежать ситуации когда шрифт есть на одном компьютере, но его нет на другом.</para>
<para>В большинстве дистрибутивов Linux сервер шрифтов включен в поставку X11 по умолчанию, и называется xfs. Его конфигурационный файл как правило находится в каталоге /etc/X11/fs. В конфигурационном файле сервера шрифтов перечисляются каталоги с растровыми шрифтами, а в конфигурационном файле X-сервера указано, что основным источником шрифтов является сервер шрифтов,запущеный на этом же компьютере.</para>
<para>Такая методика позволяла добиться достаточно качественного отображения шрифта в большинстве случаев, но в то же время такие она имеет определенные недостатки – как известно, растровые шрифты очень плохо «вращаются» на угол не кратный 90 градусам, и плохо масштабируются, а с появлением устройств высокой четкости (LCD-мониторов) возникла необходимость еще и отрисовывать шрифты в «сглаженном» виде, с мягкими переходами цвета, чего растровые шрифты также предоставить не могли.</para>
<para>Наиболее распространенное приложение, использующее методику X Core Fonts – это графический эмулятор терминала xterm, который есть в составе всех дистрибутивов, или простейший менеджер графического входа в систему XDM.</para></sect3><sect3><title>Внутри X11. FreeType и XFT</title>
<para>Для устранения этого недостатка растровых шрифтов была разработана специальные библиотеки XFT и FreeType, которые обеспечивают отображение векторных шрифтов и реализацию таких возможностей как сглаживание шрифтов, их поворот на произвольный угол и хинтинг (подгонку символов шрифта друг к другу оптимальным для данного шрифта способом). Поскольку данная методика плохо согласовывалась с уже сложившейся шрифтовой архитектурой X11, отображение векторных шрифтов было возложено на X-клиента.</para>
<para>При этом схема отображения шрифта меняется: X-клиент не передает на X-сервер запрос на вывод текста указанным шрифтом, а самостоятельно отрисовывает необходимы глифы шрифта использую функции FreeType и XFT, и передает на X-сервер уже сформированную картинку, которую X-сервер и отображает. Вполне логично, что при использовании этой методики X-клиент должен иметь доступ к оригиналу векторного шрифта (обычно это файл) – поэтому современные дистрибутивы также содержат еще и наборы векторных шрифтов PostScript и TrueType.</para>
<para>Новые версии тулкитов GTK и QT используют именно эту методику, но поскольку существуют еще и устаревшие тулкиты, такие как Motif или Xview (OpenLook) и значительное количество приложений на них основанных, да и с точки зрения необходимой полосы пропускания сети технология поддержки растровых шрифтов имеет явное преимущество пред XFT и FreeType, поддержка технологии растровых шрифтов по-прежнему входит в X11 и будет оставаться в ней еще долго.</para></sect3><sect3><title>Внутри X11. Расширения</title>
<para>Протокол X11 не является замершим в своем развитии, но его развития ведется не путем изменения самого протокола, а путем внесения в протокол расширений – то есть дополнительных опциональных наборов команд и инструкций. Например, для поддержки непрямоугольных окон было введено расширение XShape, для поддержки проигрывания видеороликов введено расширение XVideo, для поддержки OpenGL было введено расширение GLX и так далее.</para></sect3><sect3><title>Внутри X11. Полезные утилиты</title>
<para>В штатную поставку X11 входит множество полезных программ, позволяющих получать служебную информацию об ваших настройках среды X11. Перечислим некоторые из них:</para>
<para>xterm – эмулятор терминала</para>
<para>xfontsel – интерактивный просмотр растровых шрифтов</para>
<para>xdpyinfo – вывод информации о ваших настройках среды X11 и задействованных расширениях</para>
<para>xwininfo – просмотр информации об указанном окне (положение, размер, класс окна и т.п.)</para>
<para>xwd – моментальный «снимок» окна</para>
<para>xwud – показ результатов работы xwd</para>
<para>xhost – управление контролем доступа X-клиентов к X-серверу</para></sect3><sect3><title>Внутри X11. Менеджер окон</title>
<para>Существует особая разновидность X-клиентов, называемых менеджерами окон. Их основная функция – обеспечивать управление другими окнами – перемещением, изменением размеров, сворачиванием и разворачиванием окон, отрисовкой обрамлений окон, управление передачей фокуса от окна к окну а также управление Z-порядком размещения окон. Соответственно, в один момент времени для одного экрана может быть использован только один менеджер окон.</para>
<para>GNOME и KDE имеют свои собственные менеджеры окон – это metacity и kwin. Менеджеры окон являются взаимозаменяемыми – то есть вы можете выбрать и использовать тот из них, который вам больше нравится или кажется более удобным. Еще один распространенный (то есть наличествующий почти на всех UNIX-системах) менеджер окон – это twm. Крайне простой и примитивный, он тем не менее предоставляет пользователю базовые функции управления окнами и доступ к меню приложений.</para></sect3></sect2><sect2><title>Локализация</title>
<para>Широкое распространение UNIX-систем привело к необходимости введения системы локализации – поддержки предпочитаемых пользователем стандартов на запись даты и времени, формата чисел, языка сообщения программ, обозначений национальной валюты и так далее.</para>
<para>В Linux стандартом на методику локализации является спецификация i18n. Не вдаваясь в подробности, мы попытаемся получить некоторое представление о том как это выглядит для пользователя.</para>
<para>Как конечные пользователи, мы можем ознакомиться с текущими настройками своей локали используя команду locale:</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>$ locale </para>
<para>LANG=ru_RU.UTF-8 </para>
<para>LC_CTYPE="ru_RU.UTF-8" </para>
<para>LC_NUMERIC="ru_RU.UTF-8" </para>
<para>LC_TIME="ru_RU.UTF-8" </para>
<para>LC_COLLATE="ru_RU.UTF-8" </para>
<para>LC_MONETARY="ru_RU.UTF-8" </para>
<para>LC_MESSAGES=en_US </para>
<para>LC_PAPER="ru_RU.UTF-8" </para>
<para>LC_NAME="ru_RU.UTF-8" </para>
<para>LC_ADDRESS="ru_RU.UTF-8" </para>
<para>LC_TELEPHONE="ru_RU.UTF-8" </para>
<para>LC_MEASUREMENT="ru_RU.UTF-8" </para>
<para>LC_IDENTIFICATION="ru_RU.UTF-8" </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>На самом деле, программа locale в корректно настроенной системе просто выведет вам значение соответствующих переменных окружения. Каждая из этих переменных отвечает за свой собственный аспект локализации, перечислим наиболее важные:</para>
<para>LANG – локаль по умолчанию, ее значение для различных аспектов может быть перекрыто путем установки отдельных переменных в нужное вам значение</para>
<para>LC_CTYPE – отвечает за классификацию символов и различия в их регистре</para>
<para>LC_NUMERIC – отвечает за представление и форматирование чисел</para>
<para>LC_TIME – отвечает за формат даты</para>
<para>LC_COLLATE – определяет настройки сравнения строк и символов, влияет на сортировку</para>
<para>LC_MONETARY – отвечает за представление национальной валюты</para>
<para>LC_MESSAGES – определяет язык сообщений и интерфейса</para>
<para>В примере мы видим что локалью по умолчанию через переменную LANG выбрана локаль ru_RU.UTF-8 (русский язык, соответствие российским стандартам, кодировка символов UTF-8), а в качестве языка интерфейса назначен английский язык в варианте используемом в США. Фактически это означает что все программы будут иметь английский интерфейс, но показывать дату, валюту, десятичную точку и сортировать строки они должны так как это принято в России.</para>
<para>В отличие от мира Windows, где язык сообщений программы как правило жестко забит в ресурсах, а ресурсы включены в исполняемый файл, в UNIX и Linux сообщения как правило содержатся в отдельных файлах и программа загружает текстовые строки для сообщений интерфейса основываясь на значениях переменных LANG и LC_MESSAGES. Это дает возможность обеспечить работу пользователей из разных стран на привычных им языках, не прибегая к установке нескольких копий операционной системы или нескольких экземпляров программы, каждый для своего языка.</para>
<para>Системному администратору Linux достаточно обеспечить наличие файлов сообщений нужной локали для используемых пользователем программ, и правильно установить переменные окружения, после чего пользователь оказывается в привычной для него языковой обстановке и работать с привычными форматами даты, валюты, в привычных единицах измерения и т.д.</para>
<para>Более того – можно установить значение некоторых переменных окружения в нужные значения непосредственно перед запуском программы – и тогда эта программа примет будет использовать указанные настройки локали только для этого запуска, например:</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>[viking@alpha ~]$ </para>
<para>[viking@alpha ~]$ LC_MESSAGES=ru_RU.UTF-8 ls -l something </para>
<para>ls: невозможно получить доступ к something: Нет такого файла или каталога </para>
<para>[viking@alpha ~]$ </para>
<para>[viking@alpha ~]$ LC_MESSAGES=en_US.UTF-8 ls -l something </para>
<para>ls: cannot access something: No such file or directory </para>
<para>[viking@alpha ~]$ </para>
<para>[viking@alpha ~]$ LC_MESSAGES=fr_CA.UTF-8 ls -l something </para>
<para>[viking@alpha ~]$ </para>
<para>ls: ne peut accéder something: Aucun fichier ou répertoire de ce type </para>
<para>[viking@alpha ~]$ </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Таким образом, в Linux-системе возможно обеспечить одновременную работу пользователей в разных языковых окружениях, изменяя только изменение значений переменных окружения. В системах RedHat/Fedora общесистемные настройки локали хранятся в файле /etc/sysconfig/i18n, а пользователь может самостоятельно перекрыть их путем записи соответствующих значений в файле ~/.i18n:</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>[viking@alpha ~]$</para>
<para>[viking@alpha ~]$ cat /etc/sysconfig/i18n </para>
<para>LANG="ru_RU.UTF-8" </para>
<para>SYSFONT="latarcyrheb-sun16" </para>
<para>[viking@alpha ~]$ cat /homed/viking/.i18n </para>
<para>LC_MESSAGES="en_US" </para>
<para>[viking@alpha ~]$</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>В данном примере системная локаль ru_RU.UTF-8, но пользователь viking предпочитает работать в англоязычном интерфейсе, что и записал в своем персональном файле настроек локали.</para></sect2></sect1><sect1><title>Файловые системы Linux</title>
<para/><sect2><title>Создание файловых систем</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://linuxshop.ru/unix4all/?cid=&amp;id=160">http://linuxshop.ru/unix4all/?cid=&amp;id=160</ulink>
</para>
<para>Автор: Алексей Федорчук (<ulink url="mailto:alv@linux-online.ru">alv@linux-online.ru)</ulink>
</para>
<para>C версии: 1.3</para>
<para/>
<para>Создание файловых систем на дисковых разделах (или, в терминах DOS/Windows, форматирование последних) - второй этап подготовки диска к инсталляции Linux. Само по себе это действо - не из самых сложных, однако осознанное его выполнение требует некоторой подготовки.</para><sect3><title>Необходимое введение</title>
<para>Термин "файловая система" - один из самых многозначных в компьютерной терминологии вообще, и в литературе, связанной с ОС Unix и ее клонами (а Linux именно к таковым и относится) - в особенности: больше значений имеет, пожалуй, только просто слово "система". Так сложилось исторически, и потому значение термина приходится определять по контексту. Мне таких значений известно как минимум пять, и нет уверенности, что это - все возможные значения.</para>
<para>Во-первых, файловой системой или, иногда, подсистемой, называют часть ядра, которая управляет организацией файлов и операциями над ними: в этом аспекте в одном ряду с файловой системой выступают система управления процессами и система ввода/вывода. Впрочем, именно это значение мы пока рассматривать не будем.</para>
<para>Во-вторых, и это специфично для Unix и Unix-подобных ОС, файловая система - универсальный интерфейс доступа ко всем ресурсам, как локальной машины, так и компьютеров, объединенных в сеть любого рода - от модемного подключения до спутникового канала. Собственно говоря, именно задействование такого интерфейса в некоей ОС и являет собой один из поводов для отнесения ее к семейству Unix-подобных.</para>
<para>Во-третьих, файловая система - это способ описания некоего физического устройства (обычно - дискового раздела). Именно это значение используется в термине "идентификатор типа файловой системы", о котором говорилось в статье <ulink url="http://linuxshop.ru/unix4all/?cid=1&amp;id=12">о дисковых разделах</ulink>. Он обычно специфичен для конкретной ОС, и потому здесь уместны термины: DOS-раздел, расширенный (Extended) раздел DOS, раздел Linux native и так далее. Хотя большинство всамделишних операционных систем способны тем или иным образом опознавать "неродные" для них идентификаторы и обращаться к данным на них. А в Linux в качестве "родных" (native) рассматривает дисковые разделы, идентифицированные целым рядом файловых систем в третьем понимании термина - от истинно родного Linux native до Extended DOS, включая логические тома (LVM) о которых говорилось в <ulink url="http://linuxshop.ru/unix4all/?cid=13&amp;id=62">соответствующей статье</ulink>, и программные RAID-массивы.</para>
<para>Здесь следует отметить, что помимо файловых систем физических (то есть надстраивающих реальные дисковые устройства, почему в этом контексте нередко фигурирует выражение - disk based file system), существуют и виртуальные файловые системы различных типов. К ним относятся и файловая система устройств - devfs, и временная файловая система в оперативной памяти - tmpfs, и procfs - система, ответственная за представление в виде файловой системы (уж простите за тавтологию) процессов. Иногда используются и файловые системы промежуточного типа, например, виртуальные диски (RAM-диски). Подобно tpmfs, они существуют только в оперативной памяти, однако в остальном ведут себя также, как и файловые системы disk-based.</para>
<para>В четвертых, под файловыми системами понимается внутренняя управляющая структура, позволяющая хранить, идентифицировать и отыскивать данные, ну и, конечно, манипулировать ими. Такие структуры, с одной стороны, специфичны для операционных систем, как FAT16 (со всеми ее вариациями типа VFAT или FAT32) для DOS, UFS для FreeBSD или Ext2fs - для Linux. С другой же - структуры управления файлами в ряде операционок строятся по близким принципам, чему ярким примером служат файловые системы Unix- и Unix-подобных ОС . И потому они могут быть объединены в одно семейство, противопоставляемое FAT-семейству, например.</para>
<para>Кроме того, Linux в настоящее время способен работать с управляющими структурами различных типов - от Ext3fs, являющей собой надстройку над традиционной Ext2fs, до XFS и JFS, разработанных первоначально для версий Unix от SGI и IBM, соответственно, а также ReiserFS. Нет запрета и на размещение Linux'а на файловой системе типа FAT (хотя и резонов к тому - нет также).</para>
<para>Добавлю, что в списке из предыдущего абзаца перечислены только файловые системы, способные нести базовые компоненты Linux, отвечающие за ее запуск и минимальную функциональность. Что же касается обмена данными - таковой возможен из Linux'а практически со всеми известными файловыми системами, хотя с некоторыми из них (например, NTFS или HPFS) - только в режиме чтения.</para>
<para>Наконец, в пятых, файловая система в Unix - это и логическая структура каталогов и файлов, которая объединяет и физические, и виртуальные файловые системы самых различных типов (например, дисковые разделы с файловыми системами Ext2fs и FAT16, виртуальные procfs, devfs и tmpfs), причем не только на локальной машине, но и и на любой удаленной. Структура эта - иерархическая, или древовидная, начинающаяся с корневого каталога, родительского по отношению ко всем прочим, от которого ответвляются отдельные файлы и дочерние каталоги, которые, в свою очередь, могут выступать как родительские по отношению к подкаталогам более глубоких уровней вложенности.</para>
<para>Положение дел в настоящий момент таково, что в Linux структура файловой системы обычно специфична для конкретного дистрибутива или их группы, связанной единством происхождения. Поэтому нередко можно столкнуться с такими выражениями, как файловая система Red Hat или Debian. Собственно, именно исторически сложившиеся различия в иерархии каталогов являются одним из критериев обособления нескольких линий дистрибутивов Linux. Как, впрочем, и потенциальной причиной их несовместимости. Однако можно надеяться, что усилиями стандартизирующих организаций, таких, как <ulink url="http://www.linuxbase.org/">Linux Standard Base</ulink> и <ulink url="http://www.pathname.com/fhs">Filesystem Hierarchy Standard</ulink>, русский перевод стандарта - на <ulink url="http://linuxshop.ru/unix4all/linux-ve.net">сайте Виктора </ulink>
<ulink url="http://linuxshop.ru/unix4all/linux-ve.net">Костромина</ulink>), увенчаются успехом, и можно будет говорить о единой логической файловой системы Linux, подобно тому, как это имеет место в ОС линии BSD.</para>
<para>В контексте настоящей статьи нас интересует только четвертый аспект файловых систем, то есть создание управляющих файлами структур, базируемых на дисках (вернее, их разделах).</para></sect3></sect2><sect2><title>Устройство файловых систем Unix-семейства</title>
<para>В этом разделе будет говориться о предметах, общих для всех Unix. Все файлы в Unix физически состоят из двух частей, реально локализованных в различных блоках дискового накопителя, но обязательно находящихся в одном дисковом разделе, первичном или логическом.</para>
<para>Первая часть файла - его так называемые метаданные, которые содержат файловый дескриптор (это просто некое уникальное число), сведения о его атрибутах (принадлежности, правах доступа, времени модификации и т.д.), а также информацию о том, в каких блоках дискового раздела (которые так и называются - блоки данных) физически размещено содержимое файла - те самые последовательности байтов, которые образуют доступный пользователю ASCII-текст или исполняемый модуль программы.</para>
<para>Метаданные каждого файла записаны в специальной области диска, называемой суперблоком, где образуют т.н. inodes (от information nodes - информационные узлы). Каждому существующему файлу соответствует свой inode, и именно он однозначно идентифицируется файловым дескриптором. А сам по себе список inodes, соответствующих как существующим файлам, так и свободным блокам дискового раздела, и определяет границы файловой системы, то есть сколько файлов может быть в ней создано.</para>
<para>Так вот, суть процесса создания файловой системы на дисковом разделе (или, в понимании DOS/Windows, его форматирования) - в создании на нем суперблока (или, в некоторых файловых системах, нескольких его копий), списка inodes и отведении дискового пространства под блоки данных (а также загрузочного блока, о котором будет сказано ниже), а устройством этих дисковых областей определяются различия между файловыми системами различных типов. В результате на новом разделе образуется единственный файл - каталог корневого (для данной файловой системы) раздела (в некоторых случаях создается еще и каталог /lost+found, предназначенный для хранения нарушенных файлов).</para>
<para>Возникает вопрос, почему такой, казалось бы неотъемлемый, атрибут файла, как его имя, не обнаруживается ни в его метаданных, ни, тем более, среди его данных. Ответ прост: в Unix имя являет собой атрибут не файла, но файловой системы (в пятом, логическом, понимании термина). И для хранения имен файлов предназначены файлы особого типа - каталоги (в Unix есть и другие типы файлов, например, упомянутые выше файлы устройств). Они представляют собой просто списки файловых дескрипторов идентификаторов и соответствующих им имен файлов. Поэтому идущая от MacOS и активно используемая в Windows метафора каталога как папки с документами - в Unix только затемняет суть дела: здесь это скорее именно каталожный ящик в библиотеке.</para>
<para>Не смотря на столь простое устройство, роль каталогов в файловой системе Unix трудно переоценить: имена файлов, через которые они включаются в файловую систему (и через которые пользователь получает доступ к их содержимому), фигурируют только в составе каталога, к которому файл приписан - и больше нигде в системе. Так что удаление имени файла (или подкаталога) из списка, представляющего собой данные его родительского каталога (который, конечно, также имеет свой inode и файловый дескриптор, приписанный к каталогу, расположенному уровнем выше в иерархии файловой системы, и так далее) равносильно тому, что метаданные файла становится недоступными, а приписанные к его inode блоки данных помечаются как свободные. Именно так осуществляется удаление файла командой rm или файловым менеджером типа Midnoght Commander.</para>
<para>Нас, однако, сейчас интересует прямо противоположное - сделать файловую систему доступной. Из сказанного понятно, что для этого она со всем ее содержимым (суперблоком, списком inode, блоками данных) должна быть включена в состав какого-либо из существующих каталогов, называемого точкой монтирования. Именно это и составляет суть процесса монтирования. Результат же для монтируемой файловой системы - в том, что ее корневой каталог (до сих пор безымянный) получает имя каталога - точки монтирования (mount point), содержимое которого отныне составляет список имен ее файлов и подкаталогов. Обратный процесс - размонтирование, следствием чего является отсоединение от точки монтирования дерева смонтированной файловой системы. Кроме того, в inode ее корневого каталога устанавливается т.н. бит чистого размонтирования (clean bit). Впрочем, вопросам монтирования и размонтирования файловых систем будет посвящена специальная статья. Пока же рассмотрим особенности файловых систем, используемых в Linux'е.</para><sect3><title>Файловые системы Linux</title></sect3><sect3><title>Ext2fs</title>
<para>До недавнего времени список истинно родных (native) файловых систем для Linux ограничивался единственной - ext2fs (правда, Linux способен загрузиться и работать с FAT-раздела, но об этом мне даже не хочется говорить). Название это расшифровывается как "вторая расширенная файловая система"; "расширенная" она - по сравнению с файловой системой ОС minix, послужившей прототипом Linux, "вторая" - потому что ранние версии Linux базировались на Extfs с более ограниченными возможностями.</para>
<para>О файловой системе Ext2fs написано немало (см. дополнительные источники). Поэтому замечу только, что по способу организации хранения данных она - типичная представительница файловых систем Unix. Отличительная ее особенность - наличие нескольких копий суперблока, что повышает надежность хранения данных. Кроме того, для характерен очень эффективный механизм кэширования дисковых операций, что обеспечивает замечательное их быстродействие - едва ли не рекордное среди известных мне файловых систем. Оборотная сторона чего, однако, - относительно слабая устойчивость при аварийном завершении работы (вследствие мертвого зависания или отказа питания), поскольку отложенность записи изменений файлов делает весьма высокой вероятность нарушения связи между их inodes и блоками данных.</para>
<para>Конечно, времена, когда некорректный останов Linux-машины грозил полным разрушением файловой системы, остались в далеком прошлом. Однако в любом случае останов системы без штатного размонтирования файловых систем приводит к тому, что в них не устанавливается упомянутый выше "бит чистого размонтирования". А без этого утилиты обслуживания диска (такие, как программа проверки fsck) при перезагрузке не воспринимают их как целостные и начинают проверку, которая при современных объемах дисков может занять немалое время.</para></sect3><sect3><title>О журналируемых файловых системах</title>
<para>Проблема нарушения целостности файловой системы при некорректном завершении работы в большей или меньшей мере характерна для всех ОС семейства Unix. И потому с давних пор в них разрабатываются т.н. журналируемые файловые системы. Журнал -- это нечто вроде log-файла дисковых операций, в котором фиксируются не выполненные, а только предстоящие манипуляции с файлами, вследствие чего оказывается возможным самовосстановление целостности файловой системы после сбоя.</para>
<para>Во избежание недоразумений следует подчеркнуть, что журналирование направленно на обеспечение целостности файловой системы, но ни в коем случае не гарантирует сохранность пользовательских данных как таковых. Так, не следует ожидать, что журналирование волшебным образом восстановит не сохраненные перед сбоем изменения документа, загруженного в текстовый редактор.</para>
<para>Более того, в большинстве журналируемых файловых систем фиксируются грядущие операции только над метаданными изменяемых файлов. Обычно этого достаточно для сохранения целостности файловой системы и, уж во всяком случае, предотвращения долговременных их проверок, однако не предотвращает потери данных в аварийных ситуациях. В некоторых из файловых систем возможно распространение журналирования и на область данных файла. Однако, как всегда, повышение надежности за счет этого оплачивается снижением быстродействия.</para>
<para>Текущие версии ядра Linux поддерживают в качестве нативных четыре журналируемые файловые системы: ReiserFS и Ext3fs, специфичные для этой ОС, XFS и JFS - результаты портирования в Linux файловых систем, разработанных первоначально для рабочих станций под ОС Irix (SGI) и AIX (IBM), соответственно. Правда, широкое признание получили только три первых, так что о JFS я пока говорить не буду.</para></sect3><sect3><title>ReiserFS</title>
<para>Файловая система ReiserFS оказалась для Linux исторически первой из журналируемых - она поддерживается каноническим ядром c <ulink url="http://www.kernel.org/">http://www.kernel.org</ulink>, начиная с первых версий ветви 2.4.x (в настоящее время существуют патчи, позволяющие использовать ее и с версиями ветви 2.2.xx). И была единственной, разработанной "с нуля" специально для этой ОС Хансом Райзером и его фирмой <ulink url="http://www.namesys.com/">Namesys</ulink>. Как и в большинстве рассмотренных, в ReiserFS осуществляется журналирование только операций над метаданными файлов. Что, при определенном снижении надежности, обеспечивает высокую производительность: по моим наблюдениям, на большинстве типичных пользовательских задач она лишь незначительно уступает Ext2fs. А на такой, достаточно обычной, операции, как копировании большого количества мелких файлов, существенно ее опережает.</para>
<para>Кроме этого, ReiserFS обладает уникальной (и по умолчанию задействованной) возможностью оптимизации дискового пространства, занимаемого мелкими, менее одного блока, файлами (а следует помнить, что в любой Unix-системе такие файлы присутствуют в изобилии): они целиком хранятся в своих inode, без выделения блоков в области данных - вместе с экономией места это способствует и росту производительности, так как и данные, и метаданные (в терминах ReiserFS - stat-data) файла хранятся в непосредственной близости и могут быть считаны одной операцией ввода/вывода.</para>
<para>Вторая особенность ReiserFS - то, что т.н. хвосты файлов, то есть их конечные части, меньшие по размеру, чем один блок, могут быть подвергнуты упаковке. Этот режим (tailing) также включается по умолчанию при создании ReiserFS, обеспечивая около 5% экономии дискового пространства. Что, правда, несколько снижает быстродействие, и потому режим тайлинга можно отменить при монтировании файловой системы. Однако упаковка хвостов автоматически восстанавливается после перекомпиляции ядра - что, как будет сказано чуть ниже, требует внимательного отношения.</para>
<para>ReiserFS не совместима с Ext2fs на уровне утилит обслуживания файловой системы. Однако соответствующий инструментарий, объединенный в пакет reiserfsprogs, уже давно включается в штатный комплект современных дистрибутивов (или, в крайнем случае, может быть получен с сайта <ulink url="http://www.namesys.com/">Namesys</ulink>).</para>
<para>Более серьезная проблема с совместимостью - в том, что распространенные загрузчики Linux (и Lilo, и GRUB - хотя и по разным причинам) часто не способны загрузить ядро Linux с раздела ReiserFS, оптимизированного в режиме тайлинга. А поскольку, будучи отключен, этот режим обладает свойством самовосстановления, пользователь может столкнуться с тем, что после пересборки ядра система просто откажется загружаться. Именно поэтому выше я упоминал, что создание раздела под каталог /boot может быть необходимым.</para></sect3><sect3><title>Ext3fs</title>
<para>В отличие от ReiserFS, Ext3fs - не более чем журналируемая надстройка над классической Ext2fs, разработанная Стивеном Твиди в компании Red Hat и поддерживаемая ядром Linux, начиная с версии 2.4.16. Как следствие такого происхождения, она сохраняет со своей прародительницей полную совместимость, в том числе и на уровне утилит обслуживания (начиная с версии 1.21 объединяющего их пакета e2fsprogs). И переход от ext2fs к ext3fs может быть осуществлен простым добавлением файла журнала к первой, не только без переформатирования раздела, но даже и без рестарта машины.</para>
<para>Из этого вытекает первое преимущество ext3fs, особенно весомое в случае большого парка компьютеров. Второе же - чуть ли не максимальная надежность: ext3fs является единственной системой из рассматриваемых, в которой возможно журналирование операций не только с метаданными, но и с данными файлов.</para>
<para>В Ext3fs предусмотрено три режима работы - полное журналирование (full data journaling), журналирование с обратной записью (writeback), а также задействуемое по умолчанию последовательное (ordered).</para>
<para>Режим полного журналирования, как легко догадаться из названия, распространяется и на метаданные, и на данные файлов. Все их изменения сначала пишутся в файл журнала и только после этого фиксируются на диске. В случае аварийного отказа журнал можно повторно перечитать, приведя данные и метаданные в непротиворечивое состояние. Этот механизм практически гарантирует от потерь данных, однако является наиболее медленным.</para>
<para>В режиме отложенной записи, напротив, в файл журнала записываются только изменения метаданных файлов, подобно всем рассмотренным ниже файловым системам. То есть никакой гарантии сохранности данных он не предоставляет, однако обеспечивает наибольшее (в рамках Ext3fs) быстродействие.</para>
<para>В последовательном режиме также физически журналируются только метаданные файлов, однако связанные с ними блоки данных логически группируются в единый модуль, называемый транзакцией (transaction). И эти блоки записываются перед записью на диск новых метаданных на диск, что, хотя и не гарантирует сохранности данных, весьма последней способствует. Причем - при меньших накладных расходах по сравнению с полным журналированием, обеспечивая промежуточный уровень быстродействия.</para>
<para>Однако, по моим наблюдениям Ext3fs ни в одном из режимов не может похвастаться высокой производительностью при решении настольных пользовательских задач. А в режиме полного журналирования возможны ситуации, вызывающие на некоторое время полный паралич машины.</para></sect3><sect3><title>XFS</title>
<para>Файловая система XFS, в отличие от молодых ReiserFS и ext3fs, развивается для фирмой SGI на протяжении почти десяти лет - впервые она появилась в версии Irix 5.3, вышедшей в 1994 г. Но в Linux она была портирована лишь недавно (текущая ее версия - 1.1, свободно доступна с сайта SGI's XFS page - http://oss.sgi.com/projects/xfs) и по сию пору не поддерживается официальным ядром.</para>
<para>XFS - единственная 64-разрядная файловая система из рассмотренных. Однако уникальность ее - не только в этом. Особенностями XFS являются:</para>
<orderedlist>
<listitem>
<para>механизм allocation group, то есть деление единого дискового раздела на несколько равных областей, имеющих собственные списки inodes и свободных блоков, для распараллеливания дисковых операций; </para>
</listitem>
<listitem>
<para>логическое журналирование только изменений метаданных, но - с частым сбросом их на диск для минимизации возможных потерь при сбоях; </para>
</listitem>
<listitem>
<para>механизм delayed allocation - ассигнование дискового пространства при записи файлов не во время журналирования, а при фактическом сбросе их на диск, что, вместе с повышением производительности, предотвращает фрагментацию дискового раздела; </para>
</listitem>
<listitem>
<para>списки контроля доступа (ACL, Access Control List) и расширенные атрибуты файлов (extended attributes), рассмотрение которых далеко выходит за рамки нынешней темы. </para>
</listitem>
</orderedlist>
<para>В результате XFS предстает как очень сбалансированная файловая система: она почти столь же надежна, как Ext3fs, и не очень уступает ReiserFS в быстродействии на большинстве файловых операций. А при манипуляциях с (очень) большими файлами XFS - просто вне конкуренции: как легко догадаться по имени фирмы-разработчика, она ориентирована на работу с мультимедийными приложениями с их огромными потоками данных. Не отмечалось для нее и проблем с совместимостью.</para>
<para>Все сказанное позволяет сделать вывод, что XFS - оптимальная файловая система для Linux. Однако следует учесть: в отличие от ReiserFS и ext2fs, поддержка которых является штатными опциями ядра Linux, XFS по сию пору (текущая версия - 2.4.19) не поддерживается каноническим ядром Линуса Торвальдса (тем, которое можно получить с <ulink url="http://www.kernel.org/">http://www.kernel.org</ulink>). Хотя недавнее включение такой поддержки в разрабатываемую ветвь ядра (версии 2.5.X) позволяют надеяться, что скоро эта функция станет штатной.</para>
<para>Возможность работы с XFS обеспечивает специальный патч (xfs-2.4.1X-all-i386.bz2), который можно получить с сайта <ulink url="http://oss.sgi.com/projects/xfs">SGI</ulink> вместе с соответствующими утилитами поддержки: традиционные средства e2fsprogs, для XFS не пригодны. Утилиты поддержки для XFS объединены в несколько пакетов, из которых абсолютно необходимым является xfsprogs. Обо всем этом следует помнить при предварительной разметке диска.</para></sect3><sect3><title>Критерии выбора</title>
<para>Таким образом, каждая из четырех рассмотренных файловых систем имеет свою уникальную положительную особенность (даже Ext2fs - как бы то ни было, лидером по суммарному быстродействию остается она), и как минимум один недостаток (который, тем не менее, не служит препятствием к ее использованию). Так что выбор файловой системы должен определяться задачами пользователя и характером преобладающих его данных.</para>
<para>Кроме этого, если, как рассказывалось в статье про <ulink url="http://linuxshop.ru/unix4all/?cid=13&amp;id=62">LVM</ulink>, максимально разгрузить корневую файловую систему, выделив в логические тома отдельные ее ветви, возможно и комбинированное использование файловых систем. То есть подбор для каждого из дисковых разделов наиболее подходящей к его содержанию управляющей структуры.</para>
<para>Так, ранее неоднократно говорилось, что Ext2fs - наиболее подходящий выбор для загрузочного раздела (а при использовании в качестве загрузчика GRUB - это почти обязательное требование). Кроме того, Ext2fs вполне подходит для таких ветвей, как /tmp или /var. Для первого, по определению, устойчивость к сбоям не критична. Для второго же определяющим требованием является быстродействие (так, в Source Based дистрибутивах типа Gentoo /var задействуется для хранения временных продуктов компиляции, и быстродействие файловых операций в нем несколько способствует ускорению сборки пакетов). Наконец, на настольной машине Ext2fs можно применить и для корневой файловой системы - ведь при дробном разбиении диска в корне остается минимум редко изменяемых компонентов.</para>
<para>С другой стороны, корень - наиболее критичный в отношении устойчивости элемент файловой системы. И потому оптимальным для него представляется файловая система Ext3fs, как наиболее устоявшаяся. Кроме того, в экстремальных ситуациях она может быть без проблем смонтирована как Ext2fs. Для разделов типа /usr и /usr/local Ext3fs также видится вполне подходящим вариантом.</para>
<para>Наиболее важная часть файловой системы настольной машины с точки зрения пользователя - его, пользовательские, данные, то есть каталог /home (ибо систему можно переустановить, а вот потеря данных может быть невосполнимой). Однако это - и наиболее изменяемая ее часть, что предъявляет высокие требования к быстродействию файловых операций. И поэтому Ext3fs - не лучшее (ИМХО) решение для каталога /home, более целесообразно разместить здесь какую-либо из "быстрых" журналируемых файловых систем, ReiserFS или XFS. Выбор между ними определяется личными предпочтениями и характером данных (пользуясь случаем, замечу, что быстродействие JFS, по моим наблюдениям над типичными пользовательскими манипуляциями, оставляет желать лучшего).</para>
<para>Очевидно, что быстродействие XFS при работе с файлами (очень) большого размера делает ее предпочтительной, если речь идет об обработке изображений, мультимедийном контенте, картографической информации и т.д. В то же время преимущества ReiserFS сказываются в основном при работе с файлами (очень) маленького размера (менее блока файловой системы), каковых среди пользовательских данных обычно бывает мало. И потому мое личное мнение однозначно - и высказывается в пользу XFS. К тому же собственный опыт общения с ReiserFS был неблагоприятен, особенно в сочетании с технологией LVM. XFS же, напротив, по моим впечатления идеально с ней гармонирует.</para>
<para>Подведем итог - оптимальной мне видится следующее сочетание файловых систем:</para>
<orderedlist>
<listitem>
<para>Ext3fs - для корневого каталога (/) и каталога /usr (а также /usr/local и /usr/X11R6, если таковые обособляются в отдельные ветви); </para>
</listitem>
<listitem>
<para>Ext2fs - для загрузочного /boot, каталогов /tmp и /var; </para>
</listitem>
<listitem>
<para>XFS - для раздела под домашние каталоги (/home). </para>
</listitem>
</orderedlist>
<para>Повторяю, это лишь мое мнение, основанное на опыте настольного применения Linux - для серверов различного рода оно силы не имеет.</para></sect3></sect2><sect2><title>Практические следствия</title>
<para>Надеюсь, предыдущий раздел дал достаточно информации для выбора файловой системы, наиболее подходящей к конкретным условиям. И потому далее вкратце рассмотрим последовательность действий после того, как выбор осуществлен.</para>
<para>Обычно при установке Linux создание файловых систем - компетенция инсталлятора, который осуществляет его с некоторыми опциями по умолчанию. В контексте рассмотренного в предыдущем разделе ясно, что опции эти не всегда будут лучшими с точки зрения пользователя. Изменить же характеристики, определенные для файловой системы при ее создании, невозможно без повторного выполнения этого процесса (и, соответственно, потери данных). Однако все SB-дистрибутивы допускают ручное вмешательство в процедуру создания файловой системы, а в Gentoo, например, это - просто единственный способ ее выполнения.</para>
<para>Файловая система Ext2fs может быть создана любой из следующих команд - /sbin/mke2fs, /sbin/mkfs, /sbin/mkfs.ext2 с указанием файла устройства в качестве аргумента, например:</para>
<para>$ /sbin/mke2fs /dev/hd?#</para>
<para>Каждая из этих команд (а /sbin/mkfs.ext2 - обычно символическая ссылка на /sbin/mke2fs) имеет ряд опций, как то: -b для определения размера блока файловой системы (возможные значения - 1024, 2048 или 4096 байт, по умолчанию принято последнее),-c для проверки испорченных участков диска, -N и -i для задания числа inodes и количества байт на один узел, соответственно; с деталями можно ознакомиться на соответствующей man-странице, например, man (8) mke2fs.</para>
<para>Для создания файловой системы ext3fs можно применить ту же команду mke2fs с опцией -j, при этом случае она получит некоторые "умолчальные" характеристики. Определить же их вручную позволяет следующая форма этой команды:</para>
<para>$ /sbin/mke2fs -J опции_журналирования /dev/hd?#</para>
<para>Возможные значения опций журналирования - size=размер, задающая объем журнального файла в мегабайтах, и device=внешний_журнал подключения новой файловой системы к журналу, ранее созданному на другом дисковом разделе.</para>
<para>Можно использовать и специальную команду /sbin/mkfs.ext3 - возможности ее идентичны таковым /sbin/mke2fs (ибо она ни что иное, как символическая на нее ссылка). Но самое интересное - возможность преобразования существующей ext2fs в ext3fs простым добавлением журнала, не только без потери данных, но и без перезапуска системы (и даже без размонтирования). Делается это командой</para>
<para>$ tune2fs -j /dev/hd?#</para>
<para>Она просто добавляет файл журнала /.journal в корневом каталоге модифицируемой файловой системы (если последняя не была размонтирована), или задействует для журнала скрытый inode (если перед модификацией файловая система была размонтирована). Добавлю, что обратное преобразование - еще проще, и осуществляется командой монтирования (о чем будет говориться в следующей статье).</para>
<para>Файловая система ReiserFS создается специально предназначенной для этого командой - /sbin/mkreiserfs из пакета reiserfsprogs. Для нее доступны многочисленные опции (-s для задания размера журнала, -f для принудительного переформатирования ранее существовавшей файловой системы иного типа, и т.д.), с которыми можно ознакомиться посредством man (8) mkreiserfs. И во избежание неожиданностей напомню: если корневой раздел форматируется как ReiserFS, не лишним будет предусмотреть небольшой раздел под каталог /boot для размещения на нем файловой системы ext2fs.</para>
<para>Для создания XFS также существует собственная команда mkfs.xfs (из пакета xfsprogs). В ней предусмотрено несколько опций, каждая из которых имеет ряд субопций, принимающих численные значения. Важнейшие из них:</para>
<orderedlist>
<listitem>
<para>-b, которая посредством субопции size=## позволяет задать размер блока данных в байтах, который должен быть кратен размеру страницы оперативной памяти (для платформы i386 - 4 Кбайт) и может варьировать в диапазоне от 512 до 65536 (по умолчанию - 4096); </para>
</listitem>
<listitem>
<para>-d, определяющая параметры области данных файловой системы, такие, как количество самостоятельных областей раздела (Allocation groups, субопция agcount), или, напротив, их размер (субопция agsize); </para>
</listitem>
<listitem>
<para>-l, специфицирующая параметры журнального файла, например, его размер (субопция size). </para>
</listitem>
</orderedlist>
<para>При использовании mkfs.xfs для достижения максимальной производительности рекомендуется в явном виде задать количество allocation groups - иначе оно будет определяться автоматически, что ведет к непроизводительным расходам ресурсов. Это делается из расчета - одна allocation group на 4 Гбайт дискового пространства. Далее можно установить размер файла журнала - здесь рекомендованное значение составляет 32 Мбайт. То есть для дискового раздела объемом в 20 Гбайт команда приобретет вид</para>
<para>$ mkfs.xfs -d agcount=5 -l size=32m /dev/hda1</para>
<para>Кроме всех перечисленных, команда mkfs.xfs имеет опцию -f (от force) - принудительное создание файловой системы XFS поверх любой существующей. Ее достаточно, если последняя была ext2fs (и, исходя из общих соображений, ext3fs, хотя я этого не проверял). Если же XFS создается поверх ReiserFS - после этого возможны ошибки при монтировании новой файловой системы. Впрочем, то же относится и к обратной процедуре (замене XFS на ReiserFS), а также, если любая из этих "продвинутых" файловых систем заменяется на разделе системой ext2fs. Они связаны с тем, что команда монтирования может распознать новосозданную XFS как дефектную ReiserFS, и наоборот.</para>
<para>Во избежание этого перед таким замещением приходится прибегать к несколько шаманскому приему - обнулению начальных областей раздела (хранящего метаданные файловой системы) командой</para>
<para>$ dd if=/dev/zero of=/dev/hd?#</para>
<para>Ждать заполнения нулями всего устройства не обязательно - достаточно дать этой команде поработать секунд 10-20, после чего прервать ее комбинацией клавиш Control+D и перейти к созданию новых файловых систем.</para>
<para>И последнее, о чем следует сказать - о swap-разделе, созданном на этапе разбиения диска. Хотя файловой системы как таковой он не несет, но нуждается в определении, что достигается командой</para>
<para>$ mkswap имя_устройства</para>
<para>к которой следует подходить со вниманием - применение ее к обычному разделу уничтожит на нем все данные.</para></sect2><sect2><title>Библиография вопроса</title>
<para>Многие сложные вопросы устройства файловых систем в этой статье были затронуты лишь вскользь. За более подробной информацией по ним следует обратиться к дополнительным источникам. Так, общая организация файловой системы Unix рассматривается во многих руководствах по этой операционной системе, например: С. <ulink url="http://www.citforum.ru/operating_systems/unix/contents.shtml">Д. Кузнецов. Операционная система UNIX</ulink>.</para>
<para>Устройство файловой системы ext2fs подробно описано в статье Виктора Хименко "Файлы, файлы, файлы" (Мир ПК, 2000, <ulink url="http://www.osp.ru/pcworld/2000/02/064.htm">часть 1 - #2</ulink>; <ulink url="http://www.osp.ru/pcworld/2000/03/050.htm">часть 2 - #3</ulink>,).</para>
<para>Подробное описание современных журналируемых файловых систем, используемых в Linux, дано в цикле статей Дэниела Роббинса, русский перевод которого, выполненный Владимиром Холмановым, доступен на сайте <ulink url="http://linux.yaroslavl.ru/Docum/Fs/l-fs_ru.html">Ярославской группы пользователей Linux</ulink>.</para>
<para/></sect2><sect2><title>Linux и файловые системы: еще раз о проблеме выбора</title>
<para/>
<para>        Ссылка на оригинал: <ulink url="http://citkit.ru/articles/381/">http://citkit.ru/articles/381/</ulink>
</para>
<para>        Автор: Алексей Федорчук (<ulink url="mailto:alv@linux-online.ru">alv@linux-online.ru)</ulink>
</para>
<para>        Дата: 15.03.2007.</para>
<para>        C версии: 1.3</para>
<para/>
<para>Весна наступила... Индо взопрели озимые, солнышко рассупонилось. Старик Ромуальдыч начал к своей портянке принюхиваться - оттаяла, видать. Податтаяли и пользователи - на форумы потянулись, вопросы задавать, да ответы получать...</para>
<para>Одним из популярных вопросов в нынешнем сезоне оказался такой: как разбить диск и какую файловую систему выбрать. </para>
<para>Общий ответ на первую половину вопроса дать невозможно, а варианты решения этой проблемы обсуждались столько раз, что повторять их было бы скучно. А потому перейдем сразу ко второй половине - о дисковой разметке я вскользь скажу в самом конце.</para>
<para>В качестве "родных" для Linux (то есть тех, на которые он может быть установлен и с которых способен стартовать) рассматриваются следующие файловые системы: ext2fs, ext3fs, ReiserFS, XFS, JFS. Именно они обычно и предлагаются на выбор при установке подавляющего большинства дистрибутивов. Конечно, существуют и способы установки Linux на файловые системы FAT/VFAT/FAT32, но это - только для тех медам и мсье, которые понимают толк в извращениях, и о них я говорить не буду.</para>
<para>Исключу из рассмотрения также JFS - по следующим причинам:</para>
<orderedlist>
<listitem>
<para>малой распространенности среди пользователей Linux; </para>
</listitem>
<listitem>
<para>недостаточности источников информации по ней (именно в Linux - для родной ОС AIX эта файловая система прекрасно документирована); </para>
</listitem>
<listitem>
<para>моим лично слабым с ней знакомством. </para>
</listitem>
</orderedlist>
<para>Основными критериями при выборе файловой системы являются обычно надежность и быстродействие. В некоторых случаях приходится учитывать также фактор совместимости - в данном случае под ней понимается способность других операционок обращаться к той или иной файловой системе.</para>
<para>Начну рассмотрение с ReiserFS - потому что поводом к сочинению этой заметки послужил вопрос: а что следует считать маленькими файлами? Ведь общеизвестно, что именно эффективность работы с мелкими файлами является сильной стороной этой файловой системы.</para>
<para>Так вот, под мелкими файлами понимаются файлы размером меньше логического блока файловой системы, который в Linux в большинстве случаев равен четырем килобайтам, хотя и может задаваться при форматировании в некоторых пределах (зависящих от конкретной FS). Таких мелких файлов в любой Unix-подобной ОС - бессчетное количество. Типичным примером являются файлы, составляющие дерево портов FreeBSD, портежей Gentoo и тому подобных портообразных систем.</para>
<para>В большинстве файловых систем для таких минирофайлов существует как свой inode (информационный узел, содержащий метаинформацию о файле), так и блок данных, что приводит как к расходу дискового пространства, так и снижению быстродействия файловых операций. В частности, именно в этом причина катастрофической задумчивости файловой системы FreeBSD (как старой, UFS, так и новой, UFS2) при работе с собственной же системой портов.</para>
<para>В файловой системе ReiserFS в таких случаях отдельные блоки под данные не выделяются - она умудряется запихать данные файла непосредственно в область его же inode. За счет этого и дисковое пространство экономится, и быстродействие возрастает - буквально в несколько раз по сравнению со всеми прочими FS.</para>
<para>Такое обращение с мелкими файлами ReiserFS послужило причиной возникновения легенды о ее ненадежности. Действительно, при крахе файловой системы (то есть разрушении служебных областей) данные, размещенные совместно со своими inodes, вместе с ними же и пропадают - причем безвозвратно. Тогда как в тех файловых системах, где inodes и блоки данных всегда разобщены пространственно, последние теоретически можно восстановить. Так, для ext2/ext3 даже существуют средства, позволяющие это сделать.</para>
<para>Однако, как и всякая легенда, эта лишь производит впечатление достоверности. Во-первых, безвозвратная потеря данных относится лишь к очень маленьким файлам. Среди пользовательских таковых практически не бывает, а все прочие же легко восстанавливаются из дистрибутива.</para>
<para>Во-вторых, говоря о возможности восстановления данных из блоков, утуративших привязку к своим inodes, я не случайно употребил слово "теоретическая". Потому что на практике это занятие чрезвычайно трудоемкое, не дающее гарантированного результата. Каждый, кому приходилось этим заниматься, согласится, что предаться ему можно только от полной безысходности. И это относится ко всем файловым системам Linux. Так что этим аспектом при выборе файловой системы можно пренебречь.</para>
<para>По суммарному быстродействию ReiserFS однозначно быстрее всех остальных журналируемых FS, а по некоторым показателям превосходит и ext2. С результатами сравнения скорости выполнения некоторых распространенных файловых файловых операций можно ознакомиться <ulink url="http://posix.ru/system/test_free_vs_linux/">здесь</ulink>.</para>
<para>А вот с совместимостью у ReiserFS дело обстоит несколько хуже. Доступ к ней из ОС семейства Windows, насколько мне известно, невозможен. В некоторых операционках семейства BSD (DragonFlyBSD, FreeBSD) реализована поддержка этой файловой системы, но в режиме только для чтения. Даже вероятность того, что произвольный Linux LiveCD прошлых лет не имеет поддержку ReiserFS, не нулевая.</para>
<para>И тут впору вспомнить об ext3fs. Преимущество ее вовсе не в большей надежности - это такая же легенда, как и неустойчивость ReiserFS. О случаях краха ext3fs я слышал не меньше, чем об аналогичных происшествиях с ReiserFS. Самому мне не удавалось порушить ни ту, ни другую. Разве что с ext2 получалось - но и то очень давно, во времена ядра 2.2 (или даже еще 2.0).</para>
<para>Нет, главное преимущество ext3fs в ее совместимости - она с гарантией будет прочитана любой Linux-системой. Например, при восстановлении с какого-нибудь древнего подручного LiveCD - ситуация, практически не столь уж невероятная, мне приходилось в нее попадать. Опять же, большинство BSD-систем легко понимают ext3fs (хотя и без журналирования). Для Windows также имеются, насколько я знаю, всякого рода драйверы и plug-ins к распространенным файловым менеджерам (типа Total Commander), обеспечивающие доступ к разделам с ext2fs/ext3fs.</para>
<para>В отношении производительности ext3fs оставляет противоречивое впечатление. Во-первых, быстродействие ее очень зависит от режима журналирования, каковых предусмотрено три: с полным журналированием данных, частичным их журналированием и журналированием только метаданных. В каждом из режимов она показывает различную производительность на разных типах файловых операций. Впрочем, ни в одном случае быстродействие не является рекордным, в чем можно убедиться, пройдя по <ulink url="http://posix.ru/system/test_free_vs_linux/">указанной выше ссылке</ulink>.</para>
<para>Впрочем, если требование быстродействия ставится на первое место, то тут вне конкуренции оказывается ext2fs - правда, в этом случае придется смириться с отсутствием журналирования вообще. И, следовательно, с длительными проверками файловой системы при любом некорректном завершении работы - а при объемах современных дисков это может затянуться ой как надолго...</para>
<para>Относительно XFS можно сказать следующее. В плане совместимости к ней относится все то же самое, что написано для ReiserFS - более того, до некоторого времени она не поддерживалась стандартным ядром Linux. С точки зрения быстродействия она XFS она также не блещет, выступая суммарно примерно на одном уровне с ext3fs. А на операции удаления файлов вообще демонстрирует удручающую медлительность.</para>
<para>По моим наблюдениям, использование XFS оправдывает себя при работе не просто с большими, а с очень большими файлами - каковыми являются фактически только образы DVD и видеофайлы.</para>
<para>Возвращаюсь к вопросу о надежности. Банальное выключение питания в ходе обычной пользовательской работы, как правило, безболезненно переносят все журналируемые файловые системы (и ни одна из них не обеспечивает сохранности не записанных на диск пользовательских операций - спасение утопающих и тут остается делом рук самих утопающих). Правда, для любой файловой системы можно смоделировать ситуацию, в ходе которой выключение питания приведет к более или менее серьезным ее повреждениям. Однако в реальной жизни возникновение таких ситуаций маловероятно. А полностью исключить их пожно приобретением источника бесперебойного питания - он придаст больше уверенности в сохранности данных, чем тип файловой системы. Ну а гарантией восстановления разрушенных данных в любом случае может быть только их регулярное резервное копирование...</para>
<para>Думаю, изложенной выше информации достаточно для осознанного выбора. Мой личный выбор в течении последних нескольких лет - ReiserFS. Изредка, на системах, где оправданно вынесение за пределы корневого раздела всего, чего только можно, целесообразно использование ext3fs для корневой файловой системы и ReiserFS - для всех остальных.</para>
<para>Если предусматривается отдельный раздел под каталог /boot (а это рекомендуется при использовании загрузчика GRUB его разработчиками) - для него никакая другая файловая система, кроме ext2fs, не оправданна, какое-либо журналирование тут смысла не имеет. Наконец, если создается отдельный раздел под всякого рода мультимедийные материалы - тут можно подумать и о XFS.</para>
<para>В заключение добавлю, что более подробные сведения обо всех рассмотренных здесь материях можно получить из <ulink url="http://citkit.ru/articles/239/">цикла статей Дэниеля Роббинса</ulink>.</para></sect2></sect1><sect1><title>Windows-эквиваленты</title>
<para/>
<para>Ссылка на оригинал:<ulink url="http://ru.gentoo-wiki.com/Windows-эквиваленты">http://ru.gentoo-wiki.com/Windows-эквиваленты</ulink>
</para>
<para>C версии: 1.0</para>
<para>Обновлено: 1.4</para>
<para/>
<para>Вы знаете, что хотите сделать, но не знаете, чем? Это список пакетов в портежах Gentoo и их эквиваленты в Windows. Он, конечно же, далеко не полный, но и не предназначен для этого. Он просто даёт возможность лёгкого старта в Gentoo. </para>
<para>Для расширения этой таблицы можно использовать статью: <ulink url="http://www.linuxrsp.ru/win-lin-soft/table-rus.html">Аналоги Windows-программ в Linux - таблица соответствий</ulink>. Также, весьма полный лист можно найти здесь: <ulink url="http://komnas.com/%7Eashamril/tips/files/win-vs-lin-soft-EN.shtml">[1]</ulink>(англ.). </para>
<para>Смотрите также <ulink url="http://packages.gentoo.org/">официальную страницу портежей</ulink>(англ.) с портежами, классифицированными по <ulink url="http://packages.gentoo.org/categories/">категориям</ulink>(англ.) </para><sect2><title>Прикладные и системные программы</title>
<informaltable frame="all">
<tgroup cols="3.4"><tbody>
<row>
<entry>
<para>Категории ПО </para>
</entry>
<entry>
<para>Программы MS Windows </para>
</entry>
<entry namest="c3" nameend="c4">
<para>Программы Linux </para>
</entry>
</row>
<row>
<entry>
<para>Аналоги </para>
</entry>
<entry>
<para>Портежи </para>
</entry>
</row>
<row>
<entry>
<para>Антивирусы </para>
</entry>
<entry>
<para>много </para>
</entry>
<entry>
<para>
<ulink url="http://www.clamav.net/">ClamAV</ulink> </para>
</entry>
<entry>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-antiviruse/clamav">clamav</ulink> </para>
</entry>
</row>
<row>
<entry>
<para>Текстовые редакторы </para>
</entry>
<entry>
<para>Блокнот / Notepad, WordPad, TextPad, Vim, Xemacs,... </para>
</entry>
<entry>
<para>
<ulink url="http://www.kde.org/">Kedit (KDE)</ulink>(грф.)<ulink url="http://www.gnome.org/">Gedit (Gnome)</ulink>
<ulink url="http://www.kde.org/">Kate (KDE)</ulink>
<ulink url="http://nedit.org/">Nedit</ulink>
<ulink url="http://www.vim.org/">Vim</ulink>(кнс.)<ulink url="http://www.xemacs.org/">Xemacs</ulink>
<ulink url="http://www.bostic.com/vi/">Nvi</ulink>
</para>
</entry>
<entry>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=kde-base/kedit">kedit</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-editors/gedit">gedit</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=kde-base/kate">kedit</ulink>
</para>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-editors/nedit">nedit</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-editors/vim">vim</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-editors/xemacs">xemacs</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-editors/nvi">nvi</ulink>
</para>
</entry>
</row>
<row>
<entry>
<para>Запись CD/DVD </para>
</entry>
<entry>
<para>BurnAtOnce, <ulink url="http://www.nero.com/">Nero</ulink> </para>
</entry>
<entry>
<para>
<ulink url="http://graveman.tuxfamily.org/">Graveman</ulink>
<ulink url="http://www.k3b.org/">K3b</ulink> </para>
</entry>
<entry>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-cdr/graveman">graveman</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-cdr/k3b">k3b</ulink> </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>Работа в сети</title>
<informaltable frame="all">
<tgroup cols="3.625"><tbody>
<row>
<entry>
<para>Категории ПО </para>
</entry>
<entry>
<para>Программы MS Windows </para>
</entry>
<entry namest="c3" nameend="c4">
<para>Программы Linux </para>
</entry>
</row>
<row>
<entry>
<para>Аналоги </para>
</entry>
<entry>
<para>Портежи </para>
</entry>
</row>
<row>
<entry>
<para>Web-браузеры </para>
</entry>
<entry>
<para>Internet Explorer, <ulink url="http://www.mozilla.org/">Mozilla</ulink>, <ulink url="http://www.mozilla.com/firefox/">Firefox</ulink>, Opera... </para>
</entry>
<entry>
<para>
<ulink url="http://www.gnome.org/projects/epiphany/">Epiphany</ulink>(грф.)<ulink url="http://galeon.sourceforge.net/">Galeon</ulink>(грф.)<ulink url="http://www.kde.org/">Konqueror</ulink>
<ulink url="http://links.twibright.com/">Links</ulink>(кнс.)<ulink url="http://www.mozilla.org/">Mozilla</ulink>(грф.)<ulink url="http://www.mozilla.com/firefox/">Firefox</ulink>(грф.)<ulink url="http://www.gnome.org/projects/nautilus/">Nautilus</ulink>(грф.)<ulink url="http://www.opera.com/linux/">Opera</ulink>(грф.) </para>
</entry>
<entry>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=www-client/epiphany">epiphany</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=www-client/galeon">galeon</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=kde-base/konqueror">konqueror</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=www-client/links">links</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=www-client/mozilla">mozilla</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=www-client/mozilla-firefox">mozilla-firefox</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=gnome-base/nautilus">nautilus</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=www-client/opera">opera</ulink> </para>
</entry>
</row>
<row>
<entry>
<para>Почтовые программы </para>
</entry>
<entry>
<para>Outlook Express, Netscape/Mozilla, Thunderbird, The Bat, Eudora, Becky, Datula, Sylpheed/Sylpheed-claws, Opera </para>
</entry>
<entry>
<para>
<ulink url="http://www.gnome.org/projects/evolution/">Evolution</ulink>(грф.)</para>
<para>
<ulink url="http://www.mozilla.org/">Mozilla messenger</ulink>
<ulink url="http://sylpheed.good-day.net/">Sylpheed</ulink>
<ulink url="http://claws.sylpheed.org/">Sylpheed-claws</ulink>
<ulink url="http://www.kde.org/">Kmail</ulink>
<ulink url="http://www.gnus.org/">Gnus</ulink>(кнс.)<ulink url="http://balsa.gnome.org/">Balsa</ulink>
<ulink url="http://www.collaboration-world.com/gnumail/">Gnumail</ulink>
<ulink url="http://www.opera.com/">Opera</ulink>
<ulink url="http://www.mozilla.org/projects/thunderbird/">Thunderbird</ulink>
<ulink url="http://www.mutt.org/">Mutt</ulink>(кнс.)<ulink url="http://www.washington.edu/pine/">Pine</ulink>(кнс.) </para>
<para/>
</entry>
<entry>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=mail-client/evolution">evolution</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=www-client/mozilla">mozilla</ulink>
</para>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=mail-client/sylpheed">sylpheed</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=mail-client/sylpheed-claws">sylpheed-claws</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=kde-base/kmail">kmail</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-emacs/gnus">gnus</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=mail-client/balsa">balsa</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=gnustep-apps/gnumail">gnumail</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=www-client/opera">opera</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=mail-client/thunderbird">thunderbird</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=mail-client/mutt">mutt</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=mail-client/pine">pine</ulink> </para>
</entry>
</row>
<row>
<entry>
<para>Клиенты быстрого обмена сообщениями (IM) </para>
</entry>
<entry>
<para>ICQ Lite, ICQ Corp, MSN, AIM, Yahoo, ... </para>
<para>Trillian ICQ (бесплатный, может заменить все 3 распространённых клиента), Miranda, Gaim </para>
<para/>
</entry>
<entry>
<para>
<ulink url="http://www.licq.org/">Licq</ulink>(ICQ) <ulink url="http://thekonst.net/en/centericq">Centericq</ulink>(Все)(кнс.) <ulink url="http://www.micq.org/">Micq</ulink>(ICQ)(кнс.) <ulink url="http://gnomeicu.sourceforge.net/">GnomeICU</ulink>(ICQ) <ulink url="http://gaim.sourceforge.net/">Gaim</ulink>(Все)</para>
<para> <ulink url="http://ayttm.sourceforge.net/">Ayttm</ulink>(Все) </para>
<para>
<ulink url="http://kopete.kde.org/">Kopete</ulink>
</para>
<para>
<ulink url="http://sim-im.org/">Simple Instant Messenger</ulink>(Все) <ulink url="http://amsn.sourceforge.net/">aMSN</ulink>(MSN) </para>
<para>
<ulink url="http://ysmv7.sourceforge.net/">YSM</ulink>(ICQ)(кнс.) </para>
<para>
<ulink url="http://public.yahoo.com/%7Emmk/index.html">Yahoo Messenger for Unix</ulink> <ulink url="http://kmess.sourceforge.net/">Kmess</ulink>(MSN) <ulink url="http://gentoo-portage.com/wiki.php?s=net-im/kmess">kmess</ulink>
</para>
</entry>
<entry>
<para> <ulink url="http://gentoo-portage.com/wiki.php?s=net-im/licq">licq </ulink>
</para>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=net-im/centericq">centericq</ulink>
</para>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=net-im/micq">micq</ulink>
</para>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=net-im/gnomeicu">gnomeicu</ulink>
</para>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=net-im/gaim">gaim</ulink>
</para>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=net-im/gaim"> </ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=net-im/ayttm">ayttm</ulink>
</para>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=net-im/kopete">kopete</ulink>
</para>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=net-im/sim">sim</ulink>
</para>
<para/>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=net-im/sim"> </ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=net-im/amsn">amsn </ulink>
</para>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=net-im/ysm">ysm</ulink>
</para>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=net-im/ymessenger">ymessenger</ulink>
</para>
</entry>
</row>
<row>
<entry>
<para>Видеоредакторы и конвертеры </para>
</entry>
<entry>
<para>
<ulink url="http://www.virtualdub.org/">VirtualDub</ulink>, <ulink url="http://virtualdubmod.sourceforge.net/">VirtualDubMod</ulink> </para>
</entry>
<entry>
<para>
<ulink url="http://fixounet.free.fr/avidemux/">Avidemux</ulink> </para>
</entry>
<entry>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=media-video/avidemux">avidemux</ulink> </para>
</entry>
</row>
<row>
<entry>
<para>Virtual CD </para>
</entry>
<entry>
<para>VirtualDrive, VirtualCD, Daemon Tools, ... </para>
</entry>
<entry>
<para>mount -o loop "mycd.iso" /mnt/cdrom </para>
</entry>
<entry>
<para/>
</entry>
</row>
<row>
<entry>
<para>Другое </para>
</entry>
<entry>
<para>
<ulink url="http://www.wikipedia.org/wiki/Bsod">Blue Screen of Death</ulink> </para>
</entry>
<entry>
<para>
<ulink url="http://www.jwz.org/xscreensaver/">XScreenSaver</ulink> </para>
</entry>
<entry>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=x11-misc/xscreensaver">xscreensaver</ulink> </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>Офис/Бизнес</title>
<informaltable frame="all">
<tgroup cols="3.4"><tbody>
<row>
<entry>
<para>Категории ПО </para>
</entry>
<entry>
<para>Программы MS Windows </para>
</entry>
<entry namest="c3" nameend="c4">
<para>Программы Linux </para>
</entry>
</row>
<row>
<entry>
<para>Аналоги </para>
</entry>
<entry>
<para>Портежи </para>
</entry>
</row>
<row>
<entry>
<para>Офисный пакет </para>
</entry>
<entry>
<para>MS Office, StarOffice / OpenOffice, 602Software </para>
</entry>
<entry>
<para>
<ulink url="http://openoffice.org/">OpenOffice</ulink>
<ulink url="http://www.koffice.org/">Koffice</ulink> </para>
</entry>
<entry>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-office/openoffice">openoffice</ulink>
</para>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-office/koffice">koffice</ulink> </para>
</entry>
</row>
<row>
<entry>
<para>Текстовый процессор </para>
</entry>
<entry>
<para>Word, StarOffice / OpenOffice Writer, 602Text, Abiword </para>
</entry>
<entry>
<para>
<ulink url="http://openoffice.org/">OpenOffice Writer</ulink>
</para>
<para>
<ulink url="http://www.koffice.org/">KWord</ulink>
<ulink url="http://www.abiword.org/">AbiWord</ulink> </para>
</entry>
<entry>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-office/openoffice">openoffice</ulink>
</para>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-office/kword">kword</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-office/abiword">abiword</ulink> </para>
</entry>
</row>
<row>
<entry>
<para>Электронные таблицы </para>
</entry>
<entry>
<para>Excel, StarOffice / OpenOffice Calc </para>
</entry>
<entry>
<para>
<ulink url="http://openoffice.org/">OpenOffice Calc</ulink>
</para>
<para>
<ulink url="http://www.koffice.org/">KSpread</ulink>
<ulink url="http://www.gnome.org/projects/gnumeric/">Gnumeric</ulink> </para>
</entry>
<entry>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-office/openoffice">openoffice</ulink>
</para>
<para>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-office/kspread">kspread</ulink>
<ulink url="http://gentoo-portage.com/wiki.php?s=app-office/gnumeric">gnumeric</ulink> </para>
</entry>
</row></tbody></tgroup>
</informaltable><sect3><title>Chat</title>
<orderedlist>
<listitem>
<para>amsn: alternative for MSN Messenger </para>
</listitem>
<listitem>
<para>gaim: alternative for Aim, ICQ, IRC, Yahoo!, MSN, Jabber (Google Talk) </para>
</listitem>
<listitem>
<para>irssi: (command line based) alternative for mIRC </para>
</listitem>
<listitem>
<para>kopete: alternative for Aim, ICQ, IRC, Yahoo!, MSN, Jabber </para>
</listitem>
<listitem>
<para>licq: alternative for ICQ </para>
</listitem>
<listitem>
<para>psi: jabber client </para>
</listitem>
<listitem>
<para>xchat: альтернатива mIRC </para>
</listitem>
<listitem>
<para>
<ulink url="http://www.kvirc.ru/">KVIrc</ulink>: альтернатива mIRC </para>
</listitem>
<listitem>
<para>konversation: alternative for mIRC </para>
</listitem>
<listitem>
<para>Skype: Skype has also version in Linux </para>
</listitem>
<listitem>
<para>WengoPhone:Wengophone also has a Linux version and is open source </para>
</listitem>
<listitem>
<para>SIM-IM: alternative for ICQ, Jabber, MSN, SMS, Yahoo!, AIM </para>
</listitem>
</orderedlist></sect3><sect3><title>File managers</title>
<orderedlist>
<listitem>
<para>krusader: alternative for Total Commander </para>
</listitem>
<listitem>
<para>
<ulink url="http://www.nongnu.org/gcmd">GNOME Commander</ulink> </para>
</listitem>
</orderedlist></sect3><sect3><title>FTP</title>
<orderedlist>
<listitem>
<para>gFTP: alternative for FileZilla, SmartFTP </para>
</listitem>
</orderedlist></sect3><sect3><title>Graphics</title>
<orderedlist>
<listitem>
<para>digiKam: alternative for the propriotary digital photo software bundled with your camera </para>
</listitem>
<listitem>
<para>gimp: alternative for Adobe Photoshop </para>
</listitem>
<listitem>
<para>
<ulink url="http://inkscape.sourceforge.net/">Inkscape</ulink>: alternative for Adobe Illustrator </para>
</listitem>
<listitem>
<para>gqview: alternative for Irfanview </para>
</listitem>
<listitem>
<para>
<ulink url="http://gwenview.sourceforge.net/">gwenview</ulink>: alternative for Irfanview </para>
</listitem>
<listitem>
<para>kuickshow: alternative for Irfanview </para>
</listitem>
</orderedlist></sect3><sect3><title>Internet</title>
<orderedlist>
<listitem>
<para>Konqueror: alternative for Internet Explorer </para>
</listitem>
<listitem>
<para>Mozilla Firefox: there is no alternative! </para>
</listitem>
<listitem>
<para>Seamonkey (previously called Mozilla): alternative for Internet Explorer </para>
</listitem>
<listitem>
<para>Opera: free but proprietary alternative for Internet Explorer </para>
</listitem>
</orderedlist></sect3><sect3><title>Mail</title>
<orderedlist>
<listitem>
<para>Evolution: alternative for Outlook </para>
</listitem>
<listitem>
<para>Mozilla Thunderbird: alternative for Outlook Express </para>
</listitem>
<listitem>
<para>Kontact / kmail: alternative for Outlook Express </para>
</listitem>
</orderedlist></sect3><sect3><title>Multimedia</title>
<orderedlist>
<listitem>
<para>AmaroK: alternative for iTunes player/WMP </para>
</listitem>
<listitem>
<para>XMMS: alternative for WinAMP <ulink url="http://komnas.com/%7Eashamril/tips/files/win-vs-lin-soft-EN.shtml">http://komnas.com/~ashamril/tips/files/win-vs-lin-soft-EN.shtml</ulink> </para>
</listitem>
<listitem>
<para>beep-media-player: alternative for WinAMP </para>
</listitem>
</orderedlist>
<orderedlist>
<listitem>
<para>kaffeine: alternative for Windows Media Player (also plays DVDs) </para>
</listitem>
<listitem>
<para>MPlayer | gmplayer | kmplayer | kplayer: alternative for Windows Media Player </para>
</listitem>
<listitem>
<para>Xine: alternative for Windows Media Player (also plays DVDs) </para>
</listitem>
<listitem>
<para>vlc: alternative for Windows Media Player </para>
</listitem>
<listitem>
<para>RealPlayer: runs natively on linux! </para>
</listitem>
<listitem>
<para>Totem : alternative for WMP, Menusupport for DVDs </para>
</listitem>
</orderedlist>
<orderedlist>
<listitem>
<para>LMMS : "Linux Music Maker Studio" Linux analog of "FL Studio" <ulink url="http://ru.gentoo-wiki.com/index.php?title=HomePage:http://www.lmms.sourceforge.net/&amp;action=edit">HomePage:http://www.lmms.sourceforge.net/</ulink> </para>
</listitem>
<listitem>
<para>Rosegarden : MIDI/Audio-sequencer <ulink url="http://ru.gentoo-wiki.com/index.php?title=HomePage:http://www.rosegardenmusic.com/&amp;action=edit">HomePage:http://www.rosegardenmusic.com/</ulink> </para>
</listitem>
<listitem>
<para>Cheese-Tracker : one of the Trackers, use QT </para>
</listitem>
</orderedlist></sect3><sect3><title>Office</title>
<orderedlist>
<listitem>
<para>OpenOffice.org: alternative for MS Word, Excel, Powerpoint and Access, great support for MS formats </para>
</listitem>
<listitem>
<para>KOffice : like above without MS format support. Includes more specialized apps than even the full MS Office Pro </para>
</listitem>
<listitem>
<para>AbiWord : Only like MS Word. Decent MS Format support. Includes grammar check </para>
</listitem>
<listitem>
<para>StarOffice: commercial version of OpenOffice.org, includes extras (grammar check) </para>
</listitem>
<listitem>
<para>kpdf, xpdf, epdfview, evince: PDF readers, alternative for Adobe Acrobat Reader </para>
</listitem>
</orderedlist></sect3><sect3><title>P2P</title>
<orderedlist>
<listitem>
<para>Azureus: java bittorrent client (or bittorrent which is written in python) </para>
</listitem>
<listitem>
<para>qtorrent, ktorrent: bittorrent clients </para>
</listitem>
<listitem>
<para>Limewire + gtk-gnutella: Gnutella client </para>
</listitem>
<listitem>
<para>MLDonkey + Sancho: client and interface for bittorrent, Gnutella, FastTrack, etc. </para>
</listitem>
<listitem>
<para>aMule: alternative for eMule </para>
</listitem>
<listitem>
<para>xmule: alternative for eMule </para>
</listitem>
<listitem>
<para>nicotine: soulseek client </para>
</listitem>
<listitem>
<para>Valknut, <ulink url="http://linuxdcpp.berlios.de/articles.php?um=index">LinuxDC++</ulink>: альтернативные клиенты для DC (Direct Connect) </para>
</listitem>
</orderedlist>
<para/></sect3></sect2></sect1><sect1><title>
О Gentoo Linux</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://gentoo.ru/about">http://gentoo.ru/about</ulink>
</para>
<para>C версии: 1.0</para>
<para/>
<para/>
<para/>
<para>Gentoo – английское название вида пингвинов Pygoscelis papua (русские варианты названия: субантарктический пингвин, папуанский пингвин, ослиный пингвин). Согласно Книге рекордов Гиннеса 98 этому виду пингвинов принадлежит рекорд скорости плавания (27км/ч).</para>
<para>Gentoo Linux – дистрибутив, который может быть автоматически оптимизирован и приспособлен для применения практически в любой области в соответствии с вашими требованиями. Наивысшая производительность, настраиваемость и высококлассное сообщество пользователей и разработчиков – вот отличительные черты Gentoo.</para>
<para>Благодаря технологии портежей, Gentoo Linux станет идеальным защищенным сервером, рабочей станцией разработчика, профессиональной настольной системой, системой для игр, встроенной системой или чем-либо другим – всем, чем вы пожелаете. Из-за практически неограниченной способности дистрибутива подстраиваться под нужды пользователя, мы называем Gentoo Linux "метадистрибутивом".</para>
<para/><sect2><title>Что такое портежи?</title>
<para/>
<para>Portage — сердце Gentoo Linux, выполняющее множество ключевых функций. Например, portage — это система распространения программного обеспечения Gentoo Linux. Для того, чтобы получить доступ к последним версиям программ, в Gentoo Linux достаточно набрать всего одну команду: emerge --sync (emerge; средство установки/удаления программ (дословно: emerge - выяснять, всплывать, появляться)). Эта команда заставляет Portage обновить локальное дерево портежей вашей системы через интернет. В локальном дереве портежей содержится полная коллекция сценариев, которые используются для сборки и установки последних версий пакетов Gentoo. Сейчас в нашем дереве Portage более 10000 пакетов, а обновления и новые пакеты добавляются каждый день. </para>
<para>Portage также является системой сборки и установки пакетов. Желая установить пакет, нужно просто набрать: emerge имя_пакета, при этом Portage автоматически соберет вариант пакета «на заказ» в точности по вашим указаниям, оптимизируя его под ваше оборудование и гарантируя, что нужные вам дополнительные возможности включены, ненужные — нет. </para>
<para>Portage также следит за тем, чтобы ваша система не устаревала. </para>
<para>Команда: emerge -u world — всего одна команда — позаботится о том, чтобы все нужные именно вам пакеты в системе автоматически обновились.</para></sect2><sect2><title>Gentoo Linux</title>
<para/>
<para>С помощью портежей можно обновлять систему Gentoo Linux при малейшем желании. Поэтому опытные пользователи Gentoo не обращают особого внимания на «новые версии» Gentoo Linux: в конце концов, свежайшую версию Gentoo Linux всегда можно получить, набрав команду: emerge --sync. Нет необходимости ждать несколько месяцев выпуска «новой версии» дистрибутива, поскольку Gentoo Linux непрерывно обновляется и улучшается, а все изменения немедленно становятся доступны пользователям. </para>
<para/>
<para>Безусловно, мы издаем официальные выпуски Gentoo Linux на компакт-дисках, чтобы вновь устанавливаемые системы с самого начала были как можно свежее. Вот краткий обзор того, что включено в самый свежий выпуск Gentoo Linux:</para>
<orderedlist>
<listitem>
<para>поддержка процессоров x86, AMD64, PowerPC, UltraSparc, Alpha и MIPS </para>
</listitem>
<listitem>
<para>установка на x86, AMD64, PowerPC, UltraSparc и Alpha с диска LiveCD </para>
</listitem>
<listitem>
<para>новейшие стабильные KDE и GNOME </para>
</listitem>
<listitem>
<para>различные оптимизированные ядра Linux </para>
</listitem>
<listitem>
<para>весьма современная среда разработки GNU </para>
</listitem>
<listitem>
<para>отличная поддержка файловых систем: ReiserFS, XFS, ext3, EVMS, LVM </para>
</listitem>
<listitem>
<para>превосходная поддержка оборудования: NVIDIA, Creative Labs Live! и Audigy </para>
</listitem>
<listitem>
<para>модульная подсистема OpenGL и компилятора (с поддержкой сосуществования нескольких версий) </para>
</listitem>
<listitem>
<para>понятные сценарии запуска системы, основанные на зависимостях </para>
</listitem>
<listitem>
<para>новая инициатива системы безопасности «укрепленный Gentoo» </para>
</listitem>
<listitem>
<para>более 10000 пакетов лучших новейших программ </para>
</listitem>
<listitem>
<para>расширенные возможности системы портежей </para>
</listitem>
</orderedlist>
<para/>
<para>Если вас привлекли мощь, гибкость и скорость Gentoo Linux, обязательно испытайте его в деле. Мы уверены: вы не разочаруетесь!</para>
<para/></sect2><sect2><title>История Gentoo</title>
<para/>
<para>Все началось с Лишнего Времени. Времени — на изучение, Времени — на исследования, Времени — на эксперименты... Именно так создатель Gentoo Дэниел Роббинс шагнул в мир Linux. Он начал с Debian Linux, настроил пару приложений, изучил Linux от «А» до «Я», а затем, как поступает большинство пользователей Linux, перепробовал еще парочку дистрибутивов, принявшись помогать дистрибутиву под названием Stampede Linux. И вскоре, погрузившись в разработку Stampede, он уже работал над их системой управления пакетами. Через некоторое время, по определенным причинам, он пошел дальше и решил создать свой собственный дистрибутив. </para>
<para>Так родился «Енох». Дэниел хотел, чтобы Енох стал чрезвычайно быстрым дистрибутивом, способным полностью автоматизировать процесс создания и обновления пакетов. Вскоре появился канал #enoch на irc.freenode.net и 10 разработчиков, участвующих в создании дистрибутива. По прошествии времени, когда Енох подрос, им показалось, что дистрибутиву нужно новое имя. Они нарекли его Gentoo Linux. И как раз в то время, когда выход Gentoo 1.0 был на носу, Дэниел купил новую быструю машину. В материнской плате оказался дефектный чип, из-за которого Linux при простое зависал, и из-за этого разработка Gentoo полностью встала. </para>
<para>С тех пор чего только не происходило с Gentoo... Дэниел переключился на FreeBSD. Увиденное ему понравилось. Особенно система портов. И он вернулся в мир Linux. При поддержке других разработчиков, таких как Аким Готтингер, Gentoo снова вышел в путь и стремительно рванулся вперед. Система управления пакетами подверглась полной переработке и получила название Portage. С тех пор год за годом Gentoo пребывает в активной разработке, с постоянным добавлением массы новых возможностей. Команды добровольцев помогают удерживать Gentoo на самом переднем крае, одновременно обеспечивая максимальную безопасность и стабильность. </para>
<para>Модель разработки Gentoo дополнилась полностью проектно-ориентированным подходом, где каждый проект разрабатывается независимо, но в сотрудничестве с другими проектами Gentoo. Регулярные совещания ведущих («менеджеров проектов») поддерживают быстрый темп разработки. Чтобы позаботиться о финансовых вопросах, обеспечить юридическую защиту и удержать разработку Gentoo в рамках общественного договора, создан фонд Gentoo. </para>
<para>В апреле 2004 Дэниел решил оставить пост разработчика Gentoo. Мы все весьма благодарны Дэниелу за его вклад в Gentoo, и желаем ему всего наилучшего. </para>
<para>Сейчас Gentoo продолжает расти, развиваться и улучшаться: появляются новые проекты, присоединяются новые разработчики, каждый день добавляются свежие пакеты. Но, безусловно, наивысшая ценность Gentoo — это сообщество разработчиков и пользователей Gentoo!</para>
<para/></sect2><sect2><title>Философия Gentoo</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://gentoo.ru/philosophy">http://gentoo.ru/philosophy</ulink>
</para>
<para>С версии: 1.0</para>
<para>Автор: Daniel Robbins - изначальный разработчик Gentoo</para>
<para>Перевод: Логинов Игорь</para>
<para>Я начал работу над Gentoo, потому как не мог найти дистрибутива, который бы меня устраивал. Во всех Linux-дистрибутивах я заметил одну неприятную деталь - инсталляционные утилиты, управляющие установкой ПО в системе, предназначались для упрощения работы, однако на практике лишь мешали администрированию системы.</para>
<para>Поэтому я и создал Gentoo с её собственной системой портэжей (т.н. Portages), более совершенной, чем все системы управления ПО, существовавшие до этого. Система портэжей отличается большой гибкостью и даёт возможность пользователю успешно использовать её для решения конкретных задач независимо от поставленных целей.</para>
<para>Например, если вы хотите посмотреть подробности сборки пакета, вы можете посмотреть файл ebuild. </para>
<para>ebuild - сборочный файл (вероятно, авторское сокращение от emerge build file)</para>
<para>и получить всю необходимую информацию оттуда. Чтобы настроить параметры установки, можно воспользоваться переменной USE. Чтобы добавить новый пакет, можно просто создать новый файл ebuild для дерева портэжей. Вы также можете установить требуемый пакет командой emerge - система автоматически проследит за установкой всех необходимых пакетов, от которых зависит нужное вам приложение.</para>
<para>Linux-сообщество оценило новую систему портэжей, и Gentoo начал стремительно развиваться. Дистрибутив получил известность как "дистрибутив исходников", однако сутью Gentoo является вовсе не принцип "from source" (из исходников). Конечно, это важный, ключевой принцип дистрибутива, но не основной. Основным здесь является технология, позволяющая пользователю делать с системой всё что угодно, без каких либо ограничений.</para>
<para>Работая над этой технологией, я представлял себе произвольного пользователя ОС Linux. Что он (или она) хотел бы сделать с системой? </para>
<para/>
<para>Философия Gentoo - дистрибутив, дающий возможность делать с системой всё что угодно.</para>
<para>Камнем преткновения для появления Gentoo было отсутствие простого метода автоматической установки ПО из исходников, ориентированного на пользователей, с подробными инструкциями. На данный момент мы решили эту задачу практически полностью. Частично реализована поддержка прекомпилированных пакетов, хотя, с другой стороны, с момента своего появления система портежей Gentoo поддерживала установку бинарников.</para>
<para>Реализация поддержки бинарных пакетов очень важна, т.к. большое количество ПО распространяется именно в бинарниках (например, в виде пакетов RPM - прим. переводчика). Если бы Gentoo не поддерживал бинарные пакеты, мы бы не смогли бы назвать его удобным дистрибутивом, позволяющим пользователю делать с системой всё, что ему придёт в голову. Впрочем, помимо "философских" причин для поддержки бинарников есть много причин практических.</para>
<para>Философию Gentoo можно сформулировать в нескольких предложениях:</para>
<orderedlist>
<listitem>
<para>Каждый линуксоид использует компьютер для решения своих конкретных задач. </para>
</listitem>
<listitem>
<para>Главной целью Gentoo является предоставление ПО, позволяющего пользователю выполнять свои задачи эффективно.</para>
</listitem>
<listitem>
<para>Утилиты Gentoo должны быть удобны в использовании, должны позволить пользователю оценить по достоинству все преимущества открытого ПО вообще и Linux в частности. Такое возможно лишь при наличии огромной базы открытого ПО, отражающей все потребности современных пользователей, содержащей тысячи разнообразных программ, по возможности удобных. </para>
</listitem>
<listitem>
<para>Если некая утилита вынуждают пользователя выполнять какие-то нестандартные действия для совершения стандартных операций - она скорее мешает работе, чем помогает. Каждый встречал подобные утилиты, неудобные в работе, лишённые ряда очевидных функций. Такое ПО противоречит философии Gentoo.</para>
</listitem>
</orderedlist>
<para/>
<para>Другими словами, философия Gentoo также заключается в разработке корректного ПО. Когда утилита выполняет свои и только свои обязанности, но выполняет их в полной мере, вы можете забыть о её присутствии (что, впрочем, соответствует философии Unix вообще как таковой - прим. переводчика). Она не помешает, не попытается взаимодействовать с вами, пока вы сами не захотите этого.</para>
<para>В настоящее время в перспективы Gentoo входит поддержка и создание ПО, близкого к идеалу - мощных и простых в использовании утилит, способных обеспечить выполнение множества различных задач. Разве не прекрасно иметь возможности найти ПО, делающее именно то, что вы от него хотите? Разве это не вызывает чувство эстетического наслаждения? Наша задача - донести это чувство до как можно большего числа людей.</para></sect2></sect1><sect1><title>Советы пользователям Gentoo </title>Советы пользователям Gentoo<para/>
<para>Ссылка на оригинал: <ulink url="http://ylsoftware.com/?action=news&amp;na=viewfull&amp;news=130">http://ylsoftware.com/?action=news&amp;na=viewfull&amp;news=130</ulink>
</para>
<para>C версии: 1.0</para>
<para>Автор: <ulink url="mailto:moose@home.ylsoftware.com?subject=По%20поводу%20вашей%20статьи:%20Советы%20пользователям%20Gentoo">MooSE</ulink>
</para>
<para>Дата: 22.11.2006</para>
<para/>
<para/>
<para>Gentoo - один из самых трудных для изучения дистрибутивов. Хотя многие старые пользователи скажут что огромное сообщество и обширная документация могут здорово помочь новичкам. В этой статье приведён ряд подсказок, которые помогут новым пользователям быстрее освоить Gentoo.</para>
<para/>
<para>Для начала приготовьтесь прочитать огромное количество документации. Вы не сможете установить Gentoo не изучив внимательно <link linkend="">Handbook (</link>
<link linkend="">Главное руководство Gentoo- см. ниже: Настольная книга пользователя).</link>
</para>
<para/>
<para>Gentoo имеет графический инсталлятор, но новичкам не стоит его использовать. Установка Gentoo "традиционным" способом вынуждает читать документацию, и способствует лучшему понимаю системы. Так же инсталлятор Gentoo не так хорош при установке и настройке драйверов как инсталляторы других дистрибутивов.</para>
<para/>
<para>Handbook содержит основную информацию о Gentoo. Дополнительная информация (например о настройке X и ALSA) может быть найдена на странице документации или на Gentoo Wiki.</para>
<para/>
<para>Ви́ки (WiKi) (от гавайского: быстрый) — гипертекстовая среда (обычно Веб-сайт) для сбора и структуризации письменных сведений (в программировании: документации, советов, часто задаваемых вопросов(FAQ), мини-руководств(HOWTO)). </para>
<para>Характеризуется следующими признаками:</para>
<orderedlist>
<listitem>
<para>Множество авторов. Некоторые вики могут править все посетители.</para>
</listitem>
<listitem>
<para>Возможность многократно править текст посредством самой вики-среды (вебсайта), без применения особых приспособлений на стороне редактора.</para>
</listitem>
<listitem>
<para>Проявление изменений сразу после их внесения.</para>
</listitem>
<listitem>
<para>Разделение информации на страницы, где у каждой своё название.</para>
</listitem>
<listitem>
<para>Особый язык разметки, позволяющий легко и быстро размечать в тексте структурные элементы, форматирование, гиперссылки и т. п.</para>
</listitem>
<listitem>
<para>Учёт изменений (учёт версий) текста и возможность отката к ранней версии.</para>
</listitem>
</orderedlist>
<para/>
<para>Для создания вики-среды необходимо особое ПО — движок вики. Это частный вид системы управления сайтом, довольно простой в своём устройстве и функциональности, ибо почти все действия по структуризации и обработке сведений делаются пользователями вручную. Главная особенность — посетители  сайта могут сами редактировать содержимое этих страниц и создавать новые. Wiki сделаны так, чтобы редактировать страницы было просто; для редактирования ничего кроме программы веб-броузера не нужно.</para>
<para>ALSA, или Advanced Linux Sound Architecture — продвинутая Звуковая Архитектура Linux, обеспечивает аудио- и MIDI- (Musical Instrument Digital Interface — Цифровой Интерфейс Музыкальных Инструментов) функциональность в операционной системе Linux. ALSA является основной звуковой подсистемой в ядрах 2.6, заменившей собой OSS (Open Sound System - Открытая Звуковая Система), которая использовалась в ядрах 2.4</para>
<para>X-сервер (или просто Иксы)- обычного пользователя могут испугать мысли о необходимости печатать в командной строке. Почему бы ему не прокладывать свой путь на территории свободы выбора Gentoo (и Linux вообще), просто «водя мышкой»? Ну, конечно, вы сможете это сделать :-). В Linux предлагается широкое разнообразие пользовательских интерфейсов и сред, которые можно установить поверх установленной у вас системы. </para>
<para/>
<para>Это один из самых больших сюрпризов, с которым сталкиваются новички: графический интерфейс пользователя — это всего лишь прикладная программа, выполняемая в системе. Он не является частью ядра Linux или каких-либо других компонентов системы. Это — мощный инструмент, позволяющий полностью задействовать графические возможности вашего компьютера. </para>
<para/>
<para>Так как стандартизация очень важна, для организации прорисовки и перемещения окон по экрану, взаимодействия пользователя с мышью и клавиатурой, а также других важных базовых аспектов, был создан стандарт под названием X Window System, сокращённо X11 или просто X. Он используется в Unix, Linux и других Unix-подобных операционных системах во всем мире. </para>
<para/>
<para>Приложение, которое дает пользователям Linux возможность запускать графические интерфейсы пользователя и использует стандарт X11, называется Xorg-X11, ответвление проекта XFree86. Проектом XFree86 было решено использовать лицензию, возможно, несовместимую с лицензией GPL, поэтому рекомендуется использовать Xorg. Пакет XFree86 больше не поддерживается в официальном дереве портежей. </para>
<para/><sect2><title>Проект X.org</title>
<para/>
<para>Проектом X.org создана и поддерживается бесплатно распространяемая реализация системы X11 с открытым исходным кодом. Это открытая инфраструктура рабочей станции, основанная на X11. </para>
<para/>
<para>Xorg обеспечивает интерфейс между устройствами вашего компьютера и нужными вам графическими программами. Кроме того, Xorg является полностью сетевым, то есть вы можете запускать программу на одной системе, а отображать ее — на другой. </para>
<para>Если у вас возник специфический вопрос, не освещённый в документации - попробуйте спросить на форуме или в <link linkend="">IRC</link>.</para>
<para/></sect2></sect1><sect1><title>Основы Portage</title>
<para/>
<para>Одно из фундаментальных отличий Gentoo от других дистрибутивов - его система управления пакетами, названная Portage, ориентированная в первую очередь на установку программ из исходных текстов. Это позволяет иметь множество настроек и точек контроля для одного пакета там, где пользователи бинарных дистрибутивов имеют несколько пакетов с разными опциями и зависимостями (фактически это тоже самое, только управление различными опциями сборки не такое гибкое). С Portage вы можете установить так называемые USE-флаги для настройки опций одного пакета или даже всей системы.</para>
<para/>
<para>Например если вы хотите включить поддержку KDE и выключить поддержку GNOME вам нужно добавить к строке USE в файле /etc/make.conf флаги "kde -gnome". Для получения более подробной информации о USE-флагах смотрите <link linkend="">Gentoo Handbook</link>.</para>
<para/>
<para>Для работы с Portage используется команда emerge. Например для установки пакета moo достаточно набрать команду: emerge moo. Portage проверит зависимости, скачает все необходимые архивы с исходниками, соберёт пакет и установит его. Вся необходимая информация сохранена в базе, состоящей из ebuild'ов, каждый из которых представляет собой специальный скрипт. Все ebuild'ы находятся в папке /usr/portage.</para>
<para/><sect2><title>Управление настройками Portage</title>
<para/>
<para>Первое правило Gentoo - нужно внимательно следить за флагами USE. Почему при установке Midnight Commander устанавливается X.Org - потому что у вас разрешён флаг X. Почему нет KPDF в KDE? - Потому что KDE был собран без флага pdf (не спрашивайте почему всё же собрался KGhostScript).</para>
<para/>
<para>Всегда устанавливайте новые пакеты командной emerge --ask --verbose (или emerge -av) для просмотра USE-флагов перед началом компиляции. Установите пакет gentoolkit (emerge gentoolkit) - среди множества полезных вещей он содержит утилиту euse, которая существенно упрощает управление флагами USE<footnote>
<para> Также имеется утилита: ufed (установка: emerge ufed) для более дружественного просмотра  USE флагов</para>
</footnote>. Выполните euse -i flag для получения информации о флаге "flag". Так же просмотрите man-страницу euse (не волнуйтесь. она короткая :-)).</para>
<para/>
<para>Если вы хотите изменить USE-флаги только для одного пакета не пытайтесь собирать его командой USE="some flags" emerge moo. Это конечно сработает, но при обновлении системы пакет будет пересобран со старыми флагами. Лучше прописывайте USE-флаги в /etc/portage/package.use, для этого выполните echo "category/moo some flags" &gt;&gt; /etc/portage/package.use перед установкой пакета.</para>
<para/>
<para>Тоже относится и к ACCEPT_KEYWORDS - используйте /etc/portage/package.keywords. В Portage 2.1 вы можете использовать папки package.use и package.keywords вместо файлов для более простого управления.</para>
<para/></sect2><sect2><title>Когда нужно использовать оверлеи?</title>
<para>Оверлей - набор ebuild'ов, которые вы хотите добавить к официальной базе данных (дереву) Portage</para>
<para/>
<para>Иногда возникает необходимость установить пакет, отсутствующий в Portage. Например вы можете захотеть установить пакет, удалённый из дерева Portage. Тогда вам нужно взять его ebuild из архива Portage CVS. Или например вы захотите установить новый пакет, взяв ebuild в bugzilla. Возможна ситуация, когда вы просто захотите немного подправить официальный ebuild.</para>
<para/>
<para>В любом случае вам нужно в такой ситуации поместить ваш ebuild в локальный оверлей. Оверлей - набор ebuild'ов, которые вы хотите добавить к официальной базе данных (дереву) Portage. </para>
<para/>
<para/>
<para>Не храните свои ebuild'ы внутри официального дерева (/usr/portage), поскольку при обновлении они будут удалены. </para>
<para/>
<para>Создайте каталог для оверлея, и создайте в нём структуру подкаталогов, аналогичную /usr/portage. Поместите туда ваш ebuild. Добавьте PORTDIR_OVERLAY="/path/to/local/overlay" в ваш файл /etc/make.conf.</para>
<para/>
<para>Обычное место для оверлеев - /usr/local/overlays. Таким образом местом для вашего ebuild'а будет /usr/local/overlays/local. Что же ещё может находиться в /usr/local/overlays.</para>
<para/>
<para>Во многих случаях, когда вы ищите пакеты, не включённые в официальное дерево, вы находите не только ebuild'ы, но и оверлеи. Например один из самых популярных оверлеев xgl-coffee содержит всё, что нужно для работы XGL. Вы можете установить его в /usr/local/overlays/xgl-coffee что не смешивать с другими оверлеями и обновлять его через SVN.</para>
<para/>
<para>Вы можете найти подробную информацию относительно использования оверлеев на <ulink url="http://ru.gentoo-wiki.com/">Gentoo Wiki</ulink>. Там же вы найдёте список неофициальных оверлеев и описание процесса синхронизации с ними.</para>
<para/></sect2><sect2><title>Как часто нужно обновляться?</title>
<para/>
<para>Вам нет смысла обновляться чаще чем раз в сутки. Можно даже реже. Вы можете следить за вашими любимыми пакетами периодически посещая сайты packages.gentoo.org или gentoo-portage.com (или подписавшись на RSS).</para>
<para/>
<para>Сохраните мир чистым !</para>
<para/>
<para>Каждый раз, когда вы выполняете emerge some-package, имя пакета записываете в файл /var/lib/portage/world. Когда вы обновляете систему командой emerge --update --deep world - используется список из этого файла. Поэтому этот файл должен быть по возможности короче. В нём должны быть только необходимые пакеты. </para>
<para/>
<para>Если какой-то пакет является всего лишь зависимостью другого - не стоит держать его в файле world.</para>
<para/>
<para>Например, если вы устанавливаете пакет, использующий библиотеку wxWidgets, то эта библиотека устанавливается как зависимость и не добавляется в файл world. Если вы деинсталлируете все пакеты использующие эту библиотеку - она перестанет обновляться при выполнении emerge --update (...) world, и будет удалены после вызова emerge --depclean. Единственный случай когда стоит добавить wxWidgets в world - если вы разрабатываете приложения на основе этой библиотеки.</para>
<para/>
<para>Существует скрипт, помогающий очистить world от всего лишнего. Для установки пакета без занесения его в world используйте опцию --oneshot. Эта опция так же будет хорошем решением при временной установке какого-либо пакета.</para>
<para/></sect2><sect2><title>Деинсталляция пакетов</title>
<para/>
<para>Все ваши действия с emerge записываются в файл /var/log/emerge.log. Если вы хотите знать какой пакет собирается в настоящее время - выполните tail /var/log/emerge.log. Утилита genlop (emerge genlop) позволяет извлечь множество различной информации из этого файла. Например genlop -c покажет вам какой пакет собирается в данный момент и попытается предсказать сколько времени осталось до конца сборки.</para>
<para/></sect2><sect2><title>Удаление временных файлов</title>
<para/>
<para>Когда сборка пакета завершается с ошибкой - остаётся каталог с временными файлами в /var/tmp/portage. Если вы устраняете проблему и пакет нормально собирается - файлы удаляются. Если же нет - вы можете очистить каталог /var/tmp/portage вручную.</para>
<para/>
<para>После обновления вы можете удалить устаревшие файлы из /usr/portage/distfiles. Для этого воспользуйтесь утилитой eclean из пакета gentoolkit. Она поможет удалить ненужные файлы. Эта утилита может работать как с исходниками, так и с бинарными пакетами. (просто вызовите её как eclean-dist или eclean-pkg соответственно). Прочитайте страницу man для получения полного списка опций.</para>
<para/>
<para>Gentoo предоставляет вам огромные возможности по настройке вашей системы. Автор статьи надеется что после прочтения этих строк вы сможете воспользоваться этими возможностями и испытать чувство глубокого удовлетворение от возможности управления любыми аспектами системы. Вам понравиться это ощущение.</para></sect2></sect1><sect1><title>Gentoo Linux: установка и настройка</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://posix.ru/distro/gentoo_old/">http://posix.ru/distro/gentoo_old/</ulink>
</para>
<para>Автор: Алексей Федорчук (<ulink url="mailto:alv@linux-online.ru?subject=По%20поводу%20статьи%20о%20Gentoo">alv@linux-online.ru</ulink>)</para>
<para>С версии: 1.0</para>
<para/>
<para>О Gentoo Linux</para>
<para/>
<para>Gentoo Linux - один из типичных представителей т.н. Source Based дистрибутивов. То есть систем, основанных не на прекомпилированных бинарных пакетах, а собираемых непосредственно из исходных текстов. Gentoo относительно молод, но известностью сравнялся с такими ветеранами дистростроения, как Red Hat или Debian. </para>
<para/>
<para>Gentoo создан в 2001 г. Дэниелем Роббинсом. Официальный сайт проекта – http://www.gentoo.org.(Русский: http://gentoo.ru)</para>
<para/>
<para>С самого начала Gentoo являл собой синтез наиболее передовых технологий Linux с традиционными достижениями BSD-систем (в первую очередь - FreeBSD). В частности, в нем приняты сценарии начальной загрузки системы в BSD-стиле - большинство популярных дистрибутивов Linux наследуют схему инициализации системы, унаследованную от Unix System V (именно она была принята за основу Линусом Торвальдсом при создании своего ядра).</para>
<para/>
<para>Главная особенность Gentoo также идейно унаследована от FreeBSD. В последней, как известно, только базовые компоненты (т.н. Distribution) устанавливаются из прекомпилированных пакетов. Для установки же пользовательских приложений предназначена т.н. система портов. Это - набор средств для автоматизированного получения из Сети (с мастер-сайтов разработчиков или их официальных зеркал) исходных текстов программ, их конфигурирования, компиляции, установки и регистрации в специальной базе данных. Конечно, и FreeBSD поставляется с наборами прекомпилированных пакетов (packages), однако роль их сугубо вспомогательная.</para>
<para/>
<para>В Gentoo концепция портов (именуемых здесь портежами - Portages) проводится еще более последовательно, чем во FreeBSD. Поскольку здесь этим путем можно установить (или - обновить) не только прикладные программы, но и все базовые компоненты системы, вплоть до ядра, компилятора gcc и главной системной библиотеки glibс.</para>
<para/>
<para>Система портежей Gentoo позволяет:</para>
<orderedlist>
<listitem>
<para>очень гибкое конфигурирование системы, с подбором только необходимых (и осознанно выбираемых) приложений;</para>
</listitem>
<listitem>
<para>открыть путь для оптимизации системы не только под различные архитектуры (а на данный момент дистрибутивом поддерживаются, кроме i86, также Sparc, PowerPC и Alpha), но и под конкретные типы процессоров;</para>
</listitem>
<listitem>
<para>средства генерации бинарных пакетов (аналог packages FreeBSD), которые могут быть установлены на целевую платформу, отличную от host-машины;</para>
</listitem>
<listitem>
<para>оптимизировать пакеты с учетом особенностей целевой (например, более слабой) машины.</para>
</listitem>
</orderedlist>
<para/>
<para>Дополнительным плюсом дистрибутива Gentoo является его прекрасная документированность. На сайте проекта доступны <link linkend="">Gentoo Handbook</link> и множество более частных источников информации, ряд из которых переведен на русский язык.</para>
<para/>
<para>Название дистрибутива (произносится как "джен-ту") может показаться несколько странным. Но объясняется просто - это один из видов пингвина (научное название Pygoscelis papua), обитающий на Циркум-Антарктических островах (Фолклендских, Кергелен, Южная Георгия).</para>
<para/>
<para>В специальной литературе можно прочитать, что джен-ту отличается небольшим размером и стремительностью. Именно эти его качества и воплощены в дистрибутиве Gentoo.</para>
<para/><sect2><title>Получение дистрибутива</title>
<para/>
<para>Все версии дистрибутива Gentoo доступны на основном сервере проекта и на ряде его зеркал. Скачивание - по протоколам http и ftp, разумеется, свободно и бесплатно. Конечно, за некоторую сумму можно заказать и CD-вариант, но в наших условиях это не актуально.</para>
<para/>
<para>Процесс получения Gentoo имеет некоторые особенности, отличающие его от получения (приобретения) любого пакетного дистрибутива. Если для последнего достаточно скачать iso-образы CD-дисков и записать их на соответствующие носители, продуктивное использование Gentoo требует выхода в Интернет. Правда, не обязательно с той же машины, на которую он устанавливается - вполне допустима ситуация, когда необходимые компоненты получаются, например, по рабочему каналу, а сама система устанавливается дома.</para>
<para/>
<para>Итак, первое, что необходимо для установки - скачать образ инсталляционного диска. Объемы образов - достаточно скромны, обычно около 200 Мбайт (в зависимости от версии). Образы эти являют собой Live CD - то есть фактически полноценную Linux-систему, запускаемую с компакт-диска. И включающую набор не только системных утилит, но и пользовательских приложений.</para>
<para/>
<para>Образ инсталляционного диска обычно содержит все необходимое для установки. Однако в некоторых версиях его оказывается недостаточно - потребуется еще три архива (*.tar.bz2), содержащие (в прекомпилированном виде) компоненты базовой системы. Первый из них (файл stage1-*, объемом около 10 Мбайт) специфичен для архитектуры (i86, PowerPC, Sparc и т.д.). Два других тарбалла (stage2-* и stage3-*, около 50 и 80 Мбайт, соответственно), кроме этого, для PC-архитектуры представлены в нескольких вариантах, оптимизированных под конкретные процессоры: от i486 до Pentium-4 (включая и Athlon). Ясно, что скачиванию подлежат только тарбаллы, соответствующие реалиям пользователя.</para>
<para/>
<para>Далее, для установки пре-релиза потребуется скачать архив системы портежей - один из файлов вида portage-200XXXXX.tar.bz2, расположенных в каталоге ~/gentoo/snapshots (в стабильной версии текущий архив портежей размещен на установочном диске). Как легко понять, цифры в имени файла соответствуют дате создания архива (а обновляется система портежей чуть ли не ежедневно), и лучше выбирать последний по времени.</para>
<para/>
<para>И наконец, при установке на машину без выхода в сеть неплохо заблаговременно скачать архивы исходных текстов базовых компонентов системы - об их составе я скажу несколько позже. И не обязательно с сайта разработчика: исходники всех портированных в Gentoo программ можно найти на сайте проекта в каталоге ~/gentoo/distfiles (или ~/gentoo/gentoo-sources, содержание их идентично). Наличие их очень упростит жизнь, однако, как будет показано ниже, обойтись без них можно.</para>
<para/>
<para>А вот без чего никак не обойтись - это без одного из дополнительных носителей, на котором будут размещены скачанные компоненты. При установке на "чистую" машину ими могут быть: второй CD (при наличии двух приводов, например, пишущего и читающего) или Zip (как нетрудно подсчитать - желательно 250-мегабайтного объема, иначе их придется менять в процессе установки). Можно также временно подцепить дополнительный винчестер с уже существующим разделом и какой-либо файловой системой (из числа поддерживаемых) на нем. Ну и заблаговременно переписать на эти носители все требуемые файлы - тарбаллы stage2-*, stage3-* и portage-* - обязательно, прочие - по возможности и желанию.</para>
<para/>
<para>К слову сказать, на тот же носитель хорошо поместить и инструкцию по установке с сайта Gentoo (добавлю, и все прочие файлы документации - тоже, отнюдь не повредят). Или, по крайней мере, держать ее распечатку под рукой - зело способствует. И можно приступать к установке.</para>
<para/>
<para>Помещать тарбаллы базовой системы и системы портежей, а также документацию, можно где угодно - хоть в корне файловой системы дополнительного накопителя. А вот под архивы исходников лучше создать на нем отдельный каталог, например, src - ниже будет ясно, почему.</para>
<para>Загрузка системы и первые шаги</para>
<para/>
<para>Редкий инсталляционный диск Linux-дистрибутива ныне не является загрузочным. И Gentoo тут - не исключение: чтобы загрузиться с любого из вышепоименованных образов, достаточно поместить диск в привод, нажать на Reset, выставить соответствующие опции в Setup BIOS и подождать некоторое время, по возможности вникая в появляющиеся сообщения об имеющемся оборудовании (впрочем, все эти сведения можно будет получить и потом - командой dmesg.</para>
<para/>
<para>Ожидание завершается выводом приглашения на ввод пользовательского имени (login), ответом на что служит волшебное слово root, а затем и пароля - на это отвечаем просто нажатием клавиши Enter. За этим появляется приглашение командной строки - и можно приступить к дальнейшим действиям.</para>
<para/>
<para>Они не вполне тривиальны. Еще одна отличительная особенность дистрибутива Gentoo, о которой я не упомянул ранее - полное отсутствие какого-либо инсталлятора, все манипуляции по установке осуществляются прямыми директивами из командной строки и прямым редактированием конфигурационных файлов в текстовом редакторе. Что начинающего (да и не очень начинающего) пользователя может просто обескуражить.</para>
<para/>
<para>Однако все не так страшно. Во-первых, в нашем распоряжении - вышеупомянутая подробная, буквально пошаговая, инструкция по установке. А во-вторых (и об этом также говорилось ранее), установочный диск Gentoo - не просто загрузочный, а так называемый Live CD. То есть просто-напросто загружающий полноценную рабочую Linux-среду с корневой файловой системой в оперативной памяти (способной монтировать в себя файловые системы любых устройств). И потому в процессе установки в руках пользователя - вся мощь ОС Linux, включая командную оболочку bash и 6 виртуальных консолей (авторизоваться в любой из них можно точно так же, как и в первой - вводом имени root без пароля). Ну а в третьих - загружаемое с CD Linux-ядро собрано с поддержкой абсолютно всех опций, которые могут потребоваться при установке (встроенной в ядро или модульной).</para>
<para/>
<para>И потому первое действие после старта системы - загрузка всех необходимых модулей. Это будут модули поддержки:</para>
<orderedlist>
<listitem>
<para>устройств хранения данных - SCSI-адаптеров, контроллеров IDE-RAID, Zip-приводов (atapi-floppy, в терминологии Linux), короче, всего, на что мы собираемся устанавливать систему или считывать устанавливаемые компоненты;</para>
</listitem>
</orderedlist>
<orderedlist>
<listitem>
<para>файловых систем: это потребуется, только если устанавливаемые тарбаллы и архивы исходников размещены на разделе с файловой системой FATxx - поддержка всех родных (native) файловых систем Linux, включая XFS, встроена в установочное ядро);</para>
</listitem>
<listitem>
<para>сетевого адаптера - если таковой, вместе с постоянным подключением к Сети, имеется;</para>
</listitem>
<listitem>
<para>соединения ppp - это даст возможность использовать при установке модемное подключение к Сети.</para>
</listitem>
</orderedlist>
<para/>
<para>При этом возможно, что многие из перечисленных устройств (в частности, сетевые карты) будут корректно определены при загрузке системы и соответствующие модули загрузятся автоматически, что проверяется командой</para>
<para>$ modprobe имя_модуля</para>
<para/>
<para>В остальных случаях это придется сделать вручную, командой</para>
<para>$ insmod имя_модуля</para>
<para/>
<para>Имена поддерживаемых модулей можно посмотреть (авторизовавшись в следующей виртуальной консоли) в соответствующих подкаталогах каталога /lib/modules/2.6.XX.X/kernel/ - ведь наша корневая система пока находится в оперативной памяти.</para>
<para/>
<para>Следующий шаг - настройка сетевого соединения (при постоянном подключении). Если машина использует динамически выделяемый IP-адрес, назначаемый через DHCP-сервер (а в большинстве случаев это так и есть), делается это элементарно просто, командой</para>
<para>$ dhcpcd eth0</para>
<para/>
<para>Все остальное происходит почти автоматически. При статическом IP-адресе потребуется ручная настройка, но на этом я останавливаться не буду (все вопросы конфигурирования сети очень подробно рассмотрены в руководстве).</para>
<para/>
<para>При отсутствии постоянного подключения необходимо смонтировать носитель со скачанными ранее архивными файлами. Для этого в каталоге /mnt создаем соответствующую ситуации точку монтирования, например,</para>
<para>$ mkdir /mnt/zip</para>
<para/>
<para>для Zip-диска, или</para>
<para>$ mkdir /mnt/cd2</para>
<para/>
<para>для второго CD (каталог для установочного CD - /mnt/cdrom, - там уже имеется, и диск этот в него уже смонтирован). А теперь даем команду монтирования. Для zip-диска "из коробки" она будет выглядеть так:</para>
<para>$ mount /dev/hdd4 -t msdos /mnt/zip</para>
<para/>
<para>где, кроме явного указания файловой системы, обращаю внимание, что файл устройства - именно /dev/hdd4: при фабричной разметке на zip-дисках создается один, но четвертый, первичный раздел. И еще одна тонкость: вследствие особенностей реализации файловой системы devfs в дистрибутиве Gentoo, zip-диск должен находиться в приводе в момент старта системы - иначе соответствующий файл устройства просто не будет создан.</para>
<para/>
<para>Аналогичны и действия по монтированию второго CD или дискового раздела. Единственно, что в этом случае может не потребоваться явного указания на тип файловой системы (хотя и вреда от него, конечно, не будет).</para>
<para/>
<para>Завершив монтирование носителя установочных файлов, следует перво-наперво активизировать еще одну виртуальную консоль и вывести на нее <link linkend="">инструкцию по инсталляции</link> - дабы сверять с ней все дальнейшие шаги, как со Священным писанием:</para>
<para>$ lynx /mnt/mount_point/build.html</para>
<para/>
<para>При наличии модемного подключения к Сети можно настроить и его - даже если все требуемые файлы, включая исходники базовой системы, размещены на смонтированном носителе, не исключено, что в процессе их синхронизации может потребоваться какой-либо специфичный для Gentoo патч, скачать который по модему - дело пары минут, а то и секунд. Хотя должен предупредить, что установить базовую систему чисто по модему (что вполне реально, скажем, для FreeBSD) - не то что невозможно, но, скажем так, весьма долго и накладно для кармана.</para>
<para/>
<para>Для настройки модемного соединения проще всего использовать программу wvdial, находящуюся на Live CD (в каталоге /usr/bin). Подгрузив модули поддержки протокола ppp (общий, ppp_generic, и асинхронного соединения, ppp_async), запускаем программу</para>
<para>$ wvdialconf /etc/wvdial.conf</para>
<para/>
<para>Она автоматически определит порт, к которому подключен модем, определит его скорость и создаст строку инициализации, занеся все эти сведения в файл, указанный в качестве аргумента. В результате содержание его примет вид, подобный следующему:</para>
<para/>
<para>[Dialer Defaults]</para>
<para>Modem = /dev/ttyS0</para>
<para>Baud = 115200</para>
<para>Init1 = ATZ</para>
<para>Init2 = ATQ0 V1 E1 S0=0 &amp;C1 &amp;D2 +FCLASS=0</para>
<para>ISDN = 0</para>
<para>Modem Type = Analog Modem</para>
<para/>
<para>Пользователю остается только добавить туда строку, определяющую способ дозвона. По умолчанию он - тоновый, тогда как в наших условиях, скорее всего, потребуется импульсный дозвон:</para>
<para/>
<para>Dial Command = ATDP</para>
<para/>
<para>Остальное же - обычная информация: телефон провайдера</para>
<para/>
<para>Phone = </para>
<para/>
<para>имя пользователя и его пароль</para>
<para/>
<para>Username = </para>
<para>Password = </para>
<para/>
<para>Теперь, проследив, чтобы в файле /etc/hostname наличествовала единственная строка</para>
<para/>
<para>localhost</para>
<para/>
<para>подкорректируем содержимое файла /etc/resolv.conf: значение строки nameserver должно соответствовать реальному IP-адресу DNS-сервера провайдера. И теперь при необходимости для дозвона можно использовать команду</para>
<para/>
<para>$ wvdial</para>
<para/>
<para>А больше на этапе установки нам ничего и не требуется - все остальное сделает система портежей.</para>
<para/>
<para>Возникает вопрос: а каким образом редактировать все вышепоименованные конфигурационные файлы (и те файлы, которые потребуется редактировать в дальнейшем)? Этой цели в дистрибутиве Gentoo штатно служит текстовый редактор nano - очень простой в освоении и обращении, снабженный встроенной справкой и обеспечивающий достаточные базовые функции редактирования. Нужно только не забывать запускать его в форме</para>
<para>$ nano -w имя_файла</para>
<para/>
<para>где опция -w отключает режим переноса строк - конфигурационные файлы на это, как правило, реагируют болезненно. Поскольку редактор понадобится нам за время установки неоднократно, резонно было бы сразу определить псевдоним:</para>
<para/>
<para>$ alias nano='nano -w'</para>
<para/>
<para>благо, как уже говорилось, в нашем распоряжении полнофункциональная оболочка bash.</para></sect2><sect2><title>Установка - первый этап</title>
<para/>
<para>Вот теперь подготовительные мероприятия закончены - можно начинать собственно установку, начальный этап которой происходит внутри корневой файловой системы Live CD. Первый шаг на этом этапе - создание дисковых разделов и файловых систем на них. Эти вопросы были предметом детального рассмотрения в моей статье, подготовленной к печати (Открытые системы, #11, 2002) и потому здесь я на них остановлюсь лишь вкратце.</para>
<para/>
<para>Для первой операции можно использовать одну из программ - fdisk, cfdisk, parted, все они имеются на Live CD. А созданию файловых систем служат специфичные для них утилиты: mkefs для ext2fs, mkfs.xfs - для XFS, mkswap - для раздела подкачки, и так далее. Рекомендуемая в руководстве схема разбиения для одного диска (первого на первом IDE-канале) приведена в табл. 1.</para>
<para/>
<para/>
<para>Таблица 1. Рекомендуемая схема разбиения диска для установки Gentoo</para>
<para/>
<para>     Раздел                      Размер                                              Тип                Устройство</para>
<para>Загрузочный        100 Мбайт                                    ext2fs или ext3fs        /dev/hda1</para>
<para>Раздел подкачки        128 Мбайт=&lt;2*RAM=&lt;2 Гбайт        Linux swap                /dev/hda2</para>
<para>Корневой раздел        1,5 Гбайт минимум                      XFS, ext3               /dev/hda3</para>
<para/>
<para/>
<para>Разумеется, эта рекомендация - приблизительна. Так, 1,5 Гбайт для корневого раздела - лишь абсолютно необходимый минимум. При интенсивном использовании системы портежей цифру эту нужно увеличить в два-три раза, а то и более. Или выделить файловую систему /usr в отдельный раздел. Кроме того, на мой взгляд, абсолютно необходимо создать отдельный раздел под файловую систему /home - для домашних каталогов пользователей. А в некоторых случаях целесообразно выделение и каталогов /var и /tmp.</para>
<para/>
<para>Если под установку Gentoo предполагается задействовать более одного физического диска, можно прибегнуть к таким современным технологиям, как программные RAID-массивы или система управления логическими томами (LVM - Logical Volumes Manager). Рассмотрение их далеко выходит за рамки настоящей статьи. Скажу только, что первая технология способствует повышению быстродействия дисковых операций или (иногда - и) сохранности данных. А система LVM позволяет достичь непревзойденной гибкости в управлении уже созданными и смонтированными файловыми системами (в частности, динамического перераспределения занимаемого ими дискового пространства). И, разумеется, на установочном Live CD содержится весь необходимый инструментарий для работы с программными RAID-массивами и системой LVM. Впрочем, нет препятствий и к использованию дисков, подключенных к аппаратному контроллеру IDE-RAID, хотя это потребует некоторых дополнительных действий (детали - в руководстве по установке).</para>
<para/>
<para>Следующий шаг - монтирование созданных файловых систем в структуру корневой системы (напомню, она - в оперативной памяти). Но сначала - активизируем раздел подкачки:</para>
<para>$ swapon /dev/hda2</para>
<para/>
<para>что будет способствовать быстродействию при всех дальнейших манипуляциях, особенно при не очень большом объеме ОЗУ.</para>
<para/>
<para>Теперь необходимо создать точку монтирования для той файловой системы, которая в дальнейшем станет корневой:</para>
<para>$ mkdir /mnt/gentoo</para>
<para/>
<para>и смонтировать в нее соответствующий раздел:</para>
<para>$ mount /dev/hda3 /mnt/gentoo</para>
<para/>
<para>Если создавались отдельные разделы под каталоги /boot, /usr, /home - они тоже потребуют своих точек монтирования, теперь уже относительно каталога /mnt/gentoo:</para>
<para>$ mkdir /mnt/gentoo{/boot,/usr,/home}</para>
<para/>
<para>и выполнить для них команды монтирования:</para>
<para>$ mount /dev/hda1 /mnt/gentoo/boot</para>
<para/>
<para>и так далее. Теперь командой </para>
<para>$ cd /mnt/gentoo/</para>
<para/>
<para>переходим в будущий корневой каталог Gentoo и вспоминаем наконец о наших архивных файлах. Разворачиваем тарбалл первой очереди, находящий на инсталляционном CD:</para>
<para>$ tar -xvjpf /mnt/cdrom/nocompress/stage1-x86-*.tar.bz2</para>
<para/>
<para>Здесь и далее следует обратить внимание на опцию -p в командной строке: она необходима для сохранения оригинальных атрибутов доступа к файлам, извлекаемым из архива. По самой же команде разворачивается иерархия каталогов в дереве /mnt/gentoo (/mnt/gentoo/etc, /mnt/gentoo/proc и т.д.) и устанавливается некий минимум прекомпилированных программ, необходимых для дальнейшей инсталляции, в том числе и ftp-клиент wget. И действительно, при постоянном подключении к Сети более ничего не потребуется - можно переходить к подготовке смены корневого каталога. Однако тем, кто не может им похвастаться, предварительно придется распаковать два оставшихся тарбалла, stage2* и stage3*.</para>
<para/>
<para>Делается это точно так же, как и развертывание первого, только пути к соответствующим файлам нужно указать те, что соответствуют их реальному расположению, например:</para>
<para>$ tar -xvjpf /mnt/zip/stage2*.tar.bz2</para>
<para/>
<para>и так далее. После этого мы имеем в каталоге /mnt/gentoo тот самый набор прекомпилированных библиотек, утилит и приложений, который объединяется понятием base Linux. И, соответственно, морально готовы к тому, чтобы сделать каталог /mnt/gentoo корневым.</para></sect2><sect2><title>Этап второй - подготовка к смене корня</title>
<para/>
<para>Однако этот ответственный шаг требует некоторых подготовительных мероприятий - ведь после него все остальные ветви нынешнего корневого каталога станут недоступными. Правда, только с текущей, первой, консоли - во всех прочих сеансах корневым останется каталог в оперативной памяти.</para>
<para/>
<para>Для начала, чтобы не делать двойную работу, скопируем настроенные нами конфигурационные файлы - ведь и они пока существуют только виртуально:</para>
<para>$ cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</para>
<para>$ cp /etc/hostname /mnt/gentoo/etc/hostname</para>
<para>$ cp /etc/wvdial.conf /mnt/gentoo/etc/wvdial.conf</para>
<para/>
<para>Теперь воспользуемся замечательным свойством современных ядер Linux - возможностью доступа к одной и той же файловой системе через разные точки монтирования. И смонтируем таким образом файловую систему процессов (она, как ясно из названия, представляет протекающие в системе процессы в виде файлов):</para>
<para>$ mount -o bind /proc /mnt/gentoo/proc</para>
<para/>
<para>К слову сказать, таким же образом можно поступить и с тем носителем, на котором у нас размещены архивы системы портежей и исходников (если последние мы туда помещали). А можно, просто размонтировав его (доступ к ним из виртуального корня Live CD больше не обязателен), смонтировать заново - но уже относительно будущего нового корня:</para>
<para>$ mount /dev/hdd4 /mnt/gentoo/mnt</para>
<para/>
<para>Ведь в нем развернута собственная корневая система, имеющая все положенные компоненты. Правда, в этом случае мы потеряем доступ к инструкции по установке - а она нам еще потребуется. Вообще говоря, обойтись с этим носителем можно самыми разными способами - например, не перемонтируя его, просто обращаться с других виртуальных консолей. Я опишу самый, на мой взгляд, удобный.</para>
<para/>
<para>Не предпринимая никаких размонтировочных действий, переходим в каталог /mnt/gentoo/usr (таковой ведь у нас тоже имеется). И из него разворачиваем архив портежей, точно так же, как мы это делали для основных тарбаллов:</para>
<para>$ tar -xvjpf /mnt/zip/portage*.tar.bz2</para>
<para/>
<para>Если исходников на вспомогательном носителе нет - можно оставить его в покое, нужды в нем больше не возникнет. Если же исходники имеются - создаем в новообразованном каталоге /mnt/gentoo/usr/portage подкаталог distfiles и копируем в него все наши архивы исходных текстов:</para>
<para>$ cp /mnt/zip/src/* /mnt/gentoo/usr/portage/distfiles</para>
<para/>
<para>Теперь они находятся именно там, где их ожидает встретить система портежей, прежде чем обращаться к Сети (и выдавать сообщение об ошибке при отсутствии подключения). А дополнительный носитель оставляем смонтированным - чтобы подсматривать в документацию через другой виртуальный терминал.</para>
<para/>
<para>Теперь все готово к волнующему моменту - смене корневого каталога. Итак, командой</para>
<para>$ chroot /mnt/gentoo /bin/bash</para>
<para/>
<para>объявляем каталог /mnt/gentoo корнем, одновременно запуская новый экземпляр командной оболочки (уже из нового источника). Теперь пересчитываем пути к системным библиотекам</para>
<para>$ env-update</para>
<para/>
<para>ответом на что будет сообщение</para>
<para>Regenerating /etc/ld.so.cache...</para>
<para/>
<para>И устанавливаем для нового экземпляра оболочки переменные окружения:</para>
<para>$ source /etc/profile</para>
<para/>
<para>Все, мы - внутри системы Gentoo Linux, причем уже очень даже реальной, не имеющей никакого отношения к виртуальной системе, загруженной с Live CD. И далее все пути к файлам в абсолютной форме (типа /usr/portage) будут указываться с учетом того, что отныне наш / - это не что иное, как /mnt/gentoo.</para></sect2><sect2><title>Третий этап - внутри Gentoo</title> Gentoo<para/>
<para>Итак, мы уже как бы установили операционную систему Gentoo Linux (без перезагрузки, прошу обратить внимание). И вот тут-то и начинается самый охмурежь - рядом планомерных и последовательных действий мы можем после перезагрузки (ну куда же без нее) получить не просто полнофункциональную и аккуратно настроенную, но, не побоюсь громких слов, - идеально оптимизированную систему.</para>
<para/>
<para>Требуемые к тому действия описываются в предположении: а) установки всех трех тарбаллов и системы портежей, б) помещения в каталог /usr/portage/distfiles (уже относительно нового корня - /mnt/gentoo) некоторого набора минимально необходимых исходников, и в) хоть какого-то соединения с Интернетом (на крайний случай). Без последнего можно, как я неоднократно говорил, и обойтись - но тут уж потребуется ювелирная точность в выборе предварительно скачанных (и ныне помещенных в /usr/portage/distfiles) архивов исходников.</para>
<para/>
<para>В чем смысл этих действий? Да ни много, ни мало, как в полной пересборке базовой системы (те, кто имел дело с FreeBSD, неизбежно вспомнят тут make world) и доустановки необходимых компонентов. Поскольку это - не apt-get, и не установка прекомпилированных пакетов, все требуемое извлекается непосредственно из исходников. И потому первое, что нам потребуется - настройка условий компиляции.</para>
<para/>
<para>Глобальные параметры сборки посредством системы портежей описываются в файле /etc/make.conf. Вызываем его в редакторе nano (не забыв про опцию -w, если не решили этот вопрос разом - определением псевдонима) и начинаем действовать.</para>
<para/>
<para>Первое, что бросается в глаза после открытия вышеупомянутого файла - переменная USE. Смысл ее - в определении условий предкомпиляционного конфигурирования исходников. То есть, она эквивалента опциям --enable/disable или --with/without скрипта ./configure, с исполнения которого начинается ручная сборка любой программы. И, задав значения этой переменной (несложно догадаться, что указав</para>
<para>USE="gpm"</para>
<para/>
<para>мы включаем поддержку службы консольной мыши во всех собираемых через портежи программах (разумеется, тех, где это имеет физический смысл). А задав значение</para>
<para>USE="-gpm"</para>
<para/>
<para>таковую отключаем раз и навсегда (на самом деле - не совсем навсегда, но это тема отдельной беседы).</para>
<para/>
<para>Список включенных по умолчанию значений переменной USE можно подсмотреть в файле /usr/portage/profiles/default-x86-XX/make.defaults. А полный (и логично классифицированный) список доступных значений можно найти в файле документации - use-howto.html. Мы ведь списали его на дополнительный носитель? Да? - тогда можем вызвать с очередной виртуальной консоли...</para>
<para/>
<para>Следующая переменная файла /etc/make.conf -</para>
<para>CHOST='i686-pc-linux-gnu'</para>
<para/>
<para>Она указывает на архитектуру машины, на которой будут собираться программы. И ее, при необходимости, нужно будет привести в соответствие с реалиями оной. Правда, ныне такая необходимость возникнет редко - разве что поменять первую шестерку на пятерку в случае Pentium-просто...</para>
<para/>
<para>А вот следующая строка,</para>
<para>CFLAGS="*"</para>
<para/>
<para>очень важна. Ею задаются именно те флаги оптимизации, передаваемые компилятору для оптимизации под конкретный процессор. Вдаваться в детали опять же не буду - и это тема особого, и очень подробного, разговора. Достаточно помнить, что флаг -O3 (а именно он указан здесь по умолчанию) устанавливает самый высокий уровень оптимизации, а оба флага -mcpu=* и -march=* указывают, под какой именно процессор оптимизировать следует. Различие между ними - в том, что программа, собранная с флагом -mcpu=i686, будучи оптимизирована под класс процессоров Pentium Pro и выше (а с формальной точки зрения, и P-II, и P-III, и даже P-4 принадлежат к нему), теоретически способна запуститься и на Pentium-100, тогда как флаг -march=athlon-xp потребует именно того процессора, который указан - даже на просто Athlon'е скомпилированная с ним программа работать не будет.</para>
<para/>
<para>Смысл переменной</para>
<para>CXXFLAGS=</para>
<para/>
<para>аналогичен - только для программ, написанных не на Си, а на Си++. И ее имеет смысл определить просто, через переменную CFLAGS=</para>
<para>CXXFLAGS="${CFLAGS}"</para>
<para/>
<para>как это и сделано в example-файле. Остальные строки которого определяют условия скачивания (в частности, ftp-клиента по умолчанию). Менять их на данном этапе - оснований не вижу, кроме разве что идиосинкразии к wget, используемому по умолчанию.</para>
<para/>
<para>Определившись с условиями, можно начинать перестройку. Для этого меняем каталог</para>
<para>$ cd /usr/portage</para>
<para/>
<para>и запускаем сценарий</para>
<para>$ scripts/bootstrap.sh</para>
<para/>
<para>Он производит сборку пакетов binutils, gcc, gettext и glibc (замещая установленные из тарбаллов прекомпилированные их варианты), а после сборки glibc - пересборку binutils, gcc и gettext. Достигая, таким образом, их идеальной оптимизации... Хотя и ценой временных затрат - процесс даже на мощной машине вполне может занять часок-другой.</para>
<para/>
<para>Теперь можно полюбоваться на список пакетов, установленных в нашей системе - ибо это и есть тот самый base Linux с очень небольшими коррективами. Для этого даем команду</para>
<para>$ emerge -p system</para>
<para/>
<para>Если есть желание, время, а главное - полный набор исходников в /usr/portage/distfiles, можно завершить пересборку базовой системы командой</para>
<para>$ emerge system</para>
<para/>
<para>Здесь без постоянного коннекта с очень большой вероятностью рано или поздно последует сообщение об ошибке - о невозможности получить пакет имя_рек с такого-то адреса. Если имеется модем, к подбору исходников мы подошли ответственно, - не беда: активизируем еще одну виртуальную консоль (а на ней будет жить наша первозданная Live-система с CD) и дозваниваемся до провайдера через программу wvdial (а она у нас пока существует только в той самой виртуальной Live-системе), а потом повторяем последнюю команду. И, скорее всего, дело было в каком-нибудь исконно Gentoo'ском патчике объемом в пару килобайт, так что процедура эта нас не разорит. Если же обуяет приступ жадности, можно просто продолжить, а к emerge system вернуться в другой раз - после полного зеркалирования каталога distfiles с сайта Gentoo, и за казенный счет, разумеется :-)</para></sect2><sect2><title>Этап четвертый: в недра ядра</title>
<para/>
<para>На предыдущем этапе были перестроены все компоненты базовой системы, кроме одного - зато самого главного: ядра системы. Перекомпиляция ядра - процедура, рано или поздно неизбежная для пользователя любого дистрибутива Linux, даже самого user-ориентированного. Перед пользователем же Source Based дистрибутива она встает с неотвратимостью рока уже при установке системы.</para>
<para/>
<para>Gentoo - опять не составляет исключения. Хотя в заключительных разделах я расскажу, как при крайней необходимости можно обойти этот этап, однако по хорошему к тому нет никаких причин. И потому, хотя тема пересборки ядра - совершенно отдельная, и нам придется еще не раз к ней возвращаться, применительно случаю постараюсь осветить ее здесь в минимально возможном объеме.</para>
<para/>
<para>Чтобы пересобрать ядро, для начала нужно иметь его исходники. Ни на инсталляционном диске, ни в составе тарбаллов stage2-3 мы их не найдем. Что делать?</para>
<para/>
<para>При подключении к Сети - все просто: к нашим услугам система портежей. Отправляемся в каталог /usr/portage, просматриваем содержимое подкаталога sys-kernel - и остается только дивиться свалившемуся на голову богачеству: даже отметая классово чуждые портежи ядер для Sparc, PPC, Alpha, на выбор предоставляется чуть не дюжина вариантов. Подчеркну, речь идет не о прекомпилированных ядрах, а именно о вариантах исходников, снабженных патчами, обеспечивающими дополнительные опции относительно ядра первозданного.</para>
<para/>
<para>Разумеется, и последнее, каноническое ядро от Линуса Торвальдса - тоже доступно (под известным именем vanilla-sources) для тех, кто хочет быть святее папы римского. Далее - фирменная коронка, gentoo-sources, это - лучший выбор с точки зрения функциональности). Ну и ac-sources - ядро от Алана Кокса, в патчах которого обычно воплощены новейшие достижения ядреной науки и техники.</para>
<para/>
<para>Есть и более специфичные варианты: usermode-sources - ядро для запуска Linux в Linux, в т.н. пользовательской моде (предназначается обычно для тестирования); openmosix-sources - ядро с поддержкой одноименной (openMosix) кластерной технологии, и т.д..</para>
<para/>
<para>Так что в этих условиях главное - определиться с выбором. А потом - простая команда</para>
<para>$ emerge sys-kernel/name-sources</para>
<para/>
<para>некоторый период ожидания, пока скачиваются сами исходники ядра и все необходимые патчи , еще чуть-чуть времени на развертывание архивов - и вперед, в каталог /usr/src/linux для конфигурирования.</para>
<para/>
<para>При наличии предусмотрительно скачанных исходников ядра, наиболее явно необходимых патчей и модемного подключения - сложнее, но не намного. Выполняем ту же команду. Если повезет - все по прежней схеме, но предупреждаю, шансов на это мало: почти наверняка при предварительном скачивании какой-то Gentoo-специфичный патч будет пропущен (учтем также наше пока еще очень ограниченное знакомство с системой портежей вообще - в дальнейшем такой ситуации можно и избежать). Но не беда: получив сообщение об ошибке, соединяемся с Сетью и либо скачиваем недостающий патч вручную (хоть через браузер lynx - полный адрес к недостающему компоненту будет выведен), либо (и это, товарищи, правильнее) запускаем процедуру по новой. Разорвав соединение по завершении установки исходников ядра.</para>
<para/>
<para>И не нужно бояться, что это больно ударит по карману: при соединении по линии, способной вынести протокол V90, скачивание большинства патчей занимает минуты. И wget при обрыве коннекта способен к докачке - так что непроизводительные расходы сведены к минимуму.</para>
<para/>
<para>Хуже, если нет ни полного комплекта исходников, ни модема. И это не смертельно, но придется кое-чем поступиться (надеюсь, не принципами). То есть: просто тупо распаковываем архив исходников ядра в каталог /usr/src, распаковываем и накладываем минимально необходимые патчи, далее - обычным порядком, как описано ниже. Можно и просто ограничиться каноническим ядром Линуса. Недостаток - кроме возможных потерь некоторых функций, эти действия не будут зафиксированы в базе данных портежей (имеющей место пребывания в каталоге /var/db/pkg), то есть система портежей о них как-бы и не узнает (на самом деле - не совсем, но все равно - этот способ может рассматриваться как временное решение).</para>
<para/>
<para>И еще одно временное решение - вообще отказаться от пересборки ядра. А как при этом получить возможность загрузить систему - я расскажу под занавес (если вы к тому времени сами не догадаетесь).</para>
<para/>
<para>В любом случае, кроме последнего, исходники ядра мы получили, так что можно отправляться в вышеупомянутый каталог /usr/src/linux (или /usr/src/linux-номер_версии-имя_варианта, без разницы, - первый лишь символическая на него ссылка). И давать команду</para>
<para>$ make menuconfig</para>
<para/>
<para>которая сгенерирует меню настройки опций ядра. Любители отвечать черному экрану могут выбрать и make config - но я к ним не принадлежу.</para>
<para/>
<para>Сам процесс конфигурирования описывать не буду - это совсем другая история. Отмечу только обязательные опции. Первая из них - поддержка экспериментальных и разрабатываемых опций: большинство продвинутых возможностей ядра Linux описываются именно этими терминами (что не мешает им функционировать вполне справно). В секции файловых систем необходимо отметить поддержку файловых систем процессов (procfs), файловой системы виртуальной памяти (Virtual Memory Filesystem) и файловой системы устройств (devfs). И, конечно же, тех файловых систем, которые были размещены на созданных разделах (например, XFS или ext3fs - про поддержку ext2fs, надеюсь, не забудет ни один линуксоид). Ну и учесть поддержку требуемых устройств - сами знаете, что у вас вкручено в машине.</para>
<para/>
<para>Закончив с конфигурированием, выходим из системы меню (не забыв сохранить изменения) и даем последовательность команд:</para>
<para>$ make dep</para>
<para>$ make clean</para>
<para>$ make bzImage</para>
<para>$ make modules</para>
<para>$ make modules_install</para>
<para/>
<para>Разумеется, не обязательно последовательно, можно и одной строкой, разделяя символом ; (или, правильнее, &amp;&amp;). А то и вообще в форме, рекомендованной руководством:</para>
<para>$ make dep &amp;&amp; make clean bzImage modules modules_install</para>
<para/>
<para>Теперь остается только скопировать образовавшийся образ ядра в загрузочный каталог</para>
<para>$ cp /usr/src/linux/arch/i386/boot/bzImage /boot</para>
<para/>
<para>И ядерный вопрос можно считать закрытым. Хотя остается еще вопрос, косвенным образом с ним связанный - программы поддержки файловых систем. Их, в соответствие с выбором и предпочтениями, устанавливаем через систему портежей, например, команда</para>
<para>$ emerge sys-apps/xfsprogs</para>
<para/>
<para>установит все необходимое для работы с файловой системой XFS. Напомню, что архив исходников пакета xfsprogs должен иметься в каталоге distfiles.</para>
<para/>
<para>Попутно через систему портежей можно установить и другие программы, однако я пока ограничился бы только тем, что облегчит завершение конфигурирования, а именно - службой консольной мыши:</para>
<para>$ emerge sys-libs/gpm</para>
<para/>
<para>А теперь активизируем ее. Если мы имеем наиболее типичного ныне грызуна с колесиком и под разъем PS/2, это будет выглядеть так:</para>
<para>$ gpm -t imps2 -m /dev/psaux</para>
<para/>
<para>И на следующих этапах гораздо проще будет выделять нужные фрагменты и вставлять их щелчком средней клавиши, нежели набрать вручную.</para>
<para>Финал: постинсталляционное конфигурирование</para>
<para/>
<para>Собственно установка на этом закончена. Осталось довести систему до идеала не только изнутри, но и снаружи. И первый шаг здесь - настройка часового пояса: для Source Based дистрибутивов это не последнее дело (утилита управления компиляцией make обращает внимание на даты создания файлов). Реализуем просто: созданием символической ссылки</para>
<para>$ ln -sf /usr/share/zoneinfo/path/timezonefile /etc/localtime</para>
<para/>
<para>Рискну предположить, что компонент пути path/timezonefile для большинства моих читателей окажется в диапазоне от Europe/Kaliningrad до Asia/Kamchatka (наличие Анадыря в нашей стране почему-то упорно игнорируется - но, слава богу, хоть о Петропавловске-Камчатском знают). Если системное время в BIOS установлено на не время по Гринвичу, дополнительно потребуется внести коррективы в файл /etc/rc.conf.</para>
<para/>
<para>Теперь увековечим монтирование новых файловых систем. Как? - очень просто, лобовым редактированием ответственного за сие файла /etc/fstab. Вызываем его:</para>
<para>$ nano -w /etc/fstab</para>
<para/>
<para>И видим, если исключить комментарии, следующую картину:</para>
<para>/dev/BOOT                /boot                ext2                noauto,noatime        1 1</para>
<para>/dev/ROOT                /                xfs                noatime                0 0</para>
<para>/dev/SWAP                none                      swap                sw                0 0</para>
<para>/dev/cdroms/cdrom0        /mnt/cdrom        iso9660                noauto,ro        0 0</para>
<para>proc                        /proc                proc                defaults        0 0</para>
<para/>
<para>#tmpfs                /dev/shm        tmpfs                defaults        0 0</para>
<para/>
<para>Если мы следовали рекомендациям инструкции, остается только заменить символы верхнего регистра конкретными реалиями, как то: /dev/hda1, /dev/hda3, /dev/hda2. Или, что будет более корректно, /dev/discs/disc0/part1 и т.д., сняв при этом комментарий со строки #tmpfs. Если же использовалась какая-либо иная схема разбиения - можно в одной из ранее активизированных консолей с помощью команды mount без аргументов подсмотреть, какой раздел с какой файловой системой куда монтировался. И просто перетащить мышью (не зря же мы ее запускали) соответствующие значения в наш /etc/fstab. Ну и всякого рода коррективы (типа монтирования FAT-разделов, флоппи-дисков, zip-накопителей и еще чего требуется) также никто не запрещает.</para>
<para/>
<para>Внимательный читатель обратил внимание - в строке /dev/BOOT по умолчанию стоит значение noauto, предписывающее не монтировать соответствующий раздел автоматически при старте системы. Именно так рекомендуется делать при использовании GRUB - он принят в Gentoo в качестве загрузчика по умолчанию. Так вот, настало время обеспечить загрузку системы. Для этого даем команду grub и после появления одноименного приглашения последовательно вводим:</para>
<para>grub&gt; root (hd0,0)</para>
<para>grub&gt; setup (hd0)</para>
<para/>
<para>вслед за чем выходим из программы:</para>
<para>grub&gt; quit</para>
<para/>
<para>Начальный загрузчик установлен в первый раздел первого диска, тот самый, который в текущий момент смонтирован у нас как /boot. И который в дальнейшем не будет монтироваться автоматически - дополнительная защита, в первую очередь от человеческого фактора. Так что в дальнейшем не следует удивляться, если, собрав новое ядро системы, вы не сможете его сразу скопировать в каталог /boot - предварительно оный придется смонтировать вручную.</para>
<para/>
<para>Теперь остается GRUB настроить. Для этого посредством того же редактора создаем файл его меню:</para>
<para>$ nano -w /boot/grub/menu.lst</para>
<para/>
<para>и записываем в него две секции. Строки первой относятся к GRUB в целом:</para>
<para>default 0</para>
<para>timeout [значение_в_секундах]</para>
<para>splashimage=(hd0,0)/boot/grub/splash.xpm.gz</para>
<para/>
<para>Она указывает на ОС, загружаемую по умолчанию, время ожидания выбора в секундах и описывает путь к файлу графической заставки. Последняя штатно - нечто вроде аметиста с морионовым оттенком. Не нравится - заставку можно убрать (стерев или закомментировав третью строку). Или - изготовить собственную соответствующем формате.</para>
<para/>
<para>Вторая секция описывает непосредственно загрузку Gentoo.</para>
<para>title=My Love Gentoo Linux</para>
<para>root (hd0,0)</para>
<para>kernel /boot/имя_образа root=/dev/hda3</para>
<para/>
<para>Первая строка - произвольное название пункта меню. Вторая определяет имя устройства, с которого будет загружаться система. Имя это дается в нотации GRUB, отличной от принятой в Linux: дело в том, что GRUB способен загрузить ядро с не смонтированной файловой системы, относящейся к незагруженной операционке. И это распространяется не только на Linux, но на практически любую ОС из клана свободных Unix'ов (например, на FreeBSD или OpenBSD). </para>
<para/>
<para>В третьей строке определяется имя образа ядра, подлежащего загрузке, и устройство, на котором после этого будет располагаться корневая файловая система. Если мы собирали собственное ядро, в качестве образа будет выступать тот самый файл /boot/bzImage, который был скопирован в каталог /boot после компиляции. Если же ядро не собиралось, значение kernel, как будет показано ниже, проще всего определить как /boot/linux. А имя устройства с корневым каталогом на этот раз дается в нотации Linux - ведь соответствующее ядро уже загружено, и оно знает, что такое /dev/hda?.</para>
<para/>
<para>Напомню еще раз, что все действия по редактированию меню GRUB можно выполнить, просто перетаскивая мышью соответствующие фрагменты руководства (там приведены все необходимые примеры) в наш /boot/grub/menu.lst и редактируя их в соответствии с собственными реалиями.</para>
<para>И все же - супер финал</para>
<para/>
<para>Настройкой загрузчика можно считать завершенной официальную часть инсталляции. Однако для полного счастья не хватает еще некоторых штрихов. Так, руководство рекомендует (и это - более чем резонно) оптимизировать режим работы жесткого диска на предмет использования DMA - что весьма способствует его быстродействию. Для такого рода штук предназначен файл /etc/conf.d/local.start. Открываем его в редакторе и после комментария (по умолчанию там больше ничего нет) приписываем строку</para>
<para>hdparm -d 1 /dev/hda</para>
<para/>
<para>Если физических дисков больше одного - повторяем ее для каждого устройства. А затем, воспользовавшись случаем, обеспечим здесь же и загрузку консольной мыши при старте системы:</para>
<para>gpm -t imps2 -m /dev/psaux</para>
<para/>
<para>Теперь обратимся к локализации. Не смотря на свое исходно американское происхождение, Gentoo - дистрибутив интернациональный (это ясно из состава команды его разработчиков). И потому в нем есть все базовые средства для работы с языками, отличными от американского. Нужно только немного потрудиться для их активизации.</para>
<para/>
<para>Достигается это можно редактированием файла /etc/rc.conf. Что может показаться необычным для пользователей Linux. Но мы помним, что в Gentoo принят порядок начальной загрузки в стиле BSD (а не в стиле System V, как в большинстве распространенных дистрибутивов Linux, за исключением Slackware и его сородичей). Впрочем, вдаваться в подробности пока не буду - это тема для отдельной беседы. Пока же - голая практика: все, что мы хотим видеть загруженным при старте машины, должно быть явным образом указано в файле /etc/rc.conf. И именно в том порядке, в каком требуется.</para>
<para/>
<para>Так что открываем этот универсальный файл</para>
<para>$ nano -w /etc/rc.conf</para>
<para/>
<para>отыскиваем в начале его строку</para>
<para>KEYMAP="us"</para>
<para/>
<para>и заменяем чуждую нам Америку на что-нибудь родное, от братчиков Кирилла и Мефодия. Что именно - определяем в какой-либо из иных виртуальных консолей командой</para>
<para>$ ls /usr/share/keymaps/i386/qwerty/ru*</para>
<para/>
<para>В ответ она выведет на экран такой список:</para>
<para>/usr/share/keymaps/i386/qwerty/ru1.map.gz</para>
<para>/usr/share/keymaps/i386/qwerty/ru2.map.gz</para>
<para>/usr/share/keymaps/i386/qwerty/ru3.map.gz</para>
<para>/usr/share/keymaps/i386/qwerty/ru4.map.gz</para>
<para>/usr/share/keymaps/i386/qwerty/ru-cp1251.map.gz</para>
<para>/usr/share/keymaps/i386/qwerty/ru.map.gz</para>
<para>/usr/share/keymaps/i386/qwerty/ru-ms.map.gz</para>
<para>/usr/share/keymaps/i386/qwerty/ru_win.map.gz</para>
<para>/usr/share/keymaps/i386/qwerty/ru-yawerty.map.gz</para>
<para/>
<para>Можно видеть, что в нем присутствуют кириллические раскладки на все случаи жизни (а пути к ним, хотя и взяты с Live CD, соответствуют тем, что будут в инсталлированной системе). Дело, конечно, сугубо личное (я бы даже сказал, интимное), но по мне предпочтительна ru4: это раскладка для кодировки KOI8-R с Windows-маркировкой клавиш (не путать с собственно раскладкой для Windows-кодировки - ее, как видно из списка, тоже можно использовать) и переключением с латиницы на кириллицу по нажатию CapsLock. Так что вписываем</para>
<para>KEYMAP="ru4"</para>
<para/>
<para>и переходим к следующей строке, определяющей экранный шрифт консоли - CONSOLEFONT. Очевидно, что умолчальное ее значение описывает шрифт без символов кириллицы. Но - их у нас есть, в чем легко убедиться, просмотрев каталог /usr/share/consolefonts. Шрифтов там немерянно, и среди них легко отыскиваются семейства alt-*.psf.gz и cp866-*.psf.gz. И то, и другое нам (почти) подходит - это экранные шрифты с символами кириллицы в кодировке CP866 (она же - альтернативная, кодировка DOS или IBM). Почему так - ведь мы только что установили раскладку KOI8-R для клавиатуры, да и шрифты (семейства koi8r-*.gz), имеются? Распространяться не буду, ограничившись словами: это лучше, Леня.</para>
<para/>
<para>А слово "почти" я добавил потому, что все имеющиеся стандартно кириллические шрифты далеки от совершенства как эстетически, так и медицински. Так что в дальнейшем лучше будет воспользоваться шрифтами из пакета Виктора Вагнера console-tools-cyrillic - там есть очень симпатичные экземпляры, но об этом - как-нибудь в другой раз. Пока же просто вписываем, например,</para>
<para>CONSOLEFONT="cp866-8x16"</para>
<para/>
<para>И начинаем рассуждать логически: как же так, раскладка клавиатуры KOI8, а кодировка экранного шрифта - CP866. Ясно, что без загрузки карты трансформации одного в другое не обойтись. И такая карта у нас есть тоже - в каталоге /usr/share/consoletrans обнаруживаем файл koi2alt. Имя которого и вписываем в строку</para>
<para>CONSOLETRASLATION="koi2alt"</para>
<para/>
<para>сняв с нее предварительно стоящий по умолчанию комментарий. Откладываем в уме, что таким образом карта соответствия будет загружена только на одной, первой, из виртуальных консолей (она же - консоль системная) - к этому мы еще вернемся. А пока, дабы покончить с файлом /etc/rc.conf, вспоминаем, что системные часы нашей машины установлены по местному часовому поясу (скорее всего - хотя в последнее время я осознал преимущества времени гринвичского) - тому самому, который мы определили через файл-ссылку /etc/localtime. И обращаем внимание, что строка</para>
<para>CLOCK="UTC"</para>
<para/>
<para>указывает у нас, напротив, именно на время по Гринвичу (UTC=GMT). Заменяем UTC на localtime - и файл /etc/rc.conf можно закрывать (прочие его строки можно оставить без изменений, если вам лично не известны веские причины их сделать).</para>
<para/>
<para>А вот теперь пора довести до конца дело с картами соответствия. Открываем файл /etc/init.d/local: как явствует из названия, он предназначен для всякой всячины местного значения (и исполняется после всех остальных конфигурационных файлов). И вставляем в его конец с помощью редактора (или перетаскиваем мышью из данного руководства) простенький скрипт (оператор цикла):</para>
<para>for i in 1 2 3 4 5 6</para>
<para>        do</para>
<para>        echo -ne '' &gt; /dev/vc/$i</para>
<para>done</para>
<para/>
<para>В первой его строке определяется значение переменной i (ее можно обозвать любым другим образом) как диапазона цифр от 1 до 6 (по умолчанию у нас именно шесть виртуальных консолей), вторая - указывает, что следующей строкой будет тело цикла. А тело цикла - вывод "магической последовательности" ESC-(K (именно она и обеспечивает активизацию карты соответствия) и ее перенаправление на виртуальные консоли, номера которых заданы переменной i, то есть /dev/vc/1 - /dev/vc6. Это - если используется файловая система устройств (devfs), в противном случае (если не был снят комментарий со строки tmpfs в файле /etc/fstab) имена консолей будут обычными - /dev/tty0 - /dev/tty5.</para>
<para/>
<para>Отступление для любовников (или невольников) кодировки CP1251. Все сказанное о русификации применимо и к ней. Нужно только определить в файле /etc/fstab загрузку соответствующих раскладки клавиатуры (они, как уже говорилось, имеются) и карты соответствия CP1251-&gt;CP866. А вот ее придется поискать (где - за ненадобностью не помню) или просто слямзить из любого отечественного дистрибутива - Altlinux или ASPLinux.</para>
<para/>
<para>Все же открою секрет - почему в консоли в любом случае предпочтительны экранные шрифты в кодировке DOS. Так уж исторически сложилось: вследствие аппаратных особенностей VGA-адаптеров (а в консоли мы имеем дело именно с режимом VGA, сколь бы крутой GeForce не стоял в машине) только они обеспечивают нормальный вывод на экран символов псевдографики. Кроме того, их просто больше, и некоторые среди них, как я говорил, лучше. Так что есть резон загружать именно их, даже если программы с псевдографикой не используются совсем. В том числе и Midnight Commander - но какой же русский не любит детей командира Нортона!</para>
<para/>
<para>Мы же пока завершим русификацию. Для чего установим собственно локаль последней строкой в файле /etc/init.d/local (опять прекрасный каламбур, господа!):</para>
<para>export  LANG="ru_RU.KOI8-R"</para>
<para/>
<para>Она обеспечит установку всех локально-зависимых переменных (не только страны, языка, набора символов, но и формата даты, времени, денежной единицы, и так далее) в значения, принятые для нашей многострадальной Отчизны. Тем не менее, для представления чисел я сделал бы исключение, добавив строку</para>
<para>export  LC_NUMERIC="POSIX"</para>
<para/>
<para>Ведь в любых программах, связанных со счетом, удобнее оперировать с десятичной точкой, а не запятой (а говорят, что некоторые такие программы этого просто требуют).</para>
<para/>
<para>В итоге, выполнив несложную последовательность действий, мы получили корректно русифицированную систему - русифицированную ничуть не хуже, чем те дистрибутивы, кириллической поддержкой в которых гордятся (и - справедливо гордятся) именитые отечественные разработчики - Altlinux и ASPLinux. А поскольку мы сделали все это своими руками и с полным пониманием сути действий, у нас тоже есть основание для гордости. Правда, "лобовым" способом, без учета специфики дистрибутива - но зато работающим всегда и везде. А к "идеологически правильному" (для Gentoo) методу локализации можно будет вернуться позднее.</para>
<para/>
<para>Можно, конечно, активизировав внесенные в конфигурацию изменения командой etc-update, продолжать устанавливать программы (Иксы, например). Или даже начинать обычную работу - установленная система, внутри которой мы находимся, это вполне уже позволяет. Однако для полной проверки лучше все-таки сначала перезагрузиться.</para>
<para/>
<para>Итак, временно расстаемся с нашим новым Gentoo командой exit, после чего вновь оказываемся в системе Live CD, той же командой зарываем все виртуальные консоли, кроме первой (а у нас их могло расплодиться немало) и готовимся к выходу.</para>
<para/>
<para>Хотя - стоп. А собирали ли мы при установке ядро системы. Если да - все в порядке, тотальный unmount:</para>
<para>$ umount /mnt/gentoo/boot</para>
<para>$ umount /mnt/gentoo</para>
<para/>
<para>и что было смонтировано руками, а затем - reboot (или halt, если есть желание прерваться - при первой загрузке хорошо бы внимательно следить за ее ходом по сообщениям на экране).</para>
<para/>
<para>Если же ядро не собиралось (за отсутствием каких-то исходников - другого оправдания такому разгильдяйству нет), то совершаем последнее установочное действие: просто тупо копируем ядро с Live CD (оно, как мы уже убедились, не только работоспособно, но и поддерживает большинство жизненно необходимых функций):</para>
<para>$ cp /cdroot/boot/linux /mnt/gentoo/boot/</para>
<para/>
<para>Правда, у нас не собиралось не только ядро, но и модули. И это не беда, их тоже копируем с CD:</para>
<para>cp -R /cdroot/lib/modules /mnt/gentoo/lib/modules</para>
<para/>
<para>А далее - все то же, размонтирование и перезагрузка. Конечно, в ходе ее мы рискуем получить кое-какие сообщения об ошибках, но, по моему опыту - ни одна из них не критична. И загрузившаяся система будет вполне пригодной к использования. По крайней мере, до тех пор, пока не разживемся всеми необходимыми архивами и все-таки ядро не пересоберем - от этого все равно не уйти.</para>
<para>Заключительный аккорд</para>
<para/>
<para>У терпеливого читателя, добравшегося до этих строк, может возникнуть три совершенно законных вопроса: не слишком ли все это сложно, на кой все это нужно, и кому все это нужно. Постараюсь ответить последовательно.</para>
<para/>
<para>Относительно сложности - могу заверить, что это из той самой оперы, когда глаза боятся, а руки делают. Проверено на собственном опыте - причем первый из них проводился в подмосковной деревне, где не то что постоянного подключения к Сети - и телефона-то с модемом не было. И все исходники скачивались на службе (в полутора часах езды) и таскались домой на CD и съемном винчестере. И если праведно выполнять все заветы инструкции по установке, то сложностей возникнет не много (надеюсь, что и настоящий мемуар поспособствует их преодолению).</para>
<para/>
<para>Второй вопрос - а зачем их было преодолевать, когда можно легко и быстро развернуть любой пакетный дистрибутив, разработчики которого уже решили все мои проблемы. Отвечаю: решить-то они решили, но - не скажу плохо, просто в меру своих представлений, как это нужно народу (и конкретно мне, как его представителю). Gentoo же позволяет не просто поставить систему, идеально оптимизированную под железо, но и настроить ее тоже в соответствие именно со своим представлением об идеале. Причем - с полным осознанием, что и зачем делается, немало способствующим общему образованию.</para>
<para/>
<para>Ну а третий ответ очевиден из второго. Дистрибутив Gentoo нужен пользователю, которому требуется система, настроенная на максимальную производительность для конкретной тяжелой задачи - счетной, графической, GIS или CAD. Разработчику, которому надоело проводить время компиляции тысяч и тысяч строк кода за игрой в тетрис. Сисадмину, у которого в системе не должно быть ничего лишнего, но все необходимое должно быть. Изучающему Linux, которого не устраивают готовые рецепты, предлагаемые руководствами пакетных дистрибутивов. И наконец, тому, кто просто стремится к идеалу - пусть идеал этот и недостижим...</para></sect2></sect1><sect1><title>Краткое руководство по установке Gentoo Linux x86</title>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/gentoo-x86-quickinstall.xml">http://www.gentoo.org/doc/ru/gentoo-x86-quickinstall.xml</ulink>
</para>
<para>C версии: 1.0</para><sect2><title>Установочный диск</title>
<para/>
<para>Скачайте компакт-диск с одного из наших зеркал. ISO-образы находятся в каталогах: releases/&lt;архитектура&gt;/&lt;выпуск&gt;/установочный-диск. Минимальный установочный диск подходит только для установки из интернета; с универсального диска также возможна установка без обращения к сети. </para>
<para>Запишите компакт-диск, затем загрузитесь с него. В загрузочном окне нажмите F2, чтобы выяснить, какие варианты загрузки предлагаются. Если вам нужна поддержка PCMCIA, сразу после загрузки потребуется запустить сценарий инициализации pcmcia. </para>
<para>Установочные диски позволяют запускать сервер sshd, добавлять новых пользователей, запускать irssi (консольный чат-клиент) и просматривать веб-страницы с помощью lynx или links2. </para>
<para/></sect2><sect2><title>Настройка сети</title>
<para/>
<para>Если ваша сеть еще не работает, для ее настройки можно использовать net-setup. Перед настройкой вам может потребоваться загрузить поддержку свой сетевой платы с помощью modprobe. Если у вас ADSL, используйте adsl-setup и adsl-start. Для поддержки PPTP, сначала отредактируйте /etc/ppp/chap-secrets и /etc/ppp/options.pptp, а затем запустите pptp &lt;ip сервера&gt;. </para>
<para>При беспроводном доступе для установки параметров соединения используйте iwconfig, а затем либо опять net-setup, либо запустите вручную ifconfig, dhcpcd и/или route. </para>
<para>Если вы находитесь за прокси-сервером, не забудьте инициализировать систему с помощью export http_proxy, ftp_proxy и RSYNC_PROXY. </para></sect2><sect2><title>Подготовка дисков</title>
<para/>
<para>Для организации разделов запустите fdisk или cfdisk. Вам нужен хотя бы раздел подкачки (тип 82) и один раздел Linux (тип 83). </para>
<para>Для создания файловых систем на своих Linux-разделах используйте mke2fs, mke2fs -j, mkreiserfs, mkfs.xfs mkfs.jfs. Подготовьте свой раздел подкачки командами mkswap и swapon. </para>
<para>Смонтируйте свеже созданные файловые системы в /mnt/gentoo. Создайте каталоги для других точек монтирования (например, /mnt/gentoo/boot), если они вам нужны. </para>
<para/></sect2><sect2><title>Установка стадии</title>
<para/>
<para>Прежде всего, установите верную дату командой date MMDDhhmmYYYY. Далее скачайте файл стадии с одного из наших зеркал или используйте находящийся на установочном диске (в /mnt/cdrom/stages). Перейдите в /mnt/gentoo и распакуйте стадию командой tar -xvjpf &lt;архив стадии&gt;. </para>
<para>В случае установки без сети установите снимок портежей: перейдите в /mnt/gentoo/usr и запустите tar -xvjf /mnt/cdrom/snapshots/&lt;файл снимка&gt;. Другие пользователи таким же образом могут скачать снимок портежей и установить его. </para>
<para>При установке без сети, скопируйте файлы исходников из /mnt/cdrom/distfiles/ в /mnt/gentoo/usr/portage/distfiles/. </para>
<para>Отредактируйте /mnt/gentoo/etc/make.conf под ваши нужды (флаги USE, CFLAGS и CXXFLAGS). Для этого можно использовать редактор nano. </para>
<para/></sect2><sect2><title>Установка базовой системы Gentoo</title>
<para/>
<para>Сначала смонтируйте файловую систему /proc, скопируйте файл /etc/resolv.conf поверх существующего, а затем смените корневой каталог (chroot) на свою среду Gentoo. </para>
<para/>
<para>Листинг 1.1: Подготовка и смена корневого каталога</para>
<para># mount -t proc none /mnt/gentoo/proc</para>
<para># cp /etc/resolv.conf /mnt/gentoo/etc/</para>
<para># chroot /mnt/gentoo /bin/bash</para>
<para># env-update &amp;&amp; source /etc/profile</para>
<para/>
<para/>
<para>Если вы не выполняете бессетевую установку, командой emerge --sync обновите свое дерево портежей. </para>
<para>Далее убедитесь, что /etc/make.profile указывает на верный профиль. Профиль по умолчанию должен подойти большинству пользователей; имеются подпрофили для различных ядер (например, 2.4/ для профилей, основанных на ядре 2.4). Изменяйте профиль командой ln -sfn. </para>
<para>Самогенерация системы (не выполняется при бессетевой установке) запускается сценарием scripts/bootstrap.sh в каталоге /usr/portage. </para>
<para>Установка системы (не выполняется при бессетевой установке) запускается командой emerge -e system (или -N, если вы не меняли значения CFLAGS/CXXFLAGS по умолчанию). </para>
<para/></sect2><sect2><title>Настройка ядра</title>
<para/>
<para>Установите сведения о своем часовом поясе, сменив символьную ссылку /etc/localtime на указывающую на верное место в /usr/share/zoneinfo командой ln -sf. </para>
<para>Установите исходный код ядра (при установке без сети доступны gentoo-sources и vanilla-sources) и настройте его с помощью make menuconfig, затем make &amp;&amp; make modules_install внутри каталога /usr/src/linux. Скопируйте файл arch/i386/boot/bzImage в /boot, заменяя существующий. Также можно выполнить emerge genkernel и genkernel all. </para>
<para>Пользователям, использующим Genkernel, потребуется выполнить emerge coldplug и rc-update add coldplug default. </para>
<para/></sect2><sect2><title>Настройка системы</title>
<para/>
<para>Отредактируйте свой /etc/fstab; пример показан ниже. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1.2: Пример файла fstab</para>
</entry>
</row>
<row>
<entry>
<para>/dev/hda1       /boot          ext2      defaults,noatime                     1 2</para>
<para>/dev/hda2        none         swap    sw                                           0 0</para>
<para>/dev/hda3       /                 ext3      noatime                               0 1</para>
<para>none             /proc            proc     defaults                              0 0</para>
<para>none             /dev/shm     tmpfs   nodev,nosuid,noexec           0 0</para>
<para>/dev/cdroms/cdrom0   /mnt/cdrom    auto      noauto,user       0 0</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Для настройки своей сети отредактируйте /etc/conf.d/hostname и /etc/conf.d/domainname, запустите rc-update add domainname default, затем отредактируйте /etc/conf.d/net. Добавьте сценарий инициализации net.eth0 к уровню запуска по умолчанию (default run level). Если у вас несколько сетевых карт (NIC), поместите символьные ссылки на них в сценарий инициализации net.eth0, и также добавьте их в уровень запуска по умолчанию. </para>
<para/>
<para>Отредактируйте /etc/hosts; примеры приведены ниже: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1.3: Примеры файла /etc/hosts</para>
</entry>
</row>
<row>
<entry>
<para>(Для статических IP-адресов)</para>
<para>127.0.0.1     localhost</para>
<para>192.168.0.5   jenny.homenetwork jenny</para>
<para>192.168.0.6   benny.homenetwork benny</para>
<para>192.168.0.7   tux.homenetwork tux</para>
<para>(Для динамических IP-адресов)</para>
<para>127.0.0.1     localhost.homenetwork tux localhost</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para/>
<para>При необходимости установите (emerge) pcmcia-cs и добавьте его в уровень запуска по умолчанию. </para>
<para>Установите пароль root с помощью passwd. </para>
<para>Выполните необходимую настройку в файлах: /etc/rc.conf, /etc/conf.d/rc, /etc/conf.d/keymaps, /etc/conf.d/clock. </para>
<para/></sect2><sect2><title>Установка системных утилит</title>
<para/>
<para>Пользователям ядра 2.4 нужно запустить emerge --unmerge udev и emerge devfsd. </para>
<para>Установите системный журнал, например syslog-ng, и добавьте его в уровень запуска по умолчанию. Сделайте то же самое для демона cron, например, vixie-cron (необязательный шаг). </para>
<para>Установите необходимые средства для файловых систем (xfsprogs, reiserfsprogs или jfsutils), а также для сети (dhcpcd или rp-pppoe). </para>
<para/></sect2><sect2><title>Настройка загрузчика</title>
<para/>
<para>Установите (emerge) grub или lilo. Отредактируйте /boot/grub/grub.conf или /etc/lilo.conf, соответственно. Ниже приведены примеры обоих. </para><sect3><title>Grub</title>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1.4: Пример grub.conf</para>
</entry>
</row>
<row>
<entry>
<para>default 0</para>
<para>timeout 30</para>
<para>splashimage=(hd0,0)/grub/splash.xpm.gz</para>
<para># для пользователей genkernel</para>
<para>title=Gentoo Linux 2.6.11-r3</para>
<para>root (hd0,0)</para>
<para>kernel /kernel-genkernel-x86-2.6.11-gentoo-r3 root=/dev/ram0 init=/linuxrc ramdisk=8192 real_root=/dev/hda3 udev</para>
<para>initrd /initramfs-genkernel-x86-2.6.11-gentoo-r3</para>
<para># для остальных пользователей (без initrd)</para>
<para>title=Gentoo Linux 2.6.11 r3</para>
<para>root (hd0,0)</para>
<para>kernel /kernel-2.6.11-gentoo-r3 root=/dev/hda3</para>
<para># только если вам нужна двойная загрузка</para>
<para>title=Windows XP</para>
<para>root (hd0,5)</para>
<para>makeactive</para>
<para>chainloader +1</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para/>
<para/></sect3><sect3><title>Lilo</title>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1.5: Пример файла lilo.conf</para>
</entry>
</row>
<row>
<entry>
<para>boot=/dev/hda</para>
<para>prompt</para>
<para>timeout=50</para>
<para>default=gentoo</para>
<para/>
<para># для пользователей, не использующих genkernel</para>
<para>image=/boot/kernel-2.6.11-gentoo-r3</para>
<para>  label=gentoo</para>
<para>  read-only</para>
<para>  root=/dev/hda3</para>
<para/>
<para># для пользователей genkernel</para>
<para>image=/boot/kernel-genkernel-x86-2.6.11-gentoo-r3</para>
<para>  label=gentoo</para>
<para>  read-only</para>
<para>  root=/dev/ram0</para>
<para>  append="init=/linuxrc ramdisk=8192 real_root=/dev/hda3 udev"</para>
<para>  initrd=/boot/initramfs-genkernel-x86-2.6.11-gentoo-r3</para>
<para/>
<para># Для двойной загрузки</para>
<para>other=/dev/hda6</para>
<para>  label=windows</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Пользователям GRUB необходимо установить GRUB в главную загрузочную запись (MBR) командой grub-install /dev/hda после копирования /proc/mounts в /etc/mtab. Пользователям LILO нужно запустить /sbin/lilo. </para>
<para>Выйдите из изолированной среды, размонтируйте все файловые системы и перезагрузитесь. </para></sect3></sect2><sect2><title>Окончание установки</title>
<para/>
<para>Зайдите как root, затем добавьте одного или нескольких пользователей для повседневного использования командой useradd -m -G &lt;группа&gt; &lt;имя пользователя&gt;. </para>
<para>Если вы выполняли установку без сети, смонтируйте компакт-диск с пакетами в /mnt/cdrom и выполните export PKGDIR="/mnt/cdrom", после чего вы сможете устанавливать дополнительное ПО, например, kde, командой emerge -k &lt;имя пакета&gt;. для . </para>
<para>Спасибо за установку Gentoo!</para></sect2></sect1><sect1><title>Описание альтернативных способов установки Gentoo Linux</title>
<para>Ссылка на оригинал:  <ulink url="http://www.gentoo.org/doc/ru/altinstall.xml">http://www.gentoo.org/doc/ru/altinstall.xml</ulink>
</para>
<para>С версии: 1.0</para>
<para/><sect2><title>1. Об этом документе</title>
<para/>
<para>Если у вас не работает стандартный метод установки boot-from-CD (или он вас не устраивает), вам сюда. Этот документ описывает альтернативные приемы установки Gentoo Linux для тех, кто в них нуждается. Или, если хотите, это место сбора всех "оригинальных" способов установки. Если у вас один такой завалялся, или вы откопали новую прикольную методу, не стесняйтесь, написать запрос в Bugzilla. </para>
<para/></sect2><sect2><title>2. Загрузка с установочного диска при помощи Smart BootManager</title>
<para/>
<para>Скачайте Smart BootManager с http://btmgr.sourceforge.net/download.html. Доступны как исходники, так и бинарники для Linux, не говоря уже про виндовский .exe и множество языковых пакетов. Все-таки, в настоящее время, бинарный формат предпочтительнее, поскольку исходники могут не откомпилироваться современными версиями NASM. </para>
<para/>
<para>Скомпилируйте пакет или возьмите уже готовый. Ниже я расскажу о некоторых полезных опциях, доступных при создании загрузочной дискеты. </para>
<para/>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.1: Опции Smart BootManager</para>
</entry>
</row>
<row>
<entry>
<para>sbminst [-t theme] [-d drv] [-b backup_file] [-u backup_file]</para>
<para/>
<para>   -t тема      выбор используемой темы, где тема должна быть:</para>
<para>                   us = English тема       de = German тема </para>
<para>                   hu = Hungarian тема     zh = Chinese тема </para>
<para>                   ru = Russian тема       cz = Czech тема</para>
<para>                   es = Spanish тема       fr = French тема </para>
<para>                   pt = Portuguese тема </para>
<para/>
<para>                 </para>
<para>   -d диск      выбор диска, куда вы собираетесь инсталлировать Smart BootManager;</para>
<para>                 для Linux:</para>
<para>                   /dev/fd0 первый floppy-диск, </para>
<para>                   /dev/hda первый IDE-диск.</para>
<para>                   /dev/sda первый SCSI-диск.</para>
<para>                 для DOS:</para>
<para>                    0   первый floppy-диск</para>
<para>                    128 первый жесткий диск;</para>
<para/>
<para>   -c           отключить загрузку с CD-ROM;</para>
<para/>
<para>   -b backup_file сохранить (для будущей деинсталляции) данные, которые будут</para>
<para>                  перезаписаны;</para>
<para/>
<para>   -u backup_file деинсталлировать Smart BootManager, нельзя использовать</para>
<para>                  с другими ключами;</para>
<para/>
<para>   -y             никаких вопросов и предупреждений.</para>
<para/>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para/>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.2: Использование sbminst для создания загрузочной дискеты</para>
</entry>
</row>
<row>
<entry>
<para># sbminst -t us  -d /dev/fd0</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Примечание: Замените fd0 на имя вашего floppy-дисковода (если у вас он называется по-другому). </para>
<para/>
<para/>
<para>Теперь просто вставьте дискету в дисковод компьютера, на котором вы хотите запустить установочный диск, и загрузитесь с нее. </para>
<para/>
<para>Вас поприветствует Smart BootManager. Выберите CD-ROM и нажмите ENTER для загрузки установочного диска. Если все прошло удачно, следуйте стандартной процедуре установки. </para>
<para/>
<para>Больше информации по Smart BootManager вы найдете на http://btmgr.sourceforge.net/ </para>
<para/></sect2><sect2><title>3. Установка при помощи Knoppix</title>Установка при помощи Knoppix<para>Примечание: Knoppix доступен только для пользователей x86. </para>
<para/>
<para/>
<para>Загрузившись с Knoppix LiveCD, вы получаете полностью работоспособную систему для компиляции Gentoo. Во время сборки Tux Racer скрасит ваше ожидание, а для работы вы можете пользоваться OpenOffice. </para>
<para>Предупреждение: Помните, что если вы что-либо сохраните в домашний каталог Knoppix, ожидая установки своей системы Gentoo, вы потеряете это после перезагрузки в Gentoo. Убедитесь, что сохраняете важные файлы на жесткий диск или на другой компьютер! </para>
<para/>
<para>Загрузитесь с Knoppix CD. Если у вас Knoppix 3.6-3.8.2, потребуется указать knoppix26 в качестве параметра ядра, чтобы загрузить ядро 2.6. Если вы пропустите этот шаг, то при chroot вы получите сообщение об ошибке, что ваше ядро слишком старое. Однако, если у вас Knoppix 3.9+, этот шаг не потребуется, так как ядро 2.6 выбрано по умолчанию. </para>
<para/>
<para>По умолчанию вы попадаете на рабочий стол KDE. Откройте консоль и введите su -, чтобы была возможность изменить пароль. Это позволяет задать пароль для root в Knoppix. Теперь, при желании, можете настроить sshd для удаленного входа в систему. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.1: Создание точки монтирования /mnt/gentoo</para>
</entry>
</row>
<row>
<entry>
<para># mkdir /mnt/gentoo</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Далее вы можете придерживаться стандартного руководства по установке, начиная с части 4. Кроме монтирования /proc. Тут вам надо поступить по-другому:</para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.2: Монтирование с привязкой псевдо-ФС proc</para>
</entry>
</row>
<row>
<entry>
<para># mount -o bind /proc /mnt/gentoo/proc</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Также знайте, что некоторые возможности (FEATURES) портежей не будут работать в knoppix. Будьте особенно осторожны с userpriv и usersandbox. Если вы обнаружили, что начали получать ошибки, будет разумным отключить все или некоторые необязательные возможности. </para>
<para/></sect2><sect2><title>4. Установка со Stage 1 без доступа в сеть</title>
<para/>
<para>Создайте установочный компакт-диск из iso-образа. </para>
<para/>
<para>Возьмите последний snapshot портежей из http://distro.ibiblio.org/pub/linux/distributions/gentoo/snapshots/ (или с любимого зеркала). Запишите этот tarball на существующий раздел в компьютере, где будет проходить установка, или прожгите его на CD. </para>
<para/>
<para>Следуйте инструкции из Gentoo Install Doc вплоть до chroot /mnt/gentoo в главе 6. Если у вас в наличии только один привод CD-ROM, не забудьте при загрузке ввести опцию docache чтобы иметь возможность размонтировать установочный компакт-диск и смонтировать CD со snapshot-ом портежей. </para>
<para/>
<para>Открыв новую консоль (Alt-F2), а в ней руководство по установке, мы можем следовать ему вплоть до запуска скрипта bootstrap.sh. </para>
<para>Предупреждение: В старых выпусках установочного компакт-диска требуется изменить пароль командой passwd прежде чем логиниться с другой консоли. </para>
<para/>
<para>Возвращаемся к первой консоли (Alt-F1, without chroot) и монтируем второй CD в /mnt/gentoo/mnt/cdrom2. Копируем portage tarball с cdrom2 и распаковываем в /mnt/gentoo/usr. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.1: Монтирование snapshot cd</para>
</entry>
</row>
<row>
<entry>
<para># umount /mnt/cdrom</para>
<para># mkdir /mnt/gentoo/mnt/cdrom2</para>
<para># mount /dev/cdroms/cdrom0 /mnt/gentoo/mnt/cdrom2</para>
<para># cp /mnt/gentoo/mnt/cdrom2/portage-$date.tar.bz2 /mnt/gentoo/usr</para>
<para># cd /mnt/gentoo/usr</para>
<para># tar -xvjpf portage-$date.tar.bz2</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Снова переключаемся на вторую консоль. Если сейчас попытаться запустить bootstrap.sh, ничего не выйдет, так как он не сможет закачать ни одного файла. Мы получим эти файлы из другого места и разместим их в /usr/portage/distfiles (в консоли F2). </para>
<para/>
<para>Нам необходим список пакетов Stage1: glibc, baselayout, texinfo, gettext, zlib, binutils, gcc, ncurses плюс их зависимости. </para>
<para>Примечание: Не забываете, что вам нужны версии пакетов, синхронизированные с вашим деревом портежей. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.2: Получение списка для скачивания</para>
</entry>
</row>
<row>
<entry>
<para>(Не забывайте 2 перед &gt;)</para>
<para># emerge -fp glibc baselayout texinfo gettext zlib binutils gcc ncurses 2&gt; stage1.list</para>
<para># mount -t vfat /dev/fd0 /mnt/floppy</para>
<para># cp /mnt/gentoo/stage1.list /mnt/floppy</para>
<para># umount /mnt/floppy</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Вставьте дискету в компьютер с хорошим каналом. Если заглянуть в файл stage1.list, можно увидеть, что в нем перечисляются несколько ссылок на каждую загрузку. К сожалению, это не совсем то, что нам надо. Сначала список надо почистить от лишнего: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.3: Stripping URLs</para>
</entry>
</row>
<row>
<entry>
<para>(Этот скрипт привязан к формату вывода emerge, который может измениться</para>
<para> без предварительного предупреждения - используйте с осторожностью!)</para>
<para># cut -f 1 -d ' ' stage1.list &gt; stage1.download</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Теперь используйте wget для загрузки списка исходников: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.4: Загружаем пакеты с помощью wget</para>
</entry>
</row>
<row>
<entry>
<para># wget -N -i stage1.download</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Получив все файлы, переносим их в наш компьютер в /mnt/gentoo/usr/portage/distfiles. Вот теперь можно запускать bootstrap.sh. Повторяем ту же операцию с wget для stage2 и 3. </para>
<para/></sect2><sect2><title>5. Бездисковая установка с загрузкой через PXE</title>
<para/>
<para>Что необходимо</para>
<para/>
<para>Нужна сетевая карта на бездисковом клиенте, которая способна загружаться по протоколу PXE (многие карточки 3com). BIOS тоже должен поддерживать такой способ загрузки. </para>
<para/>
<para>Настройки на стороне сервера</para>
<para/>
<para>Создание папок: Во-первых, следует создать папки, в которых будет размещена ваша бездисковая система. Начнем с /diskless, в ней будет находиться по отдельной папке для каждого бездискового клиента. Дальше мы рассмотрим работу с клиентом 'eta'. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5.1: создание папок</para>
</entry>
</row>
<row>
<entry>
<para># mkdir /diskless</para>
<para># mkdir /diskless/eta</para>
<para># mkdir /diskless/eta/boot</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Настройка DHCP и TFTP: Клиент получает загрузочную информацию, используя DHCP, затем загружает необходимые файлы с помощью TFTP. Собираем DHCP командой emerge и настраиваем его для наших нужд. Добавляем следующее в /etc/dhcp/dhcpd.conf: </para>
<para>Примечание: Мы получим статический IP для клиента и путь к загрузочному образу PXE, здесь pxegrub. Вам необходимо подставить соответствующий MAC-адрес сетевой карты вашего клиента и определиться с директорией, где будут храниться клиентские файлы. </para>
<para/>
<para/>
<para>Для DHCPd, запустите emerge dhcp (или любой другой сервер DHCP на свое усмотрение). Убедитесь, что в /etc/conf.d/dhcp выбран верный интерфейс. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5.2: dhcp.conf</para>
</entry>
</row>
<row>
<entry>
<para>option option-150 code 150 = text ;</para>
<para>ddns-update-style none ;</para>
<para>host eta {</para>
<para>hardware ethernet 00:00:00:00:00:00;</para>
<para>fixed-address ip.add.re.ss;</para>
<para>option option-150 "/eta/boot/grub.lst";</para>
<para>filename "/eta/boot/pxegrub";</para>
<para>}</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Для установки TFTP, соберите app-admin/tftp-hpa. Впишите следующее в /etc/conf.d/in.tftpd: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5.3: in.tftpd</para>
</entry>
</row>
<row>
<entry>
<para>INTFTPD_PATH="/diskless"</para>
<para>INTFTPD_USER="nobody"</para>
<para>INTFTPD_OPTS="-u ${INTFTPD_USER} -l -vvvvvv -p -c -s ${INTFTPD_PATH}"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Настройка GRUB: Я использую GRUB для PXE-загрузки. Чтобы можно было использовать PXE, вы должны самостоятельно скомпилировать GRUB ... ведь это просто. Во-первых, скачайте самую свежую версию исходников GRUB (emerge -f grub поместит tarball в /usr/portage/distfiles). Скопируйте tarball в /diskless и скомпилируйте GRUB, чтобы получить доступный для pxe бинарник. Готовый бинарник копируем в boot-папку бездискового клиента. И редактируем файл grub.lst: </para>
<para/>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5.4: установка grub</para>
</entry>
</row>
<row>
<entry>
<para># tar zxvf grub-0.92.tar.gz</para>
<para># cd grub-0.92</para>
<para># ./configure --help</para>
<para>(Среди опций вы увидите список поддерживаемых драйверов сетевых интерфейсов.)</para>
<para>(Выберите драйвер, совместимый с вашей картой. Здесь он фигурирует как $nic)</para>
<para># ./configure --enable-diskless --enable-$nic</para>
<para># make</para>
<para># cd stage2</para>
<para># cp pxegrub /diskless/eta/boot/pxegrub</para>
<para># nano -w /diskless/eta/boot/grub.lst</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5.5: grub.lst</para>
</entry>
</row>
<row>
<entry>
<para>default 0</para>
<para>timeout 30</para>
<para/>
<para>title=Diskless Gentoo</para>
<para>root (nd)</para>
<para>kernel /eta/bzImage ip=dhcp root=/dev/nfs nfsroot=ip.add.re.ss:/diskless/eta</para>
<para/>
<para>(В опции nfsroot указывается IP адрес сервера и путь к директории,)</para>
<para>(в которой на сервере лежат файлы нашего бездискового клиента.)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Настройка NFS: NFS легко сконфигурировать. Все что нам надо - это добавить одну строку в конфигурационный файл /etc/exports: </para>
<para/>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5.6: /etc/exports</para>
</entry>
</row>
<row>
<entry>
<para># nano -w /etc/exports</para>
<para># /etc/exports: NFS file systems being exported.  See exports(5).</para>
<para>/diskless/eta eta(rw,sync,no_root_squash)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Обновление hosts: Еще одно важное дело - изменение файла /etc/hosts. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5.7: /etc/hosts</para>
</entry>
</row>
<row>
<entry>
<para>127.0.0.1 localhost</para>
<para/>
<para>192.168.1.10 eta.example.com eta</para>
<para>192.168.1.20 sigma.example.com sigma</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Создание системы на сервере</para>
<para/>
<para>Вы можете захотеть перезагрузить сервер с установочного диска Gentoo, хотя точно так же можете немедленно продолжить, если знать, как выполнять инструкции по установке Gentoo на установленной системе. Следуйте стандартной процедуре установки, как описано в Gentoo Install Howto, НО с учетом следующих отличий: Для монтирования файловой системы сделайте следующее (здесь hdaX - раздел, в котором создана папка /diskless). Вам не надо монтировать другие разделы, так как все файлы располагаются в /diskless/eta. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5.8: монтирование файловой системы</para>
</entry>
</row>
<row>
<entry>
<para># mount /dev/hdaX /mnt/gentoo</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Stage tarballs и chroot: Этот пример использует tarball stage3. Смонтируйте /proc в вашу бездисковую директорию и выполните chroot в нее(директорию) для продолжения установки. Дальше - по инструкции вплоть до конфигурации ядра. </para>
<para>Предупреждение: Будьте очень внимательны при разархивировании stage tarball. Не распакуйте его в существующую систему. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5.9: извлечение stage tarball</para>
</entry>
</row>
<row>
<entry>
<para># cd /mnt/gentoo/diskless/eta/</para>
<para># tar -xvjpf  /mnt/cdrom/gentoo/stage3-*.tar.bz2</para>
<para># mount -t proc /proc /mnt/gentoo/diskless/eta/proc</para>
<para># cp /etc/resolv.conf /mnt/gentoo/diskless/eta/etc/resolv.conf</para>
<para># chroot /mnt/gentoo/diskless/eta/ /bin/bash</para>
<para># env-update</para>
<para># source /etc/profile</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Конфигурация ядра: При выполнении make menuconfig во время конфигурации ядра, не забудьте сделать доступными следующие опции (помимо рекомендуемых в руководстве по установке): </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5.10: опции menuconfig</para>
</entry>
</row>
<row>
<entry>
<para>- Your network card device support</para>
<para>(в ядре, *не* как модуль!)</para>
<para/>
<para>- Under "Networking options" :</para>
<para/>
<para>[*] TCP/IP networking</para>
<para>[*] IP: kernel level autoconfiguration</para>
<para>[*] IP: DHCP support</para>
<para>[*] IP: BOOTP support</para>
<para/>
<para/>
<para>- Under "File systems --&gt; Network File Systems" :</para>
<para/>
<para>&lt;*&gt; NFS file system support</para>
<para>[*] Provide NFSv3 client support</para>
<para>[*] Root file system on NFS</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Сохраните ядро в / своей изолированной среды (не в /boot), в соответствии с настройкой pxegrub, определенной ранее. Затем настройте /etc/fstab своего бездискового клиента. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5.11: /etc/fstab</para>
</entry>
</row>
<row>
<entry>
<para># nano -w /etc/fstab</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0</para>
<para>proc /proc proc defaults 0 0</para>
<para>tmpfs /dev/shm tmpfs nodev,nosuid,noexec 0 0</para>
<para/>
<para/>
<para>Вам также потребуется предотвратить запуск на клиенте проверки файловой системы: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5.12: Исключение запуска проверки файловой системы на клиенте</para>
</entry>
</row>
<row>
<entry>
<para># touch /fastboot</para>
<para># echo "touch /fastboot" &gt;&gt; /etc/conf.d/local.start</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Установите nfs-utils, так как ваш клиент будет сильно зависеть от них: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5.13: Установка nfs-utils</para>
</entry>
</row>
<row>
<entry>
<para># emerge nfs-utils</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Загрузчик. Не устанавливайте других загрузчиков, так как один у нас уже есть - pxegrub. Просто завершаете установку и перезагружаете сервер. Запустите службы, необходимые для загрузки новоиспеченного клиента: DHCP, TFTPD и NFS. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5.14: Запуск служб</para>
</entry>
</row>
<row>
<entry>
<para># /etc/init.d/dhcp start</para>
<para># /etc/init.d/in.tftpd start</para>
<para># /etc/init.d/nfs start</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Загрузка нового клиента</para>
<para/>
<para>Чтобы клиент загрузился, надо настроить bios и сетевую карту для использования PXE как первого способа загрузки - до CD-ROM или floppy. Помощником вам будет документация к оборудованию или website производителя. Сетевая карта должна получить IP адрес от DHCP и загрузить PXE-образ GRUB при помощи TFTP. Дальше вы увидите симпатичное черно-белое меню GRUB, в котором можно выбрать ядро для загрузки, а нажав Enter, и загрузить его. Если все в порядке, ядро примонтирует корневую файловую систему, используя NFS, и выведет на терминал приглашение для входа в систему. Вот и все. </para>
<para/></sect2><sect2><title>6. Установка Gentoo из существующей Linux-системы</title>
<para/>
<para>Что необходимо</para>
<para/>
<para>Для установки Gentoo из существующей системы Linux вам должна быть доступна команда chroot, а также копия установочного tarball-а Gentoo, либо его ISO-образ. Не помешает доступ в сеть, если вы не хотите ограничиваться тем, что есть в вашем tarball-е. (к слову, tarball - это просто файл, заканчивающийся на .tbz иди .tar.gz). Автор (ориг.текста) использовал RedHat Linux 7.3 как "базовую" ОС, хотя это не так уж важно. Итак, приступим! </para>
<para/>
<para/>
<para>Обзор</para>
<para/>
<para>Сначала надо отвести раздел для Gentoo, изменив размер существующего раздела Linux, смонтировать его, разархивировать tarball, chroot внутрь нашей псевдо-системы, и начинаем строительство. После настройки загрузчика немного поработаем напильником, просто для того, чтобы система была способна загрузиться самостоятельно, перезагружаемся и пользуемся Gentoo. </para>
<para/>
<para>Как отвести место для Gentoo?</para>
<para/>
<para>Корневой раздел - это файловая система, примонтированная к /. Запущенная команда mount показывает, о чем я веду речь. Еще мы можем выполнить df (disk free), чтобы посмотреть, сколько свободного места у нас есть. Прошу заметить - совсем не обязательно кромсать ваш root раздел! Вы можете отрезать в любом другом месте, доступном вашей программе редактирования разделов жесткого диска, но мы поговорим об этом чуть позже. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 6.1: Информация о файловых системах</para>
</entry>
</row>
<row>
<entry>
<para># mount</para>
<para>/dev/hdb2 on / type ext3 (rw) </para>
<para>none on /proc type proc (rw) </para>
<para>none on /dev/pts type devpts (rw,gid=5,mode=620) </para>
<para>none on /dev/shm type tmpfs (rw,nodev,nosuid,noexec)</para>
<para># df -h </para>
<para>Filesystem           Size Used Avail Use% Mounted on </para>
<para>/dev/hdb2            4.0G 1.9G  2.4G  82% /</para>
<para>none                 38M    0   38M   0% /dev/shm </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Как видите, раздел, смонтированный как /, носит имя /dev/hdb2 и на нем еще свободно 2.4 гигабайта. В моем случае, думаю, 400 МБ свободного пространства хватит с головой, следовательно, под Gentoo отводим 2 ГБ. Совсем неплохо, учитывая, что большинству пользователей хватит и одного гигабайта. Приступим!</para>
<para/>
<para/>
<para/>
<para>Сборка parted для переразбивки разделов</para>
<para/>
<para>Parted - утилита, поддерживаемая GNU foundation, старым, респектабельным, безразмерным проектом, софтом которого мы в данный момент и собираемся воспользоваться. Всего одним инструментом, который вполне нам подходит. Называется он parted, partition editor, загрузить его можно из http://www.gnu.org/software/parted/ </para>
<para>Примечание: Конечно, существуют и другие инструменты для работы с разделами, но автор не уверен/не интересуется, сможет ли PartitionMagic(tm) или любая другая программа сделать то, что нам нужно. Проверить - это забота читателя. </para>
<para/>
<para>Взгляните на ту страницу руководства parted, где речь идет о типе файловой системы, размер которой вы собираетесь изменять, и узнайте, сможет ли parted это сделать. Если нет, что ж, вам не повезло. Придется убить какой-нибудь раздел и создать по-новому, чтобы было место для Gentoo. Вперед, качаем программу, устанавливаем. Возникает проблема. Мы хотим изменить размер корневого раздела, следовательно нам нужно загрузить с дискеты минимальную linux-систему и использовать предварительно скомпилированный parted для редактирования /. Если в вашем случае можно отмонтировать выбранный раздел, оставаясь в Linux, вам везет и нет необходимости делать то, что описано ниже. Просто соберите parted и запустите его на разделе, который хотите урезать. А вот то, что я сделал в своей системе. </para>
<para/>
<para>Важно: Убедитесь, что действия, которые вы собираетесь проделать с разделом, поддерживаются parted! </para>
<para/>
<para>Скачайте загрузочный/корневой диск mininux (бесплатный мини-дистрибутив Linux c ядром 2.4 на дискете) с http://mininux.free.fr/uk/, создайте дискету, как описано в прилагающейся документации, вставьте еще одну чистую дискету в дисковод и перейдите к следующему шагу. </para>
<para>Примечание: Опять замечу, что Linux - синоним понятия "Этот путь не единственный". Наша цель - запустить parted на отмонтированном разделе жесткого диска и это можно сделать не только описанным способом. Вы можете использовать любой другой набор boot/root дискет, не только mininux. Вы можете вообще не выполнять данный шаг, главное, что нужно - отмонтировать файловую систему, которую вы собираетесь использовать под Gentoo, и перекроить ее, используя parted. </para>
<para/>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 6.2: Создание вспомогательной дискеты</para>
</entry>
</row>
<row>
<entry>
<para># mkfs.minix /dev/fd0</para>
<para>480 inodes</para>
<para>1440 blocks</para>
<para>Firstdatazone=19 (19)</para>
<para>Zonesize=1024</para>
<para>Maxsize=268966912</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Продолжим со сборкой parted. Если он еще не закачан и не распакован, сделайте это. А затем перейдите в каталог, куда вы его распаковали. И здесь выполните следующий набор команд для сборки утилиты и записи ее на дискету. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 6.3: Подготовка вспомогательной дискеты</para>
</entry>
</row>
<row>
<entry>
<para>#  mkdir /floppy; mount -t minix /dev/fd0 /floppy &amp;&amp; </para>
<para>export CFLAGS="-O3 -pipe -fomit-frame-pointer -static" &amp;&amp; ./configure </para>
<para>&amp;&amp; make &amp;&amp; cp parted/parted /floppy &amp;&amp; umount /floppy </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Поздравляю, вы готовы перезагрузиться и изменять выбранный раздел. Только делайте это после хотя бы беглого просмотра документации к parted на GNU website. Наберитесь терпения - изменение размера может занять больше получаса на больших дисках. Загрузитесь с дискеты mininux, а после этого замените загрузочную дискету на вспомогательную, которую мы только что создали. Введите mount /dev/fd0 /floppy и parted будет доступен в папке /floppy. Нам туда. Запускаете parted и перекраиваете нужный раздел жесткого диска. Когда этот бесконечный процесс наконец завершится, все будет готово для того, чтобы получить истинное наслаждение, устанавливая Gentoo. Диск, с которым мы работаем - это тот, на котором находится раздел, размер которого мы меняем. К примеру, если мы хотим изменить /dev/hda3, то диск, соответственно, будет называться /dev/hda. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 6.4: Команды, которые следует выполнить, загрузившись с mininux</para>
</entry>
</row>
<row>
<entry>
<para># mount /dev/fd0 /floppy </para>
<para># cd /floppy; ./parted [диск, с которым мы работаем]</para>
<para>(parted)  print </para>
<para>Disk geometry for /dev/hdb: 0.000-9787.148 megabytes</para>
<para>Disk label type: msdos</para>
<para>Minor    Start       End     Type      Filesystem  Flags</para>
<para>1          0.031   2953.125  primary   ntfs        </para>
<para>3       2953.125   3133.265  primary   linux-swap  </para>
<para>2       3133.266   5633.085  primary   ext3        </para>
<para>4       5633.086   9787.148  extended              </para>
<para>5       5633.117   6633.210  logical               </para>
<para>6       6633.242   9787.148  logical   ext3        </para>
<para>(parted)  help resize </para>
<para>  resize MINOR START END        resize filesystem on partition MINOR</para>
<para/>
<para>        MINOR is the partition number used by Linux.  On msdos disk labels, the</para>
<para>        primary partitions number from 1-4, and logical partitions are 5</para>
<para>        onwards.</para>
<para>        START and END are in megabytes</para>
<para>(parted)  resize 2 3133.266 4000.000 </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Важно: Наберитесь терпения! Компьютер работает! Посмотрите на индикатор обращения к жесткому диску (находится на корпусе), чтобы убедиться, что это так. Процесс может занять от 2 до 30 минут. </para>
<para/>
<para/>
<para>Когда процесс завершится, перезагрузитесь в вашу старую linux-систему. После этого откройте документ Настольная книга Gentoo: подготовка дисков и следуйте инструкциям. Дойдя до chroot, используйте следующую команду чтобы очистить переменные окружения: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 6.5: Обновление среды при chroot</para>
</entry>
</row>
<row>
<entry>
<para># env -i HOME=$HOME TERM=$TERM chroot /mnt/gentoo /bin/bash</para>
<para># /usr/sbin/env-update</para>
<para># source /etc/profile</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Удачи!</para></sect2></sect1><sect1><title>Полезные советы по установке Gentoo/x86</title>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/gentoo-x86-tipsntricks.xml">http://www.gentoo.org/doc/ru/gentoo-x86-tipsntricks.xml</ulink>
</para>
<para>С версии: 1.0</para>
<para/><sect2><title>1. Вступление</title>Вступление<para/>
<para>Для начала</para>
<para/>
<para>Этот документ содержит различные полезные советы по установке Gentoo/x86. Большинство из них описаны кратко — подразумевается, что они послужат дополнением к руководству по установке, а не заменой ему. </para>
<para/></sect2><sect2><title>2. Расширенная установка</title>
<para/>
<para>Программный RAID</para>
<para>Примечание: Если вы не знакомы с программным RAID, пожалуйста, прочтите Software-RAID-HOWTO (англ.). </para>
<para/>
<para>Примечание: Более подробное описание установки приведено в руководстве по быстрой установке программного RAID и LVM2 для x86 (англ.). </para>
<para/>
<para>После загрузки с установочного CD, загрузите соответствующие модули RAID. Например, если вы собираетесь использовать RAID-1: </para>
<para/>
<para>Листинг 2.1: Загрузка модуля RAID-1</para>
<para># modprobe raid1</para>
<para/>
<para/>
<para>Разбивая свои диски, убедитесь, что используете тип раздела fd (Linux raid autodetect), а не 83 (Linux native). Тип раздела можно изменить, используя команду t программы fdisk. </para>
<para/>
<para>Теперь, до начала создания массивов RAID, нам потребуется создать узлы метаустройств: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.2: Создание узлов метаустройств</para>
</entry>
</row>
<row>
<entry>
<para># mknod</para>
<para># mknod /dev/md2 b 9 2</para>
<para># mknod /dev/md3 b 9 3d /dev/md1 b 9 1</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>После разбивки на разделы, создайте файл /etc/mdadm.conf (да, именно так, в среде установочного CD), с помощью mdadm, расширенного средства управления RAID. Например, чтобы зеркалировать (RAID-1) разделы boot, swap и root, охватывая /dev/sda и /dev/sdb, можете использовать:</para>
<para/>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.3: Создание устройств raid командой mdadm</para>
</entry>
</row>
<row>
<entry>
<para># mdadm --create --verbose /dev/md1 --level=1 --raid-devices=2 /dev/sda1 /dev/sdb1</para>
<para># mdadm --create --verbose /dev/md2 --level=1 --raid-devices=2 /dev/sda2 /dev/sdb2</para>
<para># mdadm --create --verbose /dev/md3 --level=1 --raid-devices=2 /dev/sda3 /dev/sdb3</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Важно: На загрузочном разделе не следует использовать никаких разновидностей чередования (striping), таких как RAID-0 or RAID-5. </para>
<para/>
<para/>
<para>Драйвер Linux Software RAID начнет создавать метаустройства. Вы можете проследить за этим в /proc/mdstat. Перед продолжением дождитесь, пока создание метаустройств окончательно завершится.. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.4: Сохранение сведений о созданных устройствах</para>
</entry>
</row>
<row>
<entry>
<para># mdadm --detail --scan &gt; /etc/mdadm.conf</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Теперь и далее используйте /dev/md1 для загрузочного раздела, /dev/md2 для раздела подкачки и /dev/md3 для корневого раздела. </para>
<para/>
<para>Прямо перед изменением корня (chroot), не забудьте скопировать /etc/mdadm.conf в /mnt/gentoo/etc. </para>
<para/>
<para>При конфигурации ядра, обязательно включите соответствующую поддержку RAID в состав ядра, а не модулем. </para>
<para/>
<para>При установке дополнительных утилит, также установите mdadm. Заметьте, что она есть не на всех установочных CD, поэтому у вас может не получиться бессетевая установка Gentoo на программный raid. </para>
<para/>
<para>При настройке загрузчика не забудьте установить его в MBR обоих дисков, если используется зеркалирование. </para>
<para/>
<para>ATA RAID c ядрами 2.4</para>
<para/>
<para>Удостоверьтесь, что вы загрузились с установочного CD с параметром doataraid. После загрузки, проверьте содержимое /dev/ataraid. Там должны находиться различные каталоги disc* для каждого жесткого диска, доступного в ATA RAID. Целый диск показывается как disc, а разделы — как part*. </para>
<para/>
<para>Выпишите различные файлы устройств /dev/ataraid/disc*/*, на которые будете устанавливать Gentoo. При установке вам потребуется указывать этот путь вместо /dev/hda, указанного в примерах. </para>
<para/>
<para>Перед изменением корня, свяжите структуру /dev с новой средой: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.5: Связывание /dev</para>
</entry>
</row>
<row>
<entry>
<para># mount -o bind /dev /mnt/gentoo/dev</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>При настройке ядра не забудьте включить поддержку вашего ATA RAID чипсета с нужными параметрами. Например, для популярной системы ATA RAID Promise FastTrack built-in RAID требуется включение в ядро Promise FastTrack Options. </para>
<para/>
<para>При настройке GRUB сначала потребуется создать загрузочный диск GRUB. Это не так сложно, как кажется. Сначала установите GRUB как обычно, а дойдя до пункта, в котором GRUB устанавливается в MBR, следуйте этим инструкциям: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.6: Создание загрузочного диска GRUB</para>
</entry>
</row>
<row>
<entry>
<para># cd /boot/grub</para>
<para># dd if=stage1 of=/dev/fd0 bs=512 count=1</para>
<para># dd if=stage2 of=/dev/fd0 bs=512 seek=1</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Еще вам потребуется записать файл grub.conf. Здесь нет никаких отличий от установочных инструкций, просто убедитесь, что запись root= указывает на ваше устройство ATA RAID. </para>
<para/>
<para>После окончания установки, загрузитесь со своего загрузочного диска GRUB. Вы должны увидеть приглашение командной строки GRUB. Теперь настройте GRUB для загрузки с устройства ATA RAID: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.7: Установка GRUB на ATA RAID</para>
</entry>
</row>
<row>
<entry>
<para>grub&gt; root (hd0,x)</para>
<para>grub&gt; setup (hd0)</para>
<para>grub&gt; quit</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Теперь перезагрузитесь (вытащив загрузочную дискету GRUB из дисковода). </para>
<para/>
<para>Пользователи LILO могут просто следовать указаниям руководства по установке. </para>
<para/>
<para>Использование ядра с установочного CD</para>
<para/>
<para>Если вы не хотите компилировать ядро сами, можно взять ядро с установочного компакт-диска и скопировать его в свою систему. Дойдя в процессе инсталяции Gentoo до стадии компиляции ядра, перейдите на другую виртуальную консоль (Alt-F2) и войдите в систему как ROOT, используя пароль, установленный вами в начали установки (passwd root). </para>
<para/>
<para>Скопируйте ядро и модули в свою систему: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.8: Копирование ядра с установочного CD</para>
</entry>
</row>
<row>
<entry>
<para>(${KN} это название ядра, обычно это что-то вроде 'gentoo' или 'smp')</para>
<para>cdimage ~# cp /mnt/cdrom/isolinux/${KN} /mnt/cdrom/isolinux/${KN}.gz /mnt/gentoo/boot</para>
<para>cdimage ~# mkdir -p /mnt/gentoo/lib/modules</para>
<para>cdiamge ~# cp -Rp /lib/modules/`uname -r` /mnt/gentoo/lib/modules</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Удостоверьтесь в том, что вы установили hotplug (emerge hotplug) и уже добавили его в загрузку. Чтобы все запущенные сейчас модули (с установочного CD) загружались на вашей машине, запустите следующие команды из среды с измененным корнем (chroot): </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.9: Добавление всех запущенных модулей в файл modules.conf</para>
</entry>
</row>
<row>
<entry>
<para># cat /proc/modules | cut -d ' ' -f 1 &gt;&gt; \</para>
<para>  /etc/modules.autoload.d/kernel-`uname -r | cut -d . -f -2`</para>
<para># modules-update</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/></sect2><sect2><title>3. Упрощение установки</title>
<para/>
<para>Как оставить терминал без присмотра</para>
<para/>
<para>Многим хочется отойти от своей системы, пока она компилируется. Иногда это довольно сложно, поскольку установка производится в месте, где много народу и нельзя доверять всем подряд. На этот случай пригодится возможность проводить компиляцию в фоновом режиме, выйдя изо всех терминалов. </para>
<para/>
<para>Есть несколько возможных путей. Первый — использовать screen. После загрузки с LiveCD, установите пароль для root и запустите сеанс screen: </para>
<para>Примечание: screen есть не на всех LiveCD. Если у вас его нет, придется использовать один из других способов, описанных в этом разделе. </para>
<para/>
<para/>
<para>Листинг 3.1: Запуск сеанса screen</para>
<para># screen -S gentoo</para>
<para/>
<para/>
<para>Из сеанса screen можно хоть провести полную установку. Захотев уйти от терминала, нажмите Ctrl-a, d (то есть control и a одновременно, затем d), чтобы открепить свой сеанс screen. Теперь можно с уверенностью выйти из системы. </para>
<para/>
<para>Чтобы восстановить доступ к терминалу, опять войдите как root и прикрепитесь к запущенному сеансу screen: </para>
<para/>
<para>Листинг 3.2: Прикрепление к сеансу screen</para>
<para># screen -x gentoo</para>
<para/>
<para/>
<para>Если вы не можете использовать screen, есть другой путь отойти от терминала. Следуйте инструкциям по установке, а дойдя до пункта, в котором запускается длительная компиляция (например, шаг с запуском ./scripts/bootstrap.sh), используйте команду nohup, которая позволит процессу продолжиться, даже если вы выйдете. Не забудьте добавить в конце "&amp;", иначе процесс не будет выполняться в фоновом режиме! Запомните, в каком каталоге вы находитесь (команда pwd покажет ее), так как это вам позже понадобится. </para>
<para/>
<para/>
<para/>
<para/>
<para/>
<para>Листинг 3.3: Использование nohup</para>
<para># pwd</para>
<para>/usr/portage</para>
<para># nohup ./scripts/bootstrap.sh &amp;</para>
<para/>
<para/>
<para>Теперь выйдите из среды измененного корня (exit) и из сеанса загрузочного CD. Компиляция продолжится в фоновом режиме. </para>
<para/>
<para>Захотев проверить компиляцию, войдите как root (на установочный CD) и сделайте chroot обратно в свою среду, затем перейдите в оставленный каталог: </para>
<para/>
<para/>
<para/>
<para>Листинг 3.4: Chroot обратно</para>
<para># chroot /mnt/gentoo /bin/bash</para>
<para># env-update &amp;&amp; source /etc/profile</para>
<para># cd /usr/portage</para>
<para/>
<para/>
<para>Теперь запустите команду less на файле nohup.out, расположенном внутри каталога. Компиляция добавляет свои сообщения в этот файл, так что при желании следить за ней запустите less nohup.out и нажмите F, чтобы наблюдать за ее ходом. Когда компиляция закончится, можно приступать к следующему пункту указаний по установке. </para>
<para/>
<para>Если вам надоело следить за изменениями, нажмите Ctrl-C, затем q. Это остановит только процесс less, не затрагивая процесс компиляции. </para>
<para/></sect2><sect2><title>4. Решение ошибок/проблем</title>
<para/>
<para>Тщательное тестирование дисков</para>
<para/>
<para>Если вы считаете, что необходимо тщательно проверить ваш диск на предмет целостности (неисправные секторы и т.д.), можете включить параметр -c при создании на нем файловой системы ext2 или ext3 (используя mke2fs). Это запустит проверку на чтение, которая пометит все неисправные блоки. Если вы настоящий параноик, можете включить -c -c, чтобы провести детальный тест на чтение/запись. </para>
<para/>
<para>Листинг 4.1: Проверка целостности диска</para>
<para># mke2fs -j -c /dev/hda3</para>
<para/>
<para/><sect3><title>Восстановление сбойной установки</title>
<para/>
<para>Если по какой-то причине ваша установка Gentoo дает сбой, вам не придется повторять ее раз за разом с самого начала. Вместо этого можно спокойно вернуться к моменту, в который вы, как вам кажется, ошиблись (или где, как вы считаете, есть ошибка в инструкции), и попробовать другой подход. </para>
<para/>
<para>Прежде всего, вам потребуется перейти обратно в свою среду Gentoo Linux командой chroot. Снова следуйте указаниям, пропуская шаги по разбивке диска, так как ваши разделы уже созданы и даже заполнены. Таким образом, вы можете сразу монтировать эти разделы в /mnt/gentoo. Следует также пропустить шаги, связанные с извлечением файла стадии и изменением make.conf — вы же не хотите перезаписывать существующие файлы, не так ли? </para>
<para/>
<para>Изменив корень на свою среду Gentoo Linux, сразу переходите к шагу, где, как вам кажется, следует попробовать действовать по-другому. Не повторяйте все шаги, такие как самогенерация, если не считаете, что именно там что-то пошло не так. </para>
<para/>
<para>Например, если вы считаете, что неверно настроили grub.conf, можно сразу запустить свой редактор, чтобы изменить /boot/grub/grub.conf. </para>
<para/>
<para>Попробовав другой подход в своей ситуации, вы, скорее всего, сможете представить, сколько последующих шагов потребуется выполнить снова. Если последующие действия зависели от вашего изменения, их потребуется повторить. </para>
<para/>
<para>Например: </para>
<para>изменив переменную в make.conf, вам потребуется выполнить всю последующую компиляцию, поскольку ее результаты зависят от настройки make.conf </para>
<para>изменив /boot/grub/grub.conf, можно сразу выходить из среды измененного корня и перезагружаться, так как никакие последующие шаги не зависят от grub.conf </para>
<para>перекомпилировав свое ядро, вам нужно лишь убедиться, что конфигурация вашего начального загрузчика указывает на верный образ ядра (убедитесь, что вы смонтировали свой /boot!), затем можно выйти из среды измененного корня и перезагрузиться </para>
<para>изменив /etc/fstab, можно выходить из среды измененного корня и перезагружаться </para>
<para/>
<para>Как видите, после большинства действий по восстановлению можно сразу перезагружаться. Лишь изредка вам потребуется повторять последующие шаги установки.</para>
<para/>
<para/>
<para/></sect3></sect2></sect1><sect1><title>Шпаргалка по установке Gentoo</title>
<para>Ссылка на оригинал: <ulink url="http://ru.gentoo-wiki.com/Шпаргалка_по_установке_Gentoo">http://ru.gentoo-wiki.com</ulink>
</para>
<para>Автор: Molin </para>
<para>С версии: 1.4</para>
<para/><sect2><title>Описание </title>
<para>Данное руководство является шпаргалкой по настройке Gentoo для тех, кого утомляет чтение <link linkend="">Настольной книги.</link>
</para></sect2><sect2><title>Подготовка к установке </title>
<para>Перед установкой необходимо иметь: </para>
<orderedlist>
<listitem>
<para>не слишком старый компьютер; </para>
</listitem>
<listitem>
<para>широкополосный доступ в интернет; </para>
</listitem>
<listitem>
<para>много времени и терпения. </para>
</listitem>
</orderedlist>
<para>Прежде чем приступить к установке, следует загрузить на компьютер какую-либо готовую систему... </para>
<para>...при единственном жёстком дискеВзять любой LiveCD с дистрибутивом Linux, поддерживающий настройку сети:</para>
<orderedlist>
<listitem>
<para>
<ulink url="http://distro.ibiblio.org/pub/linux/distributions/gentoo/releases/x86/2007.0/installcd/">Gentoo 2007.0 InstallCD</ulink> </para>
</listitem>
<listitem>
<para>
<ulink url="http://www.mandriva.com/en/download/free">Mandriva Linux One 2008</ulink> </para>
</listitem>
<listitem>
<para>
<ulink url="http://sourceforge.net/project/showfiles.php?group_id=55396&amp;release_id=123430">Cool Linux CD</ulink> </para>
</listitem>
<listitem>
<para>
<ulink url="http://wiki.debian.org/DebianLive/Download">Debian Live</ulink> </para>
</listitem>
</orderedlist>
<para>Сделать загрузочный CD (DVD, USB-drive), загрузиться, поднять сеть согласно документации к выбранному дистрибутиву. </para>
<para>...при установке на второй жёсткий диск с работающей системыВключить компьютер и убедиться в работающем интернете. Условимся, что Gentoo будет устанавливаться на устройство /dev/sda. </para></sect2><sect2><title>Порядок основных действий и команд </title><sect3><title>Разбиение диска </title>
<para>1. Разметка# fdisk /dev/sda</para>
<para>ВАЖНО: Требует дополнительных действий (См. "Логику разметки диска") </para>
<para>2. Форматирование разделов# mkfs -t &lt;тип_ФС&gt; /dev/sda&lt;номер_раздела&gt;и т.д. </para></sect3><sect3><title>Установка базовой системы </title>
<para>3. Монтирование разделов# mount /dev/sda&lt;номер_раздела&gt; /mnt/gentoo/&lt;путь&gt;и т.д. </para>
<para>4. Переход в каталог gentoo# cd /mnt/gentoo </para>
<para>5. Скачивание архива стадии# wget &lt;сервер&gt;/gentoo/releases/&lt;архитектура&gt;/current/stages/stage3-&lt;архитектура&gt;-2007.0.tar.bz2 </para>
<para>6. Скачивание снимка дерева портежей# wget &lt;сервер&gt;/gentoo/snapshots/portage-latest.tar.bz2 </para>
<para>7. Распаковка архива стадии# tar xvjpf stage3-i686-2007.0.tar.bz2 </para>
<para>8. Распаковка снимка дерева портежей# tar xvjf /mnt/gentoo/portage-latest.tar.bz2 -C /mnt/gentoo/usr </para>
<para/></sect3><sect3><title>Файлы настройки </title>
<para>9. Правка одного из основных файлов Gentoo</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /mnt/gentoo/etc/make.conf </para>
</entry>
</row>
<row>
<entry>
<para># За подробностями см. make.conf.example</para>
<para>CFLAGS="-O&lt;уровень_оптимизации&gt; -march=&lt;тип_ЦПУ&gt; -pipe"</para>
<para>CXXFLAGS="${CFLAGS}"</para>
<para/>
<para># Не изменять</para>
<para>CHOST="&lt;архитектура&gt;"</para>
<para/>
<para>MAKEOPTS="-j&lt;кол-во_процессоров+1&gt;"</para>
<para>GENTOO_MIRRORS="http://distro.ibiblio.org/pub/linux/distributions/gentoo/ "</para>
<para>SYNC="rsync://rsync.gentoo.org/gentoo-portage"</para>
<para/>
<para># Для поддержки мыши и клавиатуры в Xorg</para>
<para>INPUT_DEVICES="keyboard mouse"</para>
<para># Для поддержки видеокарты в Xorg</para>
<para>VIDEO_CARDS="&lt;название_драйвера&gt;"</para>
<para/>
<para># См. /mnt/gentoo/usr/portage/profiles/use.desc</para>
<para># См. /mnt/gentoo/usr/portage/profiles/use.local.desc</para>
<para>USE="&lt;флаги&gt;"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>10. Настройка DNS</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /mnt/gentoo/etc/resolv.conf </para>
</entry>
</row>
<row>
<entry>
<para>nameserver &lt;IP_сервера_DNS&gt;</para>
<para>nameserver &lt;IP_ещё_одного_сервера_DNS&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Или просто скопировать текущую информацию о DNS-серверах# cp -L /etc/resolv.conf /mnt/gentoo/etc/resolv.conf </para>
<para>11. Информация о файловых системах</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /mnt/gentoo/etc/fstab </para>
</entry>
</row>
<row>
<entry>
<para>/dev/sda1                /          &lt;файловая_система&gt;  defaults    0 1</para>
<para>/dev/sda&lt;номер_раздела&gt;  none       swap                sw          0 2</para>
<para>/dev/sda&lt;номер_раздела&gt;  &lt;каталог&gt;  &lt;файловая_система&gt;  defaults    0 2</para>
<para>proc                     /proc      proc                defaults    0 0</para>
<para/>
<para># Если /tmp нужен в ОЗУ</para>
<para>none                     /tmp       tmpfs               defaults    0 0</para>
<para/>
<para># Если CD/DVD монтируется вручную</para>
<para># Указанное для mod значение снимает флаг исполнения с файлов на CD/DVD</para>
<para>/dev/hd&lt;X&gt; /mnt/cdrom   auto user,ro,noauto,uid=1000,gid=1000,mode=100644  0 0</para>
<para/>
<para># Если планируется использование DVD-RAM</para>
<para>/dev/hd&lt;X&gt; /mnt/dvdram  auto user,rw,noauto   0 0</para>
<para/>
<para># Если флоппи кому-то ещё нужен</para>
<para>/dev/fd0   /mnt/floppy  auto user,iocharset=cp1251,noauto,rw,noexec,showexec  0 0</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>12. Имя машины</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /mnt/gentoo/etc/conf.d/hostname </para>
</entry>
</row>
<row>
<entry>
<para>HOSTNAME="&lt;название_хоста&gt;"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>13. Настройка сетевых параметров</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /mnt/gentoo/etc/conf.d/net </para>
</entry>
</row>
<row>
<entry>
<para># Задать параметры вручную...</para>
<para>config_eth0=( " 192.168.0.1 netmask 255.255.255.0 broadcast 192.168.0.255" )</para>
<para>routes_eth0=( "default gw 192.168.0.1" )</para>
<para/>
<para># ...или получить их автоматически</para>
<para>config_eth0=( "dhcp" )</para>
<para>dhcp_eth0="nodns nontp nonis"</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3><sect3><title>Оживление Gentoo </title>
<para>14. Монтирование /proc# mount -t proc none /mnt/gentoo/proc </para>
<para>15. Монтирование /dev# mount -o bind /dev /mnt/gentoo/dev </para>
<para>16. Смена корневого каталога# chroot /mnt/gentoo /bin/bash </para>
<para>ВАЖНО: Дальнейшие команды будут выполняться в среде Gentoo </para>
<para>17. Обновление переменных среды# env-update# source /etc/profile </para>
<para>18. Смена приглашения командной строки# export PS1="(chroot) $PS1" </para>
<para/></sect3><sect3><title>Сборка ядра </title>
<para>19. Обновление дерева портежей# emerge --syncили# emerge-webrsync </para>
<para>20. Установка исходных кодов ядра Gentoo# USE="-doc symlink" emerge gentoo-sources </para>
<para>21. Настройка ядра Gentoo# cd /usr/src/linux# make menuconfig </para>
<para>ВАЖНО: Требует дополнительных действий (См. "Логика настройки ядра") </para>
<para>22. Компиляция ядра# make &amp;&amp; make modules_install </para>
<para>23. Установка ядра# cp arch/i386/boot/bzImage /boot/linux-&lt;архитектура&gt;-gentoo </para>
<para/></sect3><sect3><title>Прочие системные установки </title>
<para>24. Сетевое подключение при загрузке системы# rc-update add net.eth0 default </para>
<para>25. Пароль суперпользователя# passwd </para>
<para>26. Система журналирования# emerge syslog-ng# rc-update add syslog-ng default </para>
<para>27. Периодические задания (по необходимости)# emerge vixie-cron# rc-update add vixie-cron default </para>
<para>28. Установка клиента DHCP (по необходимости)# emerge dhcpcd </para>
<para>29. Установка клиента PPPoE (по необходимости)# USE="-X" emerge rp-pppoe </para>
<para/></sect3><sect3><title>Настройка загрузчика </title>
<para>30. Установка загрузчика LILO# emerge lilo </para>
<para>31. Настройка LILO</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/lilo.conf </para>
</entry>
</row>
<row>
<entry>
<para>boot=/dev/sda</para>
<para>prompt</para>
<para>timeout=200</para>
<para>default=gentoo</para>
<para/>
<para>image=/boot/linux-&lt;архитектура&gt;-gentoo</para>
<para> label=gentoo</para>
<para> read-only </para>
<para> root=/dev/sda&lt;X&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>32. Записать LILO# /sbin/lilo </para>
<para/></sect3><sect3><title>Локализация в UNICODE </title>
<para>33. Установка шрифтов# emerge terminus-font intlfonts freefonts cronyx-fonts corefonts artwiz-fonts kbd </para>
<para>34. Включение нужных локалей</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/locale.gen </para>
</entry>
</row>
<row>
<entry>
<para>en_US ISO-8859-1</para>
<para>en_US.UTF-8 UTF-8</para>
<para>ru_RU.CP1251 CP1251</para>
<para>ru_RU.KOI8-R KOI8-R</para>
<para>ru_RU.UTF-8 UTF-8</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>35. Пересборка glibc# emerge -av glibc </para>
<para>36. Сборка локали# locale-gen </para>
<para>37. Переменные окружения</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/env.d/02locale </para>
</entry>
</row>
<row>
<entry>
<para>LC_ALL=""</para>
<para>LANG="ru_RU.UTF-8"</para>
<para>LC_NUMERIC="C"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>38. Файл rc.conf</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/rc.conf </para>
</entry>
</row>
<row>
<entry>
<para>UNICODE="yes"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>39. Шрифт консоли</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/conf.d/consolefont </para>
</entry>
</row>
<row>
<entry>
<para>CONSOLEFONT="Cyr_a8x16"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>40. Карта</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/conf.d/keymaps </para>
</entry>
</row>
<row>
<entry>
<para>KEYMAP="-u ru4"</para>
<para>SET_WINDOWKEYS="yes"</para>
<para>EXTENDED_KEYMAPS=""</para>
<para>DUMPKEYS_CHARSET="koi8-r"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/></sect3><sect3><title>Загрузка Gentoo </title>
<para>41. Выход из окружения Gentoo# exit </para>
<para>42. Размонтирование разделов# cd /# umount /mnt/gentoo/&lt;путь&gt;и т.д. </para>
<para>43. Перезагрузка# reboot </para>
<para>Базовая установка Gentoo завершена!За более тонкой настройкой системы см. документацию. </para>
<para/></sect3></sect2><sect2><title>Вспомогательная информация </title><sect3><title>Логика разметки диска </title>
<informaltable frame="all">
<tgroup cols="5"><tbody>
<row>
<entry>
<para>Раздел </para>
</entry>
<entry>
<para>Каталог </para>
</entry>
<entry>
<para>Размер </para>
</entry>
<entry>
<para>Размещение </para>
</entry>
<entry>
<para>Файловая система </para>
</entry>
</row>
<row>
<entry>
<para>Загрузчик </para>
</entry>
<entry>
<para>/boot </para>
</entry>
<entry>
<para>~30Мб </para>
</entry>
<entry>
<para>в начале диска </para>
</entry>
<entry>
<para>ext2, ext3, ReiserFS </para>
</entry>
</row>
<row>
<entry>
<para>Своп </para>
</entry>
<entry>
<para>нет </para>
</entry>
<entry>
<para>100-200% от объёма ОЗУ </para>
</entry>
<entry>
<para>начало диска, но при достаточном объёме ОЗУ и/или работе с не ресурсоёмкими приложениями может не создаваться </para>
</entry>
<entry>
<para>Без ФС (swap-область) </para>
</entry>
</row>
<row>
<entry>
<para>Основные системные файлы </para>
</entry>
<entry>
<para>/bin, /etc, /lib, /sbin и /sys </para>
</entry>
<entry>
<para>0,1-0,5Гб </para>
</entry>
<entry>
<para>ближе к началу диска </para>
</entry>
<entry>
<para>ext2, ext3, ReiserFS, XFS </para>
</entry>
</row>
<row>
<entry>
<para>Изменяемые данные </para>
</entry>
<entry>
<para>/var </para>
</entry>
<entry>
<para>Обычно от 0,5Гб, но для Gentoo -- 2-4Гб, т.к. сборка из portage требует много места под временные файлы на /var/tmp </para>
</entry>
<entry>
<para>ближе к началу диска </para>
</entry>
<entry>
<para>ext3, ReiserFS, XFS </para>
</entry>
</row>
<row>
<entry>
<para>Временные файлы </para>
</entry>
<entry>
<para>/tmp </para>
</entry>
<entry>
<para>0,5-2Гб (некоторые программы требуют много места) </para>
</entry>
<entry>
<para>ближе к началу диска, но раздел может быть создан и в ОЗУ </para>
</entry>
<entry>
<para>ext2, JFS, XFS tmpfs </para>
</entry>
</row>
<row>
<entry>
<para>Прикладное ПО </para>
</entry>
<entry>
<para>/usr </para>
</entry>
<entry>
<para>1-10Гб (зависит от задач) </para>
</entry>
<entry>
<para>середина или конец диска </para>
</entry>
<entry>
<para>ext2, ReiserFS, XFS ,JFS </para>
</entry>
</row>
<row>
<entry>
<para>Несвободное ПО </para>
</entry>
<entry>
<para>/opt </para>
</entry>
<entry>
<para>от 0,1Гб (в основном для игр и узкоспециализированного ПО) </para>
</entry>
<entry>
<para>середина или конец диска </para>
</entry>
<entry>
<para>ext2, ReiserFS, XFS, JFS </para>
</entry>
</row>
<row>
<entry>
<para>Данные пользователей </para>
</entry>
<entry>
<para>/home </para>
</entry>
<entry>
<para>зависит от задач </para>
</entry>
<entry>
<para>конец диска </para>
</entry>
<entry>
<para>ext3, ReiserFS, XFS, JFS </para>
</entry>
</row>
<row>
<entry>
<para>Данные для чтения из ОС Windows </para>
</entry>
<entry>
<para>/mnt/fat, /mnt/win или т.п. </para>
</entry>
<entry>
<para>зависит от задач </para>
</entry>
<entry>
<para>конец диска </para>
</entry>
<entry>
<para>FAT32 </para>
</entry>
</row>
<row>
<entry>
<para>ОС Windows </para>
</entry>
<entry>
<para>нет </para>
</entry>
<entry>
<para>зависит от задач </para>
</entry>
<entry>
<para>зависит от задач </para>
</entry>
<entry>
<para>NTFS </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/></sect3><sect3><title>Логика настройки ядра </title>
<para>По умолчанию многие необходимые опции уже включены. </para>
<para>Выбор семейства ЦПУ </para>
<para>Processor type and features ---&gt;</para>
<para> Processor family (выбрать ЦПУ) ---&gt;</para>
<para>Поддержка паравиртуализации </para>
<para>Processor type and features ---&gt;</para>
<para>  [*] Paravirtualization support (EXPERIMENTAL)</para>
<para>Поддержка виртуальной машины ядра (KVM) </para>
<para>Device Drivers ---&gt;</para>
<para> Virtualization  ---&gt;</para>
<para>   &lt;*&gt; Kernel-based Virtual Machine (KVM) support</para>
<para>Поддержка дисков SATA </para>
<para>Device Drivers ---&gt;</para>
<para> &lt;*&gt; Serial ATA (prod) and Parallel ATA (experimental) drivers  ---&gt;</para>
<para>   &lt;*&gt;   AHCI SATA support</para>
<para>   выбрать нужный SATA драйвер</para>
<para>Поддержка PPP </para>
<para>Device Drivers ---&gt;</para>
<para> Networking device support ---&gt;</para>
<para>   &lt;*&gt; PPP (point-to-point protocol) support</para>
<para>   &lt;*&gt;   PPP support for async serial ports</para>
<para>   &lt;*&gt;   PPP support for sync tty ports</para>
<para>Поддержка интерфейса PCI-Express </para>
<para>Bus options (PCI, PCMCIA, EISA, MCA, ISA)  ---&gt; </para>
<para> [*]   PCI Express support</para>
<para>Поддержка DRM </para>
<para>Device Drivers ---&gt;</para>
<para> Character devices  ---&gt;</para>
<para>  &lt;*&gt; Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)</para>
<para>Поддержка фреймбуфера </para>
<para>Device Drivers ---&gt;</para>
<para> Graphics support  ---&gt;</para>
<para>  &lt;*&gt; Support for frame buffer devices </para>
<para>  выбрать необходимый драйвер</para>
<para>Поддержка звука (ALSA) </para>
<para>Device Drivers ---&gt;</para>
<para> Sound  ---&gt;</para>
<para>  Advanced Linux Sound Architecture  ---&gt;</para>
<para>   &lt;*&gt; Advanced Linux Sound Architecture</para>
<para>   &lt;*&gt;   OSS Mixer API</para>
<para>   &lt;*&gt;   OSS PCM (digital audio) API</para>
<para>   [*]   Verbose procfs contents</para>
<para>Поддержка файловых систем </para>
<para>File systems ---&gt;</para>
<para>  выбрать необходимое</para></sect3></sect2></sect1><sect1><title>Настольная книга Gentoo Linux x86</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/handbook/handbook-x86.xml">http://www.gentoo.org/doc/ru/handbook/handbook-x86.xml</ulink>
</para>
<para>С версии: 1.0</para>
<para/>
<para>Содержание:</para>
<para/>
<para>Установка Gentoo</para>
<para>Из этой части вы узнаете, как устанавливать Gentoo на свою систему. </para>
<para/>
<para>Об установке Gentoo Linux</para>
<para>В этой главе дается общее представление о предлагаемом порядке установки. </para>
<para/>
<para/>
<para>Выбор подходящего источника для установки</para>
<para>Gentoo можно устанавливать по-разному. Здесь описывается, как установить Gentoo с минимального установочного диска. Способ подходит и для установки с универсального установочного диска. </para>
<para/>
<para>Настройка сети</para>
<para>Чтобы загрузить новейший исходный код, потребуется настройка сети. Здесь описывается порядок ее выполнения. </para>
<para/>
<para>Подготовка дисков</para>
<para>Чтобы установить Gentoo, нужно создать подходящие дисковые разделы. В этой главе описывается, как разбить диск для будущего использования. </para>
<para/>
<para>Установка установочных файлов Gentoo</para>
<para>Установка Gentoo выполняется с помощью архива третьей стадии (stage3). В этой главе мы расскажем, как извлечь файл третьей стадии и настроить Portage. </para>
<para/>
<para>Установка базовой системы Gentoo</para>
<para>После установки и настройки третьей стадии в вашем распоряжении оказывается базовая система Gentoo. Здесь описывается, как этого достичь. </para>
<para/>
<para>Настройка ядра</para>
<para>Ядро Linux — сердце каждого дистрибутива. В этой главе описывается, как его настроить. </para>
<para/>
<para>Настройка параметров системы</para>
<para>Вам потребуется отредактировать несколько важных конфигурационных файлов. Из этой главы вы получите представление об этих файлах и поймете, как с ними обращаться. </para>
<para/>
<para>Установка нужных системных средств</para>
<para>Как отмечено ранее, Gentoo — это богатство выбора. В этой главе мы поможем вам выбрать и установить некоторые важные инструменты. </para>
<para/>
<para>Настройка начального загрузчика</para>
<para>Для архитектуры x86 существует несколько загрузчиков. Каждый из них настраивается по-своему. В этой главе мы шаг за шагом объясним вам порядок настройки начального загрузчика для ваших нужд. </para>
<para/>
<para>Завершение установки Gentoo</para>
<para>Установка почти закончена. Осталось создать одну (или несколько) учетных записей для пользователей вашей системы. Как это делается, описано в данной главе. </para>
<para/>
<para>Чем заняться дальше?</para>
<para>Теперь у вас появилась собственная система Gentoo. Но чем же заняться дальше? </para>
<para/>
<para>Работа с Gentoo</para>
<para>Здесь вы научитесь работать с Gentoo: устанавливать программное обеспечение, изменять значения переменных, управлять поведением Portage и т.д. </para>
<para/>
<para>Введение в Portage</para>
<para>В этой главе описываются «простые» шаги, которые вам точно потребуется знать для поддержания в порядке и обслуживания программного обеспечения. </para>
<para/>
<para>USE-флаги</para>
<para>USE-флаги (признаки использования) — очень важный аспект Gentoo. Прочитав эту главу, вы научитесь обращаться с ними и разберетесь, как USE-флаги влияют на систему. </para>
<para/>
<para>Возможности Portage</para>
<para/>
<para>Откройте для себя дополнительные возможности Portage: поддержку распределенной компиляции, кэш компилятора и др. </para>
<para/>
<para>Сценарии инициализации</para>
<para>В Gentoo используется специальный формат сценариев инициализации (initscript), в котором, например, предусмотрены решения, управляемые зависимостями, и виртуальные сценарии. Здесь описываются эти аспекты, и объясняется, как обращаться со сценариями. </para>
<para/>
<para>Переменные среды</para>
<para>В Gentoo можно довольно легко управлять системными переменными среды. В этой главе объясняется, как это делать, и описываются часто используемые переменные.</para>
<para> </para>
<para>Работа с Portage</para>
<para>В этой части подробно описывается Portage, средство управления программным обеспечением Gentoo.</para>
<para> </para>
<para>Файлы и каталоги</para>
<para>Чтобы поближе познакомиться с Portage, вам потребуется узнать, где же хранятся его файлы и данные. </para>
<para/>
<para>Настройка с помощью переменных</para>
<para>Portage полностью настраивается с помощью различных переменных, которые устанавливаются в конфигурационном файле или как переменные среды. </para>
<para/>
<para>Смешение ветвей программного обеспечения</para>
<para>Программное обеспечение в составе Gentoo подразделяется на ветви в зависимости от стабильности и поддержки различных архитектур. В этой главе рассказывается, как настраивать использование ветвей, а также как при необходимости преодолевать такое разделение. </para>
<para/>
<para>Дополнительные средства Portage</para>
<para>В состав Portage входит несколько дополнительных инструментов, которые могут значительно улучшить ваше впечатление от Gentoo. В этой главе раскрываются секреты использования dispatch-conf и других инструментов. </para>
<para/>
<para>Отступление от официального дерева</para>
<para>Здесь даются советы и показываются приемы «выращивания» собственного дерева Portage, рассказывается о том, как синхронизировать только нужные категории, добавлять свои пакеты и т.д. </para>
<para/>
<para>Использование ebuild</para>
<para>В этой главе рассказывается о шагах, выполняемых Portage при установке программного обеспечения, и об их самостоятельном выполнении с помощью утилиты ebuild. </para>
<para/>
<para/>
<para>Настройка сети в Gentoo</para>
<para>Полное руководство по сетям в Gentoo.</para>
<para/>
<para>Начальная настройка</para>
<para>Руководство по быстрому запуску и подключению сетевого интерфейса в наиболее распространенных случаях. </para>
<para/>
<para>Расширенная настройка</para>
<para>Здесь вы изучите, как работает конфигурация — это нужно сделать перед изучением модульного построения сети. </para>
<para/>
<para>Модульное построение сети</para>
<para>В Gentoo предусмотрены гибкие сетевые средства: здесь рассказывается о выборе различных клиентов DHCP, настройке объединения, образования мостов, виртуальных сетей (VLAN) и т.п. </para>
<para/>
<para>Беспроводная сеть</para>
<para>Настроить беспроводную сеть не совсем просто. Надеемся, мы поможем вам заставить ее работать. </para>
<para/>
<para>Дополнительные возможности</para>
<para>Если вы ищете приключений, можете подключить к сети свои собственные функции. </para>
<para>Управление сетью</para>
<para>Для пользователей ноутбуков и тех, кто перемещает свои компьютеры из сети в сеть. </para>
<para/>
<para/><sect2><title>A. Установка  Gentoo</title></sect2><sect2><title>1. Об установке Gentoo Linux</title>
<para/><sect3><title>1.a. Введение</title>
<para/>
<para>Добро пожаловать!</para>
<para/>
<para>Прежде всего, добро пожаловать в Gentoo! Вы — на пороге мира больших возможностей и высокой производительности! Gentoo весь пропитан идеей свободы выбора. При установке Gentoo вы не раз убедитесь в этом: вам предстоит выбрать объем самостоятельной компиляции, способ установки Gentoo, службу журналирования системы и т.д. </para>
<para/>
<para>Gentoo — быстрый современный метадистрибутив, обладающий большой чистотой и гибкостью. Gentoo основан на свободном программном обеспечении, и не скрывает от пользователя, «что под капотом». Portage, система управления пакетами Gentoo, написана на языке Python, что позволяет легко просматривать и изменять ее исходный код. Сборка Gentoo также выполняется из исходных текстов (хотя есть и поддержка бинарных пакетов), а настройка Gentoo выполняется с помощью обычных текстовых файлов. Другими словами — сплошная открытость и свобода! </para>
<para/>
<para>Важно понимать, что Gentoo развивается именно благодаря свободе выбора. Мы стараемся ничего вам не навязывать. А если вам покажется обратное — пожалуйста, сообщите нам об этой оплошности. </para>
<para/>
<para>Как организована установка?</para>
<para/>
<para>Установка Gentoo рассматривается как последовательность из 10 шагов, которым соответствуют главы 2—11. Каждый шаг приводит к определенному состоянию: </para>
<orderedlist>
<listitem>
<para>результат шага 1: вы — в рабочей среде, готовой к установке Gentoo; </para>
</listitem>
<listitem>
<para>результат шага 2: ваше подключение к интернету готово для установки Gentoo; </para>
</listitem>
<listitem>
<para>результат шага 3: ваши жесткие диски готовы стать родным домом для Gentoo;</para>
</listitem>
<listitem>
<para>результат шага 4: подготовлена установочная среда, и вы готовы переключиться (chroot) в новую среду; </para>
</listitem>
<listitem>
<para>результат шага 5: развернуты пакеты ядра, общие для всех систем Gentoo; </para>
</listitem>
<listitem>
<para>результат шага 6: вы скомпилировали собственное ядро Linux; </para>
</listitem>
<listitem>
<para>результат шага 7: вы написали большую часть конфигурационных файлов системы Gentoo; </para>
</listitem>
<listitem>
<para>результат шага 8: установлены необходимые системные средства (которые вы сами выбрали из славного списка); </para>
</listitem>
<listitem>
<para>результат шага 9: установлен и настроен избранный загрузчик ОС, и вы вошли в новую систему Gentoo; </para>
</listitem>
<listitem>
<para>результат шага 10: вы можете начинать изучение своей собственной среды Gentoo Linux! </para>
</listitem>
</orderedlist>
<para/>
<para>Мы приложили все усилия, чтобы объяснить вам все «за» и «против» каждого варианта, когда вам предоставляется возможность выбора. При этом один из вариантов помечен как «По умолчанию: ». Другие варианты помечены как «Альтернатива: ». Не подумайте, что вариант по умолчанию — наша рекомендация. Нам просто кажется, что именно его выбирает большинство пользователей. </para>
<para/>
<para>Иногда есть возможность выполнить необязательный шаг. Такие шаги помечены как «Дополнительно: », и не требуются для установки Gentoo. Однако, некоторые из них будут обусловлены вашими предшествующими решениями. Мы будем сообщать об этом, как в момент выбора, так и непосредственно перед описанием необязательных шагов. </para>
<para/>
<para>Какие варианты установки существуют?</para>
<para/>
<para>Gentoo можно установить разными способами. Можно скачать и запустить один из установочных компакт-дисков, установить с имеющегося дистрибутива, с загрузочного CD (например, Knoppix), из сетевой загрузочной среды, с дискеты аварийного восстановления и т.д. </para>
<para/>
<para>В этом руководстве описывается установка с установочных дисков Gentoo, и, в некоторых случаях, с помощью сетевой загрузки (netboot). Предполагается, что вы собираетесь устанавливать самые свежие версии пакетов. Если вам нужна установка, при которой не требуется использование сети, обратитесь к настольным книгам Gentoo 2006.1 (англ.), где даются указания по установке в бессетевой среде. </para>
<para/>
<para>Если вы планируете использовать GRP (Gentoo Reference Platform — эталонная платформа Gentoo, набор бинарных пакетов, предназначенных для немедленного использования сразу после установки Gentoo), вам необходимо следовать инструкциям, приведенных в настольной книге Gentoo 2006.1 (англ.). </para>
<para/>
<para>Чтобы получить сведения о других способах установки, прочитайте описание альтернативных способов установки. Также рекомендуется прочитать полезные советы по установке Gentoo. Если вы почувствуете, что приведенные указания по установке слишком подробны, обратитесь к краткому руководству по установке (см. перечень документации), если, конечно, такое существует для вашей архитектуры. </para>
<para/>
<para>Кроме того, вы можете выбрать между компиляцией своей системы полностью «с нуля» или установкой заранее собранной среды, позволяющей запустить Gentoo практически моментально. Естественно, есть и промежуточные варианты, в которых вы не компилируете все подряд, а начинаете с полу готовой системы. </para>
<para/>
<para>Появились затруднения?</para>
<para/>
<para>Если при установке вы столкнулись с проблемой (или с ошибкой в документации по установке), войдите в нашу систему распределения запросов (англ.) и убедитесь, что такая ошибка еще не заявлена. В этом случае, создайте отчет об ошибке, чтобы мы о ней позаботились. Не бойтесь разработчиков, которым выпадает работа над (вашими) ошибками — людей они обычно не едят. </para>
<para/>
<para>Обратите внимание, что, хотя руководство, которое вы сейчас читаете, посвящено определенной архитектуре, в нем упоминаются и другие архитектуры. Это связано с тем, что значительная часть текста настольной книги Gentoo является общей для всех архитектур (чтобы не дублировать работу, а также из-за острой нехватки разработчиков). Во избежание путаницы, мы стараемся сократить такие упоминания до минимума. </para>
<para/>
<para>Если вы не уверены, пользовательская ли у вас ошибка (какую-то ошибку совершили вы, хотя внимательно прочитали документацию), или программная (какую-то ошибку совершили мы, хотя тщательно тестировали установку/документацию), то не стесняясь, заходите на канал #gentoo (а также #gentoo-amd64, #gentoo-ru, #rugentoo) сервера irc.freenode.net. Разумеется, мы в любом случае будем вам рады :) </para>
<para/>
<para>Если у вас есть вопрос, касающийся Gentoo, сначала загляните в список распространенных вопросов (FAQ), входящий в состав документации Gentoo. Можно также обратиться к FAQ (англ.) в наших форумах. Если вы не найдете там ответа, задайте вопрос на #gentoo, нашем IRC-канале на irc.freenode.net. Да-да, кое-кто из нас — маньяки, висящие на IRC :-) </para>
<para/></sect3></sect2><sect2><title>2. Выбор подходящего источника для установки</title>
<para/><sect3><title>2.a. Аппаратные требования</title>
<para/>
<para>Введение</para>
<para/>
<para>Прежде чем начать, перечислим аппаратные требования, необходимые для успешной установки Gentoo на вашем компьютере. </para>
<para/>
<para>Аппаратные требования:</para>
<orderedlist>
<listitem>
<para>Центральный процессор        i486 или новее;</para>
</listitem>
<listitem>
<para>Память 64 МБ;</para>
</listitem>
<listitem>
<para>Дисковое пространство 1.5 ГБ (исключая пространство подкачки);</para>
</listitem>
<listitem>
<para>Пространство подкачки не менее 256 МБ.</para>
</listitem>
</orderedlist>
<para/>
<para/></sect3><sect3><title>2.b. Установочные компакт-диски Gentoo</title>
<para/>
<para>Введение</para>
<para/>
<para>Установочные компакт-диски Gentoo — это загрузочные диски, содержащие самодостаточную среду Gentoo. Они позволяют загружать Linux прямо с компакт-диска. При запуске определяются ваши устройства и загружаются соответствующие драйверы. Эти диски сопровождаются разработчиками Gentoo. </para>
<para/>
<para>Все установочные компакт-диски позволяют загрузиться, настроить сеть, разметить разделы жесткого диска и начать установку Gentoo из интернета. В настоящее время мы выпускаем два установочных компакт-диска, одинаково подходящих для установки Gentoo с загрузкой последних версий существующих пакетов из интернета. </para>
<para/>
<para>Если вы хотите установить Gentoo без работоспособного соединения с интернетом, или желаете использовать одну из существующих программ установки, пожалуйста, следуйте указаниям по установке, приведенным в настольной книге Gentoo 2006.0 (англ.). </para>
<para/>
<para>В настоящее время мы выпускаем два установочных компакт-диска: </para>
<para>Минимальный установочный диск Gentoo, маленький загрузочный компакт-диск без излишеств, единственное назначение которого — загрузить систему, подготовить подключение к сети и перейти к установке Gentoo. </para>
<para>Живой установочный диск Gentoo, содержащий все необходимое для установки Gentoo. На нем есть графическая среда, графическая и консольная программы автоматической установки, и, конечно, указания по установке для вашей архитектуры. </para>
<para/>
<para>Чтобы помочь вам решить, какой из них нужен, мы привели главные преимущества и недостатки каждого диска. </para>
<para/>
<para>Минимальный установочный диск Gentoo</para>
<para/>
<para>Минимальный установочный диск называется install-x86-minimal-2006.0.iso и занимает всего 49 МБ. Gentoo можно устанавливать с этого диска только при постоянном наличии работоспособного подключения к интернету. Минимальный установочный диск:</para>
<para>        </para>
<para>За и против</para>
<para>+        наименьший объем загрузки из сети</para>
<para>–        не содержит ни архива stage3, ни снимков Portage, ни готовых двоичных пакетов, и поэтому не подходит для установки без сети </para>
<para/>
<para/>
<para>Живой (live) установочный диск Gentoo</para>
<para/>
<para>Живой установочный диск называется install-x86-universal-2006.0.iso и занимает 697 МБ. С этого диска вы сможете установить Gentoo даже без исправного подключения к интернету, на случай, если в процессе установки Gentoo на свой компьютер у вас появится неодолимое желание занести его еще и на соседний :) Живой установочный диск Gentoo:        </para>
<para/>
<para>За и против</para>
<para>+        содержит все, что требуется; установку можно выполнять даже без сетевого подключения; </para>
<para>–        огромный объем загрузки.</para>
<para/>
<para/>
<para>Файл Stage3</para>
<para/>
<para>Архив третьей стадии — stage3 — это файл, содержащий минимальную среду Gentoo, пригодную для продолжения установки Gentoo в соответствии с инструкциями, данными в этом руководстве (другими словами: образ (снимок) минимальной системы. </para>
<para>Когда-то в настольной книге Gentoo описывались варианты установки с использованием файла любой из трех существующих стадий создания системы. Несмотря на то, что в Gentoo до сих представлены файлы stage1 и stage2, в официальном способе установки используется архив stage3. Если вас интересует установка Gentoo из файлов stage1 или stage2, пожалуйста, обратитесь к сборнику распространенных вопросов по Gentoo, раздел как установить Gentoo, используя файлы Stage1 или Stage2? </para>
<para/>
<para>Архивы stage3 можно загрузить из releases/x86/2007.0/stages/ или с любого из официальных зеркал Gentoo; на «живом диске» они не поставляются. </para>
<para/></sect3><sect3><title>2.c. Скачивание, запись и загрузка с установочного диска Gentoo</title>
<para/>
<para>Скачивание образа и запись на диск</para>
<para/>
<para>Итак, вы выбрали нужный установочный диск Gentoo. Начнем с загрузки его образа из сети, и его записи на компакт-диск. Ранее обсуждались варианты доступных дисков, но где же их взять? </para>
<para/>
<para>Любой из установочных дисков (а при желании — заодно и диск пакетов, если есть) можно загрузить с одного из наших зеркал. Установочные диски расположены в каталоге releases/x86/2007.0/installcd. </para>
<para/>
<para>В этом каталоге находятся ISO-файлы. Это полные образы компакт-дисков, которые можно записать на CD-R. </para>
<para/>
<para>Если вас волнует, не искажен ли загруженный файл, можно сверить его контрольную сумму MD5 с рассчитанной нами (например, install-x86-minimal-2007.0.iso.DIGESTS). Вычислить контрольную сумму MD5 можно утилитой md5sum в Linux/Unix, или программой md5sum (англ.) для Windows. </para>
<para/>
<para>Другой способ убедиться в пригодности загруженного файла — с помощью GnuPG сверить криптографическую подпись с той, что хранится у нас (в файле с расширением .asc). Скачайте файл подписи, затем получите открытый ключ: </para>
<para/>
<para>Листинг 1: Получение открытого ключа</para>
<para>$ gpg --keyserver subkeys.pgp.net --recv-keys 17072058</para>
<para/>
<para/>
<para>Теперь сверьте подпись: </para>
<para/>
<para>Листинг 2: Сверка криптографической подписи</para>
<para>$ gpg --verify &lt;файл подписи&gt; &lt;скачанный образ диска&gt;</para>
<para/>
<para/>
<para>Записывать загруженный ISO-образ на компакт-диск нужно в «сыром» режиме. Как это сделать, сильно зависит от используемой программы. Здесь мы обсудим запись с помощью cdrecord и K3B. Дополнительные сведения находятся в нашем сборнике распространенных вопросов. </para>
<para>При использовании cdrecord, просто введите cdrecord dev=/dev/hdc &lt;скачанный iso-файл&gt; (/dev/hdc замените на путь к вашему устройству CD-RW). </para>
<para>При использования K3B, выберите Tools &gt; CD &gt; Burn Image (Инструменты &gt; Компакт-диск &gt; Прожечь образ). Затем в области 'Image to Burn' ('Образ для записи') укажите свой ISO-файл. В завершение нажмите Start (Запуск). </para>
<para/>
<para>Загрузка с установочного компакт-диска</para>
<para/>
<para>Важно: Перед тем, как приступить, полностью прочитайте этот подраздел, так как перед последующими действиями вам, скорее всего, больше не представится такая возможность. </para>
<para/>
<para>Записав установочный компакт-диск, пора его загрузить. Уберите все компакт-диски из своих приводов CD, перезагрузите компьютер и войдите в BIOS. В зависимости от BIOS, для этого обычно нужно нажать DEL, F1 или ESC. В BIOS измените порядок загрузки так, чтобы обращение к CD-ROM выполнялось до обращения к жесткому диску. Этот параметр часто задается в разделе «CMOS Setup». Если порядок загрузки не изменить, система просто перезагрузится с жесткого диска, игнорируя CD-ROM. </para>
<para/>
<para>Теперь поместите установочный диск в привод CD-ROM (наконец-то!) и перезагрузитесь. Должно появиться загрузочное приглашение. Здесь можно просто нажать ENTER, чтобы запустить процесс загрузки с параметрами по умолчанию, или загрузить установочный диск по-своему: указать ядро, потом загрузочные параметры, а затем нажать ENTER. </para>
<para/>
<para>Указать ядро? Да, на нашем установочном компакт-диске есть несколько вариантов ядра. По умолчанию используется gentoo. Другие ядра предназначены для специфических аппаратных задач; вариант -nofb отключает кадровый буфер. </para>
<para/>
<para>Ниже перечислены доступные варианты ядра: </para>
<para>Ядро                                 Описание</para>
<para>gentoo          ядро 2.6 с многопроцессорной поддержкой (используется по                                                       умолчанию)</para>
<para>gentoo-nofb          аналогично gentoo, но без поддержки кадрового буфера</para>
<para>memtest86     для выявления ошибок локальной оперативной памяти</para>
<para/>
<para/>
<para>Также можно указать параметры ядра, явно включающие или отключающие определенные режимы. Приведенный список соответствует тому, что выводится при нажатия F2 в экране загрузки. </para>
<para/>
<para>Листинг 3: Параметры, которые можно сообщить выбранному ядру</para>
<para/>
<para>- agpgart               загрузка agpgart (используйте при сбоях графики, зависаниях)</para>
<para>- acpi=on               включение поддержки ACPI</para>
<para>- ide=nodma    принудительное отключение DMA для сбойных IDE-устройств</para>
<para>- doscsi            поиск scsi-устройств (нарушает работу некоторых ethernet-плат)</para>
<para>- dopcmcia       запуск службы pcmcia для PCMCIA-приводов компакт-дисков</para>
<para>- nofirewire      отключение в initrd модулей firewire (предназначенных для</para>
<para>                          приводов компакт-дисков с подключением firewire и т.п.)</para>
<para>- nokeymap      отключение выбора неамериканских раскладок клавиатуры</para>
<para>- docache         кэширование исполняемой части компакт-диска в памяти, позволяет</para>
<para>                          размонтировать /mnt/cdrom для установки другого диска </para>
<para>- nodetect         запрет запуска hwsetup/kudzu и hotplug</para>
<para>- nousb             отключение загрузки модулей usb в initrd, отключает hotplug</para>
<para>- nodhcp           отмена автоматического запуска dhcp при обнаружении сетевой </para>
<para>                           платы</para>
<para>- nohotplug      отключение загрузки службы hotplug</para>
<para>- noapic            отключение apic (попробуйте, если есть аппаратные проблемы</para>
<para>                           с устройствами scsi, сетевыми платами и т.д.)</para>
<para>- noevms          отключение поддержки модулей EVMS2</para>
<para>- nolvm2           отключение поддержки модулей LVM2</para>
<para>- hdx=stroke     позволяет использовать жесткий диск целиком, даже если BIOS </para>
<para>                          не поддерживает диски большого размера</para>
<para>- noload=module1,[module2,[...]]</para>
<para>                          запрет загрузки определенных модулей ядра</para>
<para/>
<para/>
<para>Теперь загрузите систему с компакт-диска, выбрав ядро (если вас не устраивает ядро по умолчанию gentoo) и указав дополнительные параметры. В качестве примера мы покажем, как загрузить ядро gentoo с параметром dopcmcia: </para>
<para/>
<para>Листинг 4: Загрузка установочного диска</para>
<para>boot: gentoo dopcmcia</para>
<para/>
<para/>
<para>Появится заставка с полосой индикатора загрузки. Если вы устанавливаете Gentoo на машину с не американской раскладкой клавиатуры, нужно немедленно нажать ALT+F1, чтобы переключиться в подробный режим, и следовать появившимся указаниям. Если ничего не выбрано в течение 10 секунд, устанавливается раскладка по умолчанию (клавиатура США), а загрузка продолжается. По окончании загрузки для вас будет выполнен автоматический вход в «живой» Gentoo Linux в качестве «root» (администратора). В текущей консоли должно появиться прилашение root («#»). Также можно переключаться в другие консоли, нажимая ALT-F2, ALT-F3 и ALT-F4. Вернуться в первоначальную консоль можно нажатием ALT-F1. </para>
<para/>
<para>Приступим к дополнительной настройке оборудования. </para>
<para/>
<para>Дополнительная настройка оборудования</para>
<para/>
<para>При загрузке с установочного компакт-диска система пытается определить все устройства и загрузить соответствующие модули для их поддержки. В подавляющем большинстве случаев она очень хорошо справляется с этим. Однако, в редких случаях некоторые из нужных модулей не загружаются автоматически. Если какие-либо устройства пропущены при автоматическом опросе шины PCI, модули ядра для их поддержки вам придется загрузить вручную. </para>
<para/>
<para>В следующем примере мы попробуем загрузить модуль 8139too (для поддержки некоторых типов сетевого интерфейса): </para>
<para/>
<para>Листинг 5: Загрузка модуля ядра</para>
<para># modprobe 8139too</para>
<para/>
<para/>
<para>Если вам нужна поддержка PCMCIA, требуется запустить сценарий инициализации pcmcia: </para>
<para/>
<para>Листинг 6: Запуск сценария инициализации PCMCIA</para>
<para># /etc/init.d/pcmcia start</para>
<para/>
<para/>
<para>Дополнительно: оптимизация скорости жесткого диска</para>
<para/>
<para>Если вы опытный пользователь, возможно, вам захочется настроить скоростные параметры жесткого диска IDE с помощью программы hdparm. Указав параметр -tT, можно измерить скорость вашего диска (для уточнения значений запускайте программу несколько раз подряд): </para>
<para/>
<para/>
<para/>
<para>Листинг 7: Тестирование производительности диска</para>
<para># hdparm -tT /dev/hda</para>
<para/>
<para/>
<para>Для настройки вы можете использовать любой из приведенных примеров (или поэкспериментировать самостоятельно), при необходимости указав название своего диска вместо /dev/hda: </para>
<para/>
<para/>
<para>Листинг 8: Оптимизация скорости жесткого диска</para>
<para>Включение DMA:                  </para>
<para># hdparm -d 1 /dev/hda</para>
<para>Установка безопасных значений:  </para>
<para># hdparm -d 1 -A 1 -m 16 -u 1 -a 64 /dev/hda</para>
<para/>
<para/>
<para>Дополнительно: учетные записи пользователей</para>
<para/>
<para>Если вы собираетесь дать другим людям доступ к своей системе, или намерены входить в чат irssi без прав администратора (из соображений безопасности), потребуется создать учетные записи пользователей и изменить пароль администратора. </para>
<para/>
<para>Для изменения пароля администратора используйте passwd: </para>
<para/>
<para>Листинг 9: Изменение пароля администратора</para>
<para># passwd</para>
<para>New password: (введите новый пароль)</para>
<para>Re-enter password: (введите новый пароль еще раз)</para>
<para/>
<para/>
<para>Для создания учетной записи пользователя сначала задаются его реквизиты, а затем вводится пароль. Для этого служат программы useradd и passwd. В следующем примере мы создадим пользователя «john»: </para>
<para/>
<para>Листинг 10: Создание учетной записи пользователя</para>
<para># useradd -m -G users john</para>
<para># passwd john</para>
<para>New password: (введите новый пароль для john)</para>
<para>Re-enter password: (введите новый пароль Джона еще раз)</para>
<para/>
<para/>
<para>Вы также можете изменить свой идентификатор пользователя с администратора (root) на вновь созданного пользователя командой su: </para>
<para/>
<para>Листинг 11: Изменение идентификатора пользователя</para>
<para># su - john</para>
<para/>
<para/>
<para>Дополнительно: просмотр документации во время установки</para>
<para/>
<para>Если вам нужна возможность просмотра настольной книги Gentoo в процессе установки (не важно, из сети или с компакт-диска), убедитесь, что вы создали учетную запись обычного пользователя (см. дополнительно: учетные записи пользователей). Затем нажмите ALT+F2 для перехода в другой терминал, и войдите в систему. </para>
<para/>
<para>Для чтения документации c компакт-диска, вы можете сразу запустить links: </para>
<para/>
<para>Листинг 12: Просмотр документации с компакт-диска</para>
<para># links /mnt/cdrom/docs/html/index.html</para>
<para/>
<para/>
<para>Но лучше открывать настольную книгу Gentoo из сети (там она новее, чем на компакт-диске). Для этого тоже можно пользоваться links, но только после настройки сети (иначе вы не сможете выйти в интернет, чтобы прочесть документ): </para>
<para/>
<para>Листинг 13: Просмотр документации, находящейся в сети</para>
<para># links http://www.gentoo.org/doc/ru/handbook/handbook-x86.xml</para>
<para/>
<para/>
<para>На исходный терминал можно переключаться нажатием ALT+F1. </para>
<para/>
<para>Дополнительно: запуск демона SSH</para>
<para/>
<para>Если вы хотите разрешить другим пользователям доступ к своей системе в процессе установки Gentoo (возможно затем, чтобы они помогли вам с установкой или даже провели ее за вас), для них потребуется создать учетные записи, а возможно, даже дать им пароль администратора (делайте это только в том случае, если вы им полностью доверяете). </para>
<para/>
<para>Чтобы запустить демон SSH, выполните следующую команду: </para>
<para/>
<para>Листинг 14: Запуск демона SSH</para>
<para># /etc/init.d/sshd start</para>
<para/>
<para/>
<para>Для использования sshd, сначала требуется настроить сеть. Переходите к главе настройка сети. </para></sect3></sect2><sect2><title>3. Настройка сети</title>
<para/><sect3><title>3.a. Автоматическое подключение к сети</title>
<para/>
<para>Может, она уже настроена?</para>
<para/>
<para>Если ваша система подсоединена к сети Ethernet, в которой есть сервер DHCP, очень вероятно, что сетевое подключение на вашей машине уже автоматически настроено. Если так, вы сможете воспользоваться многими сетевыми командами, находящимися на установочном компакт-диске, например, ssh, scp, ping, irssi, wget и links. </para>
<para/>
<para>Если сеть уже настроена, команда /sbin/ifconfig должна показывать сетевые интерфейсы кроме lo, например, eth0: </para>
<para/>
<para>Листинг 1: /sbin/ifconfig для рабочей сетевой конфигурации</para>
<para># /sbin/ifconfig</para>
<para>(...)</para>
<para>eth0   Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A</para>
<para>          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0</para>
<para>          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link</para>
<para>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</para>
<para>          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0</para>
<para>          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0</para>
<para>          collisions:1984 txqueuelen:100</para>
<para>          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)</para>
<para>          Interrupt:11 Base address:0xe800 </para>
<para/>
<para>Дополнительно: указание прокси-серверов</para>
<para/>
<para>Если вы подключены к интернету через прокси-сервер, при установке вам может потребоваться ввести сведения о нем. Задать прокси-сервер очень просто: нужно определить переменные, содержащие необходимые сведения. </para>
<para/>
<para>В большинстве случаев в определении переменных достаточно указать имя прокси-сервера. Предположим, например, что прокси-сервер называется proxy.gentoo.org, а его порт — 8080: </para>
<para/>
<para>Листинг 2: Указание прокси-сервера</para>
<para/>
<para> (если прокси-сервер фильтрует трафик HTTP)</para>
<para># export http_proxy="http://proxy.gentoo.org:8080"</para>
<para> (если прокси-сервер фильтрует трафик FTP)</para>
<para># export ftp_proxy="ftp://proxy.gentoo.org:8080"</para>
<para> (если прокси-сервер фильтрует трафик RSYNC)</para>
<para># export RSYNC_PROXY="proxy.gentoo.org:8080"</para>
<para/>
<para/>
<para>Если прокси-сервер запрашивает имя пользователя и пароль, для значения переменной следует использовать такой формат: </para>
<para/>
<para>Листинг 3: Указание имени/пароля в адресе прокси-сервера</para>
<para>http://имя_пользователя:пароль@proxy.gentoo.org:8080</para>
<para/>
<para/>
<para>Проверка сети</para>
<para/>
<para>Может оказаться полезным проверить отклик DNS-сервера вашего поставщика услуг интернета (адрес сервера находится в /etc/resolv.conf), а также произвольного веб-сайта, чтобы убедиться, что ваши пакеты выходят в интернет, разрешение имен DNS работает и т.д. </para>
<para/>
<para>Листинг 4: Проверка доступности сети</para>
<para># ping -c 3 google.com</para>
<para/>
<para>Сеть доступна? Тогда пропустите остаток этого раздела, и переходите к разделу подготовка дисков. Если сеть все же недоступна, то, к сожалению, вам придется еще поработать над ее настройкой. </para>
<para/></sect3><sect3><title>3.b. Автоматизированная настройка сети</title>
<para/>
<para/>
<para>Если сеть не заработает сразу, при установке с некоторых носителей можно использовать net-setup (для обычных или беспроводных сетей), pppoe-setup (для пользователей ADSL) или pptp (для пользователей PPTP; есть на x86, amd64, alpha, ppc и ppc64). </para>
<para/>
<para/>
<para>Если на вашем установочном диске нет ни одного из этих средств, или сеть еще не подключена, приступайте к ручной настройке сети: </para>
<para/>
<orderedlist>
<listitem>
<para>пользователи обычной сети Ethernet — переходите к разделу по умолчанию: использование net-setup; </para>
</listitem>
<listitem>
<para>пользователи ADSL — переходите к разделу альтернатива: использование RP-PPPoE; </para>
</listitem>
<listitem>
<para>пользователи PPTP — переходите к разделу альтернатива: использование PPTP; </para>
</listitem>
</orderedlist>
<para/>
<para>По умолчанию: использование net-setup</para>
<para/>
<para>Простейший способ настройки сети, если она не произошла автоматически — запуск сценария net-setup: </para>
<para/>
<para>Листинг 5: Запуск сценария net-setup</para>
<para># net-setup eth0</para>
<para/>
<para/>
<para>net-setup задаст вам несколько вопросов о вашей сетевой среде. В результате его работы у вас должно появиться работоспособное подключение к сети. Проверьте сетевое подключение, как это описано выше. Если проверка прошла успешно, примите наши поздравления — теперь вы готовы к установке Gentoo. Пропустите оставшуюся часть этого раздела и приступайте к подготовке дисков. </para>
<para/>
<para>Если ваша сеть все еще не заработала, переходите к ручной настройке сети. </para>
<para/>
<para>Альтернатива: использование RP-PPPoE</para>
<para/>
<para>Для простоты подключения к интернету по PPPoE, в установочный диск (любой версии) включен rp-pppoe. Для настройки соединения используйте сценарий pppoe-setup, входящий в комплект. У вас будет запрошена информация о сетевом устройстве ethernet, подключенном к adsl-модему, имя пользователя, пароль, IP-адреса ваших серверов DNS. Также задается вопрос, нужно ли включать базовый межсетевой экран (firewall). </para>
<para/>
<para>Листинг 6: Использование rp-pppoe</para>
<para># pppoe-setup</para>
<para># pppoe-start</para>
<para/>
<para>Если что-то пошло не так, проверьте, правильно ли вы ввели имя пользователя и пароль, посмотрев в /etc/ppp/pap-secrets или /etc/ppp/chap-secrets, и убедитесь, что устройство ethernet указано верно. Если ваше устройство не видно в системе, потребуется загрузить соответствующие сетевые модули. Для этого нужно перейти к разделу ручная настройка сети где мы объясняем, как из загрузить. </para>
<para/>
<para>Если же все заработало, переходите к подготовке дисков. </para>
<para/>
<para>Альтернатива: использование PPTP</para>
<para/>
<para>Примечание: Поддержка PPTP имеется только для архитектуры x86. </para>
<para/>
<para>Если вам нужна поддержка PPTP, можно использовать pptpclient, который входит в состав нашего установочного диска. Но сначала нужно обеспечить правильность настройки. Отредактируйте файлы /etc/ppp/pap-secrets или /etc/ppp/chap-secrets так, чтобы в них находилось правильное сочетание имени пользователя и пароля. </para>
<para/>
<para>Листинг 7: Редактирование /etc/ppp/chap-secrets</para>
<para># nano -w /etc/ppp/chap-secrets</para>
<para/>
<para>Затем, если нужно, измените параметры PPTP в файле /etc/ppp/options.pptp: </para>
<para/>
<para>Листинг 8: Редактирование /etc/ppp/options.pptp</para>
<para># nano -w /etc/ppp/options.pptp</para>
<para/>
<para>Когда все будет готово, просто запустите pptp (с параметрами, которые вы не стали прописывать в options.pptp), чтобы соединиться с сервером: </para>
<para/>
<para>Листинг 9: Подключение к серверу коммутируемого доступа</para>
<para># pptp &lt;server ip&gt;</para>
<para/>
<para>Теперь переходите к подготовке дисков. </para>
<para/></sect3><sect3><title>3.c. Ручная настройка сети</title>
<para/>
<para>Загрузка нужных сетевых модулей</para>
<para/>
<para>При загрузке установочный диск пытается выявить все установленные устройства и загружает подходящие модули ядра (драйверы) для поддержки вашего оборудования. В подавляющем большинстве случаев он очень хорошо справляется с этой работой. Однако, в некоторых случаях он может не справиться с автозагрузкой нужных вам модулей ядра. </para>
<para/>
<para>Если net-setup или pppoe-setup не удалось загрузить нужный модуль, возможно, ваша сетевая плата сразу не обнаружена. При этом вам может потребоваться ручная загрузка необходимых модулей ядра. </para>
<para/>
<para>Чтобы выяснить, какие модули ядра для поддержки сети существуют, используйте ls: </para>
<para/>
<para>Листинг 10: Поиск имеющихся модулей</para>
<para># ls /lib/modules/`uname -r`/kernel/drivers/net</para>
<para/>
<para/>
<para>Если вы найдете драйвер для своей сетевой платы, для загрузки модуля ядра используйте modprobe: </para>
<para/>
<para>Листинг 11: Использование modprobe для загрузки модуля ядра</para>
<para>(для примера загрузим модуль pcnet32)</para>
<para># modprobe pcnet32</para>
<para/>
<para>Чтобы убедиться, что ваша сетевая плата теперь обнаружена, используйте ifconfig. Если сетевая плата обнаружена, результат выглядит подобным образом: </para>
<para/>
<para>Листинг 12: Проверка доступности сетевой платы (удачная)</para>
<para># ifconfig eth0</para>
<para>eth0      Link encap:Ethernet  HWaddr FE:FD:00:00:00:00  </para>
<para>          BROADCAST NOARP MULTICAST  MTU:1500  Metric:1</para>
<para>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</para>
<para>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</para>
<para>          collisions:0 txqueuelen:0 </para>
<para>          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)</para>
<para/>
<para/>
<para>Однако, если вы получите такое сообщение об ошибке, сетевая плата не обнаружена: </para>
<para/>
<para>Листинг 13: Проверка доступности сетевой платы (неудачная)</para>
<para># ifconfig eth0</para>
<para>eth0: error fetching interface information: Device not found</para>
<para/>
<para/>
<para>Если в вашей системе установлено несколько сетевых плат, они будут называться eth0, eth1 и т.д. Убедитесь, что сетевая плата, которую вы собираетесь использовать, работает хорошо, и в дальнейшем не забудьте везде подставлять верное имя. Мы предполагаем, что используется сетевая плата eth0. </para>
<para/>
<para>Когда ваша сетевая плата обнаружена, можно попробовать снова запустить net-setup или pppoe-setup (которые теперь должны сработать), но на случай, если вы из крутых, мы опишем, как настроить сеть вручную. </para>
<para/>
<para>Выберите один из следующих разделов, в зависимости от необходимого вида настройки: </para>
<orderedlist>
<listitem>
<para>
<link linkend="">использование </link>
<link linkend="">DHCP</link>
<link linkend=""> для автоматического присвоения IP-адреса;</link> </para>
</listitem>
<listitem>
<para>
<link linkend="">подготовка беспроводного доступа, если у вас есть беспроводная плата;</link> </para>
</listitem>
<listitem>
<para>
<link linkend="">освоение сетевой терминологии: рассказ о том, что нужно знать о подключении к сети;</link> </para>
</listitem>
<listitem>
<para>
<link linkend="">использование </link>
<link linkend="">ifconfig</link>
<link linkend=""> и </link>
<link linkend="">route</link>
<link linkend="">: описание ручной настройки сети;</link> </para>
</listitem>
</orderedlist>
<para/></sect3><sect3><title>Использование DHCP</title>
<para/>
<para>DHCP (Dynamic Host Configuration Protocol — протокол динамической настройки хоста) дает возможность автоматически получить параметры сетевого подключения (IP-адрес, маску сети, широковещательный адрес, шлюз, сервера имен и т. д.) Все это работает, только когда в вашей сети есть сервер DHCP (или ваш поставщик предоставляет услугу DHCP). Чтобы сетевой интерфейс получал эти сведения автоматически, используйте dhcpcd: </para>
<para/>
<para>Листинг 14: Использование dhcpcd</para>
<para># dhcpcd eth0</para>
<para>Некоторые сетевые администраторы требуют, чтобы вы использовали</para>
<para>имя хоста и домена, назначенное сервером DHCP.</para>
<para>В этом случае используйте</para>
<para># dhcpcd -HD eth0</para>
<para/>
<para/>
<para>Если это сработало (попробуйте «попинговать» какой-нибудь сервер интернета, например, Google), то у вас все настроено, и можно двигаться дальше. Пропустите остаток этого раздела и приступайте к подготовке дисков. </para>
<para/></sect3><sect3><title>Подготовка беспроводного доступа</title>
<para>Примечание: Поддержка команды iwconfig есть только на установочных дисках для платформ x86, amd64 и ppc. В других случаях вы все же сможете запустить расширения, следуя инструкциям проекта linux-wlan-ng (англ.). </para>
<para/>
<para/>
<para>Если вы используете беспроводную плату (802.11), перед дальнейшими действиями может потребоваться настройка параметров беспроводного подключения. Для просмотра текущей настройки беспроводной платы можете использовать iwconfig. При запуске iwconfig вы увидите подобные сведения: </para>
<para/>
<para>Листинг 15: Вывод текущих параметров беспроводного подключения</para>
<para/>
<para># iwconfig eth0</para>
<para>eth0      IEEE 802.11-DS  ESSID:"GentooNode"                                   </para>
<para>          Mode:Managed  Frequency:2.442GHz  Access Point: 00:09:5B:11:CC:F2    </para>
<para>          Bit Rate:11Mb/s   Tx-Power=20 dBm   Sensitivity=0/65535               </para>
<para>          Retry limit:16   RTS thr:off   Fragment thr:off                       </para>
<para>          Power Management:off                                                  </para>
<para>          Link Quality:25/10  Signal level:-51 dBm  Noise level:-102 dBm        </para>
<para>          Rx invalid nwid:5901 Rx invalid crypt:0 Rx invalid frag:0 Tx          </para>
<para>          excessive retries:237 Invalid misc:350282 Missed beacon:84            </para>
<para/>
<para>Примечание: Некоторые беспроводные платы могут называться подобно wlan0 или ra0, а не eth0. Для определения верного имени устройства запускайте iwconfig без каких-либо параметров командной строки. </para>
<para/>
<para/>
<para>Для большинства пользователей может потребоваться изменение только двух параметров: ESSID (названия беспроводной сети) и ключа шифрования WEP. Если ESSID и указанный адрес точки доступа уже принадлежат вашей точке доступа, и вы не используете WEP, значит, ваше беспроводное подключение работает. Если вам необходимо изменить свой ESSID или добавить ключ WEP, можно запустить следующие команды: </para>
<para/>
<para>Листинг 16: Замена ESSID и/или добавление ключа WEP</para>
<para>(так название сети устанавливается в "GentooNode")</para>
<para># iwconfig eth0 essid GentooNode</para>
<para/>
<para>(так устанавливается шестнадцатиричный ключ WEP)</para>
<para># iwconfig eth0 key 1234123412341234abcd</para>
<para/>
<para>(так устанавливается текстовый ключ (ASCII); вначале нужно добавлять "s:")</para>
<para># iwconfig eth0 key s:some-password</para>
<para/>
<para/>
<para>Проверить сделанную настройку можно, снова запустив iwconfig. Как только ваша беспроводная сеть заработает, вы можете перейти к установке параметров сети, относящихся к протоколу IP, которые описываются в следующем разделе (освоение сетевой терминологии), или использовать утилиту net-setup, как описано ранее. </para></sect3><sect3><title>Освоение сетевой терминологии</title>
<para>Примечание: Если вы знаете свой IP-адрес, широковещательный адрес, маску сети и серверы имен, можете пропустить этот подраздел и перейти к разделу использование ifconfig и route. </para>
<para/>
<para>Если все, рассказанное выше, не помогло, вам придется настроить свою сеть вручную. Это совсем нетрудно. Однако, вам понадобится освоить кое-какую сетевую терминологию, знание которой требуется для удовлетворительной настройки сети. Прочитав этот текст, вы узнаете, что такое шлюз, зачем служит маска сети, как формируется широковещательный адрес, и зачем нужны серверы имен. </para>
<para/>
<para>В сети узлы (хосты, компьютеры) различаются по IP-адресу (адресу протокола интернета). Такой адрес — это сочетание четырех чисел от 0 до 255. Ну, по крайней мере, так мы его воспринимаем. В действительности, IP-адрес состоит из 32 бит (единиц и нулей). Давайте рассмотрим пример: </para>
<para/>
<para>Листинг 17: Пример IP-адреса</para>
<para>IP-адрес (числа):       192.168.0.2</para>
<para>IP-адрес (биты):        11000000 10101000 00000000 00000010</para>
<para>                        -------- -------- -------- --------</para>
<para>                           192      168       0        2</para>
<para/>
<para/>
<para>Такой IP-адрес уникален для узла в рамках всех доступных сетей (т. е. каждый узел, с которым вы можете связаться, должен иметь уникальный IP-адрес). Чтобы различать узлы, находящиеся внутри и извне сети, IP-адрес подразделяется на две части: часть сети и часть узла. </para>
<para/>
<para>Это разделение записывается с помощью маски сети — набора единиц, за которым следует набор нулей. Часть IP-адреса, которая попадает на единицы — сетевая, оставшаяся часть — узловая. Как обычно, маска сети может записываться в виде IP-адреса. </para>
<para/>
<para>Листинг 18: Пример разделения сети/узла</para>
<para>IP-адрес:      192      168      0         2</para>
<para>            11000000 10101000 00000000 00000010</para>
<para>Маска сети: 11111111 11111111 11111111 00000000</para>
<para>               255      255     255        0</para>
<para>           +--------------------------+--------+</para>
<para>                      Сеть               Узел</para>
<para/>
<para/>
<para>Другими словами, 192.168.0.14 — все еще входит в состав сети из нашего примера, а 192.168.1.2 — уже нет. </para>
<para/>
<para>Широковещательный адрес — это IP-адрес с такой же сетевой частью, как у вашей сети, но у которого узловая часть состоит только из единиц. Каждый узел вашей сети слушает этот IP-адрес. Он действительно предназначен для широковещательной рассылки пакетов.</para>
<para/>
<para>Листинг 19: Широковещательный адрес</para>
<para>IP-адрес:             192      168      0         2</para>
<para>                   11000000 10101000 00000000 00000010</para>
<para>Широковещательный  11000000 10101000 00000000 11111111</para>
<para>адрес:                192      168      0        255</para>
<para>                  +--------------------------+--------+</para>
<para>                              Сеть              Узел</para>
<para/>
<para>Чтобы бороздить просторы интернета, вы должны знать, через какой узел происходит подключение к интернету. Этот узел называется шлюзом. Так как это обычный узел, ему присвоен обычный IP-адрес (например, 192.168.0.1). </para>
<para/>
<para>Выше мы говорили, что каждому узлу присваивается свой собственный IP-адрес. Чтобы связываться с узлом по имени (вместо IP-адреса), нужна служба, которая переводит имя (такое, как dev.gentoo.org) в IP-адрес (например, 64.5.62.82). Такая служба называется службой имен. Чтобы пользоваться ей, нужно указать необходимые серверы имен в /etc/resolv.conf. </para>
<para/>
<para>Иногда ваш шлюз сам является сервером имен. В остальных случаях вам необходимо указывать серверы имен, предоставляемые поставщиком интернета. </para>
<para/>
<para>В итоге, для дальнейшего вам потребуется следующая информация: </para>
<para/>
<para>Параметр настройки сети        Пример</para>
<para>Ваш IP-адрес                        192.168.0.2</para>
<para>Маска сети                                255.255.255.0</para>
<para>Широковещательный адрес        192.168.0.255</para>
<para>Шлюз                                        192.168.0.1</para>
<para>Сервер(ы) имен                        195.130.130.5, 195.130.130.133</para>
<para/></sect3><sect3><title>Использование ifconfig и route</title>
<para/>
<para>Настройка вашей сети состоит из трех шагов. Сначала мы назначаем себе IP-адрес с помощью ifconfig. Затем мы настраиваем маршрутизацию к шлюзу, пользуясь route. И в завершение мы помещаем IP-адреса серверов имен в /etc/resolv.conf. </para>
<para/>
<para>Для назначения IP-адреса потребуется ваш IP-адрес, широковещательный адрес и маска сети. Узнав их, выполните следующую команду, заменив ${IP_ADDR} на свой IP-адрес, ${BROADCAST} на свой широковещательный адрес, а ${NETMASK} на свою маску сети: </para>
<para/>
<para>Листинг 20: Использование ifconfig</para>
<para># ifconfig eth0 ${IP_ADDR} broadcast ${BROADCAST} netmask ${NETMASK} up</para>
<para/>
<para/>
<para>Теперь настройте маршрутизацию с помощью route. Подставьте IP-адрес своего шлюза вместо ${GATEWAY}: </para>
<para/>
<para>Листинг 21: Использование route</para>
<para># route add default gw ${GATEWAY}</para>
<para/>
<para/>
<para>Затем откройте /etc/resolv.conf в своем любимом редакторе (в нашем примере используется nano): </para>
<para/>
<para>Листинг 22: Создание /etc/resolv.conf</para>
<para># nano -w /etc/resolv.conf</para>
<para/>
<para/>
<para>Заполните данные своих серверов имен по следующему образцу. Обязательно замените ${NAMESERVER1} и ${NAMESERVER2} на соответствующие адреса серверов имен: </para>
<para/>
<para>Листинг 23: Образец /etc/resolv.conf</para>
<para>nameserver ${NAMESERVER1}</para>
<para>nameserver ${NAMESERVER2}</para>
<para/>
<para/>
<para>Готово. Теперь проверьте свою сеть, «попинговав» какой-либо сервер интернета (например, Google). Если все заработало, примите наши поздравления! Теперь вы готовы к установке Gentoo. Приступайте к подготовке дисков. </para></sect3></sect2><sect2><title>4. Подготовка дисков</title>
<para/><sect3><title>4.a. Общие сведения о блочных устройствах</title>
<para/>
<para>Блочные устройства</para>
<para/>
<para>Мы достаточно подробно рассмотрим аспекты работы с дисками в Gentoo Linux и Linux вообще, включая файловые системы, разделы и блочные устройства. Позже, когда вы уже освоитесь с дисками и файловыми системами, мы проведем вас через процесс настройки разделов и файловых систем для установки Gentoo Linux. </para>
<para/>
<para>Для начала, давайте познакомимся с блочными устройствами. Вероятно, наиболее известно блочное устройство, соответствующее в системе Linux первому IDE-диску, а именно /dev/hda. А если в вашей системе используются диски SCSI или SATA, то первым жестким диском будет /dev/sda. </para>
<para/>
<para>Подобные блочные устройства представляют собой абстрактный интерфейс к диску. Прикладные программы могут использовать их для обращения к дискам, не беспокоясь, к какому типу те принадлежат: IDE, SCSI или какому-то еще. Программы могут просто обращаться к накопителю, как к набору смежных 512-байтных блоков с произвольным доступом. </para>
<para/>
<para>Разделы</para>
<para/>
<para>Хотя теоретически для размещения системы Linux диск можно использовать целиком, так почти никогда не делают на практике. Вместо этого большое физическое блочное устройство разбивают на меньшие блочные устройства, более удобные для обращения. В архитектуре x86 они называются разделами. </para>
<para/>
<para>Существуют разделы трех типов: первичные (primary), расширенные (extended) и логические (logical). </para>
<para/>
<para>Первичный раздел — это раздел, информация о котором хранится в MBR (Master Boot Record — главной загрузочной записи). Так как MBR очень мала (512 байт), можно определять всего четыре первичных раздела (например, от /dev/hda1 до /dev/hda4). </para>
<para/>
<para>Расширенный раздел — это особый первичный раздел (имеется в виду, что расширенный раздел должен быть одним из четырех возможных первичных разделов), в котором содержатся другие разделы. Таких разделов изначально не существовало, но их введение помогло расширить существующую схему разметки без потери совместимости, как только четырех разделов перестало хватать. </para>
<para/>
<para>Логический раздел — это раздел, входящий в расширенный раздел. Его определение находится не в MBR, а внутри расширенного раздела. </para>
<para/>
<para>Дополнительные возможности</para>
<para/>
<para>На установочном компакт-диске для х86 предусмотрена поддержка EVMS и LVM2. Использование EVMS и LVM2 повышает гибкость разбиения диска. В ходе установки мы останавливаемся на «обычных» разделах, но стоит запомнить, что EVMS и LVM2 тоже поддерживаются. </para>
<para/></sect3><sect3><title>4.b. Разработка схемы разбиения диска</title>
<para/>
<para>Схема разбиения по умолчанию</para>
<para/>
<para>Если вам не интересно заниматься разработкой схемы для своей системы, можно воспользоваться схемой, используемой в этой книге: </para>
<para/>
<para/>
<para>Раздел        Файловая система             Размер                    Описание</para>
<para>/dev/hda1          ext2                                32МБ                        загрузочный раздел</para>
<para>/dev/hda2        (swap)                        512МБ                раздел подкачки</para>
<para>/dev/hda3         ext3                        оставшаяся часть диска        корневой раздел</para>
<para/>
<para/>
<para>Если вам интересно узнать, какого размера должны быть разделы, и сколько их вам вообще может потребоваться, читайте дальше. В противном случае приступайте к созданию разделов, описанному в главе использование fdisk для создания разделов. </para>
<para/>
<para>Сколько и каких именно?</para>
<para/>
<para>Количество разделов очень сильно зависит от назначения системы. Например, если у вас много пользователей, вам, скорее всего, захочется отделить /home для повышения безопасности и упрощения резервного копирования. Если вы устанавливаете Gentoo в роли почтового сервера, следует отделить /var, т.к. вся почта хранится там. Затем, правильно выбрав файловую систему, вы добьетесь максимальной производительности. Для игровых серверов потребуется отдельный раздел /opt, так как большинство программ для их работы устанавливается туда. Причины выделения те же, что и для /home: безопасность и резервное копирование. Определенно не помешает побольше места для /usr: не только потому, что там хранится большинство приложений, а еще из-за того, что лишь дерево Portage, не считая размещенных в нем архивов с исходными кодами, занимает около 500 МБ. </para>
<para/>
<para>Как видите, все зависит от ваших целей. Наличие отдельных разделов или томов имеет следующие плюсы: </para>
<para/>
<orderedlist>
<listitem>
<para>для каждого раздела или тома можно выбрать наиболее подходящую файловую систему; </para>
</listitem>
<listitem>
<para>свободное место во всей системе не кончится «вдруг» из-за того, что одна-единственная сбойная программа постоянно записывает файлы в раздел или том </para>
</listitem>
<listitem>
<para>необходимая проверка файловых систем будет занимать меньше времени, т.к. проверка разных разделов может выполняться параллельно (еще больший выигрыш времени дает использование нескольких физических дисков) ;</para>
</listitem>
<listitem>
<para>можно повысить безопасность системы, монтируя часть разделов в режиме read-only (только для чтения), nosuid (игнорируется бит setuid), noexec (игнорируется бит исполнения) и т.д.. </para>
</listitem>
</orderedlist>
<para/>
<para>Однако, у создания множества разделов есть один большой минус: при неправильной настройке можно получить систему, в которой много свободного места на одном разделе, и совершенно нет на другом. Кроме того, на дисках SCSI и SATA возможно создание не более 15 разделов. </para>
<para/>
<para>Для примера мы покажем разбиение диска объемом 20 ГБ, используемого в демонстрационном ноутбуке (с веб-сервером, почтовым сервером, средой Gnome и т.д.): </para>
<para/>
<para>Листинг 1: Пример файловой системы</para>
<para>$ df -h</para>
<para>Filesystem    Type    Size   Used   Avail   Use% Mounted on</para>
<para>/dev/hda5        ext3    509M  132M   351M   28%      /</para>
<para>/dev/hda2        ext3    5.0G    3.0G    1.8G    63%      /home</para>
<para>/dev/hda7        ext3    7.9G    6.2G    1.3G    83%      /usr</para>
<para>/dev/hda8        ext3   1011M  483M  477M    51%     /opt</para>
<para>/dev/hda9        ext3    2.0G    607M  1.3G     32%     /var</para>
<para>/dev/hda1        ext2    51M    17M    31M      36%     /boot</para>
<para>/dev/hda6        swap   516M  12M   504M     2%       &lt;not mounted&gt;</para>
<para>(свободное место для будущего использования: 2 ГБ)</para>
<para/>
<para/>
<para>Раздел /usr, как видим, почти заполнен (использовано 83%), но когда все программы установлены, /usr растет не слишком быстро. Хотя отведение нескольких гигабайт дискового пространства для /var может показаться расточительством, помните, что этот раздел по умолчанию используется Portage для компиляции пакетов. Если вы захотите удержать /var в рамках более разумного размера, например, 1ГБ, вам потребуется изменить переменную PORTAGE_TMPDIR в /etc/make.conf, чтобы она указывала на раздел, где достаточно свободного места для компиляции чрезвычайно больших пакетов, таких как OpenOffice. </para>
<para/></sect3><sect3><title>4.c. Использование fdisk для создания разделов</title>
<para/>
<para/>
<para>В следующих разделах описывается, как разбить диск в соответствии с примерной схемой, описанной ранее, а именно:</para>
<para/>
<para> Раздел        Описание</para>
<para>/dev/hda1        загрузочный раздел</para>
<para>/dev/hda2        раздел подкачки</para>
<para>/dev/hda3        корневой раздел</para>
<para/>
<para/>
<para>Эту схему вы можете изменять по своему усмотрению. </para>
<para/>
<para>Просмотр текущей схемы разбиения диска</para>
<para/>
<para>fdisk — это популярная и очень мощная утилита для создания разделов на ваших дисках. Запустите fdisk, указав свой диск в качестве параметра (в примере мы используем /dev/hda): </para>
<para/>
<para>Листинг 2: Запуск fdisk</para>
<para># fdisk /dev/hda</para>
<para/>
<para>После запуска fdisk выдаст такое приглашение: </para>
<para/>
<para>Листинг 3: Приглашение fdisk</para>
<para>Command (m for help): </para>
<para/>
<para/>
<para>Нажмите p, чтобы вывести текущую схему разбиения диска: </para>
<para/>
<para>Листинг 4: Пример схемы разделов диска</para>
<para>Command (m for help): p</para>
<para/>
<para>Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders</para>
<para>Units = cylinders of 15120 * 512 bytes</para>
<para/>
<para>Device Boot    Start       End    Blocks   Id  System</para>
<para>/dev/hda1             1        14    105808+  83  Linux</para>
<para>/dev/hda2            15        49    264600   82  Linux swap</para>
<para>/dev/hda3            50        70    158760   83  Linux</para>
<para>/dev/hda4            71      2184  15981840    5  Extended</para>
<para>/dev/hda5            71       209   1050808+  83  Linux</para>
<para>/dev/hda6           210       348   1050808+  83  Linux</para>
<para>/dev/hda7           349       626   2101648+  83  Linux</para>
<para>/dev/hda8           627       904   2101648+  83  Linux</para>
<para>/dev/hda9           905      2184   9676768+  83  Linux</para>
<para/>
<para>Command (m for help): </para>
<para/>
<para/>
<para>В данном случае на диске есть семь разделов Linux (для которых в графе «System» указано «Linux») и один раздел подкачки (в списке показан как «Linux swap»). </para>
<para/>
<para>Удаление всех разделов</para>
<para/>
<para>Сначала удалим с диска все существующие разделы. Для удаления раздела вводите d. Например для удаления существующего /dev/hda1: </para>
<para/>
<para>Листинг 5: Удаление раздела</para>
<para>Command (m for help): d</para>
<para>Partition number (1-4): 1</para>
<para/>
<para/>
<para>Удаление раздела будет запланировано. Он больше не будет отображаться при вводе p, но фактически не будет удалятся до тех пор, пока вы не сохраните внесенные изменения. Если вы ошиблись и хотите прервать разбиение без сохранения изменений, немедленно введите q и нажмите ENTER; тогда ваш раздел сохранится в неизменном виде. </para>
<para/>
<para>Теперь, если вы действительно собираетесь удалить в своей системе все разделы, повторяйте ввод p для показа оставшихся разделов, затем d и номера удаляемого раздела до тех пор, пока разделы не кончатся. В итоге вы получите пустую таблицу разделов: </para>
<para/>
<para>Листинг 6: Пустая таблица разделов</para>
<para>Disk /dev/hda: 30.0 GB, 30005821440 bytes</para>
<para>240 heads, 63 sectors/track, 3876 cylinders</para>
<para>Units = cylinders of 15120 * 512 = 7741440 bytes</para>
<para/>
<para>Device Boot    Start       End    Blocks   Id  System</para>
<para/>
<para>Command (m for help):</para>
<para/>
<para/>
<para>Теперь, когда мы очистили таблицу разделов, хранящуюся в оперативной памяти, настало время создавать разделы. Мы воспользуемся примерной схемой разбиения, описанной выше. Естественно, не следуйте этим инструкциям буквально, если только вам не нужна таблица разделов, идентичная нашей! </para>
<para/>
<para>Создание загрузочного раздела</para>
<para/>
<para>Сначала создадим маленький загрузочный раздел. Введите n для создания нового раздела, затем p, чтобы выбрать первичный раздел, и 1 для указания первого первичного раздела. На вопрос о первом цилиндре нажмите ввод. На вопрос о последнем цилиндре введите +32M, чтобы создать раздел размером 32МБ: </para>
<para/>
<para>Листинг 7: Создание загрузочного раздела</para>
<para>Command (m for help): n</para>
<para>Command action</para>
<para>  e   extended</para>
<para>  p   primary partition (1-4)</para>
<para>p</para>
<para>Partition number (1-4): 1</para>
<para>First cylinder (1-3876, default 1): (нажмите ввод)</para>
<para>Using default value 1</para>
<para>Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): +32M</para>
<para/>
<para/>
<para>Теперь, введя p, вы должны увидеть следующий текст: </para>
<para/>
<para>Листинг 8: Созданный загрузочный раздел</para>
<para>Command (m for help): p</para>
<para/>
<para>Disk /dev/hda: 30.0 GB, 30005821440 bytes</para>
<para>240 heads, 63 sectors/track, 3876 cylinders</para>
<para>Units = cylinders of 15120 * 512 = 7741440 bytes</para>
<para/>
<para>Device Boot    Start       End    Blocks   Id  System</para>
<para>/dev/hda1          1        14    105808+  83  Linux</para>
<para/>
<para/>
<para>Нам необходимо сделать этот раздел загружаемым. Введите a для включения признака загрузки с раздела, затем нажмите 1. Если снова ввести p, можно увидеть, что в столбце «boot» появился знак *. </para>
<para/>
<para>Создание раздела подкачки</para>
<para/>
<para>Теперь создадим раздел подкачки. Для этого введите n (создание нового раздела), затем p для выбора первичного раздела. Потом нажмите 2, чтобы создать второй первичный раздел, в нашем случае /dev/hda2. На вопрос о первом цилиндре просто нажмите ввод. На вопрос о последнем — ответьте +512M, чтобы создать раздел размером 512МБ. Сделав это, введите t для указания типа раздела, 2, для выбора только что созданного раздела, и 82, чтобы установить тип раздела «Linux Swap». При нажатии p по завершении этих действий, таблица разделов должна выглядеть примерно так: </para>
<para/>
<para>Листинг 9: Список разделов после создания раздела подкачки</para>
<para>Command (m for help): p</para>
<para/>
<para>Disk /dev/hda: 30.0 GB, 30005821440 bytes</para>
<para>240 heads, 63 sectors/track, 3876 cylinders</para>
<para>Units = cylinders of 15120 * 512 = 7741440 bytes</para>
<para/>
<para>Device Boot    Start       End    Blocks   Id  System</para>
<para>/dev/hda1 *        1        14    105808+  83  Linux</para>
<para>/dev/hda2         15        81    506520   82  Linux swap</para>
<para/>
<para/>
<para>Создание корневого раздела</para>
<para/>
<para>Теперь создадим корневой раздел. Для этого введите n (создание нового раздела), затем p (первичный раздел). После этого нажмите 3 для создания третьего первичного раздела, в нашем случае /dev/hda3. На вопрос о первом цилиндре нажмите ввод. На вопрос о последнем — также нажмите ввод, чтобы раздел занял все оставшееся свободное место на диске. По завершении этих шагов, при вводе p должна выводиться подобная таблица разделов: </para>
<para/>
<para>Листинг 10: Список разделов после создания корневого раздела</para>
<para>Command (m for help): p</para>
<para/>
<para>Disk /dev/hda: 30.0 GB, 30005821440 bytes</para>
<para>240 heads, 63 sectors/track, 3876 cylinders</para>
<para>Units = cylinders of 15120 * 512 = 7741440 bytes</para>
<para/>
<para>Device Boot    Start       End    Blocks   Id  System</para>
<para>/dev/hda1 *        1        14    105808+  83  Linux</para>
<para>/dev/hda2         15        81    506520   82  Linux swap</para>
<para>/dev/hda3         82      3876  28690200   83  Linux</para>
<para/>
<para>Сохранение схемы разбиения</para>
<para/>
<para>Для сохранения схемы разбиения и выхода из fdisk, введите w. </para>
<para/>
<para>Листинг 11: Сохранение и выход из fdisk</para>
<para>Command (m for help): w</para>
<para/>
<para>Теперь, создав все разделы, перейдем к созданию файловых систем. </para>
<para/></sect3><sect3><title>4.d. Создание файловых систем</title>
<para/>
<para>Введение</para>
<para/>
<para>Разделы созданы, настало время разместить на них файловые системы. Если вам безразлично, какую файловую систему использовать, и вы вполне довольны той, что мы предлагаем в книге по умолчанию, переходите к размещению файловой системы в разделе. Если нет, читайте дальше, чтобы разузнать о существующих файловых системах... </para>
<para/></sect3><sect3><title>Файловые системы (сравнение !)</title>
<para/>
<para>В ядре Linux поддерживаются различные файловые системы. Мы расскажем о самых распространенных из них: ext2, ext3, ReiserFS, XFS и JFS. </para>
<para/>
<orderedlist>
<listitem>
<para>ext2 — испытанная файловая система Linux, в которой отсутствуют средства журналирования метаданных. Поэтому ее рядовая проверка при запуске может быть очень долгой. Сегодня существует довольно много журналируемых файловых систем нового поколения, целостность которых проверяется очень быстро, и поэтому обычно есть смысл использовать их. Журналируемые файловые системы позволяют избежать долгих задержек при запуске, когда состояние файловой системы неустойчиво. </para>
<para/>
</listitem>
<listitem>
<para>ext3 — это журналируемая версия ext2, где для ускорения восстановления появилось журналирование метаданных, а также другие режимы, наподобие полного или упорядоченного журналирования данных. ext3 — очень хорошая и надежная файловая система. В ней есть дополнительная возможность индексации через хэшированные сбалансированные деревья (b-tree), что в большинстве случаев обеспечивает высокую скорость. Такую индексацию можно включить, добавив к команде mke2fs параметр -O dir_index. Короче говоря, ext3 — превосходная файловая система. </para>
<para/>
</listitem>
<listitem>
<para>ReiserFS — файловая система, построенная на B*-деревьях. У нее очень хорошая скорость, и она намного (часто в 10-15 раз) быстрее ext2 и ext3 при работе с маленькими файлами (менее 4КБ). ReiserFS также великолепно масштабируется; в ней есть средства журналирования. На дату выхода ядра 2.4.18, ReiserFS признана стабильной и пригодной как для систем общего назначения, так и для крайних случаев типа создания больших томов, использования множества маленьких файлов, гигантских файлов или же каталогов с десятками тысяч файлов. </para>
<para/>
</listitem>
<listitem>
<para>XFS — это файловая система с журналированием метаданных и дополнительными средствами, оптимизированными для работы с максимальным объемом данных. Ее применение рекомендуется только в Linux-системах с высококлассными дисками SCSI или дисками с оптическим подключением (fibre-channel), при наличии источников бесперебойного питания. Из-за того, что XFS выполняет очень агрессивное промежуточное кэширование в оперативной памяти, при внезапном отключении питания очень вероятна потеря небрежно спроектированными программами (не принимающими адекватные меры предосторожности при записи файлов на диск, и таких довольно много) изрядного количества данных. </para>
<para/>
</listitem>
<listitem>
<para>JFS — высокопроизводительная журналируемая файловая система производства IBM. Она лишь недавно стала пригодной для широкого применения, и пока слишком мало данных, чтобы сказать что-то хорошее или плохое о ее общей стабильности. </para>
</listitem>
</orderedlist>
<para/>
<para>Размещение файловой системы в разделе</para>
<para/>
<para>Для создания в разделе или томе файловой системы каждого типа существуют специальные средства:</para>
<para>Файловая система                           Команда создания</para>
<para>        ext2                                                     mke2fs</para>
<para>        ext3                                                      mke2fs -j</para>
<para>        reiserfs                                                            mkreiserfs</para>
<para>        xfs                                                           mkfs.xfs</para>
<para>        jfs                                                           mkfs.jfs</para>
<para/>
<para/>
<para>Например, чтобы у загрузочного раздела (/dev/hda1 в наших примерах) была файловая система ext2, а у корневого раздела (/dev/hda3 в наших примерах) — ext3, требуется выполнить: </para>
<para/>
<para>Листинг 12: Создание файловых систем разделов</para>
<para># mke2fs /dev/hda1</para>
<para># mke2fs -j /dev/hda3</para>
<para/>
<para/>
<para>Теперь самостоятельно создайте файловые системы на своих только что созданных разделах (логических томах). </para>
<para/>
<para>Подключение раздела подкачки</para>
<para/>
<para>mkswap — команда, используемая для инициализации разделов подкачки: </para>
<para/>
<para>Листинг 13: Создание идентификатора раздела подкачки</para>
<para># mkswap /dev/hda2</para>
<para/>
<para>Для подключения раздела подкачки воспользуйтесь swapon: </para>
<para/>
<para>Листинг 14: Подключение раздела подкачки</para>
<para># swapon /dev/hda2</para>
<para/>
<para>Теперь командами, приведенными выше, создайте и подключите раздел подкачки в своей системе. </para>
<para/></sect3><sect3><title>4.e. Монтирование</title>
<para/>
<para>Теперь, когда разделы созданы, а файловые системы размещены, настало время смонтировать (подключить к системе) эти разделы. Используйте команду mount. Не забудьте создать для каждого раздела соответствующие каталоги монтирования. Например, смонтируем корневой и загрузочный разделы: </para>
<para/>
<para>Листинг 15: Монтирование разделов</para>
<para># mount /dev/hda3 /mnt/gentoo</para>
<para># mkdir /mnt/gentoo/boot</para>
<para># mount /dev/hda1 /mnt/gentoo/boot</para>
<para/>
<para>Примечание: Если вы хотите разместить каталог /tmp в отдельном разделе, не забудьте изменить права доступа к этому каталогу после монтирования: chmod 1777 /mnt/gentoo/tmp. Это также относится к /var/tmp. </para>
<para/>
<para/>
<para>Еще нам потребуется смонтировать файловую систему proc (виртуальный интерфейс ядра) в каталог /proc. Но сначала надо поместить в разделы нужные файлы. </para>
<para/>
<para>Переходите к установке установочных файлов Gentoo. </para>
<para/></sect3></sect2><sect2><title>5. Установка установочных файлов Gentoo</title>
<para/><sect3><title>5.a. Установка архива стадии</title>
<para/>
<para>Установка текущей даты и времени</para>
<para/>
<para>Перед тем, как продолжать, убедитесь в правильности системной даты и времени, и при необходимости обновите их. Если часы установлены неверно, это в будущем может привести к странным результатам! </para>
<para/>
<para>Для проверки времени, введите команду date: </para>
<para/>
<para>Листинг 1: Проверка даты и времени</para>
<para># date</para>
<para>Fri Mar 29 16:21:18 UTC 2007</para>
<para/>
<para/>
<para>Если часы установлены неправильно, измените время командой date ММДДччммГГГГГ (формат: Месяц, День, часы, минуты и Год). На этом этапе следует указывать время UTC. Позднее вы сможете установить свой часовой пояс. Например, для установки часов на 29 марта, 16:21, 2005 год, выполните: </para>
<para/>
<para>Листинг 2: Установка даты и времени</para>
<para># date 032916212007</para>
<para/>
<para/>
<para>Выбор источника</para>
<para/>
<para>Следующий необходимый шаг — установка архива stage3 на вашу систему. Нужный архив можно скачать из интернета, или, если вы загрузились с универсального установочного диска Gentoo, скопировать с самого диска. Если у вас есть универсальный диск, а на нем — нужная стадия, то загрузка из интернета — лишняя трата трафика и времени, т.к. файлы стадии окажутся совершенно одинаковы. В большинстве случаев, определиться с выбором архива стадии вам поможет команда uname -m. </para>
<para/>
<para>по умолчанию: использование файла стадии из интернета </para>
<para>альтернатива: использование файла стадии с установочного диска </para>
<para/></sect3><sect3><title>5.b. По умолчанию: использование файла стадии из интернета</title>
<para/>
<para>Загрузка архива стадии</para>
<para/>
<para>Перейдите в точку подключения файловой системы Gentoo (обычно — /mnt/gentoo): </para>
<para/>
<para>Листинг 3: Переход к точке подключения Gentoo</para>
<para># cd /mnt/gentoo</para>
<para/>
<para/>
<para>Для загрузки файла стадии у вас уже есть различные инструменты, зависящие от типа диска, с которого производится установка. Если имеется links, можете сразу открыть список зеркал Gentoo и выбрать ближайшее. </para>
<para/>
<para>Когда links нет, в вашем распоряжении должен оказаться lynx. Если требуется использовать прокси-сервер, экспортируйте переменные http_proxy и ftp_proxy: </para>
<para/>
<para>Листинг 4: Настройка информации о прокси-сервере для lynx</para>
<para># export http_proxy="http://proxy.server.com:port"</para>
<para># export ftp_proxy="http://proxy.server.com:port"</para>
<para/>
<para/>
<para>Предположим, у вас под рукой есть links. </para>
<para/>
<para>Перейдите в каталог releases/, в нем откройте каталог, соответствующий вашей архитектуре (например, x86/), затем каталог с версией Gentoo (2006.1/), и, наконец, каталог stages/. Здесь находятся все доступные архивы стадий для вашей архитектуры (они могут располагаться в подкаталогах с названиями разновидностей архитектуры). Выберите один из них и нажмите D для загрузки. По окончании — нажмите Q, чтобы выйти из браузера. </para>
<para/>
<para>Листинг 5: Открытие списка зеркал в links</para>
<para># links http://www.gentoo.org/main/ru/mirrors.xml</para>
<para/>
<para>(если в links нужна поддержка прокси-сервера:)</para>
<para># links -http-proxy proxy.server.com:8080 http://www.gentoo.org/main/ru/mirrors.xml</para>
<para/>
<para/>
<para>Удостоверьтесь, что вы скачали stage3-архив — установка с использованием файлов stage1 и stage2 более не поддерживается. </para>
<para/>
<para>Если вы хотите проверить целостность загруженного архива стадии, с помощью md5sum сравните результат с контрольной суммой MD5, взятой с зеркала. Например, для проверки целостности архива стадии для x86: </para>
<para/>
<para>Листинг 6: Пример проверки целостности архива стадии</para>
<para># md5sum -c stage3-x86-2007.0.tar.bz2.DIGESTS</para>
<para>stage3-x86-2007.0.tar.bz2: OK</para>
<para/>
<para>Распаковка архива стадии</para>
<para/>
<para>Распакуйте загруженный архив стадии в своей системе. Мы используем tar, т.к. это простейший способ: </para>
<para/>
<para>Листинг 7: Распаковка архива стадии</para>
<para># tar xvjpf stage3-*.tar.bz2</para>
<para/>
<para/>
<orderedlist>
<listitem>
<para>Убедитесь, что вы используете точно такие же параметры командной строки (xvjpf). Значения параметров: </para>
</listitem>
<listitem>
<para>x — извлечение; </para>
</listitem>
<listitem>
<para>v — подробные сообщения, чтобы видеть, что происходит во время распаковки (необязательный параметр);</para>
</listitem>
<listitem>
<para> j — декомпрессия bzip2;</para>
</listitem>
<listitem>
<para>p — сохранение прав доступа;</para>
</listitem>
<listitem>
<para>f — указывает на то, что мы распаковываем файл, а не то, что подается на стандартный ввод. </para>
<para/>
</listitem>
</orderedlist>
<para>Примечание: На установочных компакт-дисках и загрузочных образах для некоторых архитектур (например, MIPS) tar встроен в оболочку BusyBox, которая на данный момент не поддерживает параметр v. Тогда вместо приведенных указывайте параметры xjpf. </para>
<para/>
<para/>
<para>После развертывания установки стадии переходите к установке дерева портежей. </para></sect3><sect3><title>5.c. Альтернатива: использование файла стадии с установочного диска</title>
<para/>
<para>Извлечение архива стадии</para>
<para>Важно: Если вы — в x86 и используете «живой диск» с установщиком, на нем нет стадий. Вам понадобится последовать указаниям по использованию файла стадии из интернета. </para>
<para/>
<para/>
<para>Архивы стадий находятся на компакт-диске в каталоге /mnt/cdrom/stages. Для получения списка доступных стадий, воспользуйтесь ls: </para>
<para/>
<para>Листинг 8: Список доступных архивов стадий</para>
<para># ls /mnt/cdrom/stages</para>
<para/>
<para>Если система сообщает об ошибке, возможно, сначала нужно смонтировать CD-ROM: </para>
<para/>
<para>Листинг 9: Монтирование CD-ROM</para>
<para># ls /mnt/cdrom/stages</para>
<para>ls: /mnt/cdrom/stages: No such file or directory</para>
<para># mount /dev/cdroms/cdrom0 /mnt/cdrom</para>
<para># ls /mnt/cdrom/stages</para>
<para/>
<para/>
<para>Перейдите в точку подключения Gentoo (обычно — /mnt/gentoo): </para>
<para/>
<para>Листинг 10: Смена каталога на /mnt/gentoo</para>
<para># cd /mnt/gentoo</para>
<para/>
<para/>
<para>Теперь утилитой tar распакуем выбранный архив стадии. Убедитесь, что вы используете точно такие же параметры (xvjpf)! Параметр v необязателен и может не работать в некоторых версиях tar. В следующем примере мы распакуем архив стадии stage3-&lt;архитектура&gt;-2006.1.tar.bz2. В качестве имени архива обязательно указывайте название файла нужной вам стадии. </para>
<para/>
<para>Листинг 11: Распаковка архива стадии</para>
<para># tar xvjpf /mnt/cdrom/stages/stage3-&lt;архитектура&gt;-2007.0.tar.bz2</para>
<para/>
<para/>
<para>После установки стадии переходите к установке дерева портежей. </para>
<para/></sect3><sect3><title>5.d. Установка дерева портежей</title>
<para/>
<para>Распаковка снимка портежей</para>
<para/>
<para>Теперь вам нужно установить снимок дерева портежей — набор файлов, содержащих сведения для Portage о программном обеспечении, доступном для установки, имеющихся профилях и т.д. </para>
<para/>
<para>Загрузка и установка снимка дерева портежей</para>
<para/>
<para>Перейдите к точке подключения вашей системы (обычно — /mnt/gentoo): </para>
<para/>
<para>Листинг 12: Переход к точке подключения</para>
<para># cd /mnt/gentoo</para>
<para/>
<para/>
<para>Запустите links (или lynx) и откройте спискок зеркал Gentoo. Выберите ближайшее зеркало и перейдите в каталог snapshots/. Оттуда загрузите новейший снимок дерева портежей (portage-latest.tar.bz2), выбрав его из списка и нажав D. </para>
<para/>
<para>Листинг 13: Просмотр списка зеркал Gentoo</para>
<para># links http://www.gentoo.org/main/ru/mirrors.xml</para>
<para/>
<para/>
<para>Закройте браузер нажатием Q. Теперь у вас в /mnt/gentoo появился снимок дерева портежей. </para>
<para/>
<para>Если нужно убедиться в целостности загруженного снимка, воспользуйтесь md5sum, и сравните результат с контрольной суммой MD5, имеющейся на зеркале. </para>
<para/>
<para>Листинг 14: Checking integrity of a Portage snapshot</para>
<para># md5sum -c portage-latest.tar.bz2.md5sum</para>
<para>portage-latest.tar.bz2: OK</para>
<para/>
<para/>
<para>Теперь нужно распаковать снимок. Убедитесь в том, что вы используете в точности такие же параметры; последний параметр — заглавная C, а не строчная c. </para>
<para/>
<para>Листинг 15: Извлечение снимка дерева портежей</para>
<para># tar xvjf /mnt/gentoo/portage-latest.tar.bz2 -C /mnt/gentoo/usr</para>
<para/>
<para/></sect3><sect3><title>5.e. Настройка параметров компиляции</title>
<para/>
<para>Введение</para>
<para/>
<para>Для оптимизации Gentoo вы можете создать ряд переменных, которые повлияют на поведение Portage. Все их можно создавать как переменные среды (с помощью export), но тогда они будут лишь временными. Для хранения ваших настроек предназначен конфигурационный файл Portage, /etc/make.conf. Именно его мы сейчас будем редактировать. </para>
<para/>
<para>Примечание: Список и описание всех допустимых переменных находятся в файле /mnt/gentoo/etc/make.conf.example. Для успешной установки Gentoo, достаточно установить значения только тех переменных, которые описаны ниже. </para>
<para/>
<para/>
<para>Запустите ваш любимый редактор (в этом руководстве используется nano) для изменения параметров оптимизации, которые обсуждаются далее. </para>
<para/>
<para>Листинг 16: Открытие /etc/make.conf</para>
<para># nano -w /mnt/gentoo/etc/make.conf</para>
<para/>
<para/>
<para>Как вы могли заметить, у файла make.conf.example обычная структура: строки комментария начинаются со знака «#», а в остальных строках выражениями вида ПЕРЕМЕННАЯ="значение" определяются переменные. У файла make.conf такой же формат. Некоторые из переменных мы обсудим ниже. </para>
<para/>
<para>CHOST</para>
<para/>
<para>В переменной CHOST определяется, для какой архитектуры скомпилирована система. В ней уже должно быть установлено правильное значение. Не изменяйте эту переменную, т.к. это может повредить вашу систему. Если переменная CHOST, по-вашему, выглядит неправильно, возможно, вы используете не тот архив stage3. </para>
<para/>
<para>CFLAGS и CXXFLAGS</para>
<para/>
<para>Переменные CFLAGS и CXXFLAGS определяют параметры оптимизации компилятора gcc для языков C и C++, соответственно. При том, что общие значения следует устанавливать здесь, максимальная производительность достигается в том случае, когда для каждой компилируемой программы устанавливаются свои собственные оптимальные параметры. Причина в том, что все программы различны. </para>
<para/>
<para>В файле make.conf следует указывать параметры оптимизации, которые, на ваш взгляд, повысят скорость системы в целом. Не помещайте сюда экспериментальные значения; излишняя оптимизация может привести к плохому поведению программ (аварийным завершениям, или, что хуже, неправильной работе). </para>
<para/>
<para>Мы не будем описывать все возможные параметры оптимизации. Если вы хотите узнать о них всё, почитайте онлайновые руководства GNU (англ.) или страницу описания gcc (info gcc — доступна только на работающей системе Linux). Не забудьте прочитать сам файл make.conf.example: в нем также есть немало примеров и полезных сведений. </para>
<para/>
<para>Первый параметр — флаг -march=, где указывается название целевой архитектуры. Возможные варианты описаны в комментариях в файле make.conf.example. Например, для архитектуры x86 Athlon XP: </para>
<para/>
<para>Листинг 17: Значение -march для GCC</para>
<para># пользователям AMD64, желающим получить действительно 64-битную</para>
<para># систему, следует использовать -march=k8</para>
<para># пользователи EM64T должны указать -march=nocona</para>
<para>-march=athlon-xp</para>
<para/>
<para/>
<para>Примечание(JohnBat26) (обновлено в 1.5): Если Вы используете компилятор версии 4.2.0 и выше, то вместо указания специфичного типа процессора, можно указывать одно из двух (в параметрах: -march и -mtune):</para>
<orderedlist>
<listitem>
<para>generic: если Вы хотите, чтобы Ваш скомпилированный код запускался на всех процессорах, архитектуры x86;</para>
</listitem>
<listitem>
<para>native: если Вы хотите оптимизировать код только для Вашего процессора. В этом случае компилятор будет брать сведения о процессоре путем вызова cpuid !</para>
</listitem>
</orderedlist>
<para/>
<para>Следующий — флаг -O (заглавная латинская «O», а не ноль), определяющий класс оптимизации в gcc. Допустимые значения:</para>
<orderedlist>
<listitem>
<para>s — оптимизация по размеру; </para>
</listitem>
<listitem>
<para>0 — ноль, без оптимизации; </para>
</listitem>
<listitem>
<para>1, 2 или 3 — все большая оптимизация по скорости (в каждый класс входят все флаги предыдущего, и некоторые дополнительные). </para>
</listitem>
</orderedlist>
<para/>
<para>Например, для оптимизации класса 2: </para>
<para/>
<para>Листинг 18: Значение -O для GCC</para>
<para>-O2</para>
<para/>
<para>Другой популярный флаг оптимизации — -pipe (использование для связи между различными проходами компилятора каналов вместо временных файлов). </para>
<para/>
<para>Заметьте, что использование -fomit-frame-pointer (не хранить в регистре указатель стекового кадра для функций, которым он не нужен) может всерьез помешать отладке программ! </para>
<para/>
<para>При определении переменных CFLAGS и CXXFLAGS, нужно объединять несколько флагов оптимизации, как в следующем примере: </para>
<para/>
<para>Листинг 19: Определение переменных CFLAGS и CXXFLAGS (gcc &lt; 4.2.0)</para>
<para>CFLAGS="-march=athlon-xp -pipe -O2"  # для пользователей AMD64: -march=k8</para>
<para>          # для пользователей EM64T: -march=nocona</para>
<para>CXXFLAGS="${CFLAGS}"                 # указывайте одинаковые значения  обеих переменных</para>
<para/>
<para/>
<para>MAKEOPTS</para>
<para/>
<para>С помощью MAKEOPTS определяется, сколько параллельных процессов компиляции можно запускать при установке пакета. Хороший (но не всегда идеальный) вариант — значение, равное количеству процессоров в системе плюс один. </para>
<para/>
<para>Листинг 20: MAKEOPTS для обычной однопроцессорной системы</para>
<para>MAKEOPTS="-j2"</para>
<para/>
<para>На старт, внимание, марш!</para>
<para/>
<para>Измените /mnt/gentoo/etc/make.conf в соответствии со своими пожеланиями, и сохраните изменения (пользователям nano нужно нажать CTRL+X). Теперь вы готовы к установке базовой системы Gentoo. </para>
<para/></sect3></sect2><sect2><title>6. Установка базовой системы Gentoo</title><sect3><title>6.a. Изменение корневого каталога</title>
<para/>
<para>Дополнительно: выбор зеркала</para>
<para/>
<para>Для ускорения загрузки исходного кода рекомендуется выбрать быстрое зеркало. Portage ищет переменную GENTOO_MIRRORS в файле make.conf и использует зеркала, перечисленные в ней. Конечно, можно просмотреть наш список зеркал и выбрать одно или несколько, географически ближайших к вам (чаще всего они и будут самыми быстрыми), но мы предлагаем вам удобную утилиту mirrorselect, которая позволяет выбрать желаемые зеркала более удобным способом. </para>
<para/>
<para>Листинг 1: Запуск mirrorselect для установки переменной GENTOO_MIRRORS</para>
<para># mirrorselect -i -o &gt;&gt;/mnt/gentoo/etc/make.conf</para>
<para/>
<para>Предупреждение: Не выбирайте зеркала IPv6. Файлы стадий пока не поддерживают протокол IPv6. </para>
<para/>
<para/>
<para>Вторая важная настройка — установка значения переменной SYNC в файле make.conf. Эта переменная указывает на сервер rsync (сервер удаленной синхронизации), выбранный вами для обновления дерева Portage (коллекции файлов ebuild — сборочных сценариев, содержащих все данные, нужные Portage для скачивания и установки программ). Хотя вписать адрес сервера в SYNC можно и вручную, mirrorselect позволяет упростить это действие: </para>
<para/>
<para>Листинг 2: Выбор зеркала rsync с помощью mirrorselect</para>
<para># mirrorselect -i -r -o &gt;&gt; /mnt/gentoo/etc/make.conf</para>
<para/>
<para/>
<para>После выполнения mirrorselect, мы рекомендуем проверить все значения в файле /mnt/gentoo/etc/make.conf!</para>
<para/>
<para>Копирование сведений о DNS</para>
<para/>
<para>Перед тем, как перейти в новую среду, осталось сделать одно дело: скопировать информацию о DNS (системе доменных имен) в файл /etc/resolv.conf. Это нужно, чтобы при переходе сохранить работоспособность сети. В файле /etc/resolv.conf содержатся адреса серверов имен, используемых в вашей сети. </para>
<para/>
<para>Листинг 3: Копирование информации о DNS</para>
<para>(параметр «-L» нужен, чтобы случайно не скопировать</para>
<para> символьную ссылку)</para>
<para># cp -L /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</para>
<para/>
<para/>
<para>Монтирование файловых систем /proc и /dev</para>
<para/>
<para>Смонтируйте файловую систему /proc в /mnt/gentoo/proc, чтобы после изменения корневого каталога устанавливаемая система смогла обращаться к информации, предоставляемой ядром, а затем создайте привязку монтирования файловой системы /dev. </para>
<para/>
<para>Листинг 4: Монтирование /proc и /dev</para>
<para># mount -t proc none /mnt/gentoo/proc</para>
<para># mount -o bind /dev /mnt/gentoo/dev</para>
<para/>
<para/>
<para>Переход в новую среду</para>
<para/>
<para>Итак, все разделы подготовлены, а базовая операционная среда установлена. Теперь пора войти в нее, изменив корневой каталог. Таким образом, мы перейдем из текущей установочной среды (с компакт-диска или другого установочного носителя) в свою устанавливаемую систему (находящуюся в недавно размеченных разделах). </para>
<para/>
<para>Изменение выполняется в три этапа:</para>
<para/>
<orderedlist>
<listitem>
<para>Сначала мы с помощью chroot изменим корневой каталог с / (находящийся на  установочном носителе) на /mnt/gentoo (находящийся на ваших дисковых разделах).</para>
</listitem>
<listitem>
<para>Затем мы создадим новую среду, пользуясь утилитой env-update, которая, собственно, создает переменные среды. </para>
</listitem>
<listitem>
<para>Наконец, мы загрузим эти переменные в память при помощи source. </para>
</listitem>
</orderedlist>
<para/>
<para>Листинг 5: Изменение корневого каталога для перехода в новую среду</para>
<para># chroot /mnt/gentoo /bin/bash</para>
<para># env-update</para>
<para>&gt;&gt; Regenerating /etc/ld.so.cache...</para>
<para># source /etc/profile</para>
<para># export PS1="(chroot) $PS1"</para>
<para/>
<para>Поздравляем! Теперь вы в своей собственной среде Gentoo Linux. Конечно, на этом она далеко еще не готова, поэтому в руководстве еще осталось несколько разделов :-) </para>
<para/></sect3><sect3><title>6.b. Настройка Portage</title>
<para/>
<para>Обновление дерева Portage</para>
<para/>
<para>Теперь надо обновить дерево Portage до самой последней версии с помощью команды emerge --sync: </para>
<para/>
<para>Листинг 6: Обновление дерева портежей</para>
<para># emerge --sync</para>
<para>(если вы пользуетесь медленным терминалом, например, последовательным</para>
<para> терминалом или кадровым буфером, для ускорения процесса можно добавить </para>
<para> параметр --quiet :) </para>
<para># emerge --sync --quiet</para>
<para/>
<para/>
<para>Если компьютер подключен к интернету через межсетевой экран, блокирующий прохождение rsync-пакетов, вы можете воспользоваться командой emerge-webrsync, которая скачивает и устанавливает снимок дерева. </para>
<para>Если выдано предупреждение, что имеется новая версия Portage и ее нужно обновить, выполните обновление командой emerge portage. </para>
<para/>
<para>Выбор нужного профиля</para>
<para/>
<para>Сначала дадим небольшое определение. </para>
<para/>
<para>Профиль — конструктивный элемент любой системы Gentoo. В нем указываются не только значения по умолчанию для CHOST, CFLAGS и других важных переменных, он также привязывает систему к определенному диапазону допустимых версий пакетов. Диапазоны поддерживаются разработчиками Gentoo. </para>
<para/>
<para>Раньше пользователь редко касался профиля. Однако, пользователи х86, hppa и alpha могут выбирать из двух вариантов профиля: одного для ядра 2.4, другого для ядра 2.6. Это вызвано необходимостью улучшения интеграции ядер 2.6. Для архитектур ppc и ppc64 также существует несколько профилей. Мы поговорим о них позже. </para>
<para/>
<para>Узнать, какой профиль используется в системе в данный момент, вы можете командой: </para>
<para/>
<para>Листинг 7: Выяснение используемого профиля</para>
<para># ls -FGg /etc/make.profile</para>
<para>lrwxrwxrwx  1 48 Apr  8 18:51 /etc/make.profile -&gt; ../usr/portage/profiles/default-linux/x86/2007.0/</para>
<para/>
<para>Если вы используете одну из трех упомянутых архитектур, профиль по умолчанию даст вам систему с ядром 2.6. Это рекомендуется по умолчанию, но за вами сохраняется и право выбора другого профиля. </para>
<para/>
<para>Для некоторых архитектур также предусмотрены подпрофили desktop и server. Загляните в профиль 2007.0/, чтобы узнать, есть ли подпрофили для вашей архитектуры. Возможно, вы захотите заглянуть в make.defaults профиля desktop, чтобы определить, подходит ли он вам. </para>
<para/>
<para>Некоторым пользователям, возможно, захочется установить систему, основанную на старом профиле, с ядром 2.4. Если для этого есть веские основания, сначала надо проверить, существует ли такой дополнительный профиль. На системах x86 это можно сделать следующей командой: </para>
<para/>
<para>Листинг 8: Выяснение наличия дополнительного профиля</para>
<para># ls -d /usr/portage/profiles/default-linux/x86/no-nptl/2.4</para>
<para>/usr/portage/profiles/default-linux/x86/no-nptl/2.4</para>
<para/>
<para/>
<para>В приведенном примере дополнительный профиль 2.4 существует (т.е. нет сообщений об отсутствующем файле или каталоге). Рекомендуется использовать профиль по умолчанию, но если вы все же хотите сменить его, это можно сделать так: </para>
<para/>
<para>Листинг 9: Переключение профиля на 2.4</para>
<para>(убедитесь, что используете нужную архитектуру; этот пример - для x86)</para>
<para># ln -snf /usr/portage/profiles/default-linux/x86/no-nptl/2.4 /etc/make.profile</para>
<para>(вывод списка файлов в профиле 2.4)</para>
<para># ls -FGg /etc/make.profile/</para>
<para>total 12</para>
<para>-rw-r--r--  1 939 Dec 10 14:06 packages</para>
<para>-rw-r--r--  1 347 Dec  3  2004 parent</para>
<para>-rw-r--r--  1 573 Dec  3  2004 virtuals</para>
<para/>
<para/>
<para>Для архитектуры ppc в выпуске 2006.1 появилось несколько новых профилей: </para>
<para/>
<para>Листинг 10: Профили для PPC</para>
<para>(базовый профиль PPC, подходит для всех PPC-машин, минимальный)</para>
<para># ln -snf /usr/portage/profiles/default-linux/ppc/ppc32/2006.1 /etc/make.profile</para>
<para>(профиль для G3)</para>
<para># ln -snf /usr/portage/profiles/default-linux/ppc/ppc32/2006.1/G3 /etc/make.profile</para>
<para>(профиль для G3 Pegasos)</para>
<para># ln -snf /usr/portage/profiles/default-linux/ppc/ppc32/2006.1/G3/Pegasos/ /etc/make.profile</para>
<para>(профиль для G4 (Altivec))</para>
<para># ln -snf /usr/portage/profiles/default-linux/ppc/ppc32/2006.1/G4 /etc/make.profile</para>
<para>(профиль для G4 (Altivec) Pegasos)</para>
<para># ln -snf /usr/portage/profiles/default-linux/ppc/ppc32/2006.1/G4/Pegasos/ /etc/make.profile</para>
<para/>
<para/>
<para>Для архитектуры ppc64 в выпуске 2006.1 также появилось несколько новых профилей: </para>
<para/>
<para>Листинг 11: Профили для PPC64</para>
<para>(базовый профиль PPC64 с 64-битным режимом пользователя, для всех PPC64-машин)</para>
<para># ln -snf /usr/portage/profiles/default-linux/ppc/ppc64/2006.1/64bit-userland /etc/make.profile</para>
<para>(базовый профиль PPC64 с 32-битным режимом пользователя, для всех PPC64-машин)</para>
<para># ln -snf /usr/portage/profiles/default-linux/ppc/ppc64/2006.1/32bit-userland /etc/make.profile</para>
<para>(для каждого режима пользователя существуют подпрофили, как показано ниже.)</para>
<para>(«userland» необходимо заменять на нужный вариант режима из примеров выше)</para>
<para>(профиль 970 для JS20)</para>
<para># ln -snf /usr/portage/profiles/default-linux/ppc/ppc64/2006.1/(userland)/970 /etc/make.profile</para>
<para>(профиль для G5)</para>
<para># ln -snf /usr/portage/profiles/default-linux/ppc/ppc64/2006.1/(userland)/970/pmac /etc/make.profile</para>
<para>(профиль для POWER3)</para>
<para># ln -snf /usr/portage/profiles/default-linux/ppc/ppc64/2006.1/(userland)/power3 /etc/make.profile</para>
<para>(профиль для POWER4)</para>
<para># ln -snf /usr/portage/profiles/default-linux/ppc/ppc64/2006.1/(userland)/power4 /etc/make.profile</para>
<para>(профиль для POWER5)</para>
<para># ln -snf /usr/portage/profiles/default-linux/ppc/ppc64/2006.1/(userland)/power5 /etc/make.profile</para>
<para>(многорежимные профили на дату выхода этого выпуска нестабильны)</para>
<para/>
<para/></sect3><sect3><title>Настройка переменной USE</title>
<para/>
<para>USE («использовать») — одна из самых мощных переменных, имеющихся в распоряжении пользователей Gentoo. Она позволяет при компиляции программ включать или отключать поддержку определенных необязательных функций. Например, некоторые программы можно компилировать с поддержкой gtk или qt на выбор. Другие можно собирать, включая или отключая поддержку SSL. Некоторые программы можно даже компилировать с поддержкой кадрового буфера (svgalib) вместо поддержки X11 (X-сервера). </para>
<para/>
<para>В большинстве дистрибутивов пакеты собраны с поддержкой практически всех мыслимых вариантов. Это увеличивает размер программ и время запуска, не говоря уже о чрезмерных зависимостях. В Gentoo вы сами можете определять, с какими возможностями следует компилировать пакет. Здесь играет роль переменная USE. </para>
<para/>
<para>В переменной USE указываются ключевые слова, которые отражаются на параметрах компиляции. Например, параметр ssl включает компиляцию с поддержкой ssl всех программ, которые способны его поддерживать. -X отключает поддержку X-сервера (обратите внимание на предшествующий знак «минус»). Параметры gnome gtk -kde -qt обеспечивают компиляцию ваших программ с поддержкой Gnome и gtk, но без поддержки KDE и qt, делая систему оптимальной для GNOME. </para>
<para/>
<para>Настройки USE по умолчанию хранятся в файлах make.defaults вашего профиля. Файлы make.defaults находятся в каталоге, на который указывает /etc/make.profile, а также во всех родительских каталогах. Значение USE по умолчанию — это сумма всех значений USE во всех файлах make.defaults. Все, что вы вносите в /etc/make.conf, рассчитывается относительно этих значений. Когда вы добавляете что-либо к значению USE, оно добавляется в список по умолчанию. Когда удаляете что-либо (указывая ключевое слово с предшествующим знаком минус), оно удаляется из списка по умолчанию (если оно там вообще было). Никогда ничего не меняйте в /etc/make.profile. Все, что там находится, перезаписывается при обновлении Portage! </para>
<para/>
<para>Полное описание переменной USE находится во второй части настольной книги Gentoo в главе USE-флаги. Полное описание возможных значений признаков использования находится в вашей системе в файле /usr/portage/profiles/use.desc. </para>
<para/>
<para>Листинг 12: Просмотр допустимых USE-флагов</para>
<para># less /usr/portage/profiles/use.desc</para>
<para>(для прокрутки пользуйтесь клавишами стрелок, для выхода нажимайте "q")</para>
<para/>
<para/>
<para>Например, приведем значение USE для системы, базирующейся на KDE, с включением поддержки DVD, ALSA и записи CD: </para>
<para/>
<para>Листинг 13: Открытие файла /etc/make.conf</para>
<para># nano -w /etc/make.conf</para>
<para/>
<para>Листинг 14: Значение USE</para>
<para>USE="-gtk -gnome qt kde dvd alsa cdr"</para>
<para/>
<para/>
<para>Дополнительно: региональные параметры GLIBC</para>
<para/>
<para>Скорее всего, вы будете использовать в системе один-два набора региональных параметров. Нужные регионы можно указать в /etc/locale.gen. </para>
<para/>
<para>Листинг 15: Открытие /etc/locale.gen</para>
<para># nano -w /etc/locale.gen</para>
<para/>
<para/>
<para>Вот пример одновременного подключения как английского (США), так и немецкого (Германия) с соответствующими кодировками (например, UTF-8). </para>
<para/>
<para>Листинг 16: Укажите свои региональные настройки</para>
<para>en_US/ISO-8859-1</para>
<para>en_US.UTF-8/UTF-8</para>
<para>de_DE/ISO-8859-1</para>
<para>de_DE@euro/ISO-8859-15</para>
<para/>
<para/>
<para>Следующий шаг — запустить locale-gen. Это сгенерирует настройки для всех регионов, указанных вами в файле /etc/locale.gen. </para>
<para>Примечание: locale-gen имеется в glibc-2.3.6-r4 и более новой. Если у вас старшая версия glibc, сейчас ее следует обновить. </para>
<para/>
<para>Примечание: Настройки, подобной приведенной, для поддержки русского языка недостаточно. За дополнительными сведениями обращайтесь к отдельным руководствам по русификации Gentoo. — прим. пер. </para>
<para/>
<para/>
<para>Теперь приступим к настройке ядра. </para></sect3></sect2><sect2><title>7. Настройка ядра</title>
<para/><sect3><title>7.a. Часовой пояс</title>
<para/>
<para>Сначала необходимо выбрать часовой пояс (time zone), чтобы система знала, где вы находитесь. Найдите подходящий пояс в /usr/share/zoneinfo, затем скопируйте его в /etc/localtime. Постарайтесь, пожалуйста, избегать использования часовых поясов /usr/share/zoneinfo/Etc/GMT*, т. к. их названия не соответствуют ожидаемым поясам. Например, GMT-8 фактически является поясом GMT+8. </para>
<para/>
<para>Листинг 1: Установка часового пояса</para>
<para># ls /usr/share/zoneinfo</para>
<para>(допустим, вы хотите использовать GMT)</para>
<para># cp /usr/share/zoneinfo/GMT /etc/localtime</para>
<para/>
<para>Примечание (JohnBat26): Если возникают проблемы со временем (особенно с часовыми поясами), то выполните следующее (получено с форума):</para>
<para/>
<orderedlist>
<listitem>
<para>Выставите правильное время.</para>
</listitem>
<listitem>
<para>Удалите файл /etc/adjtime. Все, часы идут при перезагрузке нормально.</para>
</listitem>
<listitem>
<para>nano -w /etc/conf.d/clock.   Ставьте там вместо UTC Local,и все!!!</para>
</listitem>
</orderedlist>
<para>  </para>
<para/></sect3><sect3><title>7.b. Установка исходных кодов ядра</title>
<para/>
<para>Выбор ядра</para>
<para/>
<para>Ядро Linux — это то, вокруг чего формируются все дистрибутивы. Это слой между пользовательскими программами и вашим оборудованием. Пользователи Gentoo могут выбирать из нескольких типов ядра. Их полный список и описание находится в руководстве по выбору ядра Gentoo (англ.). </para>
<para/>
<para>Для x86 систем, помимо прочего, есть такие ядра, как </para>
<orderedlist>
<listitem>
<para>vanilla-sources (ядро по умолчанию от разработчиков linux ядра);</para>
</listitem>
<listitem>
<para>gentoo-sources (ядро с заплатками, улучшающими производительность). </para>
</listitem>
</orderedlist>
<para/>
<para>С помощью команды emerge выберите и установите ядро. USE="-doc" требуется, чтобы на этом этапе избежать установки xorg-x11 или других связанных пакетов. USE="symlink" при новой установке не требуется, но обеспечивает правильное создание символьной ссылки /usr/src/linux: </para>
<para/>
<para>Листинг 2: Установка исходных кодов ядра</para>
<para># USE="-doc symlink" emerge gentoo-sources</para>
<para/>
<para/>
<para>Просмотрев содержимое каталога /usr/src, вы увидите символьную ссылку linux, которая указывает на каталог с исходными кодами ядра. В данном случае, установленный исходный код ядра указывает на gentoo-sources-2.6.12-r10. Имейте в виду, что ваша версия может отличаться. </para>
<para/>
<para>Листинг 3: Просмотр папки с исходными кодами ядра</para>
<para># ls -l /usr/src/linux</para>
<para>lrwxrwxrwx    1 root     root           12 Oct 13 11:04 /usr/src/linux -&gt; linux-2.6.12-gentoo-r10</para>
<para/>
<para/>
<para>Теперь настало время настройки и компиляции ядра. Можно использовать сценарий genkernel, который сформирует стандартное ядро, аналогичное используемому на установочном компакт-диске. Однако сначала мы расскажем о «ручной» настройке ядра, так как это лучший из способов оптимизации системы. </para>
<para/>
<para>Если вы собираетесь настроить ядро вручную, то переходите к разделу по умолчанию: ручная настройка. Если вы хотите использовать genkernel, то читайте альтернатива: использование genkernel. </para>
<para/></sect3><sect3><title>7.c. По умолчанию: ручная настройка</title>
<para/>
<para/>
<para>Введение</para>
<para/>
<para>Ручная настройка ядра считается одним из самых сложных вопросов для пользователей Linux. Зато после настройки нескольких вариантов ядра вы и не вспомните, что это когда-то было трудно ;) </para>
<para>Однако есть одна непреложная истина: запуская ручную настройку ядра, следует знать состав аппаратуры своего компьютера. Большую часть информации можно собрать, установив пакет pciutils (emerge pciutils), в который входит lspci. lspci можно использовать, находясь в среде с временным корневым каталогом. Можно не обращать внимания на предупреждения, касающиеся pcilib (например: pcilib: cannot open /sys/bus/pci/devices [pcilib: не могу открыть /sys/bus/pci/devices]), которые выводит на экран lspci. Можно запустить lspci и вне временной среды установки. Результат тот же. Вы также можете запустить lsmod для просмотра модулей ядра, используемых установочным компакт-диском (это даст хорошую подсказку, какие параметры включать). </para>
<para/>
<para>Теперь войдите в каталог с исходными кодами ядра и введите команду make menuconfig. Этой командой вы вызовете меню настройки, использующее ncurses. </para>
<para/>
<para>Листинг 4: Вызов меню настройки</para>
<para># cd /usr/src/linux</para>
<para># make menuconfig</para>
<para/>
<para/>
<para>Перед вами появятся несколько разделов настройки. Сначала перечислим пункты, включение которых обязательно (иначе Gentoo не заработает, или для его работы потребуются дополнительные ухищрения). </para>
<para/>
<para>Включение нужных пунктов</para>
<para/>
<para>Прежде всего, разрешите использование разрабатываемого и экспериментального кода и драйверов. Без этого не появятся некоторые важные пункты: </para>
<para/>
<para>Листинг 5: Выбор экспериментальных кодов/драйверов, основные параметры</para>
<para>Code maturity level options ---&gt;</para>
<para>  [*] Prompt for development and/or incomplete code/drivers"</para>
<para>General setup  ---&gt;</para>
<para>  [*] Support for hot-pluggable devices</para>
<para/>
<para/>
<para>Удостоверьтесь, что каждый драйвер, жизненно необходимый для загрузки системы (например, SCSI-контроллера), собран внутри ядра, а не как модуль, иначе система совсем не сможет загрузиться. </para>
<para/>
<para>Далее выберите нужное семейство процессоров: </para>
<para/>
<para>Листинг 6: Выбор подходящего семейства процессоров</para>
<para>Processor type and features ---&gt;</para>
<para>  (измените в соответствии со своей системой)</para>
<para>  (Athlon/Duron/K7) Processor family </para>
<para/>
<para/>
<para>Теперь войдите в File Systems и выберите поддержку всех нужных файловых систем. Не компилируйте их как модули, иначе система Gentoo не сможет смонтировать дисковые разделы. Также выберите Virtual memory и /proc file system. При использовании ядра 2.4, вам потребуется включить /dev file system, т.к. это ядро не поддерживает udev. </para>
<para/>
<para>Листинг 7: Выбор необходимых файловых систем</para>
<para>(при использовани ядра 2.4.x)</para>
<para>File systems ---&gt;</para>
<para>  [*] Virtual memory file system support (former shm fs)</para>
<para>  [*] /proc file system support</para>
<para>  [*] /dev file system support (EXPERIMENTAL)</para>
<para>  [*]   automatically mount /dev at boot</para>
<para>  [ ] /dev/pts file system for Unix98 PTYs</para>
<para/>
<para>(при использовании ядра 2.6.x)</para>
<para>File systems ---&gt;</para>
<para>  Pseudo Filesystems ---&gt;</para>
<para>    [*] /proc file system support</para>
<para>    [*] Virtual memory file system support (former shm fs)</para>
<para/>
<para>(включите поддержку всех нужных вам файловых систем)</para>
<para>  &lt;*&gt; Reiserfs support</para>
<para>  &lt;*&gt; Ext3 journalling file system support</para>
<para>  &lt;*&gt; JFS filesystem support</para>
<para>  &lt;*&gt; Second extended fs support</para>
<para>  &lt;*&gt; XFS filesystem support</para>
<para/>
<para/>
<para>Если ваш BIOS не поддерживает жесткие диски большого размера, и вы ограничили перемычками сообщаемый диском объем, то для получения доступа ко всему диску нужно включить следующие параметры ядра: </para>
<para/>
<para>Листинг 8: Включение поддержки автокоррекции геометрии</para>
<para>(только в ядре 2.4.x)</para>
<para>ATA/IDE/MFM/RLL support ---&gt;</para>
<para>  IDE, ATA and ATAPI Block devices ---&gt;</para>
<para>    &lt;*&gt;   Include IDE/ATA-2 DISK support</para>
<para>    [ ]     Use multi-mode by default</para>
<para>    [*]     Auto-Geometry Resizing support</para>
<para/>
<para/>
<para>Не забудьте включить поддержку режима DMA для ваших дисков: </para>
<para/>
<para>Листинг 9: Включение DMA</para>
<para>Device Drivers ---&gt;</para>
<para>  ATA/ATAPI/MFM/RLL support ---&gt;</para>
<para>    [*] Generic PCI bus-master DMA support</para>
<para>    [*]   Use PCI DMA by default when available</para>
<para/>
<para/>
<para>Если вы используете PPPoE или коммутируемого соединения для соединения с интернетом, потребуется включить в ядре следующие функции: </para>
<para/>
<para>Листинг 10: Выбор нужных драйверов PPPoE</para>
<para>(при использовании ядра 2.4.х)</para>
<para>Network device support ---&gt;</para>
<para>  &lt;*&gt; PPP (point-to-point protocol) support</para>
<para>  &lt;*&gt;   PPP support for async serial ports</para>
<para>  &lt;*&gt;   PPP support for sync tty ports</para>
<para>  </para>
<para>(при использовании ядра 2.6.x)</para>
<para>Device Drivers ---&gt;</para>
<para>  Networking support ---&gt;</para>
<para>    &lt;*&gt; PPP (point-to-point protocol) support</para>
<para>    &lt;*&gt;   PPP support for async serial ports</para>
<para>    &lt;*&gt;   PPP support for sync tty ports</para>
<para/>
<para/>
<para>Два параметра сжатия данных не являются обязательными, но и не повредят. То же относится и к параметру PPP over Ethernet который нужен только для rp-pppoe, для поддержки PPPoE в режиме ядра. </para>
<para/>
<para>При необходимости, не забудьте включить в ядре поддержку своей сетевой платы. </para>
<para/>
<para>Если у вас процессор Intel с поддержкой HyperTreading или многопроцессорная система, следует включить «симметричную многопроцессорную обработку»: </para>
<para/>
<para>Листинг 11: Включение поддержки SMP</para>
<para>Processor type and features  ---&gt;</para>
<para>  [*] Symmetric multi-processing support</para>
<para/>
<para/>
<para>Если вы пользуетесь устройствами ввода на шине USB, (например, мышью или клавиатурой), не забудьте включить их поддержку: </para>
<para/>
<para>Листинг 12: Включение поддержки USB для устройств ввода</para>
<para>USB Support ---&gt;</para>
<para>  &lt;*&gt;   USB Human Interface Device (full HID) support</para>
<para/>
<para/>
<para>Владельцам ноутбуков, которым нужна поддержка PCMCIA, не нужно включать драйверы PCMCIA в ядре, выбрав ядро версии 2.4. В пакете pcmcia-cs, который будет устанавливаться позже, есть более свежие драйверы. Пользователям ядра 2.6 следует использовать драйверы PCMCIA, включенные в ядро. </para>
<para/>
<para>Наряду с включением поддержки PCMCIA в ядре 2.6, не забудьте включить поддержку моста PCMCIA своей системы: </para>
<para/>
<para>Листинг 13: Включение поддержки PCMCIA для ядра 2.6</para>
<para>Bus options (PCI, PCMCIA, EISA, MCA, ISA)  ---&gt;</para>
<para>  PCCARD (PCMCIA/CardBus) support  ---&gt;</para>
<para>    &lt;*&gt; PCCard (PCMCIA/CardBus) support</para>
<para>(если нужно (обычно нужно), включите поддержку старых 16-битных карт PCMCIA)</para>
<para>    &lt;*&gt;   16-bit PCMCIA support</para>
<para>    [*]   32-bit CardBus support</para>
<para>(выберите наиболее подходящий мост)</para>
<para>    --- PC-card bridges</para>
<para>    &lt;*&gt; CardBus yenta-compatible bridge support (NEW)</para>
<para>    &lt;*&gt; Cirrus PD6729 compatible bridge support (NEW)</para>
<para>    &lt;*&gt; i82092 compatible bridge support (NEW)</para>
<para>    &lt;*&gt; i82365 compatible bridge support (NEW)</para>
<para>    &lt;*&gt; Databook TCIC host bridge support (NEW)</para>
<para/>
<para/>
<para>Закончив настройку ядра, приступайте к компиляции и установке. </para>
<para/>
<para>Компиляция и установка</para>
<para/>
<para>Теперь, когда ядро настроено, настало время его скомпилировать и установить. Выйдите из настройки и запустите процесс компиляции: </para>
<para/>
<para>Листинг 14: Компиляция ядра</para>
<para>(для ядра 2.4)</para>
<para># make dep &amp;&amp; make bzImage modules modules_install</para>
<para/>
<para>(для ядра 2.6)</para>
<para># make &amp;&amp; make modules_install</para>
<para/>
<para/>
<para/>
<para/>
<para>По завершении компиляции, скопируйте образ ядра в каталог /boot. Используйте любое имя, которое вам покажется подходящим для избранного ядра, и запомните его, так как позже при настройке начального загрузчика оно потребуется. Не забудьте заменить &lt;версия-ядра&gt; на имя и версию своего ядра. </para>
<para/>
<para>Листинг 15: Установка ядра</para>
<para># cp arch/i386/boot/bzImage /boot/&lt;версия-ядра&gt;</para>
<para/>
<para/>
<para>Теперь переходите к модулям ядра. </para>
<para/></sect3><sect3><title>7.d. Альтернатива: использование genkernel</title>
<para/>
<para>Если вы читаете эти строки, значит, вы собираетесь использовать наш сценарий genkernel для настройки ядра за вас. </para>
<para/>
<para>Теперь когда исходные коды ядра установлены, настало время скомпилировать ядро, собрав его автоматически при помощи сценария genkernel. genkernel выполняет настройку ядра практически так же, как настраивается ядро на установочном компакт-диске. То есть система, ядро которой собрано genkernel, как правило, будет выполнять определение всех устройств при загрузке. Поскольку genkernel не требует никакой ручной настройки ядра, это идеальное решение для тех, кому неуютно от одной мысли, что придется компилировать ядро. </para>
<para/>
<para>Рассмотрим, как использовать genkernel. Сначала установите его: </para>
<para/>
<para>Листинг 16: Установка genkernel</para>
<para># emerge genkernel</para>
<para/>
<para/>
<para>Теперь, если вы собираетесь использовать ядро ветви 2.6, скопируйте настройку ядра, используемую установочным диском, в каталог, где genkernel ищет настройку по умолчанию: </para>
<para/>
<para>Листинг 17: Копирование файла настройки ядра с установочного диска</para>
<para>(только если вы собираетесь настраивать ядро 2.6.х)</para>
<para># zcat /proc/config.gz &gt; /usr/share/genkernel/x86/kernel-config-2.6</para>
<para/>
<para/>
<para>Теперь скомпилируйте исходный код ядра, запустив genkernel all. Имейте в виду, что компиляция займет приличное время, поскольку genkernel собирает ядро, поддерживающее практически любое оборудование. </para>
<para/>
<para>Если в загрузочном разделе не используется файловая система ext2 или ext3, то вам придется вручную настроить ядро, запустив genkernel --menuconfig all, добавив поддержку используемой файловой системы в ядро (т.е. не модулем). Пользователям EVMS2 или LVM2, вероятно, захочется также добавить параметр командной строки --evms2 или --lvm2. </para>
<para/>
<para>Листинг 18: Запуск genkernel</para>
<para># genkernel all</para>
<para/>
<para/>
<para/>
<para>В итоге работы genkernel будет создано ядро, полный набор модулей и начальный корневой диск (initrd). Ядро и initrd будут использоваться в процессе настройки загрузчика системы, которая описана далее в руководстве. Запишите имена ядра и начального корневого диска, так как они понадобятся при составлении конфигурационного файла загрузчика. initrd запускается сразу при начальной загрузке, выполняя автоматическое определение устройств (точно так же, как при запуске установочного диска), до запуска «настоящей» системы. </para>
<para/>
<para>Листинг 19: Уточнение названия созданного образа ядра и initrd</para>
<para># ls /boot/kernel* /boot/initramfs*</para>
<para/>
<para/>
<para>Теперь давайте еще на шаг приблизим нашу систему к установочному диску: соберем coldplug. Если initrd определяет оборудование, необходимое для загрузки системы, coldplug выполняет автоопределение всех остальных устройств. Для установки и подключения coldplug введите команду: </para>
<para/>
<para>Листинг 20: Установка и подключение coldplug</para>
<para># emerge coldplug</para>
<para># rc-update add coldplug boot</para>
<para/>
<para/></sect3><sect3><title>7.e. Модули ядра</title>
<para/>
<para>Настройка модулей</para>
<para/>
<para>Модули, которые требуется загружать автоматически, нужно указать в /etc/modules.autoload.d/kernel-2.4 (или kernel-2.6). Также, при желании, модулям можно сообщить дополнительные параметры. </para>
<para/>
<para>Для просмотра всех доступных модулей запустите команду find, заменив «&lt;версия ядра&gt;» на версию только что собранного ядра: </para>
<para/>
<para>Листинг 21: Просмотр перечня доступных модулей</para>
<para># find /lib/modules/&lt;kernel version&gt;/ -type f -iname '*.o' -or -iname '*.ko'</para>
<para/>
<para/>
<para>Например, для автоматической загрузки модуля 3c59x.o измените файл kernel-2.4 или kernel-2.6, указав в нем имя модуля. </para>
<para/>
<para>Листинг 22: Изменение /etc/modules.autoload.d/kernel-2.4</para>
<para>(показан пример для ядра 2.4.x)</para>
<para># nano -w /etc/modules.autoload.d/kernel-2.4</para>
<para/>
<para/>
<para>Листинг 23: /etc/modules.autoload.d/kernel-2.4 или kernel-2.6</para>
<para>3c59x</para>
<para/>
<para/>
<para>Теперь переходите к настройке параметров системы. </para>
<para/></sect3></sect2><sect2><title>8. Настройка параметров системы</title>
<para/><sect3><title>8.a. Параметры файловых систем</title>
<para/>
<para>Что такое fstab?</para>
<para/>
<para>В Linux все разделы, используемые системой, должны быть перечислены в /etc/fstab. В этом файле указываются точки подключения разделов (mountpoints, местоположение разделов в файловой системе), порядок подключения, а также дополнительные параметры (автоматический или ручной режим подключения, достаточность прав пользователя для подключения и т.п.) </para>
<para/>
<para>Создание /etc/fstab</para>
<para/>
<para>В /etc/fstab используется специальный формат. Каждая строка состоит из шести полей, разделяемых пробелами, знаками табуляции или их сочетанием. Каждое поле имеет свое назначение:</para>
<para> </para>
<orderedlist>
<listitem>
<para>Первое поле обозначает раздел (partition) (путь к файлу устройства). </para>
</listitem>
<listitem>
<para>Второе поле указывает точку подключения (mountpoint), в которую монтируется раздел. </para>
</listitem>
<listitem>
<para>Третье поле задает тип файловой системы (filesystem), используемой в разделе. </para>
</listitem>
<listitem>
<para>В четвертом поле указываются параметры подключения (mountoptions), используемые mount при подключении раздела. Поскольку для каждой файловой системы существуют свои параметры, рекомендуется прочитать страницу справки по mount (man mount), где приведен их полный перечень. При указании нескольких параметров подключения их следует разделять запятыми. </para>
</listitem>
<listitem>
<para>Пятое поле используется dump для определения, требуется ли резервное копирование раздела средствами dump. Обычно это поле можно просто установить в 0 (ноль). </para>
</listitem>
<listitem>
<para>Шестое поле используется fsck для определения порядка проверки (check) файловых систем после некорректного завершения работы системы. Для корневой файловой системы рекомендуется значение 1, а для остальных — 2 (или 0, когда проверка файловой системы не требуется). </para>
</listitem>
</orderedlist>
<para/>
<para>Важно: Вариант файла /etc/fstab по умолчанию, входящий в Gentoo, не является работоспособным. Вам потребуется создать свой собственный /etc/fstab. </para>
<para/>
<para/>
<para>Листинг 1: Открытие /etc/fstab</para>
<para># nano -w /etc/fstab</para>
<para/>
<para/>
<para>Укажите правила, соответствующие вашей схеме разбивки, и добавьте правила для /proc, для tmpfs, для своих дисководов CD-ROM (если есть другие разделы или устройства, их тоже можно указать). </para>
<para/>
<para/>
<para/>
<para>Теперь на основе приведенного примера создайте собственный файл /etc/fstab: </para>
<para/>
<para>Параметр auto позволяет mount определять тип файловой системы автоматически (рекомендуется для съемных носителей, которые могут оказаться размечены в одной из множества существующих файловых систем), а user позволяет монтировать компакт-диски обычным пользователям. </para>
<para/>
<para>Чтобы повысить быстродействие, большинству пользователей стоит добавить параметр noatime в параметры подключения, что приведет к ускорению за счет отключения регистрации отметки времени доступа к файлам (обычно в ней все равно нет необходимости): </para>
<para/>
<para>Перепроверьте свой файл /etc/fstab, сохраните его, и выйдите из редактора, чтобы продолжить настройку. </para>
<para/></sect3><sect3><title>Примечание (JohnBat26): пример моего /etc/fstab:</title>Примечание (JohnBat26):/etc/fstab:<para/>
<para>Листинг 2: Пример  /etc/fstab</para>
<para/>
<para>/dev/sda2                /boot                ext2        defaults,noatime                                       1 2</para>
<para>/dev/sda5                /                xfs        defaults,noatime                                 0 1</para>
<para>/dev/sda3                none                swap        sw                                                                     0 0</para>
<para>/dev/sda7                /home                xfs        defaults,noatime                                           0 1</para>
<para>/dev/sr0                    /mnt/cdrom        auto           noauto,ro,user,iocharset=utf8                                  0 0</para>
<para># раздел с FAT32</para>
<para>/dev/sda1                     /windows/c         vfat        auto,iocharset=utf8,quiet,user,umask=000,noatime     0 0</para>
<para># раздел NTFS только для чтения</para>
<para>/dev/sda6                     /windows/d          ntfs               auto,nls=utf8,umask=0,user,noatime                    0 0</para>
<para>/dev/sda8                 /windows/e         vfat     auto,iocharset=utf8,user,quiet,umask=000,noatime      0 0</para>
<para>/dev/sda9                     /home/media       xfs                  defaults,noatime                                                  0 1</para>
<para># раздел NTFS для чтения и записи при помощи ntfs-3g</para>
<para>/dev/sda10                     /mnt/windows/f   ntfs-3g              -o silent,umask=0,locale=ru_RU.utf8 </para>
<para># NOTE: The next line is critical for boot!</para>
<para>proc                        /proc                 proc                defaults                                                            0 0</para>
<para># flash drive </para>
<para>/dev/sdb                         /mnt/flash           auto      user,noauto,rw,async,iocharset=utf8                           0 0</para>
<para>shm                        /dev/shm        tmpfs                nodev,nosuid,noexec                                           0 0</para></sect3><sect3><title>8.b. Параметры сети</title>
<para/>
<para>Hostname, Domainname и т. д.</para>
<para/>
<para>Еще один вопрос, который нужно решить пользователю — как назвать свой компьютер. Он кажется довольно простым, но многие затрудняются дать подходящее имя для своей Linux-системы. Чтобы вам стало легче, запомните, что какое бы имя вы не выбрали, потом его всегда можно изменить. Например, вы могли бы просто назвать свою систему tux, а домен — homenetwork. </para>
<para/>
<para>Листинг 2: Установка имени узла</para>
<para># nano -w /etc/conf.d/hostname</para>
<para/>
<para>(присвойте переменной HOSTNAME имя своего узла)</para>
<para>HOSTNAME="tux"</para>
<para/>
<para/>
<para>Во-вторых, установим имя домена (domainname) в /etc/conf.d/net: </para>
<para/>
<para>Листинг 3: Установка имени домена</para>
<para># nano -w /etc/conf.d/net</para>
<para>(присвойте переменной DNSDOMAIN имя своего домена)</para>
<para>dns_domain_lo="homenetwork"</para>
<para/>
<para/>
<para>Если у вас есть домен NIS (а если вы не знаете, что это такое, то у вас его точно нет), его также необходимо указать: </para>
<para/>
<para>Листинг 4: Установка имени NIS-домена</para>
<para># nano -w /etc/conf.d/net</para>
<para/>
<para>(укажите название своего домена NIS переменной nis_domain)</para>
<para>nis_domain_lo="my-nisdomain"</para>
<para/>
<para/>
<para>Настройка сети</para>
<para/>
<para>Прежде, чем возмутиться: «Эй, мы же все это уже делали!» — вспомните, что подключение к сети, настроенное вначале, было предназначено лишь для установки Gentoo. Теперь же вы настраиваете сеть для постоянного использования. </para>
<para>Примечание: Более подробные сведения о сетях, включая дополнительные темы, такие как объединение, образование мостов, настройка виртуальных сетей (VLAN) 802.1Q или беспроводных сетей, представлены в разделе настройка сети в Gentoo. </para>
<para/>
<para>Все настройки сети собраны в файле /etc/conf.d/net. В нем используется простой формат, хотя, если вы не знакомы с ручной настройкой сети, он не слишком очевиден. Но не бойтесь, мы все объясним. В файле /etc/conf.d/net.example приведен подробно прокомментированный пример, охватывающий много различных конфигураций. </para>
<para/>
<para>По умолчанию используется DHCP. Чтобы DHCP заработал, требуется установить DHCP-клиент, как описано далее в разделе Установка нужных системных средств. Не забудьте установить DHCP-клиент. </para>
<para/>
<para>Если настройка сетевого подключения нужна вам для указания специфических параметров DHCP, или из-за того, что вы вообще не используете DHCP, откройте /etc/conf.d/net в своем любимом редакторе (в этом примере использован nano): </para>
<para/>
<para>Листинг 5: Открытие /etc/conf.d/net для изменения</para>
<para># nano -w /etc/conf.d/net</para>
<para/>
<para/>
<para>Вы увидите следующее: </para>
<para/>
<para>Листинг 6: /etc/conf.d/net по умолчанию</para>
<para># This blank configuration will automatically use DHCP for any net.*</para>
<para># scripts in /etc/init.d.  To create a more complete configuration,</para>
<para># please review /etc/conf.d/net.example and save your configuration</para>
<para># in /etc/conf.d/net (this file :]!).</para>
<para/>
<para>(# Этот пустой файл настройки приводит к автоматическому использованию</para>
<para> # DHCP всеми сценариями net.* из /etc/init.d. Для создания более полной</para>
<para> # настройки, пожалуйста, просмотрите /etc/conf.d/net.example, а свою</para>
<para> # настройку сохраните в /etc/conf.d/net (в этом файле :]!).            )</para>
<para/>
<para/>
<para>Чтобы указать свой собственный адрес IP, маску сети и шлюз, потребуется настроить как config_eth0, так и routes_eth0: </para>
<para/>
<para>Листинг 7: Ручная настройка параметров IP для eth0</para>
<para>config_eth0=( "192.168.0.2 netmask 255.255.255.0 brd 192.168.0.255" )</para>
<para>routes_eth0=( "default gw 192.168.0.1" )</para>
<para/>
<para/>
<para>Чтобы при использовании DHCP указать специфические параметры, определите config_eth0 и dhcp_eth0: </para>
<para/>
<para>Листинг 8: Автоматическое получение адреса IP для eth0</para>
<para>config_eth0=( "dhcp" )</para>
<para>dhcp_eth0="nodns nontp nonis"</para>
<para/>
<para/>
<para>Список допустимых параметров дан в файле /etc/conf.d/net.example. </para>
<para/>
<para>Если у вас несколько сетевых интерфейсов, повторите эти шаги для config_eth1, config_eth2 и т.д. </para>
<para/>
<para>Теперь сохраните параметры и выйдите из редактора, чтобы продолжить настройку. </para>
<para/>
<para>Автоматический запуск сетевого подключения при загрузке</para>
<para/>
<para>Для запуска сетевых интерфейсов при загрузке необходимо добавить их в уровень запуска по умолчанию. Если у вас интерфейсы типа PCMCIA, пропустите этот шаг, поскольку интерфейсы PCMCIA запускаются сценарием инициализации PCMCIA. </para>
<para/>
<para>Листинг 9: Добавление net.eth0 в уровень запуска default</para>
<para># rc-update add net.eth0 default</para>
<para/>
<para/>
<para>Если у вас несколько сетевых интерфейсов, потребуется создать для них соответствующие сценарии инициализации net.eth1, net.eth2 и т.д. Для этого можно использовать ln: </para>
<para/>
<para>Листинг 10: Создание дополнительных сценариев инициализации</para>
<para># cd /etc/init.d</para>
<para># ln -s net.lo net.eth1</para>
<para># rc-update add net.eth1 default</para>
<para/>
<para/>
<para>Указание сетевых узлов</para>
<para/>
<para>Теперь расскажем системе Linux о вашей сети. Эти сведения указываются в /etc/hosts, и помогают разрешению имен в IP-адреса для узлов, не обрабатываемых сервером имен. Требуется определить вашу систему. Также можно определить другие системы в сети, если вы не собираетесь устанавливать собственную систему DNS. </para>
<para/>
<para>Листинг 11: Открытие /etc/hosts</para>
<para># nano -w /etc/hosts</para>
<para/>
<para>Листинг 12: Указание сведений об узлах сети</para>
<para>(определение текущей системы)</para>
<para>127.0.0.1     tux.homenetwork tux localhost</para>
<para/>
<para>(определите другие машины в своей сети,</para>
<para>для этого у них должен быть статический IP-адрес.)</para>
<para/>
<para>192.168.0.5   jenny.homenetwork jenny</para>
<para>192.168.0.6   benny.homenetwork benny</para>
<para/>
<para/>
<para>Чтобы продолжить настройку, сохраните файл и выйдите из редактора. </para>
<para/></sect3><sect3><title>8.c. Параметры системы</title>
<para/>
<para>Пароль root</para>
<para/>
<para>Прежде всего, нужно установить пароль root (администратора), набрав: </para>
<para/>
<para>Листинг 13: Установка пароля root</para>
<para># passwd</para>
<para/>
<para/>
<para>Если вы хотите, чтобы root мог входить в систему через последовательный терминал, добавьте tts/0 в /etc/securetty: </para>
<para/>
<para>Листинг 14: Добавление tts/0 to /etc/securetty</para>
<para># echo "tts/0" &gt;&gt; /etc/securetty</para>
<para/>
<para/>
<para>Параметры системы</para>
<para/>
<para>Для общей настройки системы в Gentoo используется /etc/rc.conf. Откройте /etc/rc.conf и с удовольствием прочитайте все комментарии, находящиеся в этом файле :) </para>
<para/>
<para>Листинг 15: Открытие /etc/rc.conf</para>
<para># nano -w /etc/rc.conf</para>
<para/>
<para/>
<para>Завершив изменение /etc/rc.conf сохраните файл и выйдите из редактора. </para>
<para/>
<para>Как видите, этот файл подробно прокомментирован, что поможет вам в настройке необходимых конфигурационных переменных. Можно настроить систему на использование unicode, а также указать редактор по умолчанию и диспетчер отображения (например, gdm или kdm). </para>
<para/>
<para>Для управления раскладками клавиатуры в Gentoo используется /etc/conf.d/keymaps. Для настройки своей клавиатуры измените его. </para>
<para/>
<para>Листинг 16: Открытие /etc/conf.d/keymaps</para>
<para># nano -w /etc/conf.d/keymaps</para>
<para/>
<para/>
<para>Будьте особенно тщательны при установке переменной раскладки клавиатуры (KEYMAP): выбрав неверную раскладку, вы можете получить непредсказуемый результат при попытке ввода с клавиатуры. </para>
<para/>
<para>По завершении изменения /etc/conf.d/keymaps сохраните файл и выйдите из редактора. </para>
<para/>
<para>Для настройки параметров часов в Gentoo используется /etc/conf.d/clock. Изменяйте его в соответствии со своими потребностями. </para>
<para/>
<para>Если аппаратные часы вашей системы настроены не на часовой пояс UTC (Гринвич), в файл необходимо добавить строку CLOCK="local". В противном случае вы заметите сдвиг часового пояса. </para>
<para/>
<para>После завершения настройки /etc/conf.d/clock сохраните файл и выйдите из редактора. </para>
<para/>
<para>Переходите к установке нужных системных средств. </para></sect3></sect2><sect2><title>9. Установка нужных системных средств</title>
<para/><sect3><title>9.a. Диспетчер устройств</title>
<para/>
<para>Если вы используете ядро 2.4, и при этом устанавливаете Gentoo из файла третьей стадии (stage3), вам необходимо еще кое-что сделать. Так как теперь в Gentoo по умолчанию используется udev, а ядром 2.4 udev не поддерживается, вам потребуется установить devfsd, и убрать udev. </para>
<para/>
<para>Листинг 1: Установка devfsd</para>
<para>(для тех, кто использует ядро 2.4.x при установке c третьей стадии)</para>
<para># emerge --unmerge udev</para>
<para># emerge devfsd</para>
<para/>
<para/></sect3><sect3><title>9.b. Системные службы журналирования</title>
<para/>
<para>Некоторые средства не включены в архив stage3, поскольку одинаковые возможности можно обеспечить различными пакетами. Теперь вы сами выберете, какие именно установить. </para>
<para/>
<para>Первый инструмент, который вам необходимо выбрать, должен дать системе возможность журналирования. У Unix и Linux превосходная история развития журналирования — при желании в файлах журналов можно регистрировать любой чих, происходящий в вашей системе. Это обеспечивается системной службой журналирования. </para>
<para/>
<para>В Gentoo предлагается несколько служб журналирования на выбор. Это sysklogd, традиционный набор журналирующих демонов, syslog-ng, расширенная служба журналирования, и metalog — служба журналирования с очень гибкими возможностями настройки. Возможно, в Portage имеются и другие службы журналирования: количество доступных пакетов растет день ото дня. </para>
<para/>
<para>Если вы планируете использовать sysklogd или syslog-ng, позднее может потребоваться установка logrotate, поскольку в этих службах журналирования не предусмотрен никакой механизм ротации системных журналов. </para>
<para/>
<para>Чтобы установить выбранную службу журналирования, воспользуйтесь emerge, а затем добавьте ее в уровень запуска по умолчанию с помощью rc-update. В следующем примере показана установка syslog-ng. Вместо нее вы можете подставить другую службу журналирования: </para>
<para/>
<para>Листинг 2: Установка системной службы журналирования</para>
<para># emerge syslog-ng</para>
<para># rc-update add syslog-ng default</para>
<para/>
<para/></sect3><sect3><title>9.c. Дополнительно: демон cron</title>
<para/>
<para>Следующий демон — cron. Хотя он является дополнительным, и не обязателен для работы вашей системы, будет благоразумным установить его. Но что же такое демон cron? Демон cron выполняет команды по расписанию. Это очень удобно, когда нужно выполнять какие-либо команды регулярно (например, ежедневно, еженедельно или ежемесячно). </para>
<para/>
<para>В Gentoo предлагаются три варианта демона cron на выбор: dcron, fcron и vixie-cron. Установка любого из них подобна установке системной службы журналирования. Однако, при установке dcron или fcron для настройки требуется выполнение дополнительной команды, а именно crontab /etc/crontab. Если вы не знаете, что выбрать, используйте vixie-cron. </para>
<para/>
<para>При бессетевой установке доступен только vixie-cron. Если вам нужен другой демон cron, его можно установить позже. </para>
<para/>
<para>Листинг 3: Установка демона cron</para>
<para># emerge vixie-cron</para>
<para># rc-update add vixie-cron default</para>
<para>(только если выбран dcron или fcron) # crontab /etc/crontab</para>
<para/>
<para/></sect3><sect3><title>9.d. Дополнительно: индексация файлов</title>
<para/>
<para>Если вы хотите индексировать файлы в своей системе, чтобы быстро находить их с помощью locate, нужно установить sys-apps/slocate: </para>
<para/>
<para>Листинг 4: Установка slocate</para>
<para># emerge slocate</para>
<para/>
<para/></sect3><sect3><title>9.e. Утилиты для обслуживания файловых систем</title>
<para/>
<para>Для проверки целостности файловых систем, создания дополнительных файловых систем, и т.п., вам потребуются определенные утилиты, состав которых зависит от используемых файловых систем. </para>
<para/>
<para>В следующей таблице перечислены утилиты, которые необходимо устанавливать для обслуживания файловых систем различных типов: </para>
<para/>
<para>Файловая система               Утилиты          Команда установки</para>
<para>            XFS                                  xfsprogs                        emerge xfsprogs</para>
<para>         ReiserFS                        reiserfsprogs           emerge reiserfsprogs</para>
<para>            JFS                                      jfsutils                         emerge jfsutils</para>
<para/>
<para/>
<para>Если вы используете EVMS, также необходимо установить evms: </para>
<para/>
<para>Листинг 5: Установка утилит EVMS</para>
<para># USE="-gtk" emerge evms</para>
<para/>
<para/>
<para>USE="-gtk" предотвратит установку пакетов, от которых зависит данный. При желании включить графические средства evms, потом можно перекомпилировать evms. </para>
<para/>
<para>Если вам не нужны никакие дополнительные сетевые средства (типа rp-pppoe или клиента dhcp), переходите к настройке начального загрузчика. </para>
<para/></sect3><sect3><title>9.f. Сетевые средства</title>
<para/>
<para>Дополнительно: установка клиента DHCP</para>
<para/>
<para>Если требуется, чтобы Gentoo автоматически получала IP-адрес для ваших сетевых интерфейсов, необходимо установить dhcpcd (или любой другой клиент DHCP, список имеющихся клиентов DHCP см. в главе Модульное построение сети). Если не сделать этого сейчас, то после завершения установки вы не сможете подключиться к интернету! </para>
<para/>
<para>Листинг 6: Установка dhcpcd</para>
<para># emerge dhcpcd</para>
<para/>
<para/>
<para>Дополнительно: установка клиента PPPoE</para>
<para/>
<para>Если для выхода в сеть требуется rp-pppoe, его нужно установить. </para>
<para/>
<para>Листинг 7: Установка rp-pppoe</para>
<para># USE="-X" emerge rp-pppoe</para>
<para/>
<para/>
<para>USE="-X" запрещает установку xorg-x11 в порядке зависимости (в rp-pppoe есть графические средства; если их нужно подключить, можно перекомпилировать rp-pppoe позже, или же установить xorg-x11 сейчас: при его установке потребуется много времени на компиляцию). </para>
<para/>
<para>Дополнительно: утилиты RAID для оборудования IBM</para>
<para/>
<para>Если в составе системы на базе POWER5 вы используете RAID-массивы SCSI, стоит задуматься об установке iprutils, которые, среди прочего, позволяют работать с дисковыми массивами, выяснять состояние дисков в составе массива и обновлять микрокод. </para>
<para/>
<para>Листинг 8: Установка iprutils</para>
<para># emerge iprutils</para>
<para/>
<para>Теперь переходите к настройке начального загрузчика. </para></sect3></sect2><sect2><title>10. Настройка начального загрузчика</title>
<para/><sect3><title>10.a. Выбор загрузчика</title>
<para/>
<para>Введение</para>
<para/>
<para>Теперь, когда ядро настроено и собрано, а нужные конфигурационные файлы заполнены как надо, пришло время установить программу, которая будет запускать ваше ядро при старте системы. Такого рода программа называется загрузчиком. Для архитектуры x86 в Gentoo Linux есть загрузчики GRUB и LILO. Но прежде, чем приступить к установке одного из двух загрузчиков, мы расскажем, как настроить кадровый буфер (естественно, если вы захотите). С помощью кадрового буфера можно работать в командной строке Linux на фоне графических элементов (например, симпатичного изображения из загрузочной заставки Gentoo). </para>
<para/>
<para>Дополнительно: кадровый буфер</para>
<para/>
<para>Если вы настроили в ядре поддержку кадрового буфера (или оставили настройки по умолчанию при использовании genkernel), вы можете включить буфер, добавив параметр vga и/или video в файл конфигурации своего загрузчика. </para>
<para/>
<para>Для начала, вам надо узнать тип используемого кадрового буфера. При использовании исходных кодов ядра, доработанных для Gentoo (таких как gentoo-sources), у вас есть возможность выбрать vesafb-tng в качестве типа драйвера VESA (в этих исходных кодах ядра он используется по умолчанию). При использовании vesafb-tng параметр vga указывать не нужно. В других случаях используется драйвер vesafb, а параметр vga необходимо указывать. </para>
<para/>
<para>Параметр vga устанавливает разрешение и глубину цвета, используемые кадровым буфером vesafb. Как отмечено в /usr/src/linux/Documentation/fb/vesafb.txt (который устанавливается в составе пакета с деревом исходных кодов ядра), кадровому буферу необходимо передавать код режима VESA, соответствующий нужному разрешению и цветности. </para>
<para/>
<para>В следующей таблице приведены коды режимов для указания в параметре vga, а также соответствующие им значения разрешения и цветности.</para>
<para/>
<para>                    640x480        800x600        1024x768        1280x1024</para>
<para>256                   0x301                    0x303           0x305            0x307</para>
<para>32 тыс        0x310                    0x313           0x316            0x319</para>
<para>64 тыс        0x311                    0x314           0x317                    0x31A</para>
<para>16 млн        0x312                    0x315           0x318            0x31B</para>
<para/>
<para/>
<para>Параметр video отвечает за порядок отображения кадрового буфера. В нем указывается название драйвера кадрового буфера (vesafb для ядра 2.6 или vesa для ядра 2.4), а затем режимы, которые нужно включить. Все режимы приведены в /usr/src/linux/Documentation/fb/vesafb.txt, а здесь мы расскажем о трех самых используемых:</para>
<para/>
<orderedlist>
<listitem>
<para>ywrap считать, что видеоплата может закольцовывать свою память (продолжать выборку с начального адреса, когда достигнут конечный); </para>
<para/>
</listitem>
<listitem>
<para>mtrr:n        установка регистров MTRR; допустимые значения n: 0 - отключено 1 - без кэширования 2 - отложенная запись (write-back) 3 - объединенная запись (write-combining) 4 - сквозная запись (write-through); </para>
<para/>
</listitem>
<listitem>
<para>mode        (только для vesafb-tng) Установить разрешение, цветность и частоту кадров. Например, 1024x768-32@85 для разрешения 1024x768, 32-битного цвета и частоты кадров 85 Гц. </para>
</listitem>
</orderedlist>
<para/>
<para/>
<para>В результате должно получиться что-то вроде vga=0x318 video=vesafb:mtrr:3,ywrap или video=vesafb:mtrr:3,ywrap,1024x768-32@85. Запомните (или запишите) составленное значение, скоро оно понадобится. </para>
<para/>
<para>Перейдем к установке GRUB или LILO. </para>
<para/></sect3><sect3><title>10.b. По умолчанию: использование GRUB</title>
<para/>
<para>Введение в терминологию GRUB</para>
<para/>
<para>Самое сложное в освоении GRUB — освоиться с тем, как в нем именуются жесткие диски и разделы. Ваш Linux-раздел /dev/hda1, скорее всего, в GRUB станет называться (hd0,0). Обратите внимание на круглые скобки вокруг hd0,0 — они обязательны. </para>
<para/>
<para>Жесткие диски нумеруются, начиная с нуля, а не с «а»; разделы — c нуля, а не с единицы. Нужно помнить, что в виде hd нумеруются только жесткие диски, но не устройства atapi-ide, такие как приводы компакт-дисков. Та же нумерация используется для устройств SCSI (обычно им присваиваются номера большие, чем устройствам IDE, кроме случаев, когда BIOS настроен на загрузку с устройства SCSI). Когда BIOS настроен на загрузку с другого жесткого диска (например, с первичного ведомого), именно этот жесткий диск и становится hd0. </para>
<para/>
<para>Например, если у вас есть жесткий диск /dev/hda, привод CD-ROM /dev/hdb, записывающий CD /dev/hdc, второй жесткий диск /dev/hdd, а устройств SCSI нет, то разделу /dev/hdd7 будет соответствовать (hd1,6). Возможно, это покажется запутанным (так и есть), но, как мы увидим, в GRUB есть механизм автодополнения по tab, облегчающий жизнь обладателям множества жестких дисков и разделов, а также тем, кто теряется в схеме нумерации устройств GRUB. </para>
<para/>
<para>Почувствовав, что к чему, пора установить GRUB. </para>
<para/>
<para>Установка GRUB</para>
<para/>
<para>Для установки GRUB сначала добавим его в систему: </para>
<para/>
<para>Листинг 1: Установка GRUB</para>
<para># emerge grub</para>
<para/>
<para>Хотя GRUB уже установлен, нам еще потребуется подправить его файл конфигурации, и поместить GRUB в MBR, чтобы он автоматически загружал ядро. С помощью nano (или другого редактора) создайте /boot/grub/grub.conf: </para>
<para/>
<para>Листинг 2: Создание /boot/grub/grub.conf</para>
<para># nano -w /boot/grub/grub.conf</para>
<para/>
<para/>
<para>Теперь заполним grub.conf своими значениями. Ниже приведены два варианта grub.conf для показанного примера разбиения дисков. Первый вариант grub.conf мы подробно прокомментировали. Удостоверьтесь, что у себя вы указываете имя своего файла образа ядра, и при необходимости имя своего образа начального корневого диска (initrd). </para>
<para>первый вариант grub.conf — для тех, кто при сборке ядра обходился без genkernel </para>
<para>второй вариант grub.conf — для тех, кто при сборке ядра пользовался genkernel </para>
<para/>
<para>Примечание: Если ваша корневая файловая система — JFS, необходимо добавить «ro» в строку kernel, поскольку JFS «накатывает» свой журнал перед тем, как разрешить монтирование раздела на чтение-запись. </para>
<para/>
<para/>
<para>Листинг 3: grub.conf для тех, кто обошелся без genkernel</para>
<para># какой пункт загружать по умолчанию: 0 - первый, 1 - второй и т.д.</para>
<para>default 0</para>
<para># сколько секунд ждать до начала загрузки пункта по умолчанию</para>
<para>timeout 30</para>
<para># симпатичная заставка, добавить по вкусу :)</para>
<para># закомментируйте, если у вас не установлена графическая видеоплата</para>
<para>splashimage=(hd0,0)/boot/grub/splash.xpm.gz</para>
<para/>
<para>title=Gentoo Linux 2.6.12-r10</para>
<para># раздел с файлом образа ядра (или операционной системой)</para>
<para>root (hd0,0)</para>
<para>kernel /boot/kernel-2.6.12-gentoo-r10 root=/dev/hda3</para>
<para/>
<para># следующие четыре строки нужны только для двойной загрузки с Windows</para>
<para># в этом примере Windows находится на /dev/hda6</para>
<para>title=Windows XP</para>
<para>rootnoverify (hd0,5)</para>
<para>makeactive</para>
<para>chainloader +1</para>
<para/>
<para/>
<para>Листинг 4: grub.conf для тех, кто пользовался genkernel</para>
<para>default 0</para>
<para>timeout 30</para>
<para>splashimage=(hd0,0)/boot/grub/splash.xpm.gz</para>
<para/>
<para>title=Gentoo Linux 2.6.12-r10</para>
<para>root (hd0,0)</para>
<para>kernel /boot/kernel-genkernel-x86-2.6.12-gentoo-r10 root=/dev/ram0 init=/linuxrc ramdisk=8192 real_root=/dev/hda3 udev</para>
<para>initrd /boot/initramfs-genkernel-x86-2.6.12-gentoo-r10</para>
<para/>
<para># нужно только для двойной загрузки</para>
<para>title=Windows XP</para>
<para>rootnoverify (hd0,5)</para>
<para>makeactive</para>
<para>chainloader +1</para>
<para/>
<para>Примечание: Параметр udev, указанный в конце строки kernel, необходим для обхода ошибки в некоторых версиях genkernel, если вы вообще используете udev (по умолчанию — используется). </para>
<para/>
<para>Примечание: Если вы разбили жесткий диск по-другому, или у вас другое ядро, внесите необходимые изменения. При этом убедитесь, что все пути, следующие за упоминанием устройства GRUB (например (hd0,0)), приведены относительно точки подключения, а не корня файловой системы. Другими словами, (hd0,0)/grub/splash.xpm.gz — на самом деле /boot/grub/splash.xpm.gz, так как (hd0,0) — это /boot. </para>
<para/>
<para/>
<para>Кроме того, если вы избрали другую схему разбиения диска, и не выделяли для /boot отдельный раздел, префикс /boot, использованный в примерах выше, обязателен. Если же вы следовали рекомендованному нами плану разбиения, префикс /boot не требуется, но все работает благодаря символьной ссылке boot. Короче говоря, приведенные примеры должны работать независимо от того, есть у вас отдельный раздел для /boot или нет. </para>
<para/>
<para>Если вам надо передать ядру дополнительные параметры, просто добавьте их в конец строки kernel. Один параметр мы уже передаем ядру (root=/dev/hda3 или real_root=/dev/hda3); можно добавлять и другие, например, такие как параметры video и/или vga для кадрового буфера, обсуждавшиеся выше. </para>
<para/>
<para>Если вы используете ядро 2.6.7 или выше, а объем жесткого диска ограничили перемычками из-за того, что BIOS не в состоянии работать с дисками большого размера, вам потребуется добавить hdx=stroke. </para>
<para/>
<para>Тем, кто использует genkernel, нужно помнить, что их ядро использует такие же загрузочные параметры, как на установочном компакт-диске. Например, если у вас есть устройства SCSI, следует передать ядру параметр doscsi. </para>
<para/>
<para>Теперь сохраните grub.conf и выйдите из редактора. Вам по-прежнему необходимо записать GRUB в MBR (Master Boot Record), чтобы GRUB автоматически запускался при загрузке системы. </para>
<para/>
<para>Разработчики GRUB рекомендуют использовать grub-install. Однако, на случай некорректной работы grub-install есть возможность записать GRUB вручную. </para>
<para/>
<para>Переходите к разделу по умолчанию: установка GRUB с помощью grub-install или альтернатива: установка GRUB вручную. </para>
<para/>
<para>По умолчанию: установка GRUB с помощью grub-install</para>
<para/>
<para>Для установки GRUB вам надо выполнить команду grub-install. Однако, grub-install не заработает сам по себе, т.к. мы находимся в среде с измененным корневым каталогом. Нам нужно создать файл /etc/mtab, перечислив в нем все смонтированные файловые системы. К счастью, для этого есть очень легкий способ: просто скопируйте содержимое /proc/mounts поверх /etc/mtab, исключив строку rootfs, если вы не создавали отдельный загрузочный раздел. Следующая команда подойдет в обоих случаях: </para>
<para/>
<para>Листинг 5: Создание /etc/mtab</para>
<para># grep -v rootfs /proc/mounts &gt; /etc/mtab</para>
<para/>
<para/>
<para>Теперь мы можем установить GRUB, используя grub-install: </para>
<para/>
<para>Листинг 6: Выполнение grub-install</para>
<para># grub-install /dev/hda</para>
<para/>
<para/>
<para>Если у вас есть вопросы о GRUB, пожалуйста, обратитесь к GRUB FAQ (англ.) или руководству по GRUB (англ.). </para>
<para/>
<para>Переходите к перезагрузке системы. </para>
<para/>
<para>Альтернатива: установка GRUB вручную</para>
<para/>
<para>Для начала настройки, введите grub. Вы увидите приглашение grub&gt; — это командная строка grub. Теперь потребуется набрать команды, нужные для установки загрузочной записи GRUB на ваш жесткий диск. </para>
<para/>
<para>Листинг 7: Запуск оболочки GRUB</para>
<para># grub</para>
<para/>
<para>Примечание: Если у вас нет приводов для дискет, к приведенной команде добавьте --no-floppy, чтобы grub зря не опрашивал несуществующие дисководы. </para>
<para/>
<para/>
<para>В приводимом примере мы хотим установить GRUB так, чтобы он считывал нужную информацию с загрузочного раздела /dev/hda1, а загрузочная запись GRUB находилась в MBR (Master Boot Record) жесткого диска, чтобы первое, что мы видели после включения компьютера — это приглашение GRUB. Естественно, если вы при установке отклонялись от предлагаемой схемы, внесите необходимые поправки. </para>
<para/>
<para>Находясь в GRUB, можно использовать автодополнение по клавише TAB. К примеру, если ввести «root (», а затем TAB, появится список устройств (таких как hd0). Если ввести «root (hd0,» и нажать TAB, появится список для выбора раздела из возможных (такого как hd0,0). </para>
<para/>
<para>Благодаря автодополнению установка GRUB не так сложна. Теперь приступим к настройке GRUB. </para>
<para/>
<para>Листинг 8: Установка GRUB в MBR</para>
<para>grub&gt; root (hd0,0)           (указание расположения раздела с /boot)</para>
<para>grub&gt; setup (hd0)           (установка GRUB в MBR)</para>
<para>grub&gt; quit                        (выход из оболочки GRUB)</para>
<para/>
<para>Примечание: Если вы хотите установить GRUB в определенный раздел вместо MBR, команду setup потребуется исправить так, чтобы она указывала на нужный раздел. Например, команда для установки GRUB в /dev/hda3 — setup (hd0,2). Однако, так поступают немногие. </para>
<para/>
<para/>
<para>С дополнительными вопросами о GRUB, пожалуйста, обращайтесь к GRUB FAQ (англ.) или руководству по GRUB (англ.). </para>
<para/>
<para>Примечание: В случае переустановки ядра в будущем, вам больше не потребуется копировать содержимое файлов. После компиляции ядра просто запускайте make install: копирование файлов и изменение конфигурации GRUB произойдет автоматически. </para>
<para/>
<para/>
<para>Переходите к перезагрузке системы. </para>
<para/></sect3><sect3><title>10.c. Альтернатива: использование LILO</title>
<para/>
<para>Установка LILO</para>
<para/>
<para>LILO (сокращение от LInux LOader) — это проверенная временем рабочая лошадка среди загрузчиков Linux-систем. Но ей недостает ряда возможностей, которые есть в GRUB (и в том числе в этом заключается причина растущей популярности GRUB). LILO все еще используется, потому что на некоторых системах он работает, а GRUB — нет. Конечно же, он используется еще и потому, что многие просто знакомы с LILO и сроднились с ним. Так или иначе, в Gentoo поддерживаются оба загрузчика, и вы, видимо, решили использовать LILO. </para>
<para/>
<para>Установка LILO в систему проста как пробка: просто используйте emerge. </para>
<para/>
<para>Листинг 9: Установка LILO</para>
<para># emerge lilo</para>
<para/>
<para/>
<para>Настройка LILO</para>
<para/>
<para>Для настройки LILO нужно создать файл /etc/lilo.conf. Запустите свой любимый редактор (в руководстве мы для единообразия используем nano) и создайте файл. </para>
<para/>
<para>Листинг 10: Создание /etc/lilo.conf</para>
<para># nano -w /etc/lilo.conf</para>
<para/>
<para/>
<para>Несколькими разделами раньше мы попросили вас запомнить название созданного файла образа ядра. В следующем примере используется предложенная нами схема разделения диска. </para>
<para/>
<para>Пример разделен на две части: </para>
<orderedlist>
<listitem>
<para>одна — для тех, кто не пользовался для сборки ядра genkernel; </para>
</listitem>
<listitem>
<para>другая — для тех, кто при сборке ядра пользовался genkernel;</para>
</listitem>
</orderedlist>
<para/>
<para>Удостоверьтесь, что у себя вы указываете имя своего файла образа ядра, и при необходимости имя своего образа начального корневого диска (initrd).</para>
<para/>
<para>Примечание: Если ваша корневая файловая система — JFS, необходимо добавить «ro» в строку kernel, поскольку JFS «накатывает» свой журнал перед тем, как разрешить монтирование раздела на чтение-запись. </para>
<para/>
<para/>
<para>Листинг 11: Пример /etc/lilo.conf</para>
<para>boot=/dev/hda         # установка LILO в MBR</para>
<para>prompt                # предоставление шанса выбора другого варианта</para>
<para>timeout=50            # ожидание пять секунд до загрузки варианта по умолчанию</para>
<para>default=gentoo        # по истечении времени загрузка варианта gentoo</para>
<para/>
<para># для тех, кто не использует genkernel</para>
<para>image=/boot/kernel-2.6.12-gentoo-r10</para>
<para>  label=gentoo        # название этого варианта</para>
<para>  read-only           # запуск с корневой ФС только для чтения; не менять!</para>
<para>  root=/dev/hda3      # расположение корневой файловой системы</para>
<para/>
<para># для тех, кто использует genkernel</para>
<para>image=/boot/kernel-genkernel-x86-2.6.12-gentoo-r10</para>
<para>  label=gentoo</para>
<para>  read-only</para>
<para>  root=/dev/ram0</para>
<para>  append="init=/linuxrc ramdisk=8192 real_root=/dev/hda3 udev"</para>
<para>  initrd=/boot/initramfs-genkernel-2.6.12-gentoo-r10</para>
<para/>
<para># следующие две строки нужны только для двойной загрузки с Windows</para>
<para># в этом примере Windows находится на /dev/hda6</para>
<para>other=/dev/hda6</para>
<para>  label=windows</para>
<para/>
<para>Примечание: Параметр udev, указанный в конце строки kernel, необходим для обхода ошибки в некоторых версиях genkernel, если вы вообще используете udev (по умолчанию — используется). </para>
<para/>
<para>Примечание: Если вы разбили жесткий диск по-другому, или у вас другое ядро, внесите необходимые изменения. </para>
<para/>
<para/>
<para>Если нужно передать ядру дополнительные параметры, добавьте в соответствующий раздел файла выражение append. Например, добавим параметр video для включения кадрового буфера: </para>
<para/>
<para>Листинг 12: Использование append для добавления параметров ядра</para>
<para>image=/boot/kernel-2.6.12-gentoo-r10</para>
<para>  label=gentoo</para>
<para>  read-only</para>
<para>  root=/dev/hda3</para>
<para>  append="video=vesafb:mtrr,ywrap,1024x768-32@85"</para>
<para/>
<para/>
<para>Если вы используете ядро 2.6.7 или выше, а объем жесткого диска ограничили перемычками из-за того, что BIOS не в состоянии работать с дисками большого размера, вам потребуется добавить hdx=stroke. </para>
<para/>
<para>Тем, кто использует genkernel, нужно помнить, что их ядро использует такие же загрузочные параметры, как на установочном компакт-диске. Например, если у вас есть устройства SCSI, следует передать ядру параметр doscsi. </para>
<para/>
<para>Теперь сохраните файл и выйдите из редактора. Для окончания установки нужно запустить /sbin/lilo, чтобы LILO смог отразить настройки, сделанные в /etc/lilo.conf, в вашей системе (т.е. записался на диск). Имейте в виду, что при каждой установке нового ядра или изменении меню вам потребуется выполнять /sbin/lilo заново. </para>
<para/>
<para>Листинг 13: Завершение установки LILO</para>
<para># /sbin/lilo</para>
<para/>
<para>Примечание: При переустановке ядра вам больше не придется копировать файлы. Просто запустите make install после компиляции ядра; копирование файлов и изменение конфигурации LILO выполнится автоматически. </para>
<para/>
<para/>
<para>Переходите к перезагрузке системы. </para>
<para/></sect3><sect3><title>10.d. Перезагрузка системы</title>
<para/>
<para>Выйдите из изолированной среды и размонтируйте все смонтированные разделы. Затем введите ту самую волшебную команду, которую вы так заждались: reboot. </para>
<para/>
<para>Листинг 14: Размонтирование всех разделов и перезагрузка</para>
<para># exit</para>
<para>cdimage ~# cd</para>
<para>cdimage ~# umount /mnt/gentoo/boot /mnt/gentoo/dev /mnt/gentoo/proc /mnt/gentoo</para>
<para>cdimage ~# reboot</para>
<para/>
<para/>
<para>Естественно, не забудьте вынуть загрузочный компакт-диск, иначе он загрузится сам вместо вашей новой системы Gentoo. </para>
<para/>
<para>Загрузив вновь установленную систему, переходите к завершению установки Gentoo. </para></sect3></sect2><sect2><title>11. Завершение установки Gentoo</title>
<para/><sect3><title>11.a. Управление учетными записями</title>
<para/>
<para>Добавление учетной записи для повседневной работы</para>
<para/>
<para>Работа в учетной записи root (администратора) в системе Unix/Linux опасна, и ее следует всячески избегать. Поэтому настоятельно рекомендуется добавить учетную запись пользователя для повседневной работы. </para>
<para/>
<para>Членством пользователя в группах определяется, какие действия он сможет выполнять. В следующей таблице перечислено несколько важных групп, в которые вы, возможно, захотите включать пользователей. </para>
<para/>
<para/>
<para>Группа                               Описание</para>
<para>  audio        возможность доступа к аудиоустройствам</para>
<para> cdrom        возможность прямого доступа к оптическим накопителям</para>
<para>  floppy        возможность прямого доступа к гибким дискам</para>
<para> games        возможность играть в игры </para>
<para> portage        возможность использования emerge --pretend с правами пользователя </para>
<para>    usb          возможность доступа к устройствам USB </para>
<para> plugdev        возможность монтирования и использования подключаемых устройств                      типа камер и USB-брелков </para>
<para>  video        возможность доступа к средствам видеозахвата и выполнения                              аппаратного ускорения видео </para>
<para>  wheel        возможность использования команды su </para>
<para/>
<para/>
<para>Например, для создания учетной записи пользователя по имени john, входящего в группы wheel, users и audio, сначала войдите в систему как root (только root может создавать учетные записи пользователей), а затем запустите useradd: </para>
<para/>
<para>Листинг 1: Создание учетной записи на каждый день</para>
<para>Login: root</para>
<para>Password: (ваш пароль root)</para>
<para/>
<para># useradd -m -G users,wheel,audio -s /bin/bash john</para>
<para># passwd john</para>
<para>Password: (введите пароль для john)</para>
<para>Re-enter password: (повторно введите пароль для подтверждения)</para>
<para/>
<para/>
<para>Если пользователю потребуется выполнить задачу от имени root, для временного получения привилегий root можно использовать su -. Другой способ — пользоваться пакетом sudo, который при правильной настройке вполне безопасен. </para></sect3></sect2><sect2><title>12. Чем заняться дальше?</title><sect3><title>12.a. Документация</title>
<para/>
<para>Примите поздравления! У вас теперь появилась работающая система Gentoo. И что же делать дальше? Какие у вас появились возможности? На что стоит взглянуть прежде всего? Gentoo дает своим пользователям богатый выбор возможностей, а следовательно — и множество документированных (или не очень) свойств. </para>
<para/>
<para>Вам обязательно нужно прочитать следующую часть настольной книги Gentoo, работа в Gentoo, в которой рассказывается, как поддерживать программное обеспечение в актуальном состоянии, как до устанавливать программы, что такое «USE-флаги», как происходит инициализация в Gentoo и т.д. </para>
<para/>
<para>Если вас интересует оптимизация системы с точки зрения пользователя, или вы хотите узнать, как настроить полноценный «рабочий стол», обратитесь к более подробной документации по графической среде Gentoo. Кроме того, вы, возможно захотите прочитать наше руководство по локализации (англ.), что бы чувствовать себя более уютно.</para>
<para> </para>
<para>Примечание: В настоящее время для русификации рекомендуется пользоваться альтернативными руководствами по локализации Gentoo. — прим. пер. </para>
<para/>
<para/>
<para>Также имеется настольная книга по безопасности в Gentoo (англ.), которую определенно стоит прочитать. </para>
<para/>
<para>Полный список существующих материалов имеется на странице документации. </para>
<para/></sect3><sect3><title>12.b. Gentoo в интернете</title>
<para/>
<para>Естественно, мы всегда рады видеть вас на форумах Gentoo (англ.), как и на любом из множества IRC-каналов Gentoo (англ.). </para>
<para/>
<para>Кроме того, мы можем предложить вашему вниманию несколько списков рассылки, открытых для всех наших пользователей. Сведения о порядке подписки находятся на той же странице. </para>
<para/>
<para>На этом мы замолкаем, чтобы позволить вам в полной мере насладиться результатом установки :) </para>
<para/>
<para/></sect3></sect2><sect2><title>B. Работа с Gentoo</title></sect2><sect2><title>1. Введение в Portage</title>
<para/><sect3><title>1.a. Добро пожаловать в Portage</title>
<para/>
<para>Система Portage — вероятно, самое известное нововведение Gentoo в управлении программным обеспечением. Благодаря высокой гибкости и чрезвычайно богатым возможностям, она зачастую считается лучшим средством управления программным обеспечением из существующих в Linux. </para>
<para/>
<para>Portage полностью написана на Python и Bash, и в результате полностью прозрачна для пользователей, поскольку оба — языки сценариев. </para>
<para/>
<para>Большинство пользователей взаимодействует с Portage с помощью команды emerge. Эта глава не призвана заменить страницу справки emerge. Для просмотра всех возможных параметров команды emerge, обращайтесь к странице справки: </para>
<para/>
<para>Листинг 1: Чтение страницы справки emerge</para>
<para>$ man emerge</para>
<para/></sect3><sect3><title>1.b. Дерево портежей</title>
<para/>
<para>Сборочные файлы ebuild</para>
<para/>
<para>Говоря о пакетах, мы часто имеем в виду программы, доступные пользователям Gentoo через дерево портежей. Дерево портежей — это набор сборочных файлов ebuild, содержащих всю информацию, необходимую Portage для управления программным обеспечением (установки, поиска, извлечения и т.п.) По умолчанию сборочные файлы находятся в /usr/portage. </para>
<para/>
<para>Когда Portage по вашему поручению выполняет любые действия над пакетами программ, эти действия опираются на сборочные файлы, имеющиеся в системе. Поэтому необходимо регулярно обновлять сборочные файлы, чтобы Portage знала о новых программах, обновлениях, связанных с безопасностью и т.д. </para>
<para/>
<para>Обновление дерева портежей</para>
<para/>
<para>Дерево портежей обычно обновляется с помощью rsync (англ.), средства быстрой разностной передачи файлов. Обновление выполнить довольно просто, так как запуск rsync обеспечивается командой emerge : </para>
<para/>
<para>Листинг 2: Обновление дерева портежей</para>
<para># emerge --sync</para>
<para/>
<para/>
<para>Если rsync выполнить невозможно из-за ограничений межсетевого экрана, дерево портежей все-таки можно обновить из ежедневных «снимков», создаваемых нами. Для автоматического извлечения и установки в системе новейшего снимка служит утилита emerge-webrsync: </para>
<para/>
<para>Листинг 3: Запуск emerge-webrsync</para>
<para># emerge-webrsync</para>
<para/></sect3><sect3><title>1.c. Обслуживание программного обеспечения</title>
<para/>
<para>Поиск программ</para>
<para/>
<para>Для поиска программ в дереве портежей по названию можно использовать встроенные возможности команды emerge. По умолчанию команда emerge --search выдает названия пакетов, соответствующих (как полностью, так и частично) заданному условию поиска. </para>
<para/>
<para>Например, чтобы найти все пакеты, содержащие «pdf» в названии: </para>
<para/>
<para>Листинг 4: Поиск пакетов с pdf в названии</para>
<para>$ emerge --search pdf</para>
<para/>
<para/>
<para>Для поиска пакетов еще и по тексту описания можно использовать параметр --searchdesc (или -S): </para>
<para/>
<para>Листинг 5: Поиск пакетов, связанных с pdf</para>
<para>$ emerge --searchdesc pdf</para>
<para/>
<para/>
<para>Посмотрев на сообщения команды, вы отметите, что вам дается множество информации. Поля четко обозначены, поэтому мы не будем вдаваться в подробности их значения: </para>
<para/>
<para>Листинг 6: Пример вывода emerge --search</para>
<para>*  net-print/cups-pdf</para>
<para>      Latest version available: 1.5.2</para>
<para>      Latest version installed: [ Not Installed ]</para>
<para>      Size of downloaded files: 15 kB</para>
<para>      Homepage:    http://cip.physik.uni-wuerzburg.de/~vrbehr/cups-pdf/</para>
<para>      Description: Provides a virtual printer for CUPS to produce PDF files.</para>
<para>      License:     GPL-2</para>
<para/>
<para>(</para>
<para>*  net-print/cups-pdf</para>
<para>      Последняя доступная версия: 1.5.2</para>
<para>      Последняя установленная версия: [ не установлен ]</para>
<para>      Размер загружаемых файлов: 15 kB</para>
<para>      Веб-страница:  http://cip.physik.uni-wuerzburg.de/~vrbehr/cups-pdf/</para>
<para>      Описание:      Снабжает CUPS виртуальным принтером для печати PDF-файлов.</para>
<para>      Лицензия:      GPL-2 )</para>
<para/>
<para/>
<para>Примечание (JohnBat26): Для более быстрого поиска программ используйте утилиту: eix (установка emerge eix). Она работает быстрее благодаря индексированию. Не забывайте запускать update-eix после emerge —sync ;)</para>
<para/>
<para>Установка программ</para>
<para/>
<para>После того, как вы нашли нужное программное обеспечение, его можно легко установить с помощью команды emerge. Вот пример установки пакета gnumeric: </para>
<para/>
<para>Листинг 7: Установка gnumeric</para>
<para># emerge gnumeric</para>
<para/>
<para/>
<para>Так как множество приложений зависит друг от друга, любая попытка установить какой-либо пакет программ может повлечь за собой также установку дополнительных пакетов. Не беспокойтесь, Portage справится и с этим. Если вы захотите выяснить, что именно Portage собирается установить вместе с нужным вам пакетом, добавьте параметр --pretend. Например: </para>
<para/>
<para>Листинг 8: Проверка зависимостей пакета gnumeric</para>
<para># emerge --pretend gnumeric</para>
<para/>
<para/>
<para>После команды на установку пакета, Portage загружает из интернета необходимый исходный код (при необходимости), и по умолчанию сохраняет его в каталоге /usr/portage/distfiles. После этого пакет распаковывается, компилируется и устанавливается. Если вы хотите, чтобы Portage только загрузила исходный код без его установки, добавьте к команде emerge параметр --fetchonly: </para>
<para/>
<para>Листинг 9: Загрузка исходного кода пакета gnumeric</para>
<para># emerge --fetchonly gnumeric</para>
<para/>
<para/>
<para>Обнаружение документации к пакету</para>
<para/>
<para>Многие пакеты содержат собственную документацию. Иногда USE-флаг doc определяет, следует ли устанавливать документацию к пакету. Проверить наличие USE-флага doc можно командой emerge -vp &lt;название пакета&gt;. </para>
<para/>
<para>Листинг 10: Проверка наличия USE-флага doc</para>
<para>(alsa-lib - это всего лишь пример)</para>
<para># emerge -vp alsa-lib</para>
<para>[ebuild  N    ] media-libs/alsa-lib-1.0.9_rc3  +doc -jack 674 kB</para>
<para/>
<para/>
<para>USE-флаг doc можно включить или отключить как глобально в файле /etc/make.conf, так и для отдельных пакетов в файле /etc/portage/package.use. Также можно, создав каталог с названием /etc/portage/package.use, указать флаг в файле внутри этого каталога. В главе USE-флаги этот вопрос описывается более подробно. </para>
<para/>
<para>Документация от вновь установленного пакета обычно находится в подкаталоге каталога /usr/share/doc, соответствующем названию пакета. Кроме того, можно вывести список всех установленных файлов утилитой equery, которая входит в пакет gentoolkit (англ.) — app-portage/gentoolkit. </para>
<para/>
<para>Листинг 11: Обнаружение документации пакета</para>
<para># ls -l /usr/share/doc/alsa-lib-1.0.9_rc3</para>
<para>total 28</para>
<para>-rw-r--r--  1 root root  669 May 17 21:54 ChangeLog.gz</para>
<para>-rw-r--r--  1 root root 9373 May 17 21:54 COPYING.gz</para>
<para>drwxr-xr-x  2 root root 8560 May 17 21:54 html</para>
<para>-rw-r--r--  1 root root  196 May 17 21:54 TODO.gz</para>
<para/>
<para>(или используйте для поиска интересных файлов команду equery :)</para>
<para># equery files alsa-lib | less</para>
<para>media-libs/alsa-lib-1.0.9_rc3</para>
<para>* Contents of media-libs/alsa-lib-1.0.9_rc3:</para>
<para>/usr</para>
<para>/usr/bin</para>
<para>/usr/bin/alsalisp</para>
<para>(выдача обрезана)</para>
<para/>
<para/>
<para>Удаление пакета</para>
<para/>
<para>Когда вы захотите удалить пакет из системы, используйте команду emerge --unmerge. Это приведет к удалению из системы всех файлов, установленных пакетом, кроме конфигурационных файлов приложения, изменявшихся после установки. Сохранение конфигурационных файлов позволяет вернуться к работе с пакетом, если вы когда-нибудь решите снова его установить.</para>
<para/>
<para>Внимание: Portage не проверяет, зависят ли другие пакеты от удаляемого! Однако вы получите предупреждение, если удаление пакета приведет к неработоспособности системы. </para>
<para/>
<para>Листинг 12: Удаление пакета gnumeric из системы</para>
<para># emerge --unmerge gnumeric</para>
<para/>
<para/>
<para>После удаления пакета из системы, пакеты, установленные автоматически, потому что от них зависел удаленный пакет, остаются. Чтобы Portage выявила все когда-то нужные пакеты, которые теперь можно удалить, используйте команду emerge --depclean. Мы вернемся к этому ниже. </para>
<para/>
<para>Обновление системы</para>
<para/>
<para>Чтобы система сохранялась в отличной форме (не говоря уже об установке свежайших обновлений, связанных с безопасностью), ее нужно регулярно обновлять. Так как Portage просматривает сборочные файлы только в локальном дереве портежей, сперва потребуется обновить его. Обновив дерево портежей, вы сможете обновить систему командой emerge --update world. В следующем примере мы также пользуемся параметром --ask, который поручает Portage вывести список пакетов, которые она собирается обновить, и спросить вас, можно ли продолжать:</para>
<para/>
<para>Листинг 13: Обновление системы</para>
<para># emerge --update --ask world</para>
<para/>
<para/>
<para>Portage будет искать более новые версии установленных приложений. Однако проверяется только версии приложений, явно установленных вами, а не тех, от которых они зависят. Если вы хотите обновить каждый пакет в системе, добавьте аргумент --deep: </para>
<para/>
<para>Листинг 14: Обновление всей системы</para>
<para># emerge --update --deep world</para>
<para/>
<para/>
<para>Поскольку обновления, относящиеся к безопасности, случаются и в пакетах, явным образом не устанавливались (но были «подтянуты» из-за того, что он них зависят другие программы), рекомендуется изредка запускать эту команду. </para>
<para/>
<para>Если вы меняли какие-либо из USE-флагов, возможно, потом вы также захотите добавить параметр --newuse. Тогда Portage проверит, требует ли изменение установки новых пакетов или перекомпиляции существующих: </para>
<para/>
<para>Листинг 15: Выполнение полного обновления</para>
<para># emerge --update --deep --newuse world</para>
<para/>
<para/>
<para>Метапакеты</para>
<para/>
<para>У некоторых пакетов в дереве портежей нет содержимого как такового, и они используются для установки набора других пакетов. Например, пакет kde полностью устанавливает среду KDE в вашей системе, привлекая различные KDE-пакетов в качестве зависимостей. </para>
<para/>
<para>Если вы когда-либо захотите удалить из системы такой пакет, запуск emerge--unmerge не возымеет должного эффекта, так как пакеты, от которых он зависит, останутся в системе. </para>
<para/>
<para>В Portage существует возможность удаления остаточных зависимостей, но так как зависимости программ меняются со временем, доступность программного обеспечения, прежде всего требуется полностью обновить всю систему, включая реализацию изменений, произведенных путем модификации USE-флагов. После этого можно запустить emerge --depclean, чтобы удалить остаточные зависимости. Когда это сделано, вам потребуется пересобрать приложения, ранее динамически связанные с удаленными пакетами, в которых они теперь не нуждаются. </para>
<para/>
<para>Со всем этим управляются следующие три команды: </para>
<para/>
<para>Листинг 16: Удаление ненужных зависимостей</para>
<para># emerge --update --deep --newuse world</para>
<para># emerge --depclean</para>
<para># revdep-rebuild</para>
<para/>
<para/>
<para>revdep-rebuild входит в пакет gentoolkit; не забудьте сначала его установить: </para>
<para/>
<para>Листинг 17: Установка пакета gentoolkit</para>
<para># emerge gentoolkit</para>
<para/></sect3><sect3><title>1.d. Когда Portage жалуется...</title>
<para/>
<para>Слоты, виртуалы, ветви, архитектуры и профили</para>
<para/>
<para>Как уже сказано, Portage — чрезвычайно мощная система, поддерживающая множество возможностей, не хватающих другим системам управления программами. Чтобы это стало понятно, разберем несколько аспектов Portage, не вникая в подробности. </para>
<para/>
<para>С помощью Portage разные версии отдельного пакета могут сосуществовать в одной системе. В то время, как другие системы управления стремятся называть пакеты в соответствии с версией (например freetype и freetype2), в Portage используется технология слотов (SLOT), или областей. Пакет присваивает определенный слот своей версии. Пакеты с разными слотами способны сосуществовать в одной системе. Например, у пакета freetype есть ebuild как со SLOT="1", так и со SLOT="2". </para>
<para/>
<para>Существуют также пакеты, выполняющие одни и те же функции, но отличающиеся в реализации. Например metalogd, sysklogd и syslog-ng являются системными службами журналирования. Приложения, использующие «системный журнал», не могут зависеть от одной конкретной программы, например от metalogd, так как остальные программы ничем не хуже. В Portage предусмотрены виртуальные пакеты: каждая служба журналирования предоставляет virtual/syslog, и в результате в приложениях можно указывать зависимость от virtual/syslog. </para>
<para/>
<para>Программное обеспечение может располагаться в различных ветвях дерева портежей. По умолчанию в системе разрешено только использование стабильных пакетов. Большинство новых программ при поступлении включаются в тестовую ветвь, что указывает на необходимость дополнительного тестирования перед тем, как включить их в стабильные. Хотя в дереве портежей и видны сборочные файлы для таких программ, Portage не станет обновлять их до тех пор, пока они не будут помещены в стабильную ветвь. </para>
<para/>
<para>Некоторые программы имеются не для всех архитектур. Либо они не работают в определенных архитектурах, либо требуют дополнительного тестирования, или у разработчика нет возможности проверить, работает ли пакет в различных архитектурах. </para>
<para/>
<para>Каждая установка Gentoo придерживается определенного профиля, который содержит, помимо прочего, список пакетов, необходимых для работоспособности системы. </para>
<para/>
<para>Блокировка пакетов</para>
<para/>
<para>Листинг 18: Предупреждение о заблокированных пакетах (с --pretend)</para>
<para>[blocks B     ] mail-mta/ssmtp (is blocking mail-mta/postfix-2.2.2-r1)</para>
<para/>
<para/>
<para>Листинг 19: Предупреждение о заблокированных пакетах (без --pretend)</para>
<para>!!! Error: the mail-mta/postfix package conflicts with another package.</para>
<para>!!!        both can't be installed on the same system together.</para>
<para>!!!        Please use 'emerge --pretend' to determine blockers.</para>
<para/>
<para>( !!! Ошибка: пакет mail-mta/postfix конфликтует с другим пакетом.</para>
<para>  !!! оба не могут находиться в системе одновременно. Пожалуйста,</para>
<para>  !!! запустите 'emerge --pretend' для выявления блокирующих пакетов. )</para>
<para/>
<para/>
<para>В файлах ebuild есть специальные поля, сообщающие Portage о зависимостях. Возможны два вида зависимости: зависимость сборки, объявленная в DEPEND, и зависимость выполнения, объявленная в RDEPEND. Когда одна из этих зависимостей явно указывает на несовместимость пакета или виртуального пакета, это вызывает блокировку. </para>
<para/>
<para>Для разблокировки можно отказаться от установки пакета или предварительно удалить конфликтующего пакета. В данном примере можно отказаться от установки postfix или сначала удалить ssmtp. </para>
<para/>
<para>Также возможно, что два пакета, подлежащие установке, блокируют друг друга. В этом редчайшем случае следует определить, зачем вам устанавливать оба пакета. В большинстве случаев можно обойтись одним. Если это окажется не так, то, пожалуйста, заведите отчет об ошибке в системе распределения запросов Gentoo. </para>
<para/>
<para>Маскировка пакетов</para>
<para/>
<para>Листинг 20: Предупреждение о замаскированных пакетах</para>
<para>!!! all ebuilds that could satisfy "bootsplash" have been masked.</para>
<para/>
<para>(!!! все сборки, удовлетворяющие "bootsplash", замаскированы.)</para>
<para/>
<para>Листинг 21: Предупреждение о замаскированных пакетах с указанием причины</para>
<para>!!! possible candidates are:</para>
<para/>
<para>- gnome-base/gnome-2.8.0_pre1 (masked by: ~x86 keyword)</para>
<para>- lm-sensors/lm-sensors-2.8.7 (masked by: -sparc keyword)</para>
<para>- sys-libs/glibc-2.3.4.20040808 (masked by: -* keyword)</para>
<para>- dev-util/cvsd-1.0.2 (masked by: missing keyword)</para>
<para>- media-video/ati-gatos-4.3.0 (masked by: package.mask)</para>
<para>- sys-libs/glibc-2.3.2-r11 (masked by: profile)</para>
<para/>
<para>( !!! возможные кандидаты:</para>
<para/>
<para>- gnome-base/gnome-2.8.0_pre1 (маскировка: ключ ~x86)</para>
<para>- lm-sensors/lm-sensors-2.8.7 (маскировка: ключ -sparc)</para>
<para>- sys-libs/glibc-2.3.4.20040808 (маскировка: ключ -*)</para>
<para>- dev-util/cvsd-1.0.2 (маскировка: ключ отсутствует)</para>
<para>- media-video/ati-gatos-4.3.0 (маскировка: package.mask)</para>
<para>- sys-libs/glibc-2.3.2-r11 (маскировка: profile) )</para>
<para/>
<para/>
<para>Когда вы собираетесь установить пакет, не предназначенный для вашей системы, выдается ошибка маскировки. Нужно попытаться установить другую программу, существующую для вашей системы, или дождаться, пока пакет станет доступным. Всегда есть причина, по которой пакет замаскирован: </para>
<para/>
<orderedlist>
<listitem>
<para>ключ ~arch: пакет недостаточно проверен для помещения в стабильную ветвь. Подождите несколько дней или недель и попробуйте установить его еще раз; </para>
</listitem>
<listitem>
<para>ключ -arch или ключ -*: пакет не работоспособен в вашей архитектуре. Если вы полагаете, что он работает, сообщите об этом в bugzilla;</para>
</listitem>
<listitem>
<para>ключ отсутствует: пакет еще не тестировался в вашей архитектуре. Попросите группу портирования в архитектуру проверить пакет, или протестируйте его за них и сообщите о своих изысканиях в bugzilla;</para>
</listitem>
<listitem>
<para>package.mask: обнаружено повреждение пакета, нестабильность или что-то худшее, и пакет заблокирован специально; </para>
</listitem>
<listitem>
<para>profile: пакет считается не предназначенным для вашего профиля. В случае установки приложение может вызвать сбой системы или просто несовместимо с используемым профилем. </para>
</listitem>
</orderedlist>
<para/>
<para>Отсутствие нужных пакетов</para>
<para/>
<para>Листинг 22: Предупреждение об отсутствии пакета</para>
<para>emerge: there are no ebuilds to satisfy "&gt;=sys-devel/gcc-3.4.2-r4".</para>
<para/>
<para>!!! Problem with ebuild sys-devel/gcc-3.4.2-r2</para>
<para>!!! Possibly a DEPEND/*DEPEND problem.</para>
<para/>
<para>( emerge: нет сборок, удовлетворяющих "&gt;=sys-devel/gcc-3.4.2-r4".</para>
<para/>
<para>  !!! Проблема с ebuild sys-devel/gcc-3.4.2-r2</para>
<para>  !!! Возможно, ошибка в DEPEND/*DEPEND. )</para>
<para/>
<para/>
<para>Приложение, которое вы пытаетесь установить, зависит от другого пакета, недоступного вашей системе. Пожалуйста, проверьте, есть ли такой запрос в bugzilla, а если нет, сообщите об ошибке. Если вы не смешиваете ветви, такого не должно происходить, и это — явная ошибка.</para>
<para/>
<para/>
<para/>
<para/>
<para/>
<para>Неоднозначность названия пакета</para>
<para/>
<para>Листинг 23: Предупреждение о повторяющихся именах ebuild</para>
<para>!!! The short ebuild name "aterm" is ambiguous.  Please specify</para>
<para>!!! one of the following fully-qualified ebuild names instead:</para>
<para/>
<para>    dev-libs/aterm</para>
<para>    x11-terms/aterm</para>
<para/>
<para>( !!! Короткое название ebuild "aterm" неоднозначно. Пожалуйста, </para>
<para>  !!! вместо него укажите одно из полных названий ebuild:</para>
<para/>
<para>      dev-libs/aterm</para>
<para>      x11-terms/aterm )</para>
<para/>
<para/>
<para>Название приложения, которое вы собираетесь установить, соответствует более чем одному пакету. Требуется также указать название категории. Portage предложит вам возможные варианты. </para>
<para/>
<para>Циклические зависимости</para>
<para/>
<para>Листинг 24: Предупреждение Portage о циклических зависимостях</para>
<para>!!! Error: circular dependencies:</para>
<para/>
<para>ebuild / net-print/cups-1.1.15-r2 depends on ebuild /</para>
<para>app-text/ghostscript-7.05.3-r1</para>
<para>ebuild / app-text/ghostscript-7.05.3-r1 depends on ebuild /</para>
<para>net-print/cups-1.1.15-r2</para>
<para/>
<para>( !!! Ошибка: циклические зависимости:</para>
<para/>
<para>  ebuild / net-print/cups-1.1.15-r2 зависит от ebuild /</para>
<para>  app-text/ghostscript-7.05.3-r1</para>
<para>  ebuild / app-text/ghostscript-7.05.3-r1 зависит от ebuild /</para>
<para>  net-print/cups-1.1.15-r2   )</para>
<para/>
<para/>
<para>Два или более пакета, которые вы хотите установить, взаимно зависимы, и в результате их установка невозможна. Скорее всего, это ошибка в дереве портежей. Пожалуйста, выждав время, обновите дерево портежей, и попытайтесь снова. Вы можете также проверить, есть ли эта ошибка в bugzilla, и если нет, сообщить о ней. </para>
<para/>
<para>Ошибка извлечения</para>
<para/>
<para>Листинг 25: Предупреждение Portage об ошибке извлечения</para>
<para>!!! Fetch failed for sys-libs/ncurses-5.4-r5, continuing...</para>
<para>(...)</para>
<para>!!! Some fetch errors were encountered.  Please see above for details.</para>
<para/>
<para>( !!! Ошибка при извлечении sys-libs/ncurses-5.4-r5, продолжение...</para>
<para>  (...)</para>
<para>!!! При извлечении произошли ошибки.  Подробности выше. )</para>
<para/>
<para/>
<para>Portage не смогла загрузить исходный код данного приложения и попытается продолжить установку других приложений (если запланирована). Эта ошибка может произойти из-за неправильно синхронизированного зеркала, или из-за того, что ebuild указывает на неверное место. Сервер, где находятся исходные коды, также может почему-либо не работать. </para>
<para/>
<para>Повторите действие через час, чтобы посмотреть, повторится ли эта ошибка. </para>
<para/>
<para>Защита системного профиля</para>
<para/>
<para>Листинг 26: Предупреждение Portage о пакете, защищенном профилем</para>
<para>!!! Trying to unmerge package(s) in system profile. 'sys-apps/portage'</para>
<para>!!! This could be damaging to your system.</para>
<para/>
<para>( !!! Попытка удаления пакетов из системного профиля. 'sys-apps/portage'</para>
<para>  !!! Это может повредить вашей системе. )</para>
<para/>
<para/>
<para>Вы попросили удалить пакет, входящий в состав базовых пакетов вашей системы. Он отмечен в вашем профиле как обязательный, и его не следует удалять из системы. </para></sect3></sect2><sect2><title>2. USE-флаги</title><sect3><title>2.a. Что такое USE-флаги?</title>
<para/>
<para>Смысл USE-флагов</para>
<para/>
<para>Устанавливая Gentoo (или любой другой дистрибутив, или даже операционную систему вообще), вы выбираете те или иные возможности в зависимости от среды, с которой работаете. Установка сервера отличается от установки рабочей станции, а установка игровой станции — от платформы 3D-рендеринга. </para>
<para/>
<para>Это касается не только того, какие пакеты устанавливать, но и какие функции определенных пакетов должны поддерживаться. Если вам не нужен OpenGL, то зачем вам его ставить и встраивать поддержку OpenGL в большинство программ? Если вы не собираетесь использовать KDE, зачем собирать пакеты с его поддержкой, если они работают и без этого? </para>
<para/>
<para>Чтобы помочь пользователям в выборе того, что устанавливать/активировать, а что — нет, мы захотели дать им простой способ описания рабочей среды. Это позволяет пользователю решить, что же ему на самом деле надо, и облегчить работу с Portage, нашей системой управления пакетами. </para>
<para/>
<para>Определение USE-флагов</para>
<para/>
<para>Рассмотрим USE-флаги. USE-флаг — это ключевое слово, включающее сведения о поддержке и зависимостях определенного понятия или функции. При определении какого-либо USE-флага, Portage узнает, что вам нужна поддержка соответствующей функции. Конечно, это также влияет на сведения о зависимостях пакета. </para>
<para/>
<para>Давайте рассмотрим конкретный пример — ключевое слово kde. Если в вашей переменной USE нет этого слова, то все пакеты, где поддержка KDE является необязательной, собираются без нее. Все пакеты, где зависимость от KDE является необязательной, устанавливаются без установки библиотек KDE (по зависимости). Если же вы определите ключевое слово kde, то эти пакеты будут собираться с поддержкой KDE, а KDE будет установлен в качестве необходимого. </para>
<para/>
<para>Правильно определяя ключевые слова, вы создаете систему, подогнанную специально для ваших нужд. </para>
<para/>
<para>Какие USE-флаги существуют?</para>
<para/>
<para>Есть два типа USE-флагов: глобальные и локальные. </para>
<para>Глобальный USE-флаг используется несколькими пакетами и является системным. Это то, что большинство видит в качестве USE-флагов. </para>
<para>Локальный USE-флаг используется единичным пакетом для настройки определенных параметров самого пакета. </para>
<para/>
<para>Список доступных глобальных USE-флагов можно найти в сети или локально в /usr/portage/profiles/use.desc. </para>
<para/>
<para>Список локальных USE-флагов находится в вашей системе в /usr/portage/profiles/use.local.desc. </para>
<para/>
<para>Примечание (JohnBat26): Для удобной установки и чтения описаний USE флагов используйте программу: Use Flag  EDitor или ufed (emerge ufed)</para>
<para/></sect3><sect3><title>2.b. Использование USE-флагов</title>
<para/>
<para>Объявление постоянных USE-флагов</para>
<para/>
<para>В надежде, что вы убедились в важности USE-флагов, теперь мы расскажем, как их объявлять. </para>
<para/>
<para>Как сказано ранее, все USE-флаги объявляются в переменной USE. Чтобы упростить пользователям поиск и выбор флагов, мы предлагаем значение USE по умолчанию, которое представляют собой список USE-флагов, как нам кажется, наиболее часто используемых пользователями Gentoo. Это значение приведено в файле make.defaults вашего профиля. </para>
<para/>
<para>Профиль, на который ориентируется ваша система, указывается символьной ссылкой /etc/make.profile. Каждый профиль основывается на предыдущем, более крупном, а итоговый складывается из всех профилей. Верхним является базовый профиль (/usr/portage/profiles/base). </para>
<para/>
<para>Давайте взглянем на значение по умолчанию для профиля 2004.3: </para>
<para/>
<para>Листинг 1: Итоговая переменная USE make.defaults для профиля 2004.3</para>
<para>(в этом примере объединяются значения из base, default-linux,</para>
<para>default-linux/x86 и default-linux/x86/2004.3)</para>
<para>USE="x86 oss apm arts avi berkdb bitmap-fonts crypt cups encode fortran f77</para>
<para>     foomaticdb gdbm gif gpm gtk imlib jpeg kde gnome libg++ libwww mad</para>
<para>     mikmod motif mpeg ncurses nls oggvorbis opengl pam pdflib png python qt</para>
<para>     quicktime readline sdl spell ssl svga tcpd truetype X xml2 xmms xv zlib"</para>
<para/>
<para/>
<para>Как видите, эта переменная уже содержит достаточно много ключевых слов. Не меняйте файл make.defaults для настройки переменной USE под свои нужды: изменения в этом файле аннулируются при обновлении Portage! </para>
<para/>
<para>Для изменения значения по умолчанию, нужно добавлять или удалять ключевые слова из переменной USE. Это делается глобально, определением переменной USE в /etc/make.conf. В эту переменную можно добавить нужные вам USE-флаги, или удалить ненужные. Для удаления флага, его надо указывать со знаком минус в виде приставки («-»). </para>
<para/>
<para>Например, чтобы убрать поддержку KDE и QT, но добавить поддержку ldap, можно определить в /etc/make.conf переменную USE следующего вида: </para>
<para/>
<para>Листинг 2: Пример значения USE в /etc/make.conf</para>
<para>USE="-kde -qt ldap"</para>
<para/>
<para/>
<para>Объявление USE-флагов для отдельных пакетов</para>
<para/>
<para>Иногда нужно определить некоторые USE-флаги только для одного или нескольких пакетов, не трогая системных настроек. Для этого необходимо создать каталог /etc/portage (если его еще нет) и отредактировать файл /etc/portage/package.use. </para>
<para/>
<para>Например, вам не нужна глобальная поддержка berkdb, но она необходима в mysql: </para>
<para/>
<para>Листинг 3: Пример /etc/portage/package.use</para>
<para>dev-db/mysql berkdb</para>
<para/>
<para/>
<para>Естественно, можно в явном виде отключить USE-флаги для определенного пакета. Например, если вам не нужна поддержка java в PHP: </para>
<para/>
<para>Листинг 4: Второй пример /etc/portage/package.use</para>
<para>dev-php/php -java</para>
<para/>
<para/>
<para>Объявление временных USE-флагов</para>
<para/>
<para>Иногда необходимо установить какой-то USE-флаг только на один раз. Вместо того, чтобы дважды редактировать /etc/make.conf (сначала добавить изменения USE, а потом удалить), можно просто объявить USE как переменную среды. Помните, что при переустановке или обновлении приложения (явном или в составе обновления системы) ваши изменения будут утеряны! </para>
<para/>
<para>Например, уберем java из значения USE на время установки mozilla. </para>
<para/>
<para>Листинг 5: Использование USE в виде переменной среды</para>
<para># USE="-java" emerge mozilla</para>
<para/>
<para/>
<para>Наследование</para>
<para/>
<para>Конечно же, существует определенная последовательность формирования значения USE. Вы же не хотите объявить USE="-java" только для того, чтобы узнать, что java все еще включена из-за значения с более высоким приоритетом. Последовательность установки значения USE в порядке приоритета (от меньшего к большему) такова: </para>
<orderedlist>
<listitem>
<para>значение USE по умолчанию, объявленное в файлах make.defaults в составе вашего профиля; </para>
</listitem>
<listitem>
<para>значение, определенное пользователем в /etc/make.conf ;</para>
</listitem>
<listitem>
<para>значение, указанное пользователем в /etc/portage/package.use ;</para>
</listitem>
<listitem>
<para>значение, определенное пользователям в переменной среды.</para>
</listitem>
</orderedlist>
<para/>
<para>Чтобы узнать, какие же настройки USE в конечном счете видит Portage, запустите emerge --info. Эта команда выводит значения всех переменных (включая USE), используемые Portage. </para>
<para/>
<para>Листинг 6: Запуск emerge --info</para>
<para># emerge --info</para>
<para/>
<para/>
<para>Адаптация всей системы под новые USE-флаги</para>
<para/>
<para>Если вы изменили свои USE-флаги и хотите обновить всю систему в соответствии с новым значением USE, запустите emerge с параметром --newuse: </para>
<para/>
<para>Листинг 7: Пересборка всей системы</para>
<para># emerge --update -deep --newuse world</para>
<para/>
<para/>
<para>Теперь запустите функцию Portage depclean, чтобы удалить условные зависимости, присутствующие в «старой» системе, но больше не нужные при новом составе USE-флагов. </para>
<para>Предупреждение: Запуск emerge --depclean является опасной операцией, которую следует использовать с осторожностью. Дважды проверьте список «ненужных» пакетов и убедитесь, что не удалятся нужные пакеты. В следующем примере мы добавляем ключ -p, чтобы depclean только перечислил пакеты, не удаляя их. </para>
<para/>
<para/>
<para>Листинг 8: Удаление ненужных пакетов</para>
<para># emerge -p --depclean</para>
<para/>
<para/>
<para>Когда depclean закончит свою работу, запустите revdep-rebuild, чтобы пересобрать программы, динамически связанные с библиотеками, входящими в потенциально удаленные пакеты. revdep-rebuild входит в пакет gentoolkit, так что не забудьте сначала установить его. </para>
<para/>
<para>Листинг 9: Запуск revdep-rebuild</para>
<para># revdep-rebuild</para>
<para/>
<para/>
<para>После выполнения всех этих действий, ваша система будет полностью использовать новые значения USE-флагов. </para>
<para/></sect3><sect3><title>2.c. USE-флаги отдельных пакетов</title>
<para/>
<para>Просмотр доступных USE-флагов</para>
<para/>
<para>Возьмем, к примеру, mozilla — какие USE-флаги она может использовать? Чтобы это выяснить, запустим emerge с параметрами --pretend и --verbose: </para>
<para/>
<para>Листинг 10: Просмотр используемых USE флагов</para>
<para># emerge --pretend --verbose mozilla</para>
<para>These are the packages that I would merge, in order:</para>
<para/>
<para>Calculating dependencies ...done!</para>
<para>[ebuild   R   ] www-client/mozilla-1.7.12-r2  USE="crypt gnome java mozsvg ssl</para>
<para>truetype xprint -debug -ipv6 -ldap -mozcalendar -mozdevelop -moznocompose</para>
<para>-moznoirc -moznomail -moznoxft -postgres -xinerama" 0 kB</para>
<para/>
<para/>
<para>emerge — не единственное средство для решения этой задачи. Существует программа, специально предназначенная для вывода информация о пакетах. Она называется equery и находится в пакете gentoolkit. Для начала установим этот пакет: </para>
<para/>
<para/>
<para>Листинг 11: Установка gentoolkit</para>
<para># emerge gentoolkit</para>
<para/>
<para/>
<para>Теперь для просмотра USE-флагов какого-нибудь пакета запустим equery с аргументом uses. Пусть это будет пакет gnumeric: </para>
<para/>
<para>Листинг 12: Запуск equery для просмотра доступных USE-флагов</para>
<para># equery uses =gnumeric-1.6.3 -a</para>
<para>[ Searching for packages matching =gnumeric-1.6.3... ]</para>
<para>[ Colour Code : set unset ]</para>
<para>[ Legend        : Left column  (U) - USE flags from make.conf  ]</para>
<para>[               : Right column (I) - USE flags packages was installed with ]</para>
<para>[ Found these USE variables for app-office/gnumeric-1.6.3 ]</para>
<para> U I</para>
<para>- - debug   : Tells configure and the makefiles to build for debugging.</para>
<para>                     Effects vary across packages, but generally it will at</para>
<para>                     least add -g to CFLAGS.  Remember to set FEATURES=nostrip too </para>
<para>- - gnome   : Adds GNOME support</para>
<para>+ + python   : Adds support/bindings for the Python language</para>
<para>- - static   : !!do not set this during bootstrap!! Causes binaries to be</para>
<para>                     statically linked instead of dynamically</para>
<para/></sect3></sect2><sect2><title>3. Возможности Portage</title>
<para/><sect3><title>3.a. Возможности Portage</title>
<para/>
<para>В Portage есть несколько дополнительных возможностей (features), которые значительно улучшат ваше впечатление от Gentoo. Многие из этих возможностей полагаются на определенные программы, повышающие производительность, надежность, безопасность и т.п. </para>
<para/>
<para>Для включения и выключения определенных возможностей Portage нужно редактировать в файле /etc/make.conf переменную FEATURES, в которой перечислены ключевые слова, разделенные пробелами, обозначающие различные возможности. Иногда для использования соответствующих возможностей потребуется установка дополнительных утилит. </para>
<para/>
<para>Здесь перечислены не все возможности, поддерживаемые Portage. Полный перечень представлен на странице справки make.conf: </para>
<para/>
<para>Листинг 1: Вызов страницы справки make.conf</para>
<para>$ man make.conf</para>
<para/>
<para/>
<para>Чтобы узнать, какие возможности включены по умолчанию, запустите emerge --info и найдите переменную FEATURES (или отфильтруйте ее с помощью grep): </para>
<para/>
<para>Листинг 2: Выявление уже включенных возможностей</para>
<para>$ emerge --info | grep FEATURES</para>
<para/>
<para/></sect3><sect3><title>3.b. Распределенная компиляция</title>
<para/>
<para>Использование distcc</para>
<para/>
<para>distcc — программа, распределяющая компиляцию по нескольким, не обязательно одинаковым, машинам в сети. Клиент distcc посылает всю необходимую информацию на доступные серверы distcc (на которых выполняется distccd), чтобы они могли компилировать для клиента части исходного кода. Чистый выигрыш — более быстрая компиляция. </para>
<para/>
<para>Подробная информация о distcc (и как заставить его заработать в Gentoo) находится в нашем описании distcc в Gentoo. </para>
<para/>
<para>Установка distcc</para>
<para/>
<para>Distcc поставляется с графическим монитором (средством контроля), позволяющим отслеживать задачи, которые ваш компьютер отсылает на компиляцию. Если вы используете Gnome, тогда добавьте «gnome» к переменной USE. А если вы не пользуетесь Gnome, но при этом хотите пользоваться монитором, добавьте «gtk» к переменной USE. </para>
<para/>
<para>Листинг 3: Установка distcc</para>
<para># emerge distcc</para>
<para/>
<para/>
<para>Подключение поддержки Portage</para>
<para/>
<para>Добавьте distcc к переменной FEATURES в файле /etc/make.conf. Затем отредактируйте переменную MAKEOPTS, как вам нравится. Известная рекомендация — указывать директиву «-jX», где X — число центральных процессоров, на которых работает distccd (включая текущий компьютер) плюс один; у вас могут получиться лучшие результаты и с другими значениями. </para>
<para/>
<para>Теперь запустите distcc-config и введите список доступных серверов distcc. Для простоты примера, предположим, что доступные серверы DistCC — 192.168.1.102 (текущий компьютер), 192.168.1.103 и 192.168.1.104 (два «удаленных» компьютера): </para>
<para/>
<para>Листинг 4: Настройка distcc для использования трех доступных серверов distcc</para>
<para># distcc-config --set-hosts "192.168.1.102 192.168.1.103 192.168.1.104"</para>
<para/>
<para/>
<para>Не забудьте также запустить демон distccd: </para>
<para/>
<para>Листинг 5: Запуск демонов distccd</para>
<para># rc-update add distccd default</para>
<para># /etc/init.d/distccd start</para>
<para/>
<para/></sect3><sect3><title>3.c. Кэширование компиляции</title>
<para/>
<para>О средстве ccache</para>
<para/>
<para>ccache — это быстрый кэш компилятора. Когда вы компилируете программу, он кэширует промежуточные результаты так, что всякий раз, когда вы перекомпилируете ту же самую программу, время компиляции значительно сокращается. В типичных случаях общее время компиляции может сокращаться в 5—10 раз. </para>
<para/>
<para>Если вы интересуетесь подробностями ccache, пожалуйста, посетите домашнюю страницу ccache. </para>
<para/>
<para>Установка ccache</para>
<para/>
<para>Для установки ccache, выполните emerge ccache: </para>
<para/>
<para>Листинг 6: Установка ccache</para>
<para># emerge ccache</para>
<para/>
<para/>
<para>Подключение поддержки Portage</para>
<para/>
<para>Откройте /etc/make.conf и добавьте ccache к переменной FEATURES. Затем добавьте новую переменную по имени CCACHE_SIZE (размер кэша), и установите её равной «2G»: </para>
<para/>
<para>Листинг 7: Редактирование CCACHE_SIZE в /etc/make.conf</para>
<para>CCACHE_SIZE="2G"</para>
<para/>
<para/>
<para>Для проверки работоспособности ccache, запросите статистику ccache. Из-за того, что Portage использует другой домашний каталог ccache, вам также потребуется установить переменную CCACHE_DIR: </para>
<para/>
<para>Листинг 8: Просмотр статистики ccache</para>
<para># CCACHE_DIR="/var/tmp/ccache" ccache -s</para>
<para/>
<para/>
<para>Домашний каталог ccache по умолчанию — /var/tmp/ccache; изменить это назначение можно, определив переменную CCACHE_DIR в /etc/make.conf. </para>
<para/>
<para>Однако, при запуске ccache используется каталог по умолчанию, ${HOME}/.ccache, вот почему при запросе статистики (Portage) ccache требуется определять переменную CCACHE_DIR. </para>
<para/>
<para>Использование ccache для компиляции Си не в Portage</para>
<para/>
<para>Если вы хотите использовать ccache для компиляций не в Portage, добавьте /usr/lib/ccache/bin в начало вашей переменной PATH (перед /usr/bin). Это можно сделать, отредактировав /etc/env.d/00basic, который является первым файлом среды, где определяется переменная PATH: </para>
<para/>
<para>Листинг 9: Редактирование /etc/env.d/00basic</para>
<para>PATH="/usr/lib/ccache/bin:/opt/bin"</para>
<para/></sect3><sect3><title>3.d. Поддержка двоичных пакетов</title>
<para/>
<para>Создание готовых (заранее собранных) пакетов</para>
<para/>
<para>Portage поддерживает установку заранее собранных готовых пакетов. Несмотря на то, что в саму Gentoo не входят заранее собранные пакеты (за исключением снимков GRP), Portage можно настроить на полноценное управление готовыми пакетами. </para>
<para/>
<para>Чтобы создать двоичный пакет, можно использовать quickpkg, если пакет уже установлен в вашей системе, или emerge с параметрами --buildpkg или --buildpkgonly. </para>
<para/>
<para>Если вы хотите, чтобы Portage создавал двоичные пакеты из каждого пакета, который вы будете устанавливать, добавьте buildpkg к переменной FEATURES. </para>
<para/>
<para>Расширенная поддержка создания наборов готовых пакетов имеются в catalyst. Для получения подробной информации о catalyst, пожалуйста, прочитайте справочное руководство по catalyst (англ.) и распространенные вопросы о catalyst (англ.). </para>
<para/>
<para>Установка двоичных пакетов</para>
<para/>
<para>Хотя в Gentoo такого хранилища нет, вы можете создать централизованное хранилище для заранее скомпилированных двоичных пакетов. Чтобы использовать такое хранилище, потребуется указать Portage путь к нему с помощью переменной PORTAGE_BINHOST. Например, если двоичные пакеты находятся на ftp://buildhost/gentoo: </para>
<para/>
<para>Листинг 10: Установка PORTAGE_BINHOST в /etc/make.conf</para>
<para>PORTAGE_BINHOST="ftp://buildhost/gentoo"</para>
<para/>
<para/>
<para>При установке двоичных пакетов, указывайте в команде emerge параметр --getbinpkg вместе с параметром --usepkg. Первый указывает emerge загрузить двоичный пакет c сервера, определенного раньше, а второй сообщает emerge, что до загрузки исходных кодов и их компиляции сначала нужно попытаться установить этот двоичный пакет. </para>
<para/>
<para>Например, чтобы установить gnumeric из двоичных пакетов: </para>
<para/>
<para>Листинг 11: Установка двоичного пакета gnumeric</para>
<para># emerge --usepkg --getbinpkg gnumeric</para>
<para/>
<para/>
<para>Подробную информацию о параметрах установки двоичных пакетов можно найти на странице справки emerge: </para>
<para/>
<para>Листинг 12: Чтение справки по emerge</para>
<para>$ man emerge</para>
<para/></sect3></sect2><sect2><title>4. Сценарии инициализации</title>
<para/><sect3><title>4.a. Уровни запуска</title>
<para/>
<para>Процесс загрузки системы</para>
<para/>
<para>При загрузке вашей системы по экрану пробегает много текста. Если присмотреться, заметно, что этот текст не меняется от загрузки к загрузке. Последовательность всех этих действий называется последовательностью загрузки и в той или иной степени постоянна. </para>
<para/>
<para>Во-первых, загрузчик размещает в памяти образ ядра, который вы указали в файле его конфигурации. После этого ядро запускается. Когда ядро загружено и запущено, оно инициализирует относящиеся к ядру структуры и задания, и запускает процесс init. </para>
<para/>
<para>Этот процесс удостоверяется, что все файловые системы (определенные в /etc/fstab) смонтированы и готовы к использованию. Затем он выполняет несколько сценариев, находящихся в каталоге /etc/init.d, которые запускают службы, необходимые для нормального запуска системы. </para>
<para/>
<para>И, наконец, когда все сценарии выполнены, init подключает терминалы (чаще всего просто виртуальные консоли, которые видны при нажатии ALT+F1, ALT+F2 и т.д.), прикрепляя к каждой консоли специальный процесс под названием agetty. Этот процесс впоследствии обеспечивает возможность входа в систему с помощью login. </para>
<para/>
<para>Сценарии инициализации</para>
<para/>
<para>Сейчас процесс init запускает сценарии из каталога /etc/init.d не просто в случайном порядке. Более того, запускаются не все сценарии из /etc/init.d, а только те, которые предписано исполнять. Решение о запуске сценария принимается в результате просмотра каталога /etc/runlevels. </para>
<para/>
<para>Во-первых, init запускает все сценарии из /etc/init.d, на которые есть символьные ссылки из /etc/runlevels/boot. Обычно сценарии запускаются в алфавитном порядке, но в некоторых сценариях имеется информация о зависимостях от других сценариев, указывающая системе на необходимость их предварительного запуска. </para>
<para/>
<para>Когда все сценарии, указанные в /etc/runlevels/boot, будут выполнены, init переходит к запуску сценариев, на которые есть символьные ссылки из /etc/runlevels/default. И снова запуск происходит в алфавитном порядке, пока в сценарии не встретится информация о зависимостях; тогда порядок изменяется для обеспечения правильного порядка запуска. </para>
<para/>
<para/>
<para>Как работает init</para>
<para/>
<para>Конечно, init не принимает решений сам по себе. Ему необходим конфигурационный файл, где описаны необходимые действия. Этот файл — /etc/inittab. </para>
<para/>
<para>Если вы запомнили последовательность загрузки, описанную чуть ранее, вы вспомните, что первое действие init — это монтирование всех файловых систем. Это определяется в строке /etc/inittab, приведенной ниже: </para>
<para/>
<para/>
<para>Листинг 1: Строка инициализации системы из /etc/inittab</para>
<para>si::sysinit:/sbin/rc sysinit</para>
<para/>
<para/>
<para>Этой строкой процессу init предписывается выполнить /sbin/rc sysinit для инициализации системы. Самой инициализацией занимается сценарий /sbin/rc, так что можно сказать, что init делает не слишком много — он просто делегирует задачу по инициализации системы другому процессу. </para>
<para/>
<para>Во-вторых, init выполняет все сценарии, на которые есть символьные ссылки из /etc/runlevels/boot. Это определяется следующей строкой: </para>
<para/>
<para>Листинг 2: Инициализация системы, продолжение</para>
<para>rc::bootwait:/sbin/rc boot</para>
<para/>
<para/>
<para>И снова все необходимые действия выполняются сценарием rc. Заметьте, что параметр, переданный rc (boot), совпадает с названием используемого подкаталога в /etc/runlevels. </para>
<para/>
<para>Теперь init проверяет свой конфигурационный файл, чтобы определить, какой уровень запуска использовать. Для этого из /etc/inittab считывается строка: </para>
<para/>
<para>Листинг 3: Строка initdefault</para>
<para>id:3:initdefault:</para>
<para/>
<para/>
<para>В приведенном примере (который подходит для подавляющего большинства пользователей Gentoo) номер уровня запуска — 3. Пользуясь этой информацией, init проверяет, что нужно выполнить для запуска уровня запуска 3: </para>
<para/>
<para>Листинг 4: Определение уровней запуска</para>
<para>l0:0:wait:/sbin/rc shutdown</para>
<para>l1:S1:wait:/sbin/rc single</para>
<para>l2:2:wait:/sbin/rc nonetwork</para>
<para>l3:3:wait:/sbin/rc default</para>
<para>l4:4:wait:/sbin/rc default</para>
<para>l5:5:wait:/sbin/rc default</para>
<para>l6:6:wait:/sbin/rc reboot</para>
<para/>
<para/>
<para>В строке, определяющей уровень 3, для запуска служб снова используется сценарий rc (на этот раз с аргументом default). Опять-таки, обратите внимание, что аргумент, передаваемый сценарию rc, совпадает с названием подкаталога из /etc/runlevels. </para>
<para/>
<para>По окончании работы rc, init принимает решение о том, какие виртуальные консоли включить и какие команды выполнить в каждой из них: </para>
<para/>
<para>Листинг 5: Определение виртуальных консолей</para>
<para>c1:12345:respawn:/sbin/agetty 38400 tty1 linux</para>
<para>c2:12345:respawn:/sbin/agetty 38400 tty2 linux</para>
<para>c3:12345:respawn:/sbin/agetty 38400 tty3 linux</para>
<para>c4:12345:respawn:/sbin/agetty 38400 tty4 linux</para>
<para>c5:12345:respawn:/sbin/agetty 38400 tty5 linux</para>
<para>c6:12345:respawn:/sbin/agetty 38400 tty6 linux</para>
<para/>
<para/>
<para>Что такое уровень запуска?</para>
<para/>
<para>Как вы заметили, init применяет нумерацию для определения уровня запуска, который надо использовать. Уровень запуска — это то состояние, в котором запускается ваша система, он содержит набор сценариев (сценариев уровня запуска или сценариев инициализации [initscript]), которые следует выполнять, при входе и выходе из определенного уровня запуска. </para>
<para/>
<para>В Gentoo определено семь уровней запуска: три служебных и четыре определяемых пользователем. Служебные называются sysinit, shutdown и reboot. Действия, совершаемые ими, в точности соответствуют их названиям: инициализация системы, выключение системы и ее перезагрузка. </para>
<para/>
<para>Определяемые пользователем уровни — это те, которым соответствуют подкаталоги в /etc/runlevels: boot, default, nonetwork и single. Уровень boot запускает все службы, необходимые системе и используемые всеми остальными уровнями. Остальные уровни отличаются друг от друга запускаемыми службами: default используется для повседневной работы, nonetwork — для тех случаев, когда не требуется сеть, а single — при необходимости восстановления системы. </para>
<para/>
<para>Работа со сценариями инициализации</para>
<para/>
<para>Сценарии, запускаемые процессом rc, называются сценариями инициализации. Каждый сценарий из /etc/init.d может запускаться с аргументами start, stop, restart, pause, zap, status, ineed, iuse, needsme, usesme и broken. </para>
<para/>
<para>Для запуска, остановки или перезапуска службы (и всех, зависящих от нее) следует использовать start, stop и restart: </para>
<para/>
<para>Листинг 6: Запуск postfix</para>
<para># /etc/init.d/postfix start</para>
<para/>
<para>Примечание: Останавливаются или перезапускаются только те службы, которым необходима данная служба. Остальные зависимые службы (те, которые используют службу, но не нуждаются в ней) эта операция не затрагивает. </para>
<para/>
<para/>
<para>Если вы хотите остановить службу, но оставить зависимые от нее работающими, можно использовать аргумент pause: </para>
<para/>
<para>Листинг 7: Остановка postfix без остановки зависимых служб</para>
<para># /etc/init.d/postfix pause</para>
<para/>
<para/>
<para>Чтобы узнать текущее состояние службы (запущена, остановлена, приостановлена и т.д.), можно использовать аргумент status: </para>
<para/>
<para>Листинг 8: Информация о состоянии postfix</para>
<para># /etc/init.d/postfix status</para>
<para/>
<para/>
<para>Если указано, что служба работает, но вы знаете, что это не так, можно сбросить состояние на stopped (остановлена), используя аргумент zap: </para>
<para/>
<para>Листинг 9: Сброс информации о состоянии postfix</para>
<para># /etc/init.d/postfix zap</para>
<para/>
<para/>
<para>Для того, чтобы выяснить зависимости службы, можно использовать аргументы iuse или ineed. С помощью ineed вы увидите те службы, которые действительно необходимы для правильного функционирования интересующей вас службы. С другой стороны, iuse покажет те службы, которые могут использоваться нашей службой, но не обязательны для ее работы. </para>
<para/>
<para>Листинг 10: Запрос списка всех необходимых служб, от которых зависит Postfix</para>
<para># /etc/init.d/postfix ineed</para>
<para/>
<para/>
<para>Аналогично вы можете узнать, какие службы нуждаются в данной службе (needsme) или могут ее использовать (usesme): </para>
<para/>
<para>Листинг 11: Запрос списка всех служб, которым необходим Postfix</para>
<para># /etc/init.d/postfix needsme</para>
<para/>
<para/>
<para>Наконец, можно просмотреть список служб, требующихся для данной, но отсутствующих в системе: </para>
<para/>
<para>Листинг 12: Запрос списка служб, необходимых Postfix, но отсутствующих</para>
<para># /etc/init.d/postfix broken</para>
<para/>
<para/></sect3><sect3><title>4.b. Использование rc-update</title>
<para/>
<para>Что такое rc-update?</para>
<para/>
<para>Система инициализации Gentoo использует дерево зависимостей для определения служб, которые запускаются в первую очередь. Т. к. это очень утомительное занятие, и мы не хотели, чтобы пользователь занимался этим вручную, мы разработали инструменты, упрощающие управление уровнями запуска и сценариями инициализации. </para>
<para/>
<para>Используя rc-update, можно включать и исключать сценарии инициализации из уровней запуска. Из rc-update автоматически запускается сценарий depscan.sh для перестроения дерева зависимостей. </para>
<para/>
<para>Добавление и удаление служб</para>
<para/>
<para>В процессе установки Gentoo вы уже добавляли сценарии инициализации в уровень запуска «default». В тот момент вы, возможно, не имели понятия, что такое «default» и зачем он нужен, но теперь вы все это знаете. Сценарию rc-update требуется второй аргумент, определяющий действие: add (добавить), del (удалить) или show (показать). </para>
<para/>
<para>Для того, чтобы добавить или удалить сценарий, просто введите rc-update с аргументом add или del, затем название сценария и уровня запуска. Например: </para>
<para/>
<para/>
<para>Листинг 13: Удаление Postfix из уровня запуска default</para>
<para># rc-update del postfix default</para>
<para/>
<para/>
<para>По команде rc-update show выводится список всех доступных сценариев с указанием соответствующих уровней запуска: </para>
<para/>
<para>Листинг 14: Получение информации о сценариях инициализации</para>
<para># rc-update show</para>
<para/>
<para/></sect3><sect3><title>4.c. Настройка служб</title>
<para/>
<para>Почему нужна дополнительная настройка?</para>
<para/>
<para>Сценарии инициализации могут быть весьма сложны. Поэтому нежелательно допускать непосредственное редактирование сценария пользователями, т.к. это может привнести в систему множество ошибок. Но, с другой стороны, необходимо правильно настроить службу. Например, может понадобиться передать службе дополнительные параметры. </para>
<para/>
<para>Вторая причина, по которой настройки хранятся отдельно от самого сценария — это возможность обновления сценария без опасения, что все ваши настройки будут утеряны. </para>
<para/>
<para/>
<para/>
<para>Каталог /etc/conf.d</para>
<para/>
<para>В Gentoo предусмотрен очень простой способ настройки служб: для каждого сценария, предполагающего настройку, в каталоге /etc/conf.d есть конфигурационный файл. Например, у сценария, запускающего apache2 (под названием /etc/init.d/apache2) есть конфигурационный файл /etc/conf.d/apache2, где могут храниться нужные вам параметры, передаваемые серверу Apache 2 при запуске: </para>
<para/>
<para>Листинг 15: Переменная, определенная в /etc/conf.d/apache2</para>
<para>APACHE2_OPTS="-D PHP4"</para>
<para/>
<para/>
<para>Такие файлы настроек содержат одни переменные (наподобие /etc/make.conf), облегчая настройку служб. Это также позволяет нам давать больше информации о переменных (в комментариях). </para>
<para/></sect3><sect3><title>4.d. Написание сценариев инициализации</title>
<para/>
<para>Мне тоже придется?..</para>
<para/>
<para>Нет, написание сценариев инициализации обычно не требуется, т.к. Gentoo содержит готовые сценарии для всех поддерживаемых служб. Однако, вы можете установить какую-либо службу, не используя систему Portage; в таком случае, вероятно, вам придется создавать сценарий инициализации самостоятельно. </para>
<para/>
<para/>
<para>Внимание: не используйте сценарий, идущий со службой, если он не написан специально для Gentoo: сценарии инициализации Gentoo не совместимы со сценариями, используемыми в других дистрибутивах! </para>
<para/>
<para>Структура</para>
<para/>
<para>Основная структура сценария инициализации показана ниже. </para>
<para/>
<para>Листинг 16: Основная структура сценария</para>
<para/>
<para>#!/sbin/runscript</para>
<para/>
<para>depend() {</para>
<para>  (информация о зависимостях)</para>
<para>}</para>
<para/>
<para>start() {</para>
<para>  (команды, необходимые для запуска службы)</para>
<para>}</para>
<para/>
<para>stop() {</para>
<para>  (команды, необходимые для остановки службы)</para>
<para>}</para>
<para/>
<para>restart() {</para>
<para>  (команды, необходимые для перезапуска службы)</para>
<para>}</para>
<para/>
<para/>
<para>В любом сценарии должна быть определена функция start(). Все остальные разделы необязательны. </para>
<para/>
<para>Зависимости</para>
<para/>
<para>Можно определять два типа зависимостей: use (использую) и need (нуждаюсь). Как упоминалось ранее, need-зависимость более строга, чем use-зависимость. Вслед за типом зависимости указывается название службы, от которой существует зависимость, или ссылка на виртуальную (virtual) зависимость. </para>
<para/>
<para>Виртуальная зависимость — это зависимость от функций, предоставляемых службой, но не какой-то единственной службой. Сценарий может зависеть от службы системного журнала, но таких достаточно много (metalogd, syslog-ng, и и т.п.). Поскольку нельзя нуждаться в каждой из них (ни в одной вразумительной системе они не запущены все сразу), мы обеспечили предоставление виртуальной зависимости всеми этими службами. </para>
<para/>
<para>Давайте взглянем на информацию о зависимостях postfix. </para>
<para/>
<para>Листинг 17: Информация о зависимостях Postfix</para>
<para>depend() {</para>
<para>  need net</para>
<para>  use logger dns</para>
<para>  provide mta</para>
<para>}</para>
<para/>
<para>Как можно увидеть, postfix: </para>
<orderedlist>
<listitem>
<para>требует сеть (net): виртуальная зависимость, удовлетворяемая, например, /etc/init.d/net.eth0; </para>
</listitem>
<listitem>
<para>использует журнал (logger): виртуальная зависимость, удовлетворяемая, например, /etc/init.d/syslog-ng;</para>
</listitem>
<listitem>
<para>использует службу имен (dns): виртуальная зависимость, удовлетворяемая, например, /etc/init.d/named); </para>
</listitem>
<listitem>
<para>предоставляет почтовый агент (mta): виртуальная зависимость, общая для всех программ — почтовых серверов. </para>
</listitem>
</orderedlist>
<para/>
<para>Порядок запуска</para>
<para/>
<para>Иногда вам нужна не сама служба, а запуск вашей службы до (или после) другой службы, если та присутствует в системе (обратите внимание на условие: это уже не зависимость) и запускается на том же уровне запуска (отметьте условие: это относится только к службам из одинакового уровня запуска). Такую очередность можно указать, используя значения before (до) или after (после). </para>
<para/>
<para>Например, рассмотрим значения для службы Portmap: </para>
<para/>
<para>Листинг 18: Функция depend() службы Portmap</para>
<para>depend() {</para>
<para>  need net</para>
<para>  before inetd</para>
<para>  before xinetd</para>
<para>}</para>
<para/>
<para/>
<para>Также можно использовать знак «*», чтобы охватить все службы данного уровня запуска, хотя это не рекомендуется. </para>
<para/>
<para>Листинг 19: Запуск сценария первым на уровне запуска</para>
<para>depend() {</para>
<para>  before *</para>
<para>}</para>
<para/>
<para/>
<para>Стандартные функции</para>
<para/>
<para>Следом за разделом depend() вам потребуется определить функцию start(). В ней содержатся все команды, необходимые для запуска вашей службы. Рекомендуется применять функции ebegin и eend для сообщений пользователю о том, что происходит: </para>
<para/>
<para>Листинг 20: Пример функции start()</para>
<para>start() {</para>
<para>  ebegin "Запуск - моя_служба"</para>
<para>  start-stop-daemon --start --quiet --exec /path/to/my_service</para>
<para>  eend $?</para>
<para>}</para>
<para/>
<para/>
<para>Если вам нужны дополнительные примеры функции start(), пожалуйста, прочитайте исходные коды сценариев инициализации, находящихся в каталоге /etc/init.d. Что касается команды start-stop-daemon, то на случай, если вам нужны дополнительные сведения, есть превосходная страница справки: </para>
<para/>
<para>Листинг 21: Вызов страницы справки по start-stop-daemon</para>
<para># man start-stop-daemon</para>
<para/>
<para/>
<para>Другими функциями, которые можно определить — stop() и restart(). От вас не требуется определение этих функций! Система инициализации, применяемая нами, достаточно развита и в состоянии самостоятельно заполнить эти функции, если вы используете start-stop-daemon. </para>
<para/>
<para>Синтаксис сценариев инициализации, применяемых в Gentoo, основан на оболочке Борна (Bourne Again Shell — bash), поэтому вы можете свободно использовать внутри своих сценариев bash-совместимые конструкции. </para>
<para/>
<para>Добавление дополнительных параметров</para>
<para/>
<para>Если вы хотите ввести в сценарий дополнительные параметры, кроме упоминавшихся, нужно добавить к переменной opts название параметра и создать функцию с названием, соответствующим параметру. Например, для поддержки параметра restartdelay: </para>
<para/>
<para>Листинг 22: Создание дополнительной функции restartdelay</para>
<para>opts="${opts} restartdelay"</para>
<para/>
<para>restartdelay() {</para>
<para>  stop</para>
<para>  sleep 3    # пауза в 3 секунды перед повторным запуском</para>
<para>  start</para>
<para>}</para>
<para/>
<para/>
<para>Переменные для настройки служб</para>
<para/>
<para>Для поддержки конфигурационного файла в каталоге /etc/conf.d ничего дополнительно делать не нужно: при запуске вашего сценария инициализации автоматически включаются следующие файлы (т.е., переменные из них становятся доступны): </para>
<para>/etc/conf.d/&lt;ваш сценарий инициализации&gt;</para>
<para>/etc/conf.d/basic</para>
<para>/etc/rc.conf</para>
<para/>
<para>Если ваш инициализационный сценарий предоставляет виртуальную зависимость (например, net), то также включается файл, соответствующий этой зависимости (например, /etc/conf.d/net). </para>
<para/></sect3><sect3><title>4.e. Изменение поведения уровней запуска</title>
<para/>
<para>Кто от этого выиграет?</para>
<para/>
<para>Большинству пользователей ноутбуков знакома ситуация: дома вам нужен запуск net.eth0, и наоборот, в дороге запуск net.eth0 не нужен (так как сеть недоступна). В Gentoo можно изменять поведение уровней запуска по своему усмотрению. </para>
<para/>
<para>Например вы можете создать второй загружаемый уровень запуска «по умолчанию», в котором будут другие сценарии. Затем при загрузке вы сможете выбрать, какой из уровней по умолчанию следует использовать. </para>
<para/>
<para>Использование программного уровня (softlevel)</para>
<para/>
<para>Прежде всего, создайте каталог для своего второго уровня запуска «по умолчанию». Например, создадим уровень запуска offline: </para>
<para/>
<para>Листинг 23: Создание каталога уровня запуска</para>
<para># mkdir /etc/runlevels/offline</para>
<para/>
<para/>
<para>Добавьте необходимые сценарии инициализации в только что созданный уровень запуска. Например, чтобы получить точную копию уровня default, за исключением net.eth0: </para>
<para/>
<para>Листинг 24: Добавление нужных сценариев инициализации</para>
<para>(копирование всех служб с уровня default в уровень offline)</para>
<para># cd /etc/runlevels/default</para>
<para># for service in *; do rc-update add $service offline; done</para>
<para>(удаление ненужных сценариев с уровня offline)</para>
<para># rc-update del net.eth0 offline</para>
<para>(просмотр сценариев, запускаемых на уровне offline)</para>
<para># rc-update show offline</para>
<para>(часть выведенного списка)</para>
<para>               acpid | offline</para>
<para>          domainname | offline</para>
<para>               local | offline</para>
<para>            net.eth0 |</para>
<para/>
<para/>
<para>Теперь необходимо отредактировать конфигурацию загрузчика, добавив запись об уровне offline. Например, в файле /boot/grub/grub.conf: </para>
<para/>
<para>Листинг 25: Добавление записи об уровне offline</para>
<para>title Автономное использование Gentoo Linux</para>
<para>  root (hd0,0)</para>
<para>  kernel (hd0,0)/kernel-2.4.25 root=/dev/hda3 softlevel=offline</para>
<para/>
<para/>
<para>Вуаля, все готово. Теперь, если при загрузке вы выберете вновь созданную запись, то вместо default будет использоваться уровень offline. </para>
<para/>
<para/>
<para/>
<para>Использование загрузочного уровня (bootlevel)</para>
<para/>
<para>Использование загрузочного уровня полностью аналогично использованию программного уровня. Единственная разница состоит в том, что вы определяете второй уровень «boot» вместо «default». </para></sect3></sect2><sect2><title>5. Переменные среды</title>
<para/><sect3><title>5.a. Переменные среды</title>
<para/>
<para>Что это такое?</para>
<para/>
<para/>
<para>Переменная среды — это именованный объект, который содержит информацию, используемую одним или несколькими приложениями. </para>
<para/>
<para>Многие пользователи (особенно новички в Linux) находят этот подход несколько странным или неуправляемым. Но это впечатление ошибочно: используя переменные среды, можно очень легко изменить настройку разнообразных программ. </para>
<para/>
<para>Важные примеры</para>
<para/>
<para>В следующей таблице описывается ряд переменных, используемых в системе Linux. Примеры их значений приведены далее. </para>
<para/>
<para>Таблица 1. Переменные среды Linux</para>
<para/>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>Переменная</para>
</entry>
<entry>
<para>Описание</para>
</entry>
</row>
<row>
<entry>
<para>PATH</para>
</entry>
<entry>
<para>В этой переменной содержится список каталогов, разделенных   двоеточиями, в которых система ищет исполняемые файлы. Если вы вводите имя исполняемого файла например, ls, rc-update или emerge), который не находится ни в одной из перечисленных здесь каталогов, этот файл не запустится (если, конечно, вы не указали полный путь, например, /bin/ls). </para>
</entry>
</row>
<row>
<entry>
<para>ROOTPATH</para>
</entry>
<entry>
<para>У этой переменной такое же значение, что и у PATH, но в ней перечисляются только те каталоги, которые нужно просматривать при вводе команды пользователем с правами root.</para>
</entry>
</row>
<row>
<entry>
<para>LDPATH</para>
</entry>
<entry>
<para>В этой переменной содержится список каталогов, разделенных двоеточиями, в которых динамический компоновщик ищет библиотеки. </para>
</entry>
</row>
<row>
<entry>
<para>MANPATH</para>
</entry>
<entry>
<para>В этой переменной содержится список каталогов, разделенных двоеточиями, в которых команда man ищет страницы справки. </para>
</entry>
</row>
<row>
<entry>
<para>INFODIR</para>
</entry>
<entry>
<para>В этой переменной содержится список каталогов, разделенных двоеточиями, в которых команда info ищет info-страницы. </para>
</entry>
</row>
<row>
<entry>
<para>PAGER</para>
</entry>
<entry>
<para>В этой переменной содержится путь к программе, позволяющей постранично просматривать содержимое файлов, например less или more. </para>
</entry>
</row>
<row>
<entry>
<para>EDITOR</para>
</entry>
<entry>
<para>В этой переменной содержится путь к программе, используемой для изменения файлов, например vi или nano. </para>
</entry>
</row>
<row>
<entry>
<para>KDEDIRS</para>
</entry>
<entry>
<para>В этой переменной содержится список каталогов, разделенных двоеточиями, в которых находятся ресурсы KDE. </para>
</entry>
</row>
<row>
<entry>
<para>CLASSPATH</para>
</entry>
<entry>
<para>В этой переменной содержится список каталогов, разделенных двоеточиями, в которых находятся классы Java. </para>
</entry>
</row>
<row>
<entry>
<para>CONFIG_PROTECT</para>
</entry>
<entry>
<para>В этой переменной содержится список каталогов, защищаемых Portage при обновлении, разделенных пробелами. </para>
</entry>
</row>
<row>
<entry>
<para>CONFIG_PROTECT_MASK</para>
</entry>
<entry>
<para>В этой переменной содержится список каталогов, исключаемых из защиты Portage при обновлении, разделенных пробелами </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para/>
<para>Ниже представлен пример определения всех этих переменных: </para>
<para/>
<para>Листинг 1: Пример определения</para>
<para>PATH="/bin:/usr/bin:/usr/local/bin:/opt/bin:/usr/games/bin"</para>
<para>ROOTPATH="/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin"</para>
<para>LDPATH="/lib:/usr/lib:/usr/local/lib:/usr/lib/gcc-lib/i686-pc-linux-gnu/3.2.3"</para>
<para>MANPATH="/usr/share/man:/usr/local/share/man"</para>
<para>INFODIR="/usr/share/info:/usr/local/share/info"</para>
<para>PAGER="/usr/bin/less"</para>
<para>EDITOR="/usr/bin/vim"</para>
<para>KDEDIRS="/usr"</para>
<para>CLASSPATH="/opt/blackdown-jre-1.4.1/lib/rt.jar:."</para>
<para>CONFIG_PROTECT="/usr/X11R6/lib/X11/xkb /opt/tomcat/conf \</para>
<para>                /usr/kde/3.1/share/config /usr/share/texmf/tex/generic/config/ \</para>
<para>                /usr/share/texmf/tex/platex/config/ /usr/share/config"</para>
<para>CONFIG_PROTECT_MASK="/etc/gconf"</para>
<para/>
<para/></sect3><sect3><title>5.b. Глобальное определение переменных</title>
<para/>
<para>Каталог /etc/env.d</para>
<para/>
<para>Для того, чтобы определить эти переменные централизованно, в Gentoo появился каталог /etc/env.d. В нём находится ряд файлов, например, 00basic, 05gcc и так далее, в которых определяются переменные, необходимые программам, указанным в названии файлов. </para>
<para/>
<para>Например, при установке gcc ebuild создает файл 05gcc, содержащий следующие определения переменных: </para>
<para/>
<para/>
<para/>
<para>Листинг 2: /etc/env.d/05gcc</para>
<para>PATH="/usr/i686-pc-linux-gnu/gcc-bin/3.2"</para>
<para>ROOTPATH="/usr/i686-pc-linux-gnu/gcc-bin/3.2"</para>
<para>MANPATH="/usr/share/gcc-data/i686-pc-linux-gnu/3.2/man"</para>
<para>INFOPATH="/usr/share/gcc-data/i686-pc-linux-gnu/3.2/info"</para>
<para>CC="gcc"</para>
<para>CXX="g++"</para>
<para>LDPATH="/usr/lib/gcc-lib/i686-pc-linux-gnu/3.2.3"</para>
<para/>
<para/>
<para>В других дистрибутивах вам предлагается изменять или добавлять определения переменных среды в /etc/profile или где-нибудь еще. Gentoo, с другой стороны, облегчает вам (и Portage) поддержку и управление переменными среды, избавляя от необходимости уделять внимание многочисленным файлам, содержащим определения переменных. </para>
<para/>
<para>Например, когда обновляется gcc, также без малейшего участия пользователя обновляется и /etc/env.d/05gcc. </para>
<para/>
<para>От этого выигрывает не только Portage, но и вы, пользователь. Иногда от вас может потребоваться глобальная установка какой-нибудь переменной. Возьмем, к примеру, переменную http_proxy. Вместо того, чтобы возиться с /etc/profile, теперь можно просто создать файл (/etc/env.d/99local) и добавить нужные определения туда: </para>
<para/>
<para>Листинг 3: /etc/env.d/99local</para>
<para>http_proxy="proxy.server.com:8080"</para>
<para/>
<para/>
<para>Используя один и тот же файл для всех своих переменных, вы можете быстро увидеть все определенные вами переменные вместе. </para>
<para/>
<para>Сценарий env-update</para>
<para/>
<para>Переменная PATH определяется в нескольких файлах в /etc/env.d. Нет, нет это не ошибка: при запуске env-update различные определения объединяются перед обновлением переменных среды, позволяя пакетам (или пользователям) добавлять собственные значения переменных, не влияя на уже существующие. </para>
<para/>
<para>Сценарий env-update объединяет значения переменных из файлов, находящихся в /etc/env.d, в алфавитном порядке. Имена файлов должны начинаться с двух десятичных цифр. </para>
<para/>
<para>Листинг 4: Порядок обновления, используемый env-update</para>
<para>         00basic        99kde-env       99local</para>
<para>     +-------------+----------------+-------------+</para>
<para>PATH="/bin:/usr/bin:/usr/kde/3.2/bin:/usr/local/bin"</para>
<para/>
<para/>
<para>Внимание: объединение выполняется не всегда, а только для следующих переменных: KDEDIRS, PATH, CLASSPATH, LDPATH, MANPATH, INFODIR, INFOPATH, ROOTPATH, CONFIG_PROTECT, CONFIG_PROTECT_MASK, PRELINK_PATH и PRELINK_PATH_MASK. Для всех остальных переменных используется значение, определенное в последнем из файлов (по алфавиту в каталоге /etc/env.d). </para>
<para/>
<para>При запуске сценария env-update создаются все переменные среды, и помещаются в /etc/profile.env (используемый файлом /etc/profile). Кроме того, на основе значения LDPATH создается /etc/ld.so.conf. После этого запускается ldconfig, чтобы вновь создать файла /etc/ld.so.cache, используемый динамическим компоновщиком. </para>
<para/>
<para>Если вы хотите, чтобы результаты работы env-update вступили в силу немедлено, для обновления среды выполните следующую команду. Пользователи, самостоятельно устанавливавшие Gentoo, возможно, помнят ее из указаний по установке: </para>
<para/>
<para>Листинг 5: Обновление среды</para>
<para># env-update &amp;&amp; source /etc/profile</para>
<para/>
<para>Примечание: Эта команда обновляет переменные только в текущем терминале, в новых консолях и их потомках. То есть, если вы работаете в X11, потребуется или набирать source /etc/profile в каждом открываемом терминале, или перезапустить X, чтобы все новые терминалы обращались к новым переменным. Если вы используете диспетчер входа в систему, станьте пользователем с правами root и наберите /etc/init.d/xdm restart. Если нет, вам придется выйти и снова войти в систему, чтобы X порождала потомков, использующих новые значения переменных. </para>
<para/>
<para/></sect3><sect3><title>5.c. Локальное определение переменных</title>
<para/>
<para>Пользовательские переменные</para>
<para/>
<para>Далеко не всегда нужно определять переменные глобально. Например, вам может понадобиться добавить /home/my_user/bin и текущий рабочий каталог (где вы находитесь) к переменной PATH, но при этом не нужно, чтобы это добавление появилось и в переменной PATH у всех остальных пользователей. Если вы хотите определить переменную среды локально, используйте ~/.bashrc или ~/.bash_profile: </para>
<para/>
<para>Листинг 6: Расширение PATH в ~/.bashrc для локальных нужд</para>
<para>(двоеточие без последующего указания каталога означает текущий рабочий каталог)</para>
<para>PATH="${PATH}:/home/my_user/bin:"</para>
<para/>
<para/>
<para>Обновление вашей переменной PATH произойдет, когда вы выйдете и снова войдете в систему. </para>
<para/>
<para>Сеансовые переменные</para>
<para/>
<para>Иногда нужны еще более жесткие ограничения. Вам может потребоваться возможность запуска исполняемых файлов из специально созданного временного каталога без указания полного пути к ним, и без изменения файла ~/.bashrc ради нескольких минут. </para>
<para/>
<para>В этом случае можно просто определить переменную PATH для текущего сеанса командой export. Переменной будет присвоено временное значение до тех пор, пока вы не завершите сеанс. </para>
<para/>
<para>Листинг 7: Определение сеансовой переменной среды</para>
<para># export PATH="${PATH}:/home/my_user/tmp/usr/bin"</para>
<para/>
<para/>
<para/></sect3></sect2><sect2><title>C. Работа с Portage</title></sect2><sect2><title>1. Файлы и каталоги</title>
<para/><sect3><title>1.a. Файлы Portage</title>
<para/>
<para>Директивы настройки</para>
<para/>
<para>Настройки Portage по умолчанию хранятся в /etc/make.globals. Когда вы откроете этот файл, вы увидите, что все настройки представляют собой переменные. Что означает каждая из переменных, описано ниже. </para>
<para/>
<para>Так как многие директивы отличаются в зависимости от используемой архитектуры, к Portage прилагаются настройки по умолчанию, которые входят в ваш профиль. На ваш профиль указывает символическая ссылка /etc/make.profile. Настройка Portage выполняется c помощью файлов make.defaults вашего профиля и всех родительских профилей. Более подробно о профилях и каталоге /etc/make.profile мы расскажем позже. </para>
<para/>
<para>Если вы планируете вносить изменения в конфигурационные переменные, не изменяйте /etc/make.globals или make.defaults. Вместо этого пользуйтесь файлом /etc/make.conf, который имеет приоритет перед вышеуказанными файлами. Вы также обнаружите файл /etc/make.conf.example. Как понятно из его названия, это просто пример — Portage не использует этот файл. </para>
<para/>
<para>Переменные Portage также можно устанавливать как переменные среды, но мы не рекомендуем этого делать. </para>
<para/>
<para>Конфигурация, определяемая профилем</para>
<para/>
<para>Мы уже встречались с каталогом /etc/make.profile. На самом деле это не каталог, а символическая ссылка на профиль, по умолчанию на тот, что содержится в /usr/portage/profiles, однако вы можете создавать свои собственные профили где угодно и ссылаться на них. Профиль, указанный ссылкой, является профилем, к которому принадлежит ваша система. </para>
<para/>
<para>В профиле содержатся сведения для Portage, специфичные для архитектуры, такие как список пакетов, принадлежащих соответствующей системе, список неработоспособных (или замаскированных) пакетов, и т.д. </para>
<para/>
<para>Конфигурация, задаваемая пользователем</para>
<para/>
<para>Если вам необходимо изменить поведение Portage относительно установки программного обеспечения, вам потребуется отредактировать файлы, находящиеся в /etc/portage. Мы настоятельно рекомендуем вам пользоваться файлами из /etc/portage, всеми силами отговариваем от настройки поведения Portage через переменные среды! </para>
<para/>
<para>Внутри /etc/portage вы можете создать следующие файлы: </para>
<orderedlist>
<listitem>
<para>package.mask, в котором перечислены пакеты, которые Portage никогда не следует устанавливать; </para>
</listitem>
<listitem>
<para>package.unmask, со списком пакетов, для которых вы хотите иметь возможность установки, даже если разработчики Gentoo отговаривают вас от этого; </para>
</listitem>
<listitem>
<para>package.keywords, где перечислены пакеты, которые должны быть доступны для установки, несмотря на то, что они не подходят для вашей системы или архитектуры (пока); </para>
</listitem>
<listitem>
<para>package.use, где перечислены значения USE-флагов, которые необходимо указывать для конкретных пакетов, а не для всей системы. </para>
</listitem>
</orderedlist>
<para/>
<para>Дополнительные сведения о каталоге /etc/portage, а также список всех файлов, которые там можно создавать, находятся на справочной странице Portage: </para>
<para/>
<para>Листинг 1: Вызов справки по Portage</para>
<para>$ man portage</para>
<para/>
<para/>
<para>Изменение файлов Portage и размещения каталогов</para>
<para/>
<para>Ранее упомянутые конфигурационные файлы нельзя хранить где угодно — Portage всегда ищет свои настроечные файлы в строго определенных местах. Однако Portage также использует множество каталогов для других целей: каталог для сборки, место для хранения исходных кодов, место для дерева Portage, и т.д. </para>
<para/>
<para>Для этих целей существуют хорошо известные каталоги по умолчанию, положение которых можно изменить на свой вкус, внеся изменения в /etc/make.conf. Оставшаяся часть этой главы посвящена описанию того, какие специальные места Portage использует для своих целей, и как изменить их расположение в файловой системе. </para>
<para/>
<para>Этот документ не претендует на статус справочника. Если вам необходим полный объем информации, пожалуйста, обратитесь к страницам справки по Portage и make.conf: </para>
<para/>
<para>Листинг 2: Вызов справки по Portage и make.conf</para>
<para>$ man portage</para>
<para>$ man make.conf</para>
<para/></sect3><sect3><title>1.b. Хранение файлов</title>
<para/>
<para>Дерево Portage</para>
<para/>
<para>Дерево Portage размещается, по умолчанию, в /usr/portage. Это определяется значением переменной PORTDIR. Когда вы храните дерево Portage где-либо в другом месте (изменив эту переменную), не забывайте соответственно изменить символическую ссылку /etc/make.profile. </para>
<para/>
<para>Если вы измените переменную PORTDIR, вам может потребоваться изменить и следующие переменные: PKGDIR, DISTDIR, RPMDIR, так как они не замечают изменений PORTDIR. Это связано с особенностями их обработки Portage. </para>
<para/>
<para>Двоичные пакеты</para>
<para/>
<para>Несмотря на то, что Portage по умолчанию не использует прекомпилированное программное обеспечение, для него предусмотрена очень мощная поддержка. Если вы укажете Portage работать с прекомпилированными пакетами, они будут разыскиваться в /usr/portage/packages. Это расположение определяется переменной PKGDIR. </para>
<para/>
<para>Исходные коды</para>
<para/>
<para>Исходные коды приложений хранятся в /usr/portage/distfiles по умолчанию. Это определяется переменной DISTDIR. </para>
<para/>
<para>Файлы RPM</para>
<para/>
<para>Несмотря на то, что Portage не может использовать RPM-файлы, есть возможность их создания командой ebuild (см. Приложение Ebuild). По умолчанию Portage хранит RPM файлы в каталоге /usr/portage/rpm, как определяется переменной RPMDIR. </para>
<para/>
<para>База данных Portage</para>
<para/>
<para>Portage хранит состояние вашей системы (какие пакеты установлены, какие файлы относятся к определенным пакетам и т. п.) в /var/db/pkg. Не изменяйте эти файлы вручную! Это может разрушить знание вашей системы Portage. </para>
<para/>
<para>Кэш Portage</para>
<para/>
<para>Кэш Portage (включая сведения о времени изменения, виртуальные пакеты, информацию дерева зависимостей и т. д.) хранится в /var/cache/edb. Это место действительно является кэшем: вы можете его очистить в любой момент, когда не запущены приложения, связанные с Portage. </para>
<para/></sect3><sect3><title>1.c. Сборка программного обеспечения</title>
<para/>
<para>Временные файлы Portage</para>
<para/>
<para>По умолчанию Portage хранит временные файлы в /var/tmp. За это отвечает переменная PORTAGE_TMPDIR. </para>
<para/>
<para>Если вы измените переменную PORTAGE_TMPDIR, вам может потребоваться изменить и переменную BUILD_PREFIX, так как она не замечает изменений PORTAGE_TMPDIR. Это связано с особенностями ее обработки Portage. </para>
<para/>
<para>Каталог сборки</para>
<para/>
<para>Portage создает специфичные каталоги сборки для каждого пакета внутри /var/tmp/portage. Это расположение задается переменной BUILD_PREFIX. </para>
<para/>
<para>Размещение «живой файловой системы»</para>
<para/>
<para>По умолчанию Portage устанавливает все файлы в текущую файловую систему (/), но это можно изменить, установив переменную окружения ROOT. Это может оказаться полезным при построении новых образов системы. </para>
<para/></sect3><sect3><title>1.d. Ведение журнала</title>
<para/>
<para>Журнал Ebuild</para>
<para/>
<para>Portage может создавать отдельные файлы журнала для каждого файла ebuild, но только тогда, когда переменная PORT_LOGDIR указывает на место, доступное для записи для Portage (пользователя portage). По умолчанию эта переменная не установлена. </para></sect3></sect2><sect2><title>2. Настройка с помощью переменных</title>
<para/><sect3><title>2.a. Настройка Portage</title>
<para/>
<para/>
<para>Как отмечалось ранее, Portage настраивается с помощью множества переменных, которые задаются в файле /etc/make.conf. За более полной и подробной информацией обращайтесь к странице справки по make.conf: </para>
<para/>
<para>Листинг 1: Чтение страницы справки по make.conf</para>
<para>$ man make.conf</para>
<para/>
<para/></sect3><sect3><title>2.b. Параметры сборки</title>
<para/>
<para>Параметры конфигурирования и компиляции</para>
<para/>
<para>Когда Portage собирает приложения, компилятору и сценарию конфигурации передаются значения следующих переменных: </para>
<orderedlist>
<listitem>
<para>CFLAGS и CXXFLAGS определяют желаемые флаги компилятора для C и C++; </para>
</listitem>
<listitem>
<para>CHOST определяет информацию об используемой платформе для сценария конфигурации приложения; </para>
</listitem>
<listitem>
<para>MAKEOPTS передается команде make и обычно применяется для установки степени распараллеливания компиляции. Более подробная информация о параметрах команды make находится на странице справки по make. </para>
</listitem>
</orderedlist>
<para/>
<para>Переменная USE также используется при конфигурировании и компиляции, но о ней уже много и подробно говорилось в предыдущих главах. </para>
<para/>
<para/>
<para>Параметры установки</para>
<para/>
<para>Когда Portage устанавливает (merge) новую версию программного продукта, файлы более старых версий удаляются из системы. Portage дает пользователю 5-ти секундную задержку перед стиранием старых версий. Эти 5 секунд задаются переменной CLEAN_DELAY. </para>
<para/></sect3><sect3><title>2.c. Защита конфигурационных файлов</title>
<para/>
<para>Места, защищаемые Portage</para>
<para/>
<para>Portage записывает файлы, предоставляемые новой версией программы, поверх старых, если только эти файлы не расположены в защищенном месте. Защищенные каталоги определяются переменной CONFIG_PROTECT. Обычно, это места расположения файлов конфигурации. Каталоги в списке разделяются пробелами. </para>
<para/>
<para>Файл, который должен быть записан в такой защищенный каталог, переименовывается, а пользователь получает предупреждение о наличии новой версии (обычно) файла конфигурации. </para>
<para/>
<para>Узнать текущее значение CONFIG_PROTECT можно из сообщений emerge --info: </para>
<para/>
<para>Листинг 2: Получение значения CONFIG_PROTECT</para>
<para>$ emerge --info | grep 'CONFIG_PROTECT='</para>
<para/>
<para/>
<para>Более подробная информация о защите конфигурационных файлов, осуществляемой системой Portage, доступна по команде emerge: </para>
<para/>
<para>Листинг 3: Подробная информация о защите конфигурационных файлов</para>
<para>$ emerge --help config</para>
<para/>
<para/>
<para>Исключение каталогов</para>
<para/>
<para>Чтобы снять защиту с определенных подкаталогов защищенного каталога, можно использовать переменную CONFIG_PROTECT_MASK. </para>
<para/></sect3><sect3><title>2.d. Параметры скачивания</title>
<para/>
<para>Расположение сервера</para>
<para/>
<para>Если запрошенная информация или данные отсутствуют в вашей системе, Portage обращается за ними в интернет. Расположение серверов для различных каналов получения информации задается следующими переменными: </para>
<orderedlist>
<listitem>
<para>GENTOO_MIRRORS определяет список адресов серверов, содержащих исходный код (distfiles); </para>
</listitem>
<listitem>
<para>PORTAGE_BINHOST указывает расположение определенного сервера, содержащего двоичные пакеты (prebuilt packages) для вашей системы; </para>
</listitem>
<listitem>
<para>Третья переменная содержит расположение сервера rsync, который используется при обновлении вашего дерева портежей: </para>
<para>SYNC указывает сервер, с которого Portage извлекает дерево портежей. </para>
</listitem>
</orderedlist>
<para/>
<para>Переменные GENTOO_MIRRORS и SYNC можно установить автоматически программой mirrorselect. Перед тем, как использовать, ее нужно установить, выполнив emerge mirrorselect. За дополнительной информацией обращайтесь к оперативной справке mirrorselect: </para>
<para/>
<para>Листинг 4: Дополнительные сведения о mirrorselect</para>
<para># mirrorselect --help</para>
<para/>
<para/>
<para>Если вы вынуждены использовать прокси-сервер, для его указания можно использовать переменные HTTP_PROXY, FTP_PROXY и RSYNC_PROXY. </para>
<para/>
<para>Команды для извлечения</para>
<para/>
<para>Когда Portage требуется извлечь исходный код, по умолчанию используется wget. Вы можете это изменить с помощью переменной FETCHCOMMAND. </para>
<para/>
<para>Portage может возобновлять скачивание частично загруженного исходного кода. По умолчанию используется wget, но это можно переопределить переменной RESUMECOMMAND. </para>
<para/>
<para>Удостоверьтесь, что ваши команды FETCHCOMMAND и RESUMECOMMAND сохраняют исходный код в нужном месте. Внутри этих переменных следует использовать \${URI} и \${DISTDIR}, для указания расположения исходных кодов и distfiles, соответственно. </para>
<para/>
<para>Также существует возможность определить индивидуальные настройки для различных протоколов, используя FETCHCOMMAND_HTTP, FETCHCOMMAND_FTP, RESUMECOMMAND_HTTP, RESUMECOMMAND_FTP, и т.п. </para>
<para/>
<para>Настройки rsync</para>
<para/>
<para>Вы не можете заменить команду rsync, которую Portage использует для обновления дерева портежей, но можно установить несколько переменных, определяющих ее поведение: </para>
<orderedlist>
<listitem>
<para>RSYNC_EXCLUDEFROM указывает на файл, где перечислены пакеты и/или категории, которые rsync должна игнорировать во время обновления. </para>
</listitem>
<listitem>
<para>RSYNC_RETRIES определяет, сколько раз rsync должна пытаться соединиться с зеркалом, на которое указывает переменная SYNC. По умолчанию равна 3. </para>
</listitem>
<listitem>
<para>RSYNC_TIMEOUT определяет количество секунд, в течение которого rsync соединение может бездействовать, перед тем как rsync сочтет его превысившим время ожидания. По умолчанию равна 180, но если вы используете соединение по модему или у вас медленный компьютер, возможно, следует установить значение этой переменной равным 300 или большим. </para>
</listitem>
</orderedlist>
<para/></sect3><sect3><title>2.e. Настройка Gentoo</title>
<para/>
<para>Выбор ветви</para>
<para/>
<para>Используемую ветвь можно изменить переменной ACCEPT_KEYWORDS. По умолчанию используется стабильная ветвь для вашей архитектуры. Дополнительная информация о ветвях Gento находится в следующей главе. </para>
<para/>
<para/>
<para>Возможности Portage</para>
<para/>
<para>Вы можете включить отдельные функции Portage с помощью переменной FEATURES. Возможности Portage рассматривались в предыдущих главах. </para>
<para/></sect3><sect3><title>2.f. Поведение Portage</title>
<para/>
<para>Распределение ресурсов</para>
<para/>
<para>С помощью переменной PORTAGE_NICENESS можно увеличивать или уменьшать значение nice, с которым выполняется Portage. Значение PORTAGE_NICENESS прибавляется к текущему значению nice. </para>
<para/>
<para>Более подробно о значениях nice написано в странице справки: </para>
<para/>
<para>Листинг 5: Дополнительные сведения о nice</para>
<para>$ man nice</para>
<para/>
<para/>
<para>Настройки вывода</para>
<para/>
<para>Переменная NOCOLOR (по умолчанию «false») определяет, следует ли Portage отключить цветовую раскраску своих сообщений. </para></sect3></sect2><sect2><title>3. Смешение ветвей программного обеспечения</title>
<para/><sect3><title>3.a. Использование одной ветви</title>
<para/>
<para>Стабильная ветвь</para>
<para/>
<para>Переменная ACCEPT_KEYWORDS определяет, какую из ветвей использовать в вашей системе. По умолчанию используется стабильная ветвь для вашей архитектуры, например x86 </para>
<para/>
<para>Мы рекомендуем использовать только стабильную ветвь. Однако, если для вас стабильность не критична и вы хотите помочь Gentoo, отсылая отчеты об ошибках на http://bugs.gentoo.org, читайте дальше. </para>
<para/>
<para>Тестовая ветвь</para>
<para/>
<para>Если вы желаете использовать наиболее свежее ПО, подумайте над использованием тестовой ветви. Чтобы Portage начала использовать тестовую ветвь, добавьте «~» перед названием вашей архитектуры. </para>
<para/>
<para>Тестовая ветвь полностью соответствует своему названию: для тестирования. Если пакет находится в стадии тестирования, это означает, что разработчики считают, что пакет работоспособен, но тщательно он не протестирован. Вы можете оказаться первым, кто столкнется с какой-либо ошибкой. В этом случае вы можете создать отчет об ошибке, чтобы разработчики узнали о ней. </para>
<para/>
<para>Однако будьте готовы к тому, что могут возникнуть проблемы со стабильностью, неудовлетворительной поддержкой пакетов (например неправильные/отсутствующие зависимости), слишком частыми обновлениями (а в результате — частыми сборками) или невозможностью собрать пакет. Если вы не знаете, как работает Gentoo и как разрешать возникающие проблемы, мы рекомендуем не отходить от стабильной и оттестированной ветви. </para>
<para/>
<para>К примеру, для выбора тестовой ветви на архитектуре x86, отредактируйте /etc/make.conf и укажите в нем: </para>
<para/>
<para>Листинг 1: Установка значения переменной ACCEPT_KEYWORDS</para>
<para>ACCEPT_KEYWORDS="~x86"</para>
<para/>
<para/>
<para>Если вы запустите обновление системы, то увидите, что многие пакеты нуждаются в обновлении. Обратите внимание, что после перехода на тестовую ветвь и обновления системы, как правило, нет простого пути назад к стабильной официальной ветви (конечно, кроме использования резервной копии). </para>
<para/></sect3><sect3><title>3.b. Одновременное использование стабильной и тестовой ветвей</title>
<para/>
<para>Местоположение package.keywords</para>
<para/>
<para>Вы можете указать, чтобы Portage использовала тестовую ветвь только для определенных пакетов, а для остальной системы — стабильную ветвь. Для этого добавьте категорию и имя пакета, для которого вы желаете использовать тестовую ветвь, в файл /etc/portage/package.keywords. Вместо этого можно создать каталог (с таким же именем) и указывать пакеты в файлах, находящихся внутри этого каталога. Например, для использования тестовой ветви для gnumeric: </para>
<para/>
<para>Листинг 2: Настройка /etc/portage/package.keywords для gnumeric, вся строка</para>
<para>app-office/gnumeric ~x86</para>
<para/>
<para/>
<para>Тестирование определенных версий</para>
<para/>
<para>Если вы желаете использовать конкретную версию ПО из тестовой ветви, но не хотите, чтобы Portage использовала тестовую ветвь для последующих версий этого ПО, можно указать в местоположении package.keywords номер необходимой версии. В этом случае вы обязаны использовать оператор =. Также можно указать диапазон версий, используя операторы &lt;=, &lt;, &gt; или &gt;=. </para>
<para/>
<para>В любом случае, добавляя информацию о версии, вы должны использовать один из этих операторов. Если вы не указываете версию, эти операторы использовать нельзя. </para>
<para/>
<para>В следующем примере мы просим Portage разрешить установку gnumeric-1.2.13: </para>
<para/>
<para>Листинг 3: Использование конкретной тестовой версии gnumeric</para>
<para>=app-office/gnumeric-1.2.13 ~x86</para>
<para/></sect3><sect3><title>3.c. Использование заблокированных пакетов</title>
<para/>
<para>Расположение package.unmask</para>
<para/>
<para>Разработчики Gentoo не поддерживают использование этого места расположения. Пожалуйста, используйте их на свой страх и риск. Просьбы о помощи, связанные с использованием package.unmask и/или package.mask, останутся без ответа. Вы предупреждены. </para>
<para/>
<para>Если использование пакета было заблокировано разработчиками Gentoo, но вы желаете его использовать несмотря на причины блокировки, указанные в файле package.mask (по умолчанию он находится в /usr/portage/profiles), добавьте для него точно такую же строку в файл /etc/portage/package.unmask (или в файл в этом каталоге, если это каталог). </para>
<para/>
<para>Например, если =net-mail/hotwayd-0.8 заблокирован, то разблокировать его можно, прописав в package.unmask точно такую же строчку: </para>
<para/>
<para>Листинг 4: /etc/portage/package.unmask</para>
<para>=net-mail/hotwayd-0.8</para>
<para/>
<para/>
<para>Местоположение package.mask</para>
<para/>
<para>Если вы не хотите, чтобы Portage использовала какое-то конкретное ПО или конкретные версии ПО, вы можете его самостоятельно заблокировать, добавив соответствующую запись в /etc/portage/package.mask (в такой файл либо в файл внутри такого каталога). </para>
<para/>
<para>Если, к примеру, вы не хотите, чтобы Portage устанавливала исходные коды ядра новее, чем gentoo-sources-2.6.8.1, добавьте такую строку в местоположение package.mask: </para>
<para/>
<para>Листинг 5: Пример использования файла /etc/portage/package.mask</para>
<para>&gt;sys-kernel/gentoo-sources-2.6.8.1</para>
<para/></sect3></sect2><sect2><title>4. Дополнительные средства Portage</title>
<para/><sect3><title>4.a. etc-update</title>
<para/>
<para>etc-update — это утилита, предназначенная для обновления в системе файлов ._cfg0000_&lt;имя&gt;. Она обеспечивает интерактивную настройку установки и может также автоматически устанавливать тривиальные изменения. Файлы создаются ._cfg0000_&lt;имя&gt; Portage, когда нужно заменить файл в каталоге, защищенном переменной CONFIG_PROTECT. </para>
<para/>
<para>Выполнить etc-update довольно просто: </para>
<para/>
<para>Листинг 1: Запуск etc-update</para>
<para># etc-update</para>
<para/>
<para/>
<para>После выполнения тривиальных обновлений, вы увидите запрос со списком защищенных файлов, ожидающих обновления. Внизу вам предложат следующие варианты: </para>
<para/>
<para>Листинг 2: Запрос etc-update</para>
<para>Please select a file to edit by entering the corresponding number.</para>
<para>              (-1 to exit) (-3 to auto merge all remaining files)</para>
<para>                           (-5 to auto-merge AND not use 'mv -i'):</para>
<para/>
<para>(Пожалуйста, выберите файл для правки, введя соответствующее число.</para>
<para>         (-1 - выход) (-3 - автоустановка всех оставшихся файлов)</para>
<para>                 (-5 для автоустановки БЕЗ использования 'mv -i'): )</para>
<para/>
<para/>
<para>При вводе -1, etc-update выходит, прекращая последующие изменения. Если вы введете -3 или -5, все перечисленные файлы конфигурации заменяются более новыми версиями. Следовательно, очень важно сначало отобрать файлы, которые не следует автоматически обновлять. Для этого надо только вводить номер, указанный слева от файлов. </para>
<para/>
<para>Например, выбираем файл конфигурации /etc/pear.conf: </para>
<para/>
<para>Листинг 3: Обновление конкретного конфигурационного файла</para>
<para>Beginning of differences between /etc/pear.conf and /etc/._cfg0000_pear.conf</para>
<para>[...]</para>
<para>End of differences between /etc/pear.conf and /etc/._cfg0000_pear.conf</para>
<para>1) Replace original with update </para>
<para>2) Delete update, keeping original as is </para>
<para>3) Interactively merge original with update </para>
<para>4) Show differences again </para>
<para/>
<para/>
<para>Теперь можно увидеть различия между двумя файлами. Если вы считаете, что обновленный файл конфигурации можно использовать без проблем, введите 1. Если вы считаете, что обновленный файл конфигурации не нужен, или не содержит новую или полезную информацию, введите 2. Если вы хотите обновить текущий файл в интерактивном режиме, введите 3. </para>
<para/>
<para>Нет никакого смысла в подробном описании интерактивного обновления. Для полноты изложения, мы перечислим возможные команды, которые можно использовать при интерактивном слиянии двух файлов. Вас встречают две строки (одна исходная, вторая измененная) и запрос, в ответ на который можно ввести одну из следующих команд: </para>
<para/>
<para>Листинг 4: Команды, доступные при интерактивном слиянии</para>
<para>ed:     редактировать и использовать оба варианта, каждый пометить заголовком</para>
<para>eb:     редактировать и использовать оба варианта</para>
<para>el:     редактировать и использовать левый вариант</para>
<para>er:     редактировать и использовать правый вариант</para>
<para>e:      редактировать новую версию</para>
<para>l:      использовать левую версию</para>
<para>r:      использовать правую версию</para>
<para>s:      молча включить общие строки</para>
<para>v:      включить общие строки, сообщив подробности</para>
<para>q:      выход</para>
<para/>
<para/>
<para>Завершив обновление важных файлов конфигурации, вы можете автоматически обновить оставшиеся файлы конфигурации. etc-update выйдет, если не найдет других файлов, подлежащих обновлению. </para>
<para/></sect3><sect3><title>4.b. dispatch-conf</title>
<para/>
<para>С помощью dispatch-conf можно обновлять файлы конфигурации, сохраняя при этом историю изменений. dispatch-conf хранит различия между файлами конфигурации в виде заплаток или в системе управления версиями RCS. </para>
<para/>
<para>Как и с etc-update, вы можете попросить сохранить файл конфигурации как есть, использовать новый файл конфигурации, редактировать текущий или объединить изменения интерактивно. Однако, у dispatch-conf также есть приятные дополнительные возможности: </para>
<orderedlist>
<listitem>
<para>автоматическое обновление файлов, в которых обновились только комментарии; </para>
</listitem>
<listitem>
<para>автоматическое обновление файлов, которые отличаются только количеством пробелов. </para>
</listitem>
</orderedlist>
<para/>
<para>Убедитесь, что вы сначала отредактировали /etc/dispatch-conf.conf и создали каталог, прописанный в archive-dir. </para>
<para/>
<para>За дополнительными сведениями обращайтесь к странице справки dispatch-conf: </para>
<para/>
<para>Листинг 5: Чтение справки по dispatch-conf</para>
<para>$ man dispatch-conf</para>
<para/>
<para/></sect3><sect3><title>4.c. quickpkg</title>
<para/>
<para>С quickpkg вы можете создавать архивы пакетов, уже установленных в системе. Эти архивы можно использовать в качестве двоичных пакетов. Запуск quickpkg прост: только укажите имена пакетов, которые нужно заархивировать. </para>
<para/>
<para>Например, чтобы поместить в архив curl, arts и procps: </para>
<para/>
<para>Листинг 6: Пример использования quickpkg</para>
<para># quickpkg curl arts procps</para>
<para/>
<para/>
<para>Двоичные пакеты будут храниться в $PKGDIR/All (по умолчанию — /usr/portage/packages/All). Символьные ссылки, указывающие на эти пакеты, помещаются в $PKGDIR/&lt;категория&gt;. </para></sect3></sect2><sect2><title>5. Отступление от официального дерева</title>
<para/><sect3><title>5.a. Использование собственного дерева Portage</title>
<para/>
<para>Исключение пакета/категории</para>
<para/>
<para>Вы можете выборочно обновлять определенные категории/пакеты, игнорируя обновление других категорий/пакетов. Это достигается путем исключения таких категорий/пакетов программой rsync на этапе выполнения emerge --sync. </para>
<para/>
<para>Вам потребуется определить имя файла, содержащего шаблоны исключаемых пакетов, в переменной RSYNC_EXCLUDEFROM в своем файле /etc/make.conf. </para>
<para/>
<para>Листинг 1: Указание файла исключаемых пакетов в /etc/make.conf</para>
<para>RSYNC_EXCLUDEFROM=/etc/portage/rsync_excludes</para>
<para/>
<para/>
<para>Листинг 2: Исключение всех игр в файле /etc/portage/rsync_excludes</para>
<para>games-*/*</para>
<para/>
<para/>
<para>Заметьте, однако, что это может привести к проблемам с зависимостями, так как новые разрешенные пакеты могут зависеть от других новых, но исключенных из обновления пакетов. </para>
<para/></sect3><sect3><title>5.b. Добавление неофициального сборочного файла ebuild</title>
<para/>
<para>Определение оверлейного каталога портежей</para>
<para/>
<para>Вы можете указать Portage использовать сборочные файлы, не входящие в официальное дерево Portage. Создайте новый каталог (к примеру, /usr/local/portage), в котором будут находиться файлы ebuild сторонних разработчиков. Используйте в точности такую же структуру каталогов, как и в официальном дереве портежей! </para>
<para/>
<para>Затем определите переменную PORTDIR_OVERLAY в /etc/make.conf, чтобы она указывала на ранее созданный каталог. Теперь при использовании Portage, эти сборочные файлы будут рассматриваться как часть системы, и не будут удаляться/перезаписываться при последующих запусках emerge --sync. </para>
<para/>
<para>Работа с несколькими оверлейными каталогами</para>
<para/>
<para>Для продвинутых пользователей, ведущих разработку в нескольких оверлейных каталогах, тестирующих пакеты перед включением в основное дерево портежей или просто желающих использовать неофициальные сборочные файлы ebuild из разных источников, в пакете app-portage/gentoolkit-dev есть утилита gensync, которая поможет поддерживать ваши оверлейные репозитории в актуальном состоянии. </para>
<para/>
<para>Используя gensync, вы можете обновить сразу все репозитории или выбрать для обновления только некоторые из них. В каждом репозитории в каталоге /etc/gensync/ должен находиться файл .syncsource, в котором содержится информация о местоположении репозитория, его имени, идентификаторе и т.д. </para>
<para/>
<para>Предположим, что у вас есть два дополнительных репозитория с названиями java (для сборочных файлов разработок, ведущихся на java) и entapps (для внутренних приложений, разработанных на вашем предприятии). Вы можете обновить эти репозитории следующей командой: </para>
<para/>
<para/>
<para/>
<para>Листинг 3: Запуск gensync для обновления нескольких репозиториев</para>
<para># gensync java entapps</para>
<para/>
<para/></sect3><sect3><title>5.c. Программы, поддерживаемые не Portage</title>
<para/>
<para>Использование Portage с пакетами самостоятельной сборки</para>
<para/>
<para>Иногда вам может потребоваться сконфигурировать, установить и поддерживать программное обеспечение самостоятельно, без автоматизации со стороны Portage, не смотря на то, что оно поддерживается Portage. Наиболее известные случаи — это исходные коды ядра и драйверы от nVidia. Вы можете настроить Portage так, чтобы системе стало известно, что определенные пакеты установлены вручную. Этот процесс называется внедрение, и поддерживается Portage посредством файла /etc/portage/profile/package.provided. </para>
<para/>
<para>Например, если вы захотите сообщить Portage, что пакет vanilla-sources-2.6.11.6 установлен вручную, нужно добавить следующую строку в /etc/portage/profile/package.provided: </para>
<para/>
<para>Листинг 4: Пример строки из файла package.provided</para>
<para>sys-kernel/vanilla-sources-2.6.11.6</para>
<para/></sect3></sect2><sect2><title>6. Использование ebuild</title>
<para/><sect3><title>6.a. Emerge и Ebuild</title>
<para/>
<para>Программа ebuild — это низкоуровневый интерфейс системы Portage. С ее помощью можно выполнять определенные действия над заданными сборками ebuild. Например, вы можете самостоятельно выполнить отдельные этапы установки. </para>
<para/>
<para>Программа ebuild предназначена в основном для разработчиков, поэтому более подробная информация находится в настольной книге разработчика (англ.). Однако, мы расскажем, какие экземпляры ebuild вызываются системой Portage на разных этапах установки, и как выполнить пост-конфигурационные шаги, которые допускаются некоторыми пакетами. </para>
<para/></sect3><sect3><title>6.b. Ручная установка программ</title>
<para/>
<para>Извлечение исходных кодов и проверка контрольных сумм</para>
<para/>
<para>Каждый раз, когда вы вызываете ebuild для какого-то ebuild-файла, проверяется совпадение контрольной суммы всех задействованных файлов с указанной в файлах Manifest или files/digest-&lt;имя&gt;-&lt;версия&gt;. Проверка выполняется после загрузки исходных кодов. </para>
<para/>
<para>Чтобы загрузить исходные коды с помощью ebuild, запустите: </para>
<para/>
<para>Листинг 1: Загрузка исходных кодов</para>
<para># ebuild путь/к/файлу-ebuild fetch</para>
<para/>
<para/>
<para>Если контрольная сумма md5 сборочного файла не совпадает с той, что указана в файле Manifest, или же один из загруженных файлов не совпадает с описанием в файле files/digest&lt;пакет&gt;, вы получите сообщение об ошибке, похожее на такое: </para>
<para/>
<para>Листинг 2: Ошибка контрольной суммы ebuild</para>
<para>!!! File is corrupt or incomplete. (Digests do not match)</para>
<para>&gt;&gt;&gt; our recorded digest: db20421ce35e8e54346e3ef19e60e4ee</para>
<para>&gt;&gt;&gt;  your file's digest: f10392b7c0b2bbc463ad09642606a7d6</para>
<para/>
<para>(!!! Файл поврежден или усечен. (Контрольные суммы не совпадают) )</para>
<para/>
<para/>
<para>На следующей строке указывается проблемный файл. </para>
<para/>
<para>Если вы абсолютно уверены, что загруженные исходные коды и сам сборочный файл ebuild именно те, что вам нужны, можете пересоздать файлы Manifest и digest-&lt;пакетe&gt;, используя фукцию digest программы ebuild: </para>
<para/>
<para>Листинг 3: Создание новых файлов Manifest и digest</para>
<para># ebuild путь/к/файлу-ebuild digest</para>
<para/>
<para/>
<para>Распаковка исходных кодов</para>
<para/>
<para>Чтобы рапаковать исходные коды в /var/tmp/portage (или любой другой каталог, указанный в /etc/make.conf), запустите функцию unpack программы ebuild: </para>
<para/>
<para>Листинг 4: Распаковка исходных кодов</para>
<para># ebuild путь/к/файлу-ebuild unpack</para>
<para/>
<para/>
<para>Эта команда выполнит функцию src_unpack() программы ebuild (которая по умолчанию просто выполняет распаковку, если функция src_unpack() не определена). Все необходимые заплатки накладываются также на этом этапе. </para>
<para/>
<para>Компиляция исходных кодов</para>
<para/>
<para>Следующий шаг в процессе установки — компиляция исходных кодов. Для этого выполняется функция src_compile() вашего сборочного файла. Если нужно, заодно выполняется конфигурация. </para>
<para/>
<para>Листинг 5: Компиляция исходных кодов</para>
<para># ebuild путь/к/файлу-ebuild compile</para>
<para/>
<para/>
<para>Если вы хотите изменить инструкции компиляции, советуем отредактировать функцию src_compile(). Однако, вы можете также обмануть Portage, заставив ее поверить, что программа ebuild уже завершила компиляцию. Запустите нужные команды самостоятельно и создайте пустой файл .compile в рабочем каталоге. </para>
<para/>
<para>Листинг 6: Сообщение Portage о завершении задания компиляции</para>
<para># touch .compiled</para>
<para/>
<para/>
<para>Установка файлов во временное место</para>
<para/>
<para>Следующий шаг — установка всех необходимых файлов во временный каталог. В него помещаются все файлы, подлежащие включению в рабочую файловую систему. Вы можете выполнить этот этап, запустив функцию установки программы ebuild, которая исполняет функцию src_install() сборочного файла. </para>
<para/>
<para>Листинг 7: Установка файлов</para>
<para># ebuild путь/к/файлу-ebuild install</para>
<para/>
<para/>
<para>Помещение файлов в рабочую файловую систему</para>
<para/>
<para>Последний этап — перенос всех файлов в рабочую файловую систему и их регистрация в системе Portage. В ebuild этот этап называется «qmerge», и включает следующие действия: </para>
<orderedlist>
<listitem>
<para>выполняется функция pkg_preinst(), если она определена;</para>
</listitem>
<listitem>
<para>все файлы копируются в рабочую файловую систему;</para>
</listitem>
<listitem>
<para>файлы регистрируются в системе Portage;</para>
</listitem>
<listitem>
<para>выполняется функция pkg_postinst(), если она определена;</para>
</listitem>
</orderedlist>
<para/>
<para>Запустите функцию qmerge программы ebuild, чтобы выполнить этот этап: </para>
<para/>
<para>Листинг 8: Помещение файлов в рабочую файловую систему</para>
<para># ebuild путь/к/файлу-ebuild qmerge</para>
<para/>
<para/>
<para>Очистка временного каталога</para>
<para/>
<para>Наконец, можно очистить временный каталог, используя команду clean программы ebuild: </para>
<para/>
<para>Листинг 9: Очистка временного каталога</para>
<para># ebuild путь/к/файлу-ebuild clean</para>
<para/>
<para/></sect3><sect3><title>6.c. Дополнительные возможности Ebuild</title>
<para/>
<para>Запуск всех команд установки</para>
<para/>
<para/>
<para>С помощью функции merge программы ebuild, можно запустить команды извлечения, распаковки, компиляции, установки и помещения за один раз: </para>
<para/>
<para>Листинг 10: Установка программы</para>
<para># ebuild путь/к/файлу-ebuild merge</para>
<para/>
<para/>
<para>Выполнение действий по настройке</para>
<para/>
<para>В некоторых приложениях содержатся инструкции по дальнейшей настройке установленного пакета. Эти инструкции могут потребовать участия пользователя, и, следовательно, не выполняться автоматически. Для запуска шагов настройки, указанных в необязательной функции config() сборочного файла, используйте команду config программы ebuild: </para>
<para/>
<para>Листинг 11: Настройка пакета</para>
<para># ebuild путь/к/файлу-ebuild config</para>
<para/>
<para/>
<para>Сборка пакета (RPM)</para>
<para/>
<para>Вы можете попросить Portage создать двоичный пакет или даже RPM из вашего сборочного файла, воспользовавшись командами package и rpm, соответственно. Эти команды несколько различаются: </para>
<orderedlist>
<listitem>
<para>команда package во многом похожа на merge, выполняя все необходимые шаги (извлечение, распаковку, компиляцию, установку) перед созданием пакета; </para>
</listitem>
<listitem>
<para>команда rpm собирает пакет RPM из файлов созданных после запуска окончания функции install программы ebuild. </para>
</listitem>
</orderedlist>
<para/>
<para>Листинг 12: Создание пакетов</para>
<para>(cоздание двоичного пакета, совместимого с Portage)</para>
<para># ebuild путь/к/файлу-ebuild package</para>
<para/>
<para>(создание пакета RPM)</para>
<para># ebuild путь/к/файлу-ebuild rpm</para>
<para/>
<para/>
<para>Созданный RPM, однако, не будет содержать информацию о зависимостях из сборочного файла ebuild. </para>
<para/></sect3><sect3><title>6.d. Дополнительная информация</title>
<para/>
<para/>
<para>За дополнительными сведениями о системе Portage, программе ebuild и сценариях ebuild обращайтесь к следующим страницам справки man: </para>
<para/>
<para>Листинг 13: Страницы справки</para>
<para>$ man portage    (сама система Portage)</para>
<para>$ man emerge     (команда emerge)</para>
<para>$ man ebuild     (команда ebuild)</para>
<para>$ man 5 ebuild   (синтаксис файлов ebuild)</para>
<para/>
<para/>
<para>Кроме того, дополнительные сведения, относящиеся к разработке, находятся в настольной книге разработчика (англ.). </para>
<para/>
<para/></sect3></sect2><sect2><title>D. Настройка сети в Gentoo</title></sect2><sect2><title>1. Начальная настройка</title><sect3><title>1.a. Приступаем к настройке</title>
<para>Примечание: В документе предполагается, что вы правильно сконфигурировали свое ядро и модули для оборудования, и вам известно интерфейсное имя устройств. Мы также предполагаем, что вы настраиваете eth0, хотя на самом деле это может оказаться eth1, wlan0 и т.д. </para>
<para/>
<para>Примечание: Требуется, чтобы у вас использовался baselayout-1.11.11 или более свежий. </para>
<para/>
<para/>
<para>Для начала настройки своей сетевой платы, нужно рассказать о ней системе Gentoo RC. Это делается созданием символической ссылки с net.lo на net.eth0 в /etc/init.d. </para>
<para/>
<para>Листинг 1: Создание символической ссылки с net.lo на net.eth0</para>
<para># cd /etc/init.d</para>
<para># ln -s net.lo net.eth0</para>
<para/>
<para/>
<para>Теперь система Gentoo RC знает об этом интерфейсе. Ей также нужно знать, как настраивать новый интерфейс. Конфигурация всех сетевых интерфейсов находится в /etc/conf.d/net. Вот простая настройка для использования DHCP или статического адреса. </para>
<para/>
<para>Листинг 2: Примеры для /etc/conf.d/net</para>
<para># использование DHCP</para>
<para>config_eth0=( "dhcp" )</para>
<para/>
<para># статический IP-адрес, используется запись CIDR</para>
<para>config_eth0=( "192.168.0.7/24" )</para>
<para>routes_eth0=( "default via 192.168.0.1" )</para>
<para/>
<para># статический IP-адрес, запись с маской подсети</para>
<para>config_eth0=( "192.168.0.7 netmask 255.255.255.0" )</para>
<para>routes_eth0=( "default gw 192.168.0.1" )</para>
<para/>
<para>Примечание: Если конфигурация для интерфейса не указывается, предполагается использование DHCP. </para>
<para/>
<para>Примечание: CIDR расшифровывается как Classless InterDomain Routing (бесклассовая междоменная маршрутизация). Первоначально, адреса IPv4 были разделены на классы A, B и C. Ранняя система классификации не была рассчитана на массовую популярность интернета, и попала под угрозу исчерпания новых уникальных адресов. CIDR — это схема адресации, позволяющая одному IP-адресу обозначать множество IP-адресов. IP-адрес CIDR выглядит как обычный IP-адрес с добавлением косой черты и числа; например, 192.168.0.0/16. CIDR описывается в RFC 1519. </para>
<para/>
<para/>
<para>Теперь, настроив интерфейс, мы можем запускать и останавливать его следующими командами: </para>
<para/>
<para>Листинг 3: Сценарии запуска и остановки сети</para>
<para># /etc/init.d/net.eth0 start</para>
<para># /etc/init.d/net.eth0 stop</para>
<para/>
<para>Важно: При поиске неисправностей сети рекомендуется установить RC_VERBOSE="yes" в /etc/conf.d/rc для получения более подробной информации о происходящем. </para>
<para/>
<para/>
<para>Теперь, успешно запустив и остановив сетевой интерфейс, вы можете захотеть, чтобы он запускался при каждой загрузке Gentoo. Вот как это сделать. Последняя команда «rc» указывает Gentoo, что нужно запускать в текущем уровне запуска любые еще не запущенные сценарии. </para>
<para/>
<para>Листинг 4: Настройка запуска сетевого интерфейса при загрузке</para>
<para># rc-update add net.eth0 default</para>
<para># rc</para>
<para/></sect3></sect2><sect2><title>2. Расширенная настройка</title><sect3><title>2.a. Расширенная настройка</title>
<para/>
<para>Переменная config_eth0 служит основой конфигурации интерфейса. Она содержит список высокоуровневых инструкций по настройке интерфейса (в данном случае, eth0). Все команды списка выполняются последовательно. Интерфейс считается работоспособным, если хотя бы одна команда выполнена успешно. </para>
<para/>
<para>Вот список встроенных инструкций: </para>
<para/>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>Команда</para>
</entry>
<entry>
<para>Описание</para>
</entry>
</row>
<row>
<entry>
<para>null</para>
</entry>
<entry>
<para>Не выполнять никаких действий</para>
</entry>
</row>
<row>
<entry>
<para>noop</para>
</entry>
<entry>
<para>Если интерфейс включен и существует адрес, успешно завершить настройку. </para>
</entry>
</row>
<row>
<entry>
<para>an IPv4 or IPv6 address</para>
</entry>
<entry>
<para>Добавить адрес к интерфейсу</para>
</entry>
</row>
<row>
<entry>
<para>dhcp, adsl or apipa(или команда запуска модуля стороннего изготовителя)</para>
</entry>
<entry>
<para>Запустить модуль, реализующий команду. Например, dhcp запускает модуль, реализующий команду. Например, dhcp запускает модуль, реализующий DHCP, которым может быть dhcpcd, udhcpc, dhclient или pump. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para/>
<para>На случай неудачного выполнения команды можно указать запасную команду. Запасной вариант должен строго соответствовать структуре конфигурации. </para>
<para/>
<para>Команды можно сцеплять. Вот несколько практических примеров. </para>
<para/>
<para/>
<para/>
<para/>
<para/>
<para>Листинг 1: Примеры настройки</para>
<para># Задание трех адресов IPv4</para>
<para>config_eth0=(</para>
<para>  "192.168.0.2/24"</para>
<para>  "192.168.0.3/24"</para>
<para>  "192.168.0.4/24"</para>
<para>)</para>
<para/>
<para># Задание одного адреса IPv4 и двух адресов IPv6</para>
<para>config_eth0=(</para>
<para>  "192.168.0.2/24"</para>
<para>  "4321:0:1:2:3:4:567:89ab"</para>
<para>  "4321:0:1:2:3:4:567:89ac"</para>
<para>)</para>
<para/>
<para># Сохранять адрес, присвоенный ядром, до отключения интерфейса.</para>
<para># При этом назначить другой через DHCP. Если DHCP не работает, </para>
<para># задать статический адрес, определяемый APIPA</para>
<para>config_eth0=(</para>
<para>  "noop"</para>
<para>  "dhcp"</para>
<para>)</para>
<para>fallback_eth0=(</para>
<para>  "null"</para>
<para>  "apipa"</para>
<para>)</para>
<para/>
<para>Примечание: При использовании модуля ifconfig для назначения нескольких адресов, для каждого дополнительного адреса создаются псевдонимы интерфейса. Так, в двух примерах, приведенных выше, создаются интерфейсы eth0, eth0:1 и eth0:2. С этими интерфейсами нельзя сделать ничего особенного, так как и ядро, и другие программы обрабатывают eth0:1 и eth0:2 просто как eth0. </para>
<para/>
<para>Важно: Порядок настройки запасного режима имеет значение! Если бы мы не указали инструкцию null, то команда apipa запускалась бы только при неудачном выполнении команды noop. </para>
<para/>
<para>Примечание: APIPA и DHCP обсуждаются позже. </para>
<para/></sect3><sect3><title>2.b. Сетевые зависимости</title>
<para/>
<para>Сценарии инициализации в /etc/init.d могут находиться в зависимости от определенного сетевого интерфейса или просто от службы сети (net). Определив переменную RC_NET_STRICT_CHECKING в /etc/conf.d/rc, службе net можно придать различный смысл. </para>
<para/>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>Значение</para>
</entry>
<entry>
<para>Описание</para>
</entry>
</row>
<row>
<entry>
<para>none</para>
</entry>
<entry>
<para>Служба net считается всегда работающей</para>
</entry>
</row>
<row>
<entry>
<para>no</para>
</entry>
<entry>
<para>В основном это означает, что по крайней мере одна служба net.*, кроме net.lo, должна работать. Это может пригодиться пользователям ноутбуков, у которых есть WIFI и статическое проводное подключение, когда нужно, чтобы при включении хотя бы одного интерфейса служба сети выглядела включенной. </para>
</entry>
</row>
<row>
<entry>
<para>lo</para>
</entry>
<entry>
<para>То же, что и no, но с учетом net.lo. Может быть полезно для тех, кого не волнует, чтобы определенный интерфейс включался при загрузке.</para>
</entry>
</row>
<row>
<entry>
<para>yes</para>
</entry>
<entry>
<para>В этом случае ВСЕ сетевые интерфейсы ДОЛЖНЫ работать, чтобы служба net считалась работающей. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para> </para>
<para>Но как насчет net.br0, зависимого от net.eth0 и net.eth1? net.eth1 может быть беспроводным или РРР-устройством, требующим предварительной настройки для возможности включения в мост. Это невозможно сделать в /etc/init.d/net.br0, так как он является символьной ссылкой на net.lo. </para>
<para/>
<para>Ответом является создание своей собственной функции depend() в /etc/conf.d/net. </para>
<para/>
<para>Листинг 2: Зависимость net.br0 в /etc/conf.d/net</para>
<para># Можно использовать любую зависимость (use, after, before),</para>
<para># как видно в текущих сценариях</para>
<para>depend_br0() {</para>
<para>  need net.eth0 net.eth1</para>
<para>}</para>
<para/>
<para/>
<para>Более подробно зависимости обсуждаются в разделе Написание сценариев инициализации Настольной книги Gentoo. </para></sect3><sect3><title>2.c. Имена и значения переменных</title>
<para/>
<para>Имена переменных являются динамическими. Обычно они следуют структуре variable_${interface|mac|essid|apmac}. Например, значение переменной dhcpcd_eth0 хранит параметры dhcpcd для eth0, а переменной dhcpcd_essid — параметры dhcpcd, используемые при подключении любого интерфейса к ESSID «essid». </para>
<para/>
<para>Однако, не существует твердого простого правила, устанавливающего, что интерфейсы должны называться ethx. На деле, имена многих беспроводных выглядят как wlanx, rax и ethx. Кроме того, некоторые пользовательские интерфейсы, например, мосты, можно называть как угодно, например, foo. Для пущего разнообразия, в именах беспроводных точек доступа также допускаются знаки, не входящие в алфавитно-цифровые; это имеет значение, потому что есть возможность настройки сетевых параметров для отдельных ESSID. </para>
<para/>
<para>Оборотная сторона всего этого в том, что для настройки сети в Gentoo используются переменные bash, а bash не в состоянии использовать что-либо кроме знаков английского алфавита и цифр. Чтобы обойти такое ограничение, мы заменяем каждый символ, не являющийся английским буквенно-цифровым, на знак подчеркивания: _. </para>
<para/>
<para>Другая особенность bash — это значения переменных: некоторые символы требуют специальной записи, перед ними помещается знак \. Им необходимо предварять следующие символы: ", ' и \. </para>
<para/>
<para>В следующем примере мы используем беспроводные ESSID, так как в них может содержаться самое широкое множество символов. Мы воспользуемся ESSID My "\ NET: </para>
<para/>
<para>Листинг 3: Пример имени переменной</para>
<para># Этот пример работает, но домен не существует</para>
<para>dns_domain_My____NET="My \"\\ NET"</para>
<para/>
<para># Предыдущая строка устанавливает домен dns в My "\ NET при </para>
<para># подключении беспроводной платы к точке доступа с ESSID My "\ NET.</para>
<para/></sect3></sect2><sect2><title>3. Модульное построение сети</title><sect3><title>3.a. Сетевые модули</title>
<para/>
<para>Сейчас мы поддерживаем модульные сетевые сценарии. Это значит, что мы можем легко добавлять поддержку для новых типов интерфейсов и конфигурационных модулей, сохраняя совместимость с существующими. </para>
<para/>
<para>По умолчанию, модули загружаются только если пакет, нужный им, установлен. Если отметить модуль, для которого не установлен пакет, будет выдана ошибка с указанием, какой пакет нужно установить. В идеале, настройка модулей требуется только тогда, когда установленно несколько пакетов, представляющих одну и ту же службу, а вам установить приоритет одного из них. </para>
<para/>
<para>Примечание: Все обсуждаемые значения хранятся в /etc/conf.d/net, если явно не указано иное. </para>
<para/>
<para/>
<para>Листинг 1: Предпочтение модуля</para>
<para># выбор iproute2, а не ifconfig</para>
<para>modules=( "iproute2" )</para>
<para/>
<para># можно также указать другие модули для отдельного интерфейса</para>
<para># здесь мы выбираем udhcpc, а не dhcpcd</para>
<para>modules_eth0=( "udhcpc" )</para>
<para/>
<para># также можно указать, какие модули не надо использовать: например,</para>
<para># возможно, вы используете supplicant или linux-wlan-ng для управления</para>
<para># параметрами беспроводной сети, но при этом желаете настраивать сетевые</para>
<para># параметры раздельно для каждого связанного ESSID</para>
<para>modules=( "!iwconfig" )</para>
<para/></sect3><sect3><title>3.b. Обработчики интерфейса</title>
<para/>
<para>Сейчас мы предоставляем два обработчика интерфейса: ifconfig и iproute2. Для настройки сети вам нужен только один из них. </para>
<para/>
<orderedlist>
<listitem>
<para>ifconfig в текущем Gentoo используется по умолчанию, и включен в системный профиль. </para>
</listitem>
<listitem>
<para>iproute2 — более мощный и гибкий пакет, который не включен в системный профиль по умолчанию. </para>
</listitem>
</orderedlist>
<para/>
<para>Листинг 2: Установка iproute2</para>
<para># emerge sys-apps/iproute2</para>
<para/>
<para># выбор iproute2, а не ifconfig, когда установлены оба</para>
<para>modules=( "iproute2" )</para>
<para/>
<para/>
<para>Так как и ifconfig и iproute2 делают очень сходные вещи, то мы сделали их базовую настройку взаимозаменяемой. Например, оба приведенных ниже примера работают не зависимо от того, какой модуль используется. </para>
<para/>
<para>Листинг 3: Примеры ifconfig и iproute2</para>
<para>config_eth0=( "192.168.0.2/24" )</para>
<para>config_eth0=( "192.168.0.2 netmask 255.255.255.0" )</para>
<para/>
<para># также можно указать широковещательный адрес</para>
<para>config_eth0=( "192.168.0.2/24 brd 192.168.0.255" )</para>
<para>config_eth0=( "192.168.0.2 netmask 255.255.255.0 broadcast 192.168.0.255" )</para>
<para/>
<para/></sect3><sect3><title>3.c. DHCP</title>
<para/>
<para>DHCP — это способ получения сетевой информации (адреса IP, сервера DNS, шлюза и т.д.) с сервера. Это значит, что если в сети запущен сервер DHCP, вам остается только сказать каждому клиенту, чтобы он использовал DHCP, и сеть настроится сама собой. Конечно, вам придется настраивать все остальное (бесроводную сеть, подключение точка-точка и т.д.), если они должны работать до использования DHCP. </para>
<para/>
<para>Поддержка DHCP обеспечивается dhclient, dhcpcd, pump или udhcpc. У каждого модуля DHCP есть свои плюсы и минусы: здесь мы быстренько рассмотрим их.</para>
<para/>
<informaltable frame="all">
<tgroup cols="4"><tbody>
<row>
<entry>
<para> Модуль DHCP</para>
</entry>
<entry>
<para>Пакет</para>
</entry>
<entry>
<para>Плюсы</para>
</entry>
<entry>
<para>Минусы</para>
</entry>
</row>
<row>
<entry>
<para>dhclient</para>
</entry>
<entry>
<para>net-misc/dhcp</para>
</entry>
<entry>
<para>Сделан ISC, теми же людьми, кто делает BIND DNS. Гибок в настройке. </para>
</entry>
<entry>
<para>Настройка чрезмерно сложна, программа довольно «распухшая», не может получать данные о серверах NTP с DHCP, по умолчанию не отправляет имя узла. </para>
</entry>
</row>
<row>
<entry>
<para>dhcpcd</para>
</entry>
<entry>
<para>net-misc/dhcpcd</para>
</entry>
<entry>
<para>Давно в Gentoo по умолчанию, не зависит от внешних утилит. </para>
</entry>
<entry>
<para>Более не поддерживается разработчиком, может быть временами медленным, не становится демоном при неограниченном сроке аренды адреса.</para>
</entry>
</row>
<row>
<entry>
<para>pump</para>
</entry>
<entry>
<para>net-misc/pump</para>
</entry>
<entry>
<para>Компактный, не зависит от внешних утилит. </para>
</entry>
<entry>
<para>Более не поддерживается разработчиком, ненадежен, особенно по модему, не может получать данные о серверых NIS по DHCP.</para>
</entry>
</row>
<row>
<entry>
<para>udhcpc</para>
</entry>
<entry>
<para>net-misc/udhcp</para>
</entry>
<entry>
<para>Компактный; наименьший существующий клиент DHCP, сделан для встроенных систем.</para>
</entry>
<entry>
<para>Не зарекомендовал себя — ни в одном дистрибутиве не используется по умолчанию; не поддерживает длительность таймаута более 3 секунд. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para/>
<para>Если у вас установлено больше одного DHCP клиента, вам нужно указать, какой использовать; иначе по умолчанию используется dhcpcd, если есть. </para>
<para/>
<para>Чтобы передать определенные параметры модулю DHCP, используйте модуль_eth0="..." (замените модуль на имя используемого модуля DHCP, например, dhcpcd_eth0). </para>
<para/>
<para>Мы попытались сделать DHCP относительным агностиком: по существу, мы поддерживаем следующие команды, с использованием переменной dhcp_eth0. По умолчанию не включена ни одна из них. </para>
<para>release — освобождать IP-адрес для повторного использования </para>
<para>nodns — не замещать /etc/resolv.conf </para>
<para>nontp — не замещать /etc/ntp.conf </para>
<para>nonis — не замещать /etc/yp.conf </para>
<para/>
<para>Листинг 4: Простая настройка DHCP в /etc/conf.d/net</para>
<para># требуется только если у вас несколько модулей DHCP</para>
<para>modules=( "dhcpcd" )</para>
<para/>
<para>config_eth0=( "dhcp" )</para>
<para>dhcpcd_eth0="-t 10" # прекращение после 10 секунд</para>
<para>dhcp_eth0="release nodns nontp nonis" # только получать адрес</para>
<para/>
<para>Примечание: По умолчанию, dhcpcd, udhcpc и pump передают текущее узла на сервер DHCP, поэтому его больше не требуется указывать. </para>
<para/>
<para/></sect3><sect3><title>3.d. Модем ADSL</title>
<para/>
<para>Сначала нужно установить программное обеспечение для ADSL. </para>
<para/>
<para>Листинг 5: Установка пакета rp-pppoe</para>
<para># emerge net-dialup/rp-pppoe</para>
<para/>
<para>Предупреждение: В baselayout-1.11.x поддерживается только PPPoE. Надеемся, что в будущих версиях появится поддержка PPPoA. </para>
<para/>
<para/>
<para>Сейчас нам нужно указать, что на eth0 будет ADSL-интерфейс, и ввести наше имя пользователя, обновив /etc/conf.d/net. </para>
<para/>
<para>Листинг 6: Настройка eth0 для ADSL в /etc/conf.d/net</para>
<para>                                   </para>
<para>config_eth0=( "adsl" )</para>
<para>adsl_user_eth0="имя-пользователя"</para>
<para/>
<para/>
<para>Наконец, нужно указать ваше имя и пароль в /etc/ppp/pap-secrets. </para>
<para/>
<para>Листинг 7: Пример /etc/ppp/pap-secrets</para>
<para># * обязательна</para>
<para>"пользователь"  *  "пароль"</para>
<para/>
<para/></sect3><sect3><title>3.e. APIPA (автоматическая частная IP-адресация)</title>
<para/>
<para> 2APIPA пытается найти свободный адрес в диапазоне 169.254.0.0-169.254.255.255, проверяя отклик на интерфейсе произвольного адреса из этого диапазона по протоколу arp. Если отклика нет, адрес назначается интерфейсу. </para>
<para/>
<para>Это полезно только в локальных сетях, где нет сервера DHCP, нет прямого подключения к интернету, и все другие компьютеры используют APIPA. </para>
<para/>
<para>Для поддержки APIPA установите net-misc/iputils или net-analyzer/arping. </para>
<para/>
<para>Листинг 8: Настройка APIPA в /etc/conf.d/net</para>
<para># сначала пробуем DHCP, при неудаче переходим на APIPA</para>
<para>config_eth0=( "dhcp" )</para>
<para>fallback_eth0=( "apipa" )</para>
<para/>
<para># использование только APIPA</para>
<para>config_eth0=( "apipa" )</para>
<para/>
<para/></sect3><sect3><title>3.f. Объединение интерфейсов</title>
<para/>
<para>Для объединения каналов в ствол (bonding) установите net-misc/ifenslave. </para>
<para/>
<para>Объединение используется для повышения пропускной способности сети. Если у вас есть две сетевых карты, выходящих в одну и ту же сеть, можно объединить их, так что ваши приложения увидят только один интерфейс, но реально будут пользоваться двумя сетевыми платами. </para>
<para/>
<para>Листинг 9: Настройка объединения в /etc/conf.d/net</para>
<para># объединение интерфейсов</para>
<para>slaves_bond0="eth0 eth1 eth2"</para>
<para/>
<para># вы можете не захотеть назначать адрес IP объединенному интерфейсу</para>
<para>config_bond0=( "null" )</para>
<para/>
<para># указание зависимости от eth0, eth1 и eth2, так как им может требоваться</para>
<para># дополнительная настройка</para>
<para>depend_bond0() {</para>
<para>need net.eth0 net.eth1 net.eth2</para>
<para>}</para>
<para/></sect3><sect3><title>3.g. Образование моста (поддержка 802.1d)</title>
<para/>
<para>Для поддержки мостов установите net-misc/bridge-utils. </para>
<para/>
<para>Мосты используются для объединения сетей. Например, у вас может быть сервер, подсоединенный к интернету через ADSL-модем, и плата беспроводного доступа для предоставления доступа в интернет через ADSL модем другим компьютерам. Чтобы соединить оба интерфейса, можно создать «мост». </para>
<para/>
<para>Листинг 10: Настройка моста в /etc/conf.d/net</para>
<para># настройка моста: подробности в "man btctl"</para>
<para>brctl_br0=( "setfd 0" "sethello 0" "stp off" )</para>
<para/>
<para># включаем порты в мост br0</para>
<para>bridge_br0="eth0 eth1"</para>
<para/>
<para># устанавливаем порты в "null", чтобы не запускался dhcp</para>
<para>config_eth0=( "null" )</para>
<para>config_eth1=( "null" )</para>
<para/>
<para># наконец, даем мосту адрес; можно использовать и DHCP</para>
<para>config_br0=( "192.168.0.1/24" )</para>
<para/>
<para># указываем зависимость от eth0 и eth1, так как им может требоваться</para>
<para># дополнительная настройка</para>
<para>depend_br0() {</para>
<para>need net.eth0 net.eth1</para>
<para>}</para>
<para/>
<para>Важно: Для использования некоторых вариантов моста вам может потребоваться обращение к документации по именам переменных. </para>
<para/>
<para/></sect3><sect3><title>3.h. MAC-адрес</title>
<para/>
<para>Для изменения MAC-адреса своего интерфейса вам не потребуется ничего устанавливать, если у вас sys-apps/baselayout-1.11.14 или новее, и вы собираетесь сменить MAC-адрес на какой-то определенный. Однако, если вам нужно сменить MAC-адрес на случайный, или ваш baselayout старше указанной версии, для смены адреса потребуется установить пакет командой emerge net-analyzer/macchanger. </para>
<para/>
<para>Листинг 11: Пример изменения MAC-адреса</para>
<para># установка MAC-адреса интерфейса</para>
<para>mac_eth0="00:11:22:33:44:55"</para>
<para/>
<para># случайная установка последних 3 байт адреса</para>
<para>mac_eth0="random-ending"</para>
<para/>
<para># установка случайного адреса из диапазона для физического соединения</para>
<para># того же типа (оптического, медного, беспроводного) любого изготовителя</para>
<para>mac_eth0="random-samekind"</para>
<para/>
<para># установка случайного адреса из диапазона для любого типа физического</para>
<para># соединения (оптического, медного, беспроводного) любого изготовителя</para>
<para>mac_eth0="random-anykind"</para>
<para/>
<para># полностью случайный; ВНИМАНИЕ, некоторые MAC-адреса, сгенерированные</para>
<para># таким образом, могут вести себя НЕ ТАК, как предполагается</para>
<para>mac_eth0="random-full"</para>
<para/>
<para/></sect3><sect3><title>3.i. Образование тоннеля</title>
<para/>
<para>Для образования тоннеля вам не нужно ничего устанавливать, поскольку на это способен сам обработчик интерфейса. </para>
<para/>
<para>Листинг 12: Настройка тоннеля в /etc/conf.d/net</para>
<para># для тоннелей GRE</para>
<para>iptunnel_vpn0="mode gre remote 207.170.82.1 key 0xffffffff ttl 255"</para>
<para/>
<para># для тоннелей IPIP</para>
<para>iptunnel_vpn0="mode ipip remote 207.170.82.2 ttl 255"</para>
<para/>
<para># для настройки интерфейса</para>
<para>config_vpn0=( "192.168.0.2 peer 192.168.1.1" )</para>
<para/>
<para/></sect3><sect3><title>3.j. Виртуальные сети (поддержка 802.1q)</title>
<para/>
<para>Для поддержки VLAN, установите net-misc/vconfig. </para>
<para/>
<para>Виртуальная локальная сеть (VLAN) — это группа сетевых устройств, которые ведут себя, как будто подключены к одному сегменту сети, даже когда это не так. Членам VLAN видны только члены той же VLAN даже если в той же физической сети присутствуют другие. </para>
<para/>
<para>Листинг 13: VLAN configuration in /etc/conf.d/net</para>
<para># указание номеров VLAN для интерфейса</para>
<para># пожалуйста, убедитесь, что ваши номера VLAN НЕ дополнены нулем</para>
<para>vlans_eth0="1 2"</para>
<para/>
<para># можно также настроить VLAN</para>
<para># за подробностями обращайтесь к man vconfig</para>
<para>vconfig_eth0=( "set_name_type VLAN_PLUS_VID_NO_PAD" )</para>
<para>vconfig_vlan1=( "set_flag 1" "set_egress_map 2 6" )</para>
<para/>
<para># настройка интерфейса как обычно</para>
<para>config_vlan1=( "172.16.3.1 netmask 255.255.254.0" )</para>
<para>config_vlan2=( "172.16.2.1 netmask 255.255.254.0" )</para>
<para/>
<para>Важно: Для использования некоторых вариантов VLAN вам может потребоваться обращение к документации по именам переменных. </para>
<para/></sect3></sect2><sect2><title>4. Беспроводная сеть</title><sect3><title>4.a. Введение</title>
<para/>
<para>В настоящее время поддерживается подключение к беспроводной сети с помощью wireless-tools или wpa_supplicant. Важно помнить, что подключение к беспроводным сетям настраивается глобально, а не для определённого интерфейса. </para>
<para/>
<orderedlist>
<listitem>
<para>wpa_supplicant — лучший выбор, но он поддерживает не все драйверы. Список поддерживаемых драйверов находится на сайте wpa_suppliant. Кроме того, сейчас wpa_supplicant может подключаться только к тем сетям, на SSID которых настроен. </para>
<para/>
</listitem>
<listitem>
<para>wireless-tools поддерживает практически все платы и драйверы, но не способен подключаться к точкам доступа, работающим исключительно с WPA.</para>
<para> </para>
</listitem>
</orderedlist>
<para>Предупреждение: Драйвер linux-wlan-ng в данный момент не поддерживается в baselayout. Это из-за того, что в linux-wlan-ng своя собственная программа установки и настройки, которая ни на что не похожа. Разработчики linux-wlan-ng, по слухам, собираются перейти на установку как в wireless-tools; когда это произойдет, вы сможете использовать linux-wlan-ng с baselayout. </para>
<para/>
<para/></sect3><sect3><title>4.b. Запросчик WPA</title>
<para/>
<para>Запросчик WPA (WPA Supplicant) — пакет, позволяющий подсоединяться к точкам доступа с протоколом WPA. Его настройка проходит достаточно гладко, и пакет работает достаточно стабильно, хотя находится на стадии бета-тестирования. </para>
<para/>
<para>Листинг 1: Установка wpa_supplicant</para>
<para># emerge net-wireless/wpa_supplicant</para>
<para/>
<para>Важно: Для работы wpa_supplicant в ядре должен быть включен параметр CONFIG_PACKET. </para>
<para/>
<para/>
<para>Теперь нам необходимо настроить /etc/conf.d/net для предпочтения wpa_supplicant по отношению к wireless-tools (по умолчанию, если обе программы установлены, работает wireless-tools). </para>
<para/>
<para>Листинг 2: Настройка /etc/conf.d/net для wpa_supplicant</para>
<para># выбор wpa_supplicant</para>
<para>modules=( "wpa_supplicant" )</para>
<para/>
<para># важно указать wpa_supplicant, какой драйвер нужно использовать,</para>
<para># так как программа пока не слишком хорошо угадывает сама</para>
<para/>
<para>wpa_supplicant_eth0="-Dбезумный-wifi"</para>
<para/>
<para>Примечание: Если вы используете драйвер host-ap, то вам потребуется перевести плату в ведомый режим (managed mode), прежде чем она сможет правильно работать с wpa_supplicant. Для этого можно указать iwconfig_eth0="mode managed" в /etc/conf.d/net. </para>
<para/>
<para/>
<para>Это довольно просто, не так ли? Однако, нужно настроить саму программу wpa_supplicant, что значительно сложнее. Сложность зависит от степени защиты точек доступа, к которым вы собираетесь подключаться. Следующий упрощенный пример взят из /etc/wpa_supplicant.conf.example, поставляемого в составе wpa_supplicant. </para>
<para/>
<para>Листинг 3: Пример /etc/wpa_supplicant.conf</para>
<para># следующую строку нельзя изменять, иначе программа не сможет работать</para>
<para>ctrl_interface=/var/run/wpa_supplicant</para>
<para/>
<para># ограничим доступ к настройкам WPA только для root</para>
<para>ctrl_interface_group=0</para>
<para/>
<para># пусть wpa_supplicant заботится о сканировании и выборе точки доступа</para>
<para>ap_scan=1</para>
<para/>
<para># простой случай: WPA-PSK, согласованный ключ - текстовая строка,</para>
<para># принимать любой допустимый шифр</para>
<para>network={</para>
<para>  ssid="просто"</para>
<para>  psk="очень тайный пароль"</para>
<para>  # чем выше приоритет, тем скорее выбор</para>
<para>  priority=5</para>
<para>}</para>
<para/>
<para># как в предыдущем, но с запросом сканирования по определенному SSID</para>
<para># (для точек доступа, отклоняющих широковещательный SSID)</para>
<para>network={</para>
<para>  ssid="второй ssid"</para>
<para>  scan_ssid=1</para>
<para>  psk="очень тайный пароль"</para>
<para>  priority=2</para>
<para>}</para>
<para/>
<para># использовать только WPA-PSK; принимать любое допустимое сочетание шифров</para>
<para/>
<para>network={</para>
<para>  ssid="пример"</para>
<para>  proto=WPA</para>
<para>  key_mgmt=WPA-PSK</para>
<para>  pairwise=CCMP TKIP</para>
<para>  group=CCMP TKIP WEP104 WEP40</para>
<para>  psk=06b4be19da289f475aa46a33cb793029d4ab3db7a23ee92382eb0106c72ac7bb</para>
<para>  priority=2</para>
<para>}</para>
<para/>
<para># открытое подключение без шифрования (не WPA, не IEEE #802.1X)</para>
<para/>
<para>network={</para>
<para>  ssid="тест-открытого-текста"</para>
<para>  key_mgmt=NONE</para>
<para>}</para>
<para/>
<para># подключение с общим ключом WEP (не WPA, не IEEE #802.1X)</para>
<para>network={</para>
<para>  ssid="тест-статического-wep"</para>
<para>  key_mgmt=NONE</para>
<para>  wep_key0="abcde"</para>
<para>  wep_key1=0102030405</para>
<para>  wep_key2="1234567890123"</para>
<para>  wep_tx_keyidx=0</para>
<para>  priority=5</para>
<para>}</para>
<para/>
<para># подключение с общим ключом WEP (не WPA, не IEEE #802.1X),</para>
<para># допуск c использованим общего ключа IEEE 802.11</para>
<para>network={</para>
<para>  ssid="тест2-статического-wep"</para>
<para>  key_mgmt=NONE</para>
<para>  wep_key0="abcde"</para>
<para>  wep_key1=0102030405</para>
<para>  wep_key2="1234567890123"</para>
<para>  wep_tx_keyidx=0</para>
<para>  priority=5</para>
<para>  auth_alg=SHARED</para>
<para>}</para>
<para/>
<para># сеть IBSS/ad-hoc с WPA-None/TKIP</para>
<para>network={</para>
<para>  ssid="тест adhoc"</para>
<para>  mode=1</para>
<para>  proto=WPA</para>
<para>  key_mgmt=WPA-NONE</para>
<para>  pairwise=NONE</para>
<para>  group=TKIP</para>
<para>  psk="тайный пароль"</para>
<para>}</para>
<para/>
<para/></sect3><sect3><title>4.c. Утилиты Wireless tools</title>
<para/>
<para>Начальная установка и режим ведомого</para>
<para/>
<para>Wireless Tools обеспечивают общий способ настройки базовых беспроводных интерфейсов, вплоть до защиты WEP. Хотя WEP является слабым методом защиты, он наиболее распространен. </para>
<para/>
<para>Для настройки Wireless Tools служат несколько основных переменных. В примере файла настроек, приведенном ниже, описано все, что вам потребуется. Нужно помнить, что отсутствие настройки означает «подключаться к нешифрующей точке доступа с самым сильным сигналом». Программа будет всегда пытаться подключить вас к чему-нибудь. </para>
<para/>
<para>Листинг 4: Установка wireless-tools</para>
<para># emerge net-wireless/wireless-tools</para>
<para/>
<para>Примечание: Хотя вы можете хранить свои параметры настройки беспроводной сети в /etc/conf.d/wireless, это руководство рекомендует хранить их в /etc/conf.d/net. </para>
<para/>
<para>Важно: Вам понадобится обратиться к документации по именам переменных. </para>
<para/>
<para/>
<para>Листинг 5: Пример настройки iwconfig /etc/conf.d/net</para>
<para># приоритет использования iwconfig над wpa_supplicant</para>
<para>modules=( "iwconfig" )</para>
<para/>
<para># Настройка ключей WEP для точек доступа ESSID1 и ESSID2</para>
<para># Можно указывать до 4 ключей WEP, но только 1 может работать в каждый</para>
<para># момент, поэтому мы указываем индекс по умолчанию [1], чтобы сделать ключ [1],</para>
<para># а впоследствии снова, чтобы изменить активный ключ на [1].</para>
<para># Это нужно, если вы настраиваете другие ESSID на использование WEP-ключей, </para>
<para># отличающихся от [1].</para>
<para>#</para>
<para># Приставка s: перед ключом означает, что ключ текстовый, иначе - </para>
<para># шестнадцатиричный</para>
<para>#</para>
<para># enc open указывает открытую защиту (более безопасно)</para>
<para># enc restricted указывает ограниченную защиту (менее безопасно)</para>
<para>key_ESSID1="[1] s:ваш-ключ-здесь key [1] enc open"</para>
<para>key_ESSID2="[1] aaaa-bbbb-cccc-dd key [1] enc restricted"</para>
<para>#</para>
<para># Нижеследующее работает только при поиске доступных точек доступа.</para>
<para/>
<para># Иногда видны несколько точек доступа, и требуется задать</para>
<para># предпочтительный порядок подключения</para>
<para>preferred_aps=( "ESSID1" "ESSID2" )</para>
<para/>
<para/>
<para>Настройка порядка выбора точки доступа</para>
<para/>
<para>Можно указать несколько дополнительных параметров для уточнения порядка выбора точки доступа, но обычно этого не требуется. </para>
<para/>
<para>Вам решать, подключаться ли только к указанным точкам доступа, или нет. По умолчанию, если подключение ко всем настроенным точкам доступа не удалось, и есть возможность подключиться к не шифрующей точке доступа, такое соединение произойдет. Этот порядок зависит от переменной associate_order. Ниже приводится таблица значений и с описанием их действия:</para>
<para/>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>Значение</para>
</entry>
<entry>
<para>Описание</para>
</entry>
</row>
<row>
<entry>
<para>any</para>
</entry>
<entry>
<para>поведение по умолчанию</para>
</entry>
</row>
<row>
<entry>
<para>preferredonly</para>
</entry>
<entry>
<para>соединяться только с видимыми точками доступа из списка</para>
</entry>
</row>
<row>
<entry>
<para>forcepreferred</para>
</entry>
<entry>
<para>принудительно подключаться к точкам доступа в заданной последовательности, если они не обнаружены при сканировании </para>
</entry>
</row>
<row>
<entry>
<para>forcepreferredonly</para>
</entry>
<entry>
<para>не сканировать точки доступа, просто пытаться подключиться к каждой по списку </para>
</entry>
</row>
<row>
<entry>
<para>forceany</para>
</entry>
<entry>
<para>так же, как в forcepreferred + подключаться к любой доступной точке доступа </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Наконец, мы можем указать blacklist_aps и unique_ap. blacklist_aps работает подобно preferred_aps. unique_ap устанавливается в yes или no, указывая, можно ли подключать второй беспроводной интерфейс к той же точке доступа, что и первый. </para>
<para/>
<para>Листинг 6: Пример blacklist_aps и unique_ap</para>
<para># иногда требуется полностью исключить возможность подключения</para>
<para># к определенным точкам доступа</para>
<para>blacklist_aps=( "ESSID3" "ESSID4" )</para>
<para/>
<para># если у вас несколько беспроводных плат, можно указать, можно ли им</para>
<para># подключаться к одной и той же точке доступа</para>
<para># значение - "yes" или "no"</para>
<para># по умолчанию - "yes"</para>
<para>unique_ap="yes"</para>
<para/>
<para/>
<para>Режим отдельного и ведущего узла</para>
<para/>
<para>Если вы хотите становиться отдельным узлом (ad hoc), когда не удается подключиться ни к какой точке доступа в ведомом режиме, это тоже возможно. </para>
<para/>
<para>Листинг 7: Откат к режиму отдельного узла</para>
<para>adhoc_essid_eth0="Этот отдельный узел"</para>
<para/>
<para/>
<para>Как насчет подключения к сетям Ad-Hoc или запуска в режиме ведущего (master), чтобы стать точкой доступа? Есть конфигурация и для такой работы! Вам может потребоваться определить WEP-ключи, как показано выше. </para>
<para/>
<para>Листинг 8: Пример настройки ad-hoc/master</para>
<para># установка режима: допускается managed (ведомый, по умолчанию),</para>
<para># ad-hoc (отдельный) или или master (ведущий). Не все драйверы поддерживают </para>
<para># каждый режим </para>
<para>mode_eth0="ad-hoc"</para>
<para/>
<para># установка ESSID интерфейса</para>
<para># в ведомом режиме заставляет интерфейс пытаться подключиться к указанному</para>
<para># ESSID, и больше ничего</para>
<para>essid_eth0="Этот отдельный узел"</para>
<para/>
<para># если не указан, используется канал 3</para>
<para>channel_eth0="9"</para>
<para/>
<para>Важно: Следующий текст взят дословно из документации BSD wavelan, входящей в документацию NetBSD. «Существуют 14 каналов. Нам сообщили, что использование каналов с 1 по 11 является законным в Северной Америке, каналов с 1 по 13 — в большинстве стран Европы, каналов с 10 по 13 — во Франции, и только канала 14 — в Японии. Если у вас есть сомнения, обратитесь к документации от вашей платы или точки доступа. Убедитесь что выбранный канал совпадает с каналом точки доступа (или другой платы в сети ad-hoc). По умолчанию на платах, продаваемых в Северной Америке и большинстве стран Европы, настроен канал 3; на платах, продаваемых во Франции — канал 11; на платах, продаваемых в Японии — канал 14.» </para>
<para/>
<para/>
<para>Устранение неполадок в wireless tools</para>
<para/>
<para>Существуют дополнительные переменные, которые можно использовать для запуска своего беспроводного оборудования и устранения неполадок, возникших из-за драйвера или проблем с сетевым окружением. Ниже приведена таблица прочих функций, которые можно перепробовать:</para>
<para/>
<informaltable frame="all">
<tgroup cols="3"><tbody>
<row>
<entry>
<para>Переменная</para>
</entry>
<entry>
<para>Значение по умолчанию</para>
</entry>
<entry>
<para>Описание</para>
</entry>
</row>
<row>
<entry>
<para>iwconfig_eth0</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>За подробными сведениями о параметрах iwconfig обращайтесь к странице справки iwconfig. </para>
</entry>
</row>
<row>
<entry>
<para>iwpriv_eth0</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>За подробными сведениями о параметрах iwpriv обращайтесь к странице справки iwpriv </para>
</entry>
</row>
<row>
<entry>
<para>sleep_scan_eth0</para>
</entry>
<entry>
<para>0</para>
</entry>
<entry>
<para>Время задержки в секундах перед попыткой сканирования. Требуется, когда драйверу или прошивке нужно дополнительное время для перехода в рабочий режим.</para>
</entry>
</row>
<row>
<entry>
<para>sleep_associate_eth0</para>
</entry>
<entry>
<para>5</para>
</entry>
<entry>
<para>Время ожидания связи интерфейса с точкой доступа (в секундах) перед переходом к опросу следующей</para>
</entry>
</row>
<row>
<entry>
<para>associate_test_eth0</para>
</entry>
<entry>
<para>MAC</para>
</entry>
<entry>
<para>Некоторые драйверы не сбрасывают MAC-адрес, связанный с недоступной точкой доступа, при потере или попытки связи. Некоторые драйверы не сбрасывают значение качества сигнала при потере или попытке соединения. Допустимые значения: MAC, quality и all. </para>
</entry>
</row>
<row>
<entry>
<para>scan_mode_eth0</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>Некоторым драйверам необходимо сканировать в режиме ad-hoc. Если сканирование не удается, попробуйте указать здесь ad-hoc.</para>
</entry>
</row>
<row>
<entry>
<para>iwpriv_scan_pre_eth0</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>Посылать интерфейсу некоторые команды iwpriv перед сканированием. За дополнительными сведениями обращайтесь к странице справки iwpriv. </para>
</entry>
</row>
<row>
<entry>
<para>iwpriv_scan_post_eth0</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para>Посылать интерфейсу некоторые команды iwpriv после сканирования. За дополнительными сведениями обращайтесь к странице справки iwpriv. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para/></sect3><sect3><title>4.d. Раздельная настройка сети по ESSID</title>
<para/>
<para>Иногда необходим статический IP при соединении с ESSID1, и DHCP при соединении с ESSID2. На деле, большинство переменных модуля можно определять раздельно по ESSID. Вот как это сделать: </para>
<para/>
<para>Примечание: Это работает при использовании WPA Supplicant или Wireless Tools. </para>
<para/>
<para>Важно: Вам потребуется свериться с документацией по именам переменных. </para>
<para/>
<para/>
<para>Листинг 9: Назначение сетевых настроек для ESSID</para>
<para>config_ESSID1=( "192.168.0.3/24 brd 192.168.0.255" )</para>
<para>routes_ESSID1=( "default via 192.168.0.1" )</para>
<para/>
<para>config_ESSID2=( "dhcp" )</para>
<para>fallback_ESSID2=( "192.168.3.4/24" )</para>
<para>fallback_route_ESSID2=( "default via 192.168.3.1" )</para>
<para/>
<para># можно также указать сервера имен и др.</para>
<para># ПРЕДУПРЕЖДЕНИЕ: DHCP переопределит настройки, если не указано иное</para>
<para>dns_servers_ESSID1=( "192.168.0.1" "192.168.0.2" )</para>
<para>dns_domain_ESSID1="some.domain"</para>
<para>dns_search_domains_ESSID1="search.this.domain search.that.domain"</para>
<para/>
<para># перенастройка производится по МАС-адресу точки доступа;</para>
<para># это полезно, когда в разных местах есть точки доступа с одинаковым ESSID</para>
<para>config_001122334455=( "dhcp" )</para>
<para>dhcpcd_001122334455="-t 10"</para>
<para>dns_servers_001122334455=( "192.168.0.1" "192.168.0.2" )</para>
<para/></sect3></sect2><sect2><title>5. Дополнительные возможности</title><sect3><title>5.a. Стандартные функции-обработчики</title>
<para/>
<para>Можно определить четыре функции, которые вызываются при операциях запуска (start) и останова (stop). При вызове функциям передается название интерфейса, так что одна и та же функция может управлять несколькими адаптерами. </para>
<para/>
<para>Для указания на то, что запуск или останов интерфейса может продолжаться, возвращаемое значение функций preup() и predown() должно быть нулевым (успешным). Если preup() возвращает ненулевое значение, запуск интерфейса прерывается. Если predown() возвращает ненулевое значение, не допускается продолжение останова интерфейса. </para>
<para/>
<para>Возвращаемые значение функций postup() и postdown() игнорируется, так как показываемая ими ошибка не обрабатывается. </para>
<para/>
<orderedlist>
<listitem>
<para>${IFACE} присваивается название запускаемого/останавливаемого интерфейса. </para>
</listitem>
<listitem>
<para>${IFVAR} — это значение ${IFACE}, преобразованное в имя переменной, разрешенное в bash. </para>
</listitem>
</orderedlist>
<para/>
<para>Листинг 1: Примеры функций до/после запуска/останова</para>
<para>preup() {</para>
<para>  # Проверка соединения интерфейса перед его запуском. Она</para>
<para>  # работает лишь с некоторыми сетевыми адаптерами и требует наличия</para>
<para>  # установленного пакета mii-diag.</para>
<para>  if mii-tool ${IFACE} 2&gt; /dev/null | grep -q 'no link'; then</para>
<para>    ewarn "Интерфейс ${IFACE} не подключен, прерывание запуска"</para>
<para>    return 1</para>
<para>  fi</para>
<para/>
<para>  # Проверка соединения интерфейса перед его запуском. Она</para>
<para>  # работает лишь с некоторыми сетевыми адаптерами и требует наличия</para>
<para>  # установленного пакета ethtool.</para>
<para>  if ethtool ${IFACE} | grep -q 'Link detected: no'; then</para>
<para>    ewarn "Интерфейс ${IFACE} не подключен, прерывание запуска"</para>
<para>    return 1</para>
<para>  fi</para>
<para/>
<para>  # Не забываем вернуть 0 при успехе</para>
<para>  return 0</para>
<para>}</para>
<para/>
<para>predown() {</para>
<para>  # Назначение этого сценария - проверить наличие корня NFS</para>
<para>  # и в этом случае предотвратить останов интерфейсов. Заметьте, что</para>
<para>  # определяя функцию predown(), вы отменяете существующую логику. </para>
<para>  # Вот она, на случай если все же понадобится...</para>
<para>  if is_net_fs /; then</para>
<para>    eerror "Корневая ФС смонтирована в сети - останов ${IFACE} невозможен"</para>
<para>    return 1</para>
<para>  fi</para>
<para/>
<para>  # Не забываем вернуть 0 при успехе</para>
<para>  return 0</para>
<para>}</para>
<para/>
<para>postup() {</para>
<para>  # Эту функцию можно использовать, например, для регистрации в</para>
<para>  # службе динамического DNS. Другой пример - отправка/прием почты после</para>
<para>  # запуска интерфейса.</para>
<para>       return 0</para>
<para>}</para>
<para/>
<para>postdown() {</para>
<para>  # Эта функция приводится в основном для полноты... Я не придумал,</para>
<para>  # что бы ценное в нее поместить ;-)</para>
<para>  return 0</para>
<para>}</para>
<para/>
<para/></sect3><sect3><title>5.b. Функции-обработчики wireless tools</title>
<para>Примечание: Это не работает вместе с WPA Supplicant, но переменные ${ESSID} и ${ESSIDVAR} доступны в функции postup(). </para>
<para/>
<para/>
<para>Можно определить две функции, вызываемые до и после функции подключения (associate). При вызове им сначала передается название интерфейса, так что одна и та же функция может управлять несколькими адаптерами. </para>
<para/>
<para>Для указания на то, что запуск или останов интерфейса можно продолжать, возвращаемое значение функции preassociate() должно быть нулевым (успешным). Если preassociate() возвращает ненулевое значение, запуск интерфейса прерывается. </para>
<para/>
<para>Возвращаемое значение функции postassociate() игнорируется, так как показываемая ей ошибка не обрабатывается. </para>
<para/>
<para>${ESSID} присваивается точный ESSID точки доступа, к которой вы подключаетесь. ${ESSIDVAR} — это ${ESSID}, преобразованный в имя переменной, разрешенное в bash. </para>
<para/>
<para>Листинг 2: Функции до/после соединения</para>
<para>preassociate() {</para>
<para>  # Ниже добавляются две конфигурационных переменных, leap_user_ESSID</para>
<para>  # и leap_pass_ESSID. Когда они обе настроены на подключаемый ESSID,</para>
<para>  # мы запускаем сценарий CISCO LEAP</para>
<para/>
<para>  local user pass</para>
<para>  eval user=\"\$\{leap_user_${ESSIDVAR}\}\"</para>
<para>  eval pass=\"\$\{leap_pass_${ESSIDVAR}\}\"</para>
<para/>
<para>  if [[ -n ${user} &amp;&amp; -n ${pass} ]]; then</para>
<para>    if [[ ! -x /opt/cisco/bin/leapscript ]]; then</para>
<para>      eend "Для поддержки LEAP, выполните emerge net-misc/cisco-aironet-client-utils"</para>
<para>      return 1</para>
<para>    fi</para>
<para>    einfo "Ожидание допуска LEAP на \"${ESSID//\\\\//}\""</para>
<para>    if /opt/cisco/bin/leapscript ${user} ${pass} | grep -q 'Login incorrect'; then</para>
<para>      ewarn "Вход пользователя ${user} не удался"</para>
<para>      return 1</para>
<para>    fi</para>
<para>  fi</para>
<para/>
<para>  return 0</para>
<para>}</para>
<para/>
<para>postassociate() {</para>
<para>  # Эта функция приводится в основном для полноты... Я не придумал,</para>
<para>  # что бы ценное в нее поместить ;-)</para>
<para/>
<para>  return 0</para>
<para>}</para>
<para/>
<para>Примечание: ${ESSID} и ${ESSIDVAR} недоступны в функциях predown() и postdown(). </para>
<para/></sect3></sect2><sect2><title>6. Управление сетью</title><sect3><title>6.a. Управление сетью</title>
<para/>
<para>Если вы часто берете компьютер в поездки, то у вас не всегда может быть возможность подключения к сети Ethernet или к беспроводной точке доступа. Но мы можем захотеть, чтобы сеть заработала автоматически, как только к компьтеру подключен кабель Ethernet или найдена беспроводная точка доступа. </para>
<para/>
<para>Здесь вы найдете некоторые инструменты, которые помогут это организовать. </para>
<para/>
<para>Примечание: В этом документе рассказывается только о ifplugd, но есть и альтернативные решения, например, quickswitch. </para>
<para/>
<para/></sect3><sect3><title>6.b. ifplugd</title>
<para/>
<para>ifplugd — это программа, которая запускает и останавливает интерфейс при подключении или отключении кабеля к сети Ethernet. Также она может обработать подключение к беcпроводной точке доступа или появление новых точек доступа. </para>
<para/>
<para>Листинг 1: Установка ifplugd</para>
<para># emerge sys-apps/ifplugd</para>
<para/>
<para/>
<para>Настройка ifplugd — довольно простая задача. Файл конфигурации расположен по адресу: /etc/conf.d/ifplugd. Для просмотра подробного описания переменных запустите man ifplugd. </para>
<para/>
<para>Листинг 2: Пример конфигурации ifplug</para>
<para># назначение интерфейса для слежения</para>
<para>INTERFACES="eth0"</para>
<para/>
<para>AUTO="no"</para>
<para>BEEP="yes"</para>
<para>IGNORE_FAIL="yes"</para>
<para>IGNORE_FAIL_POSITIVE="no"</para>
<para>IGNORE_RETVAL="yes"</para>
<para>POLL_TIME="1"</para>
<para>DELAY_UP="0"</para>
<para>DELAY_DOWN="0"</para>
<para>API_MODE="auto"</para>
<para>SHUTDOWN="no"</para>
<para>WAIT_ON_FORK="no"</para>
<para>MONITOR="no"</para>
<para>ARGS=""</para>
<para/>
<para># дополнительные параметры ifplugd для указанного интерфейса.</para>
<para># учтите, установки глобальных переменных игнорируются, если указаны значения</para>
<para># для конкретного интерфейса</para>
<para>MONITOR_wlan0="yes"</para>
<para>DELAY_UP_wlan0="5"</para>
<para>DELAY_DOWN_wlan0="5"</para>
<para/></sect3></sect2></sect1><sect1><title>Настольная книга по безопасности Gentoo</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/security/">http://www.gentoo.org/doc/ru/security/</ulink>
</para>
<para>C версии: 1.3</para><sect2><title>Введение</title>
<para>Эта настольная книга предназначена для людей, использующих Gentoo Linux в качестве сервера или чувствующих, что они нуждаются в повышении безопасности системы. </para>
<para>Если после прочтения этой книги вы заинтересуетесь дальнейшим усилением защищенности системы Gentoo, то обратите внимание на проект укрепленной системы Gentoo — <ulink url="http://www.gentoo.org/proj/en/hardened/">Hardened Gentoo Project </ulink>(англ.).</para>
<para/></sect2><sect2><title>A. Безопасность системы</title><sect3><title>1. Соображения перед началом установки</title><sect4><title>1.a. Физическая безопасность</title>
<para>Сколько преград не установи, злоумышленник, имея физический доступ к компьютеру, сможет легко их обойти. Несмотря на это, кое-какие меры для относительной защиты от злоумышленника с физическим доступом к вашей машине принять можно. Поместив оборудование в кладовку под замок, вы помешаете злоумышленнику попросту отключить его и унести с собой. Стоит запереть корпус компьютера на замок, чтобы не дать злоумышленнику просто вынуть из него жесткий диск. Чтобы предотвратить загрузку с альтернативного диска, благодаря чему можно просто обойти порядок входа в систему и права доступа, попробуйте установить в BIOS жесткий диск в качестве первого загрузочного устройства и запаролить BIOS. Также важно установить пароль для загрузчика LILO или GRUB, чтобы не дать недобросовестному пользователю загрузить систему в однопользовательском режиме, получив к ней полный доступ. Это подробно описано в третьей главе, в разделах <ulink url="http://www.gentoo.org/doc/ru/security/security-handbook.xml?style=printable&amp;full=1#passwording_GRUB">защита GRUB паролем</ulink> и <ulink url="http://www.gentoo.org/doc/ru/security/security-handbook.xml?style=printable&amp;full=1#passwording_LILO">защита LILO паролем</ulink>. </para></sect4><sect4><title>1.b. Планирование демонов/служб</title>
<para>Для начала выпишите службы, которые должны работать на машине. Это поможет вам выбрать наилучшую схему разбивки разделов в системе и позволит лучше спланировать меры безопасности. Конечно же, в этом нет необходимости, если ваш компьютер служит для одной определенной задачи, например в качестве рабочей станции или выделенного межсетевого экрана. В таких случаях не должны запускаться никакие службы, за исключением, возможно, sshd. </para>
<para>Составленный список также может пригодиться для администрирования системы. Вы увидите, что, поддерживая перечень текущих версий, значительно легче удерживать все в актуальном состоянии, когда в каких-либо из ваших демонов обнаруживаются уязвимости к удаленному доступу.</para></sect4><sect4><title>1.c. Схемы создания разделов</title>
<para>Правила разбиения разделов: </para>
<orderedlist>
<listitem>
<para>любое дерево каталогов, в которое пользователь должен иметь возможность записи (например, /home, /tmp), должно размещаться в отдельном разделе с использованием дисковых квот. Это снижает риск переполнения всей файловой системы каким-либо пользователем. Portage использует /var/tmp для компиляции, поэтому этот раздел должен быть большим </para>
</listitem>
<listitem>
<para>любое дерево каталогов, в которое вы планируете устанавливать программное обеспечение не средствами управления пакетами дистрибутива, следует размещать в отдельном разделе. Согласно <ulink url="http://www.pathname.com/fhs/">стандарту иерархии файлов</ulink> (англ.), это /opt или /usr/local. Являясь отдельными разделами, они не удаляются при переустановке системы </para>
</listitem>
<listitem>
<para>для лишней защиты можно поместить статические данные в отдельный раздел, монтируемый только для чтения. Если вы настоящий параноик, можете пользоваться неперезаписываемым носителем, например, компакт-диском </para>
</listitem>
</orderedlist></sect4><sect4><title>1.d. Пользователь root</title>
<para>Администратор системы (пользователь root) является наиболее важным пользователем, и его права не следует использовать без крайней необходимости. Если злоумышленник получит доступ с правами администратора, единственным способом восстановить доверие к системе будет переустановить ее. </para>
<para>Золотые правила для root </para>
<orderedlist>
<listitem>
<para>всегда создавайте пользователя для каждодневных работ, а если этому пользователю понадобятся права администратора, добавьте его в группу «wheel». Это дает возможность обычным пользователям выполнять команды с правами администратора с помощью su </para>
</listitem>
<listitem>
<para>никогда не запускайте X или другое пользовательское приложение под root. Права администратора следует использовать только при крайней необходимости: если уязвимость есть в приложении, запущенном от имени пользователя, злоумышленник может получить права этого пользователя. А если приложение запущено с правами администратора, то злоумышленник получит их. </para>
</listitem>
<listitem>
<para>войдя под учетной записью администратора, всегда указывайте абсолютные пути (или всегда используйте команду su -, которая заменяет переменные среды пользователя на администраторские, обеспечивая наличие в PATH администратора только защищенных каталогов, например /bin и /sbin). Иначе можно обмануть администратора и заставить его выполнить совершенно другое приложение. Если PATH администратора защищен или он использует только абсолютные пути, то можно быть уверенным, что это не произойдет </para>
</listitem>
<listitem>
<para>если пользователю нужно выполнять лишь несколько команд с правами администратора, то вместо использования учетной записи root, рекомендуется использовать команду sudo. Просто также задумывайтесь, кому вы даете доступ к этой команде! </para>
</listitem>
<listitem>
<para>никогда не оставляйте без присмотра терминал, в котором вы зарегистрированы в качестве root </para>
</listitem>
</orderedlist>
<para>В Gentoo по умолчанию есть некоторая защита от обычных пользователей, пытающихся с помощью su получить права администратора. По умолчанию настройки PAM требуют, чтобы пользователь был членом группы «wheel» для того, чтобы запускать команду su. </para></sect4><sect4><title>1.e. Правила безопасности</title>
<para>Есть ряд причин набросать правила безопасности для своей системы или сети. </para>
<orderedlist>
<listitem>
<para>хорошие правила безопасности позволяют вам наметить подход к безопасности системно, а не сваливать в кучу разрозненные меры. Например, без правил администратор может решить отключить telnet, так как в нем пароли передаются не зашифрованными, оставив доступ по FTP, обладающему таким же недостатком. Хорошие правила безопасности позволяют выявить, какие меры безопасности имеют смысл, а какие — нет </para>
</listitem>
<listitem>
<para>чтобы выявлять проблемы, проводить аудит или выслеживать злоумышленников, может потребоваться перехват данных, передаваемых по сети, проверка истории входа пользователей и выполнявшихся ими команд, а также просмотр их домашних каталогов. Без указания об этом в документации и явного предупреждения пользователей такие действия могут оказаться незаконными и привести к привлечению вас к ответственности по закону </para>
</listitem>
<listitem>
<para>похищенные учетные записи пользователей являются одной из самых распространенных угроз безопасности системы. Не объясняя пользователям, почему безопасность важна, и как ее поддерживать (например, не записывать пароли на клочках бумаги на рабочем месте), можно и не надеяться на защищенность пользовательских данных </para>
</listitem>
<listitem>
<para>хорошо задокументированная схема сети и системы поможет как вам, так и, при необходимости, суду и следствию, отслеживать проникновение злоумышленника и выявлять слабые места по факту взлома. Уведомление правил безопасности о том, что ваша система является частной сетью и несанкционированный доступ запрещен, также способствует надлежащему преследованию нарушителя по закону после его поимки </para>
</listitem>
</orderedlist>
<para>Надеемся, что теперь необходимость в хороших правилах безопасности более чем ясна. </para>
<para>Сами по себе правила — это документ или набор документов, раскрывающих функции сети или системы (например, какие именно услуги предоставляются), допустимые и запрещенные действия, применение «передового опыта» обеспечения безопасности, и т. д. Все пользователи должны быть знакомы как с правилами безопасности, так и с изменениями, которые вы вносите для поддержания их актуальности. Важно уделять время, чтобы добиваться понимания правил пользователями, объяснять, зачем знакомится под роспись, и что будет, если пользователь явно нарушит их требования (в правилах безопасности об этом должно быть ясно указано). Необходимо повторять ознакомление по крайней мере раз в год, так как правила подвержены изменениям (а также для напоминания пользователям). </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Создавайте правила, понятные для чтения и не допускающие разночтений в любой ситуации. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Правила безопасности должны охватывать по крайней мере следующие темы: </para>
<orderedlist>
<listitem>
<para>допустимые действия </para>
</listitem>
<listitem>
<para>обращение с ценными сведениями (в любом письменном виде, на электронном или бумажном носителе) </para>
</listitem>
<listitem>
<para>обращение с компьютерным оборудованием в поездках </para>
</listitem>
</orderedlist>
<para>Для разных пользователей могут требоваться разные типы или уровни доступа, и содержание ваших правил может отличаться, чтобы охватить их все. </para>
<para>В распухших правилах безопасности легко упустить важные моменты. В правилах для ИТ-персонала могут содержаться сведения, закрытые для обычных пользователей. Поэтому есть смысл разделить их на несколько небольших разделов, например, «допустимые действия», «использование паролей», «правила использования электронной почты», «правила удаленного доступа». </para>
<para>Примеры правил безопасности приведены на сайте <ulink url="http://www.sans.org/resources/policies/">проекта правил безопасности SANS</ulink> (англ.). Если у вас небольшая сеть, и вы считаете, что эти примеры слишком велики, можете обратиться к <ulink url="ftp://ftp.isi.edu/in-notes/rfc2196.txt">руководству по объектовой безопасности (Site Security Handbook)</ulink> (англ.). </para></sect4></sect3><sect3><title>2. Закручивание гаек</title><sect4><title>2.a. USE-флаги</title>
<para>В Gentoo Linux файл make.conf содержит USE-флаги, определенные пользователем, а /etc/make.profile/make.defaults — USE-флаги по умолчанию. Для данного руководства важны флаги pam (Pluggable Authentication Modules — подключаемые модули опознания), tcpd (Упаковщики TCP) и ssl (Secure Socket Layer). Все они включены в USE-флаги по умолчанию. </para></sect4><sect4><title>2.b. Защита GRUB паролем</title>
<para>В GRUB можно защитить загрузчик паролем двумя различными способами. В первом используется открытый пароль, а во втором — шифрование с использованием md5+salt. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1: /boot/grub/grub.conf</para>
</entry>
</row>
<row>
<entry>
<para>timeout 5</para>
<para>password changeme</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Благодаря этим строкам был добавлен пароль changeme. Если во время загрузки не ввести пароль, то GRUB просто загружает вариант по умолчанию. </para>
<para>При добавлении пароля MD5 вы должны преобразовать открытый пароль в зашифрованный в том же формате, что и в файле /etc/shadow. За дополнительными сведениями обращайтесь к man crypt. Зашифрованный пароль, например changeme, может выглядеть вот так: $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs. </para>
<para>Зашифровать пароль можно прямо в оболочке GRUB: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2: md5crypt в оболочке grub</para>
</entry>
</row>
<row>
<entry>
<para>#/sbin/grub</para>
<para/>
<para>GRUB version 0.92 (640K lower / 3072K upper memory)</para>
<para/>
<para>   [ Minimal BASH-like line editing is supported. For the first word, TAB lists</para>
<para>     possible command completions. Anywhere else TAB lists the possible</para>
<para>     completions of a device/filename. ]</para>
<para/>
<para>grub&gt; md5crypt</para>
<para/>
<para>Password: ********</para>
<para>(было набрано слово changeme)</para>
<para>Encrypted: $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.</para>
<para/>
<para>grub&gt; quit</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Затем скопируйте полученный пароль в /boot/grub/grub.conf. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3: /boot/grub/grub.conf</para>
</entry>
</row>
<row>
<entry>
<para>timeout 5</para>
<para>password --md5 $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Задержка в 5 секунд пригодится в случае, когда система физически недоступна, и нужна возможность перезагрузки без использования клавиатуры. Более подробно о паролях в GRUB вы можете узнать, набрав info grub. </para></sect4><sect4><title>2.c. Защита LILO паролем</title>
<para>В LILO также поддерживается два способа защиты с помощью пароля: общий и для отдельного образа, в обоих случаях пароль хранится в открытом виде. </para>
<para>Общий пароль устанавливается в начале файла конфигурации и относится к каждому загрузочному образу: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4: /etc/lilo.conf</para>
</entry>
</row>
<row>
<entry>
<para>password=changeme</para>
<para>restricted</para>
<para>delay=3</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Пароль для отдельного образа устанавливается следующим образом: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5: /etc/lilo.conf</para>
</entry>
</row>
<row>
<entry>
<para>image=/boot/bzImage</para>
<para>      read-only</para>
<para>      password=changeme</para>
<para>      restricted</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Если параметр restricted не введен, то пароль будет запрашиваться при каждой загрузке. </para>
<para>Чтобы сохранить новые сведения в файле lilo.conf, нужно запустить /sbin/lilo. </para></sect4><sect4><title>2.d. Ограничение доступа к консоли</title>
<para>С помощью файла /etc/securetty можно указать, с каких терминальных устройств (tty) можно входить в систему администратору. </para>
<para>Рекомендуется закомментировать все строки, кроме vc/1 (если у вас devfs), или кроме tty1 (если у вас udev). Благодаря этому суперпользователь сможет входить в систему одновременно только один раз и только с одного терминала. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Пользователи, входящие в группу «wheel» по-прежнему смогут воспользоваться su -, чтобы стать администратором, работая с других терминалов. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 6: /etc/securetty</para>
</entry>
</row>
<row>
<entry>
<para>(для devfs)</para>
<para>vc/1</para>
<para>(для udev)</para>
<para>tty1</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4></sect3><sect3><title>3. Журналирование</title><sect4><title>3.a. Введение</title>
<para>Для перехвата предупреждений и ошибок, которые могут свидетельствовать о происходящей атаке или успешном взломе, следует подключать дополнительное журналирование. Часто злоумышленники сканируют систему и «проверяют ее на зуб» перед атакой. </para>
<para>Также немаловажно, чтобы файлы журналов были легко читаемыми и обозримыми. В Gentoo Linux при установке на выбор предлагается 3 разных средства журналирования. </para></sect4><sect4><title>3.b. Журналирование: Syslogd</title>
<para>Syslogd является самым распространенным средством журналирования для Linux и Unix. Он способен делать ротацию журналов, однако использование /usr/sbin/logrotate с вызовом по расписанию (logrotate настраивается с помощью файла /etc/logrotate.conf) может оказаться полезней, так как у logrotate есть много дополнительных возможностей. Частота ротации подбирается в зависимости от загрузки системы. </para>
<para>Ниже приведен стандартный файл syslog.conf с некоторыми добавлениями. Мы раскомментировали строки cron и tty, и добавили удаленный сервер журналирования. Для дальнейшего усиления журналирования можно настроить ведение журнала в двух местах. </para>
<para/>
<para/>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1: /etc/syslog.conf</para>
</entry>
</row>
<row>
<entry>
<para>#  /etc/syslog.conf     Файл настройки syslogd.</para>
<para>#</para>
<para>#                       За дополнительной информацией обращайтесь к</para>
<para>#                       странице справки syslog.conf(5).</para>
<para>#                       Взято из Debian, пока пользуемся им</para>
<para>#                       Daniel Robbins, 5/15/99</para>
<para/>
<para>#</para>
<para># Сначала стандартные файлы журналов.  Журналирование по подсистемам.</para>
<para>#</para>
<para/>
<para>auth,authpriv.*                 /var/log/auth.log</para>
<para>*.*;auth,authpriv.none          -/var/log/syslog</para>
<para>cron.*                         /var/log/cron.log</para>
<para>daemon.*                        -/var/log/daemon.log</para>
<para>kern.*                          -/var/log/kern.log</para>
<para>lpr.*                           -/var/log/lpr.log</para>
<para>mail.*                          /var/log/mail.log</para>
<para>user.*                          -/var/log/user.log</para>
<para>uucp.*                          -/var/log/uucp.log</para>
<para>local6.debug                    /var/log/imapd.log</para>
<para/>
<para>#</para>
<para># Журналирование почтовой системы. Разбито на части, чтобы</para>
<para># легко писать сценарии для разбора этих файлов.</para>
<para>#</para>
<para>mail.info                       -/var/log/mail.info</para>
<para>mail.warn                       -/var/log/mail.warn</para>
<para>mail.err                        /var/log/mail.err</para>
<para/>
<para># Журналирование новостной системы INN</para>
<para>#</para>
<para>news.crit                       /var/log/news/news.crit</para>
<para>news.err                        /var/log/news/news.err</para>
<para>news.notice                     -/var/log/news/news.notice</para>
<para/>
<para>#</para>
<para># Журналы, куда может попадать "все подряд".</para>
<para>#</para>
<para>*.=debug;\</para>
<para>        auth,authpriv.none;\</para>
<para>        news.none;mail.none     -/var/log/debug</para>
<para>*.=info;*.=notice;*.=warn;\</para>
<para>        auth,authpriv.none;\</para>
<para>        cron,daemon.none;\</para>
<para>        mail,news.none          -/var/log/messages</para>
<para/>
<para>#</para>
<para># Предупреждения и чрезвычайные сообщения, посылаемые всем вошедшим.</para>
<para>#</para>
<para>*.emerg                         *</para>
<para>*.=alert                        *</para>
<para/>
<para>#</para>
<para># Мне нравится вывод сообщений на консоль, но только на ту виртуальную</para>
<para># консоль, что я обычно оставляю простаивать.</para>
<para>#</para>
<para>daemon,mail.*;\</para>
<para>       news.=crit;news.=err;news.=notice;\</para>
<para>       *.=debug;*.=info;\</para>
<para>       *.=notice;*.=warn       /dev/tty8</para>
<para/>
<para># Настройка сервера удаленного журналирования</para>
<para>*.*                        @logserver</para>
<para/>
<para># Именованный канал /dev/xconsole - для утилиты `xconsole'. Чтобы использовать,</para>
<para># следует запускать `xconsole' с параметром `-file':</para>
<para>#</para>
<para>#    $ xconsole -file /dev/xconsole [...]</para>
<para>#</para>
<para># ПРИМЕЧАНИЕ: измените список, данный ниже, или вы с ума сойдете, если</para>
<para>#      у вас осносительно загруженная площадка..</para>
<para>#</para>
<para>#daemon.*,mail.*;\</para>
<para>#       news.crit;news.err;news.notice;\</para>
<para>#       *.=debug;*.=info;\</para>
<para>#       *.=notice;*.=warn       |/dev/xconsole</para>
<para/>
<para>local2.*                --/var/log/ppp.log</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Злоумышленники, скорее всего, будут стараться уничтожать следы своего пребывания, исправляя или удаляя файлы журналов. Можно затруднить им работу, ведя журналирование на одном или нескольких удаленных серверах журнала, расположенных на других компьютерах. Узнать больше о syslogd можно, запустив man syslog.</para></sect4><sect4><title>3.c. Metalog</title>
<para>
<ulink url="http://metalog.sourceforge.net/">Metalog</ulink>, написанный Frank Dennis, не может отправлять журнал на удаленный сервер, но дает преимущество, когда речь о скорости и гибкости журналирования. Он может вести журналы по названию программы, срочности, подсистеме (как и syslogd), и комплектуется разборщиком регулярных выражений, с помощью которых можно запускать внешние сценарии при обнаружении заданных шаблонов. При необходимости это может оказаться очень полезным. </para>
<para>Стандартной настройки обычно достаточно. Если необходимо, чтобы вам отправлялось письмо при любом неверно введенном пароле, используйте один из следующих сценариев. </para>
<para>Для postfix: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2: /usr/local/sbin/mail_pwd_failures.sh для postfix</para>
</entry>
</row>
<row>
<entry>
<para>#! /bin/sh</para>
<para>echo "$3" | mail -s "Warning (program : $2)" root</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Для netqmail: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3: /usr/local/sbin/mail_pwd_failures.sh for netqmail</para>
</entry>
</row>
<row>
<entry>
<para>#!/bin/sh</para>
<para>echo "To: root</para>
<para>Subject:Failure (Warning: $2)</para>
<para>$3</para>
<para>" | /var/qmail/bin/qmail-inject -f root</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Не забудьте сделать сценарий исполняемым командой /bin/chmod +x /usr/local/sbin/mail_pwd_failures.sh. </para>
<para>Затем в файле /etc/metalog/metalog.conf раскомментируйте строку под «Password failures»: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4: /etc/metalog/metalog.conf</para>
</entry>
</row>
<row>
<entry>
<para>command  = "/usr/local/sbin/mail_pwd_failures.sh"</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>3.d. Syslog-ng</title>
<para>Syslog-ng, за некоторыми отличиями, обладает теми же возможностями, что и syslog и metalog. Он может фильтровать сообщения по уровню и содержимому (как metalog), вести удаленное журналирование, как syslog, обрабатывать журналы, получаемые от syslogd (даже потоки от Solaris), записывать в TTY, запускать программы, и служить сервером журналирования. То есть, он сочетает лучшие черты обоих средств журналирования с возможностью расширенной настройки. </para>
<para>Ниже приведен слегка подправленный классический конфигурационный файл. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5: /etc/syslog-ng/syslog-ng.conf</para>
</entry>
</row>
<row>
<entry>
<para>options { chain_hostnames(off); sync(0); };</para>
<para/>
<para>#источник, откуда читать журнал</para>
<para>source src { unix-stream("/dev/log"); internal(); };</para>
<para>source kernsrc { file("/proc/kmsg"); };</para>
<para/>
<para>#получатели</para>
<para>destination authlog { file("/var/log/auth.log"); };</para>
<para>destination syslog { file("/var/log/syslog"); };</para>
<para>destination cron { file("/var/log/cron.log"); };</para>
<para>destination daemon { file("/var/log/daemon.log"); };</para>
<para>destination kern { file("/var/log/kern.log"); };</para>
<para>destination lpr { file("/var/log/lpr.log"); };</para>
<para>destination user { file("/var/log/user.log"); };</para>
<para>destination mail { file("/var/log/mail.log"); };</para>
<para/>
<para>destination mailinfo { file("/var/log/mail.info"); };</para>
<para>destination mailwarn { file("/var/log/mail.warn"); };</para>
<para>destination mailerr { file("/var/log/mail.err"); };</para>
<para/>
<para>destination newscrit { file("/var/log/news/news.crit"); };</para>
<para>destination newserr { file("/var/log/news/news.err"); };</para>
<para>destination newsnotice { file("/var/log/news/news.notice"); };</para>
<para/>
<para>destination debug { file("/var/log/debug"); };</para>
<para>destination messages { file("/var/log/messages"); };</para>
<para>destination console { usertty("root"); };</para>
<para>destination console_all { file("/dev/tty12"); };</para>
<para>destination xconsole { pipe("/dev/xconsole"); };</para>
<para/>
<para>#создание фильтров</para>
<para>filter f_authpriv { facility(auth, authpriv); };</para>
<para>filter f_syslog { not facility(authpriv, mail); };</para>
<para>filter f_cron { facility(cron); };</para>
<para>filter f_daemon { facility(daemon); };</para>
<para>filter f_kern { facility(kern); };</para>
<para>filter f_lpr { facility(lpr); };</para>
<para>filter f_mail { facility(mail); };</para>
<para>filter f_user { facility(user); };</para>
<para>filter f_debug { not facility(auth, authpriv, news, mail); };</para>
<para>filter f_messages { level(info..warn)</para>
<para>        and not facility(auth, authpriv, mail, news); };</para>
<para>filter f_emergency { level(emerg); };</para>
<para/>
<para>filter f_info { level(info); };</para>
<para>filter f_notice { level(notice); };</para>
<para>filter f_warn { level(warn); };</para>
<para>filter f_crit { level(crit); };</para>
<para>filter f_err { level(err); };</para>
<para>filter f_failed { match("failed"); };</para>
<para>filter f_denied { match("denied"); };</para>
<para/>
<para>#связывание фильтров с получателями</para>
<para>log { source(src); filter(f_authpriv); destination(authlog); };</para>
<para>log { source(src); filter(f_syslog); destination(syslog); };</para>
<para>log { source(src); filter(f_cron); destination(cron); };</para>
<para>log { source(src); filter(f_daemon); destination(daemon); };</para>
<para>log { source(kernsrc); filter(f_kern); destination(kern); };</para>
<para>log { source(src); filter(f_lpr); destination(lpr); };</para>
<para>log { source(src); filter(f_mail); destination(mail); };</para>
<para>log { source(src); filter(f_user); destination(user); };</para>
<para>log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };</para>
<para>log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };</para>
<para>log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };</para>
<para/>
<para>log { source(src); filter(f_debug); destination(debug); };</para>
<para>log { source(src); filter(f_messages); destination(messages); };</para>
<para>log { source(src); filter(f_emergency); destination(console); };</para>
<para/>
<para>#журнал по умолчанию</para>
<para>log { source(src); destination(console_all); };</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Syslog-ng очень легко настраивается, но с той же легкостью можно что-либо упустить в файле настройки, так как он очень велик. Автор также обещает дополнительные возможности, например, шифрование, опознание, сжатие и обязательную проверку прав доступа (MAC — mandatory access control). С такими возможностями программа станет незаменимой для журналирования в сети, так как злоумышленник не сможет перехватывать журнал. </para>
<para>К тому же у syslog-ng есть еще одно достоинство: он не требует прав администратора для запуска! </para></sect4><sect4><title>3.e. Анализ журналов с помощью Logcheck</title>
<para>Конечно же, ведение журналов — это только полдела. Приложение наподобие Logcheck может значительно облегчить регулярный анализ журналов. Logcheck — это сценарий, который вместе с двоичным файлом logtail, запускается службой cron и сверяет журналы с заданными правилами на предмет подозрительной деятельности. При совпадении он отправляет электронное письмо с соответствующими записями на почтовый ящик администратора. </para>
<para>Logcheck и logtail входят в состав пакета app-admin/logsentry. </para>
<para>Logcheck использует четыре файла для выделения важных событий из обычных сообщений. Этими файлами являются logcheck.hacking, содержащий известные сообщения, встречающиеся при взломе, logcheck.violations, содержащий шаблоны, сигнализирующие о нарушениях безопасности, logcheck.violations.ignore, содержащий ключевые слова, совпадающие с шаблонами в файле нарушений, но которые можно игнорировать, и logcheck.ignore, содержащий записи, которые можно игнорировать. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: Не оставляйте logcheck.violations.ignore пустым. Для обработки журналов Logcheck использует grep, некоторые версии которого считают пустой файл знаком подстановки (wildcard). В таком случае все нарушения будут игнорироваться. </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4></sect3><sect3><title>4. Монтирование разделов</title><sect4><title>4.a. Монтирование разделов</title>
<para>При монтировании разделов с файловой системой ext2, ext3 или reiserfs можно указать различные параметры в файле /etc/fstab. Среди них: </para>
<orderedlist>
<listitem>
<para>nosuid — игнорировать установленный для файла бит SUID, уподобляя его обычному файлу </para>
</listitem>
<listitem>
<para>noexec — предотвращать запуск файлов с данного раздела </para>
</listitem>
<listitem>
<para>nodev — игнорировать файлы устройств </para>
</listitem>
</orderedlist>
<para>К сожалению, эти настройки можно легко обойти, задействовав косвенные пути. Тем не менее, установкой noexec для /tmp можно воспрепятствовать использованию большинства вредоносных программ, разработанных для запуска напрямую из каталога /tmp. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1: /etc/fstab</para>
</entry>
</row>
<row>
<entry>
<para>/dev/sda1 /boot ext2 noauto,noatime 1 1</para>
<para>/dev/sda2 none swap sw 0 0</para>
<para>/dev/sda3 / reiserfs notail,noatime 0 0</para>
<para>/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec 0 0</para>
<para>/dev/sda5 /var reiserfs notail,noatime,nodev 0 0</para>
<para>/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid 0 0</para>
<para>/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0</para>
<para>/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0</para>
<para>proc /proc proc defaults 0 0</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: Установка /tmp в режим noexec может помешать нормальной работе различных сценариев. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: За сведениями о дисковых квотах обращайтесь к разделу <ulink url="http://www.gentoo.org/doc/ru/security/security-handbook.xml?style=printable&amp;full=1#quotas">квоты</ulink>. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Я не устанавливаю для /var параметры noexec или nosuid, даже если обычно файлы никогда не запускаются из этого каталога, так как netqmail устанавливается в /var/qmail и требует разрешения на исполнение и доступ к одному файлу с SUID. Я устанавливаю /usr в режим только для чтения, так как я никогда ничего не записываю туда, кроме случая обновления Gentoo. Тогда я перемонтирую файловую систему в режиме чтения-записи, обновляю систему и перемонтирую обратно в режиме только для чтения. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Даже если вы не используете netqmail, Gentoo все же нужен установленный бит исполнения для /var/tmp, так поскольку сборка ebuild выполняется именно здесь. Но если у вас есть насущная необходимость монтировать каталог /var с параметром noexec, можно указать для этого альтернативный путь. </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4></sect3><sect3><title>5. Ограничения пользователей/групп</title><sect4><title>5.a. /etc/security/limits.conf</title>
<para>Контроль использования ресурсов может быть очень эффективным при попытке предотвращения локальной атаки на отказ от обслуживания или ограничения максимального количества входов в систему для группы или пользователя. Однако излишне строгие настройки будут затормаживать работу вашей системы и станут причиной сбоев программ, поэтому проверьте каждый из параметров. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1: /etc/security/limits.conf</para>
</entry>
</row>
<row>
<entry>
<para>*    soft core 0</para>
<para>*    hard core 0</para>
<para>*    hard nproc 15</para>
<para>*    hard rss 10000</para>
<para>*    -    maxlogins 2</para>
<para>@dev hard core 100000</para>
<para>@dev soft nproc 20</para>
<para>@dev hard nproc 35</para>
<para>@dev -    maxlogins 10</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Если вы пытаетесь установить nproc или maxlogins в 0, то подумайте, может, лучше вместо этого удалить пользователя. В примере выше установлены настройки группы dev для процессов, основных файлов и maxlogins. Все остальное установлено в значения по умолчанию. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: /etc/security/limits.conf является частью пакета PAM и применима только для пакетов, использующих PAM. </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>5.b. /etc/limits</title>
<para>/etc/limits очень схож с файлом ограничений /etc/security/limits.conf. Единственное отличие — формат, который применим лишь для пользователей или заполнителей (но не для групп). Вот пример конфигурации: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2: /etc/limits</para>
</entry>
</row>
<row>
<entry>
<para>*   L2 C0 U15 R10000</para>
<para>kn L10 C100000 U35</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Здесь устанавливаются настройки по умолчанию и специфичные настройки для пользователя kn. limits являются частью пакета sys-apps/shadow. Если вы включили pam в make.conf, то нет необходимости устанавливать какие-либо ограничения в этом файле. </para></sect4><sect4><title>5.c. Квоты</title>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: Проверьте, что рабочая файловая система поддерживает квоты. Чтобы задействовать квоты для ReiserFS, необходимо наложить заплатку на ядро,которая доступна на сайте <ulink url="ftp://ftp.namesys.com/pub/reiserfs-for-2.4/testing/quota-2.4.20">Namesys</ulink>. Пользовательские утилиты можно загрузить с сайта проекта <ulink url="http://www.sf.net/projects/linuxquota/">Linux DiskQuota project</ulink>. При совместной работе квот с ReiserFS вы можете встретить проблемы. Мы вас предупредили! </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Установка квот на файловые разделы ограничивает использование дискового пространства для каждого пользователя или каждой группы. Квоты должны быть включены в ядре и добавлены к точке монтирования в /etc/fstab. Параметр ядра включается в конфигурации ядра в разделе File systems-&gt;Quota support. Установите следующие настройки, пересоберите ядро и перезагрузитесь в систему с новым ядром. </para>
<para>Начните с установки квот, запустив emerge quota. Затем измените /etc/fstab и добавьте usrquota и grpquota к разделам, использование которых вы хотите ограничить, так, как показано в примере ниже. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3: /etc/fstab</para>
</entry>
</row>
<row>
<entry>
<para>/dev/sda1 /boot ext2 noauto,noatime 1 1</para>
<para>/dev/sda2 none swap sw 0 0</para>
<para>/dev/sda3 / reiserfs notail,noatime 0 0</para>
<para>/dev/sda4 /tmp ext3 noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0</para>
<para>/dev/sda5 /var ext3 noatime,nodev,usrquota,grpquota 0 0</para>
<para>/dev/sda6 /home ext3 noatime,nodev,nosuid,usrquota,grpquota 0 0</para>
<para>/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0</para>
<para>/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0</para>
<para>proc /proc proc defaults 0 0</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Создайте для каждого раздела, для которого включены квоты, файлы квот (aquota.user и aquota.group) и поместите их в корень каждого из разделов. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4: Создание файлов квот</para>
</entry>
</row>
<row>
<entry>
<para># touch /tmp/aquota.user</para>
<para># touch /tmp/aquota.group</para>
<para># chmod 600 /tmp/aquota.user</para>
<para># chmod 600 /tmp/aquota.group</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Это шаг выполняется для любого раздела, для которого включены квоты. После добавления и настройки файлов квот вам понадобится добавить сценарий запуска quota в загрузочный уровень запуска. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Важно: XFS проверяет все квоты самостоятельно, поэтому для нее не требуется добавления сценария quota в начальный уровень загрузки. Есть ряд файловых систем, не указанных в этом документе, которые функционируют также, поэтому обратитесь к странице руководства вашей файловой системы, для того, чтобы узнать, как она обрабатывает проверки квот. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5: Добавление квот в загрузочный уровень исполнения</para>
</entry>
</row>
<row>
<entry>
<para># rc-update add quota boot</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь настроим систему для проверки квот раз в неделю, добавив следующую строку в /etc/crontab: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 6: Добавление проверки квот в crontab</para>
</entry>
</row>
<row>
<entry>
<para>0 3 * * 0 /usr/sbin/quotacheck -avug.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Перезагрузив компьютер, время установить квоты для пользователей и групп. С помощью команды edquota -u kn запустится редактор, определенный переменной $EDITOR (по умолчанию nano) для правки квот для пользователя kn. edquota -g сделает то же самое для групп. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 7: Установка квот для пользователя kn</para>
</entry>
</row>
<row>
<entry>
<para>Quotas for user kn:</para>
<para>/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500)</para>
<para>         inodes in use: 356, limits (soft = 1000, hard = 1500)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Для большей информации обратитесь к man edquota или <ulink url="http://www.tldp.org/HOWTO/Quota.html">Quota miniHOWTO</ulink>. </para></sect4><sect4><title>5.d. /etc/login.defs</title>
<para>Если правилами определено, что пользователи должны менять свои пароли каждые две недели, измените значения переменной PASS_MAX_DAYS на 14 и PASS_WARN_AGE на 7. Это рекомендуется для того, чтобы предотвратить старение пароля, так как полный перебор всех значений может взломать любой пароль, если есть достаточно времени. Также рекомендуется установить LOG_OK_LOGINS в значение yes. </para></sect4><sect4><title>5.e. /etc/login.access</title>
<para>Файл login.access также является частью пакета sys-apps/shadow, который управляет процессом входа в систему. Он определяет на основании имени пользователя, группы или узла, кто сможет войти в систему, а кто не сможет. Так как по умолчанию этот файл содержит лишь примеры и комментарии, то все пользователи системы могут войти в систему. В зависимости от того, что вы защищаете — сервер или рабочую станцию, рекомендуется настроить этот файл так, чтобы никто, кроме вас (как администратора), не мог получить доступ к консоли. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Эти настройки не влияют на суперпользователя. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 8: /etc/login.access</para>
</entry>
</row>
<row>
<entry>
<para>-:ALL EXCEPT wheel sync:console</para>
<para>-:wheel:ALL EXCEPT LOCAL .gentoo.org</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Важно: Настраивая эти параметры, будьте осторожны, так как любая ошибка может привести к тому, что вы не сможете войти в собственную систему, не воспользовавшись правами суперпользователя. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Эти настройки не применимы для SSH, так как по умолчанию для SSH не запускается /bin/login. Это может быть включено с помощью параметра UseLogin yes в файле /etc/ssh/sshd_config. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Это устанавливает доступ на вход в систему так, что только члены группы wheel могут входить в систему локально или из домена gentoo.org. Возможно, попахивает паранойей, но лучше быть в безопасности, чем сожалеть о потерянном. </para></sect4></sect3><sect3><title>6. Права доступа к файлам</title><sect4><title>6.a. Файлы, доступные по чтению для всех</title>
<para>Обычные пользователи не должны иметь доступ к конфигурационным файлам или паролям. Атакующий может украсть пароли к базе данных или веб-сайту и использовать их для дефейса или даже хуже — для удаления файлов. Вот почему важно правильно установить разрешения на файлы. Если вы уверены, что определенный файл может использоваться только суперпользователем, установите для него права 0600 и назначьте ему правильного владельца с помощью chown. </para></sect4><sect4><title>6.b. Файлы, доступные по записи для группы или для всех</title>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1: Поиск файлов, доступных по записи всем</para>
</entry>
</row>
<row>
<entry>
<para># find / -type f \( -perm -2 -o -perm -20 \) -exec ls -lg {} \; 2&gt;/dev/null &gt;writable.txt</para>
<para># find / -type d \( -perm -2 -o -perm -20 \) -exec ls -ldg {} \; 2&gt;/dev/null &gt;&gt;writable.txt</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Эти команды создадут огромный файл, содержащий имена файлов, которые имеют права на запись для группы и всех остальных. Проверьте их и устраните ненужные права, запустив для файлов команду /bin/chmod o-w. </para></sect4><sect4><title>6.c. Файлы SUID/SGID</title>
<para>Файлы с битами SUID или SGID будут запущены с привелегиями владельца или группы владельца, а не с привелегиями запустившего их пользователя. Обычно это используется для файлов, которые должны запускаться с правами суперпользователя для выполнения необходимых задач. Эти файлы, если содержат уязвимости, могут стать источником повышения привелегий локальным пользователем. Это может быть опасным, поэтому с подобных файлов необходимо любой ценой удалить установленный бит SUID или SGID. Если вы не используете эти файлы, запустите для них команду chmod 0 или удалите пакет, установивший этот файл (проверить, какому пакету принадлежит определенный файл, можно с помощью команды equery; если у вас ее еще нет, то, чтобы установить ее, просто наберите emerge gentoolkit). Иначе просто удалите бит SUID с помощью chmod -s. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2: Поиск файлов с setuid</para>
</entry>
</row>
<row>
<entry>
<para># find / -type f \( -perm -004000 -o -perm -002000 \) -exec ls -lg {} \; 2&gt;/dev/null &gt;suidfiles.txt</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Эта команда создаст файл, содержащий список всех SUID/SGID-файлов. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3: Список файлов с setuid</para>
</entry>
</row>
<row>
<entry>
<para>/bin/su</para>
<para>/bin/ping</para>
<para>/bin/mount</para>
<para>/bin/umount</para>
<para>/var/qmail/bin/qmail-queue</para>
<para>/usr/bin/chfn</para>
<para>/usr/bin/chsh</para>
<para>/usr/bin/crontab</para>
<para>/usr/bin/chage</para>
<para>/usr/bin/expiry</para>
<para>/usr/bin/sperl5.6.1</para>
<para>/usr/bin/newgrp</para>
<para>/usr/bin/passwd</para>
<para>/usr/bin/gpasswd</para>
<para>/usr/bin/procmail</para>
<para>/usr/bin/suidperl</para>
<para>/usr/lib/misc/pt_chown</para>
<para>/usr/sbin/unix_chkpwd</para>
<para>/usr/sbin/traceroute</para>
<para>/usr/sbin/pwdb_chkpwd</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>По умолчанию в Gentoo Linux не так много файлов с битом SUID (хотя это зависит от типа вашей установки), но у вас может получиться список, представленный выше. Большинство команд используется только суперпользователем. Удалите SUID-бит с ping, mount, umount, chfn, chsh, newgrp, suidperl, pt_chown и traceroute, запустив для каждого из них chmod -s. Не удаляйте бит с su, qmail-queue или unix_chkpwd. Удалив setuid с этих файлов, вы не сможете стать суперпользователем и получать почту. Удаляя бит (там, где это безопасно), вы исключаете возможность обычного пользователя (или злоумышленника) получить права суперпользователя с помощью этих файлов. </para>
<para>В моей системе есть только несколько SUID-файлов: su, passwd, gpasswd, qmail-queue, unix_chkpwd и pwdb_chkpwd. Но если у вас запущен X-сервер, то в вашей системе их будет больше, так как X нужны повышенные привелегии, которые могут быть предоставлены посредством SUID. </para></sect4><sect4><title>6.d. SUID/SGID-файлы и жесткие ссылки</title>
<para>Файл может считаться удаленным лишь в том случае, когда нет больше ссылок, указывающих на него. Это может звучать странно, но просто следует понять, что файл (например, /usr/bin/perl) на самом деле является ссылкой на inode, в котором сохранены данные. На файл может указывать любое число ссылок, и пока каждая их них не будет удалена, файл будет существовать. </para>
<para>Если у ваших пользователей есть доступ к разделам, которые не смонтированы с параметрами nosuid или noexec (например, если /tmp, /home, /var/tmp не являются отдельными разделами), вы должны удостовериться, что они не смогут создать жесткие ссылки на файлы с SUID- или SGID-битами, благодаря чему они могут иметь доступ к устаревшим версиям файлов. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: Если вы получаете предупреждения об оставшихся жестких ссылках, а ваши пользователи имеют доступ по записи к разделам, позволяющим запускать файлы с SUID/SGID-битами, вы должны прочитать этот раздел очень внимательно. Любой из ваших пользователей может разрушить ваши обновления, сохранив устаревшую версию программы. Если ваши пользователи не могут создавать собственные файлы с битом SUID или могут только запускать программы с помощью динамического загрузчика (разделы, смонтированные с параметром noexec), то вам не о чем беспокоиться. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Пользователям не нужен доступ по чтению для файла, чтобы создать на него ссылку, им нужен всего лишь доступ по чтению к каталогу, содержащему этот файл. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Чтобы проверить, сколько ссылок имеет файл, вы можете использовать команду stat. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4: Команда stat</para>
</entry>
</row>
<row>
<entry>
<para>$ stat /bin/su</para>
<para>  File: `/bin/su'</para>
<para>  Size: 29350           Blocks: 64         IO Block: 131072 regular file</para>
<para>Device: 900h/2304d      Inode: 2057419     Links: 1</para>
<para>Access: (4711/-rws--x--x)  Uid: (    0/    root)   Gid: (    0/    root)</para>
<para>Access: 2005-02-07 01:59:35.000000000 +0000</para>
<para>Modify: 2004-11-04 01:46:17.000000000 +0000</para>
<para>Change: 2004-11-04 01:46:17.000000000 +0000</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Чтобы найти файлы с SUID и SGID со множеством ссылок, вы можете задействовать команду find. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5: Поиск suid/sgid-файлов с несколькими ссылками</para>
</entry>
</row>
<row>
<entry>
<para>$ find / -type f \( -perm -004000 -o -perm -002000 \) -links +1 -ls</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4></sect3><sect3><title>7. PAM</title><sect4><title>7.a. PAM</title>
<para>PAM — это набор библиотек, предоставляющих альтернативный способ аутентификации пользователя в программах. USE-флаг pam уже включен по умолчанию. Хотя настройки PAM в Gentoo Linux довольно разумны, всегда есть возможность что-нибудь улучшить. Для начала установите cracklib. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1: Установка cracklib</para>
</entry>
</row>
<row>
<entry>
<para># emerge cracklib</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2: /etc/pam.d/passwd</para>
</entry>
</row>
<row>
<entry>
<para>auth     required pam_unix.so shadow nullok</para>
<para>account  required pam_unix.so</para>
<para>password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2</para>
<para>password required pam_unix.so md5 use_authtok</para>
<para>session  required pam_unix.so</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>После этого с помощью cracklib будет проверяться пароль пользователя, имеет ли он длину по крайней мере 8 символов, содержит ли он по крайней мере 2 цифры, 2 других символа и не менее 3 символов, отличающихся от символов прошлого пароля. Благодаря этому пользователь будет выбирать стойкие пароли. Проверьте <ulink url="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3">документацию PAM</ulink> для других параметров. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3: /etc/pam.d/sshd</para>
</entry>
</row>
<row>
<entry>
<para>auth     required pam_unix.so nullok</para>
<para>auth     required pam_shells.so</para>
<para>auth     required pam_nologin.so</para>
<para>auth     required pam_env.so</para>
<para>account  required pam_unix.so</para>
<para>password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authtok</para>
<para>password required pam_unix.so shadow md5</para>
<para>session  required pam_unix.so</para>
<para>session  required pam_limits.so</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Любая служба, не описанная в одном из файлов PAM из каталога /etc/pam.d, будет использовать правила, взятые из /etc/pam.d/other. По умолчанию установлена политика deny, как и должно быть. Но нам нужна регистрация, поэтому добавим pam_warn.so. Последняя конфигурация — это pam_limits, которая управляется с помощью /etc/security/limits.conf. См. раздел <ulink url="http://www.gentoo.org/doc/ru/security/security-handbook.xml?style=printable&amp;full=1#limits_conf">/etc/security/limits.conf</ulink> для подробного описания этих настроек. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4: /etc/pam.d/other</para>
</entry>
</row>
<row>
<entry>
<para>auth     required pam_deny.so</para>
<para>auth     required pam_warn.so</para>
<para>account  required pam_deny.so</para>
<para>account  required pam_warn.so</para>
<para>password required pam_deny.so</para>
<para>password required pam_warn.so</para>
<para>session  required pam_deny.so</para>
<para>session  required pam_warn.so</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4></sect3><sect3><title>8. Упаковщики TCP</title><sect4><title>8.a. Упаковщики TCP</title>
<para>Обычно для контроля доступом к службам используется inetd (которого в Gentoo нет), но так же можно воспользоваться xinetd или другими сервисами. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Служба должна быть запущена с помощью tcpd в качестве аргумента сервера (для случая xinetd). См. раздел о xinetd для большей информации. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1: /etc/hosts.deny</para>
</entry>
</row>
<row>
<entry>
<para>ALL:PARANOID</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2: /etc/hosts.allow</para>
</entry>
</row>
<row>
<entry>
<para>ALL: LOCAL @wheel</para>
<para>time: LOCAL, .gentoo.org</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Как вы видите, формат записи очень похож на содержимое файла /etc/login.access. Tcpd поддерживает отдельная служба; она никак не связана с /etc/login.access. Эти настройки применимы только для служб, использующих упаковщики TCP. </para>
<para>Также возможно запускать команды при разрешенной службе (это может быть полезным для создания трансляций для коммутируемых пользователей), но это не рекомендуется, так как обычно, решая одну проблему, люди создают еще больше. Допустим, что вы настроили сценарий, отправляющий электронное письмо в том случае, когда кто-то подпал под запрещающее правило, но тогда злоумышленник может запустить DoS-атаку, попадающую под правило запрещения. Из-за этого создастся много ввода-вывода и ненужно электронной почты, поэтому не делайте так! Прочтите man 5 hosts_access для дальнейшей информации. </para></sect4></sect3><sect3><title>9. Безопасность ядра</title><sect4><title>9.a. Удаление функциональности</title>
<para>Основное правило при конфигурации ядра — удалять все ненужное. Это не только создаст маленькое ядро, но и также исключит вероятные уязвимости, которые могут присутствовать в драйверах и других возможностях. </para>
<para>Также рекомендуется отключить поддержку загружаемых модулей. Хотя возможность внедрения руткитов сохраняется, это делает систему более неприступной для обычного злоумышленника, пытающегося установить руткит в виде модуля ядра.</para></sect4><sect4><title>9.b. Файловая система proc</title>
<para>Множество параметров ядра может быть изменено с помощью файловой системы /proc или sysctl. </para>
<para>Чтобы иметь возможность на лету изменять параметры и переменные ядра, вам понадобится определить в ядре CONFIG_SYSCTL. Она включена по умолчанию в ядрах серии 2.4. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1: Отключения IP-форвардинга</para>
</entry>
</row>
<row>
<entry>
<para># /bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Проверьте, что проброс IP-пакетов отключен. Эта возможность необходима лишь для узла, имеющего доступ к нескольким сетям. Рекомендуется устанавливать и отключать этот флаг до включения или отключения других флагов. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2: Отбрасывание пакетов ping</para>
</entry>
</row>
<row>
<entry>
<para># /bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Это просто заставит ядро игнорировать все сообщения ping (ICMP-пакеты типа 0). IP-пакет, несущий ICMP-сообщение, может содержать также в нагрузку и другую информацию, о которой вы можете не подозревать, поэтому следует отключить прием. Администраторы используют ping как утилиту диагностики и часто выражают недовольство, если она отключена, но нет причины позволять чужакам пинговать узел. Тем не менее, если необходимо разрешить внутренним пользователям использовать ping, то можно отключить сообщения ICMP типа 0 в межсетевом экране (тем самым позволив локальным администраторам использовать эту утилиту). </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3: Игнорирование широковещательных запросов ping</para>
</entry>
</row>
<row>
<entry>
<para># /bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Это отключает ответ на широковещательные ICMP-запросы, предотвращая реализацию Smurf-атаки. Smurf-атака основана на отправке ICMP-пакета типа 0 (ping) по широковещательному адресу сети. Обычно для этого злоумышленник использует поддельный адрес. Все компьютеры сети ответят на сообщение ping, что может вызвать наводнение трафика на узел, адрес которого был подделан. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4: Отключение исходящих маршрутизированных пакетов.</para>
</entry>
</row>
<row>
<entry>
<para># /bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_source_route</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Не принимать исходящие маршрутизированные пакеты. Злоумышленники могут использовать исходящую маршрутизацию для генерации трафика, имеющего адрес внутренней сети, но на самом деле возвращаемого назад злоумышленнику, что позволит ему компрометировать сеть. Исходящая маршрутизация очень редко используется по назначению, так что безопаснее ее отключить. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5: Отключение приема перенаправлений</para>
</entry>
</row>
<row>
<entry>
<para># /bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_redirects</para>
<para># /bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/secure_redirects</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Не принимать ICMP-пакеты перенаправления. ICMP-перенаправления могут быть использованы злоумышленником для изменения таблиц маршрутизации. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 6: Защита против неправильных сообщений об ошибках</para>
</entry>
</row>
<row>
<entry>
<para># /bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Включить защиту против приходящих неправильных сообщений об ошибках. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 7: Включение фильтрации обратного пути</para>
</entry>
</row>
<row>
<entry>
<para># for i in /proc/sys/net/ipv4/conf/*; do</para>
<para>        /bin/echo "1" &gt; $i/rp_filter</para>
<para>done</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Включает фильтрацию обратного пути. Это поможет быть уверенным, что в пакетах используются правомерные адреса, при этом входящие пакеты будут автоматически отброшены, если запись в таблице маршрутизации об адресе этих пакетов не соответствуют сетевому интерфейсу, с которого они пришли. Это позволит предотвратить подделку IP-адресов. Необходимо включить эту возможность для каждого net/ipv4/conf/*, иначе проверка исходящих пакетов не будет полностью функционировать. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: Тем не менее включение фильтрации обратного пути может стать проблемой при использовании асимметричной маршрутизации (исходящие пакеты идут отличным от входящих пакетов путем) или при использовании немаршрутизируемом узле с несколькими IP-адресами на различных интерфейсах. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 8: Регистрация всех поддельных, исходящих маршрутизированных и перенаправленных пакетов</para>
</entry>
</row>
<row>
<entry>
<para># /bin/echo "1" &gt; /proc/sys/net/ipv4/conf/all/log_martians</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Регистрировать поддельные пакеты, пакеты с исходящей маршрутизацией и пакеты перенаправлений. </para>
<para>Все настройки будут сброшены после перезагрузки компьютера. Рекомендуется добавлять их в /etc/sysctl.conf, который будет автоматически загружен сценарием инициализации /etc/init.d/bootmisc. </para>
<para>Синтаксис /etc/sysctl.conf достаточно понятный. Удалите из указанных путей /proc/sys/ и замените / на .: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 9: Переход к файлу sysctl.conf</para>
</entry>
</row>
<row>
<entry>
<para>(Вручную с помощью команды echo:)</para>
<para>/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward</para>
<para/>
<para>(Автоматически в файле sysctl.conf:)</para>
<para>net.ipv4.ip_forward = 0</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>9.c. Grsecurity</title>
<para>Заплатка от <ulink url="http://grsecurity.net/">Grsecurity</ulink> входит в sys-kernel/hardened-sources, но по умолчанию отключена. Сначала сконфигурируйте ядро, а затем настройте параметры Grsecurity. Подробное описание доступных параметров Grsecurity можно найти на странице проекта <ulink url="http://www.gentoo.org/proj/en/hardened?style=printable">укрепленного Gentoo</ulink>. </para>
<para>Последние версии hardened-sources содержат Grsecurity версии 2.*. Для дополнительной информации о наборе патчей Grsecurity обратитесь к документации, доступной на <ulink url="http://www.grsecurity.net/">домашнем сайте Grsecurity</ulink>. </para></sect4><sect4><title>9.d. Kerneli</title>
<para>
<ulink url="http://www.Kerneli.org/">Kerneli</ulink> — это заплатка, которая добавляет функции шифрования к существующему ядру. Наложив эту заплатку на ядро, вы получите такие новые параметры, как алгоритмы шифрования, дайджеста и фильтры к зашифрованным образам. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: В настоящий момент заплатка kerneli для последнего ядра нестабильна, поэтому будьте осторожны при ее использовании. </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>9.e. Другие заплатки к ядру</title>
<orderedlist>
<listitem>
<para>
<ulink url="http://www.openwall.com/">Проект OpenWall</ulink> </para>
</listitem>
<listitem>
<para>
<ulink url="http://www.lids.org/">Linux Intrusion Detection System</ulink> </para>
</listitem>
<listitem>
<para>
<ulink url="http://www.rsbac.org/">Rule Set Based Access Control</ulink> </para>
</listitem>
<listitem>
<para>
<ulink url="http://www.nsa.gov/selinux">NSA's security enhanced kernel</ulink> </para>
</listitem>
<listitem>
<para>
<ulink url="http://sourceforge.net/projects/wolk/">Wolk</ulink> </para>
</listitem>
</orderedlist>
<para>И множество других. </para></sect4></sect3><sect3><title>10. Безопасность служб</title><sect4><title>10.a. Apache</title>
<para>Apache поставляется с достаточно полным конфигурационным файлом по умолчанию, но опять же необходимо улучшить некоторые аспекты, например, использовать для Apache только один адрес. Ниже приведены параметры, которые вы должны внести в конфигурационный файл. </para>
<para>Если вы не отключали поддержку ssl в /etc/make.conf перед установкой Apache, то теперь вы должны иметь доступ к серверу с включенным SSL. Чтобы включить ее, просто добавьте следующую строку. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1: /etc/conf.d/apache</para>
</entry>
</row>
<row>
<entry>
<para>HTTPD_OPTS="-D SSL"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2: /etc/apache/conf/apache.conf</para>
</entry>
</row>
<row>
<entry>
<para>#Добавьте свой IP для прослушивания</para>
<para>Listen 127.0.0.1</para>
<para>BindAddress 127.0.0.1</para>
<para>#Не следует использовать nobody или nogroup для каждого сервиса, запущенного</para>
<para>#без административных привелегий</para>
<para>#(просто добавляем пользователя apache с группой apache)</para>
<para>User apache</para>
<para>Group apache</para>
<para>#Не сообщать информацию о версии сервера</para>
<para>ServerSignature Off</para>
<para>ServerTokens Prod</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Apache собран с параметрами --enable-shared=max и --enable-module=all. По умолчанию это включает все модули, поэтому вы должны закомментировать все неиспользуемые модули в разделе LoadModule (LoadModule и AddModule). Затем перезапустите сервис, выполнив /etc/init.d/apache restart. </para>
<para>Документация доступна по адресу <ulink url="http://www.apache.org/">http://www.apache.org</ulink>. </para></sect4><sect4><title>10.b. Bind</title>
<para>Документацию можно найти на сайте <ulink url="http://www.isc.org/products/BIND/bind9.html">Internet Software Consortium</ulink>. Руководство администратора BIND 9 также доступно каталоге doc/arm. </para>
<para>Новые сборочные файлы BIND поддерживают изменение корневого каталога из коробки. После установки bind следуйте этим простым инструкциям: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3: Изолирование среды BIND</para>
</entry>
</row>
<row>
<entry>
<para># emerge --config bind</para>
<para>(Перед запуском следующей команды вам может потребоваться изменить каталог</para>
<para>chroot в файле /etc/conf.d/named. Иначе будет использован /chroot/dns.)</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>10.c. Djbdns</title>
<para>Djbdns — это реализация DNS, за обнаружение уязвимостей в которой автор готов выплачивать <ulink url="http://cr.yp.to/djbdns/guarantee.html">деньги</ulink>. Принцип работы сильно отличается от Bind 9, однако он работает. Дополнительная информация может быть получена на сайте <ulink url="http://www.djbdns.org/">http://www.djbdns.org</ulink>. </para></sect4><sect4><title>10.d. FTP</title>
<para>В общем случае использование FTP (File Transfer Protocol, протокол передачи файлов) является плохой идеей. Этот протокол отправляет данные незашифрованными (в том числе и пароли), прослушивает 2 порта (обычно это порты 20 и 21), и часто злоумышленники ищут анонимный доступ для обмена варезом. Так как протокол содержит ряд проблем безопасности, то следует использовать sftp или HTTP. Если это невозможно, то максимально обезопасьте свои сервисы и будьте готовы. </para></sect4><sect4><title>10.e. Mysql</title>
<para>Если вам необходимо предоставить доступ к базе данных mysql локальным приложениям, раскомментируйте следующую строку в /etc/mysql/my.cnf. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4: Отключение доступа к сети</para>
</entry>
</row>
<row>
<entry>
<para>skip-networking</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Затем мы отключаем использование команды LOAD DATA LOCAL INFILE. Это предотвратит несанкционированное чтение локальных файлов. Это также подходит против SQL-инъекций в PHP-сценариях. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5: Отключение LOAD DATA LOCAL INFILE в разделе [mysqld]</para>
</entry>
</row>
<row>
<entry>
<para>set-variable=local-infile=0</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Затем необходимо удалить тестовую базу данных (test) и все учетные записи за исключением root. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 6: Удаление тестовой базы данных и всех ненужных пользователей</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; drop database test;</para>
<para>mysql&gt; use mysql;</para>
<para>mysql&gt; delete from db;</para>
<para>mysql&gt; delete from user where not (host="localhost" and user="root");</para>
<para>mysql&gt; flush privileges;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: Если вас уже есть настроенные учетные записи, то будьте осторожны с этими командами. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Если вы изменяли пароли в командной строке MySQL, то всегда очищайте ~/.mysql_history и /var/log/mysql/mysql.log, так как они сохраняют список выполненных SQL-команд с открытыми паролями. </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>10.f. Proftpd</title>
<para>У proftpd было несколько проблем с безопасностью, но большинство из них было исправлено. Тем не менее, неплохо внести некоторые улучшения: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 7: /etc/proftpd/proftpd.conf</para>
</entry>
</row>
<row>
<entry>
<para>ServerName "My ftp daemon"</para>
<para># Не показывать ident сервера</para>
<para>ServerIdent on "Go away"</para>
<para/>
<para># Упрощаем создание виртуальных пользователей</para>
<para>RequireValidShell off</para>
<para/>
<para># Использовать альтернативные файлы паролей и групп (в формате passwd)</para>
<para>AuthUserFile "/etc/proftpd/passwd"</para>
<para>AuthGroupFile "/etc/proftpd/group"</para>
<para/>
<para># Разрешения</para>
<para>Umask 077</para>
<para/>
<para># Таймауты и ограничения</para>
<para>MaxInstances 30</para>
<para>MaxClients 10 "Only 10 connections allowed"</para>
<para>MaxClientsPerHost 1 "You have already logged on once"</para>
<para>MaxClientsPerUser 1 "You have already logged on once"</para>
<para>TimeoutStalled 10</para>
<para>TimeoutNoTransfer 20</para>
<para>TimeoutLogin 20</para>
<para/>
<para># Все входят в изолированную оболочку</para>
<para>DefaultRoot ~</para>
<para/>
<para># Не запускать с правами администратора</para>
<para>User  nobody</para>
<para>Group nogroup</para>
<para/>
<para># Регистрировать любые передачи</para>
<para>TransferLog /var/log/transferlog</para>
<para/>
<para># Проблемы с универсализацией имен файлов</para>
<para>DenyFilter \*.*/</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Дополнительная информация может быть найдена на <ulink url="http://www.proftpd.org/">http://www.proftpd.org</ulink>. </para></sect4><sect4><title>10.g. Pure-ftpd</title>
<para>Pure-ftpd является ответвлением оригинального trollftpd с модификациями Фрэнка Денниса по части безопасности и функциональности. </para>
<para>Используйте виртуальных пользователей (и никогда не применяйте системные учетные записи), включив параметр AUTH. Установите его для -lpuredb:/etc/pureftpd.pdb и создайте пользователей при помощи команды /usr/bin/pure-pw. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 8: /etc/conf.d/pure-ftpd</para>
</entry>
</row>
<row>
<entry>
<para>AUTH="-lpuredb:/etc/pureftpd.pdb"</para>
<para/>
<para>## Misc. Others ##</para>
<para>MISC_OTHER="-A -E -X -U 177:077 -d -4 -L100:5 -I 15"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Добавьте к переменной MISC_OTHER параметры запрета на подключение анонимных пользователей (-E), изменения корневого каталога для всех (-A), запрета записи и чтения файлов, начинающихся с точки (-X), максимального периода бездействия (-I), ограничения рекурсии (-L) и подходящего umask. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: Не используйте параметры -w или -W! Если же вы хотите, чтобы у вас был сайт с варезом, то перестаньте читать это руководство! </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Дополнительная информация может быть найдена на <ulink url="http://www.pureftpd.org/">http://www.pureftpd.org</ulink>. </para></sect4><sect4><title>10.h. Vsftpd</title>
<para>Vsftpd (сокращение от very secure ftp) — это небольшой FTP-демон, который может запускаться с настройками по умолчанию. Он прост и не имеет множества возможностей, присущих pureftp и proftp. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 9: /etc/vsftpd</para>
</entry>
</row>
<row>
<entry>
<para>anonymous_enable=NO</para>
<para>local_enable=YES</para>
<para/>
<para>#read only</para>
<para>write_enable=NO</para>
<para/>
<para>#enable logging of transfers</para>
<para>xferlog_std_format=YES</para>
<para/>
<para>idle_session_timeout=20</para>
<para>data_connection_timeout=20</para>
<para>nopriv_user=nobody</para>
<para/>
<para>chroot_list_enable=YES</para>
<para>chroot_list_file=/etc/vsftpd/chrootlist</para>
<para/>
<para>ls_recurse_enable=NO</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Как вы можете видеть, нет возможности установить для данного сервиса индивидуальные разрешения, но если используется настройки для анонимного доступа, то это он не так уж плох. Иногда неплохо иметь анонимный FTP-сервер (для доступа к открытому ПО), и vsftpd неплохо подходит для этой работы. </para></sect4><sect4><title>10.i. Netqmail</title>
<para>Netqmail часто признается наиболее безопасным почтовым сервером. Он написан с прицелом на безопасность (и паранойю). По умолчанию он не разрешает релей и, начиная с 1996 года, не имеет никаких уязвимостей безопасности. Просто наберите emerge netqmail и настройте его! </para></sect4><sect4><title>10.j. Samba</title>
<para>Samba — это протокол, предоставляющий файлы в сетях Microsoft/Novell, и он не должен использоваться в интернете. Его необходимо обезопасить. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 10: /etc/samba/smb.conf</para>
</entry>
</row>
<row>
<entry>
<para>[global]</para>
<para>  #Прослушивать определенный интерфейс</para>
<para>  interfaces = eth0 10.0.0.1/32</para>
<para/>
<para>  #Использовать зашифрованные пароли</para>
<para>  encrypt passwords = yes</para>
<para>  directory security mask = 0700</para>
<para/>
<para>  #Разрешить трафик из подсети 10.0.0.*</para>
<para>  hosts allow = 10.0.0.</para>
<para/>
<para>  #Включить аутентификацию</para>
<para>  #(не используйте режим share)</para>
<para>  security = user</para>
<para/>
<para>  #Запретить привелигерованные учетные записи</para>
<para>  invalid users = root @wheel</para>
<para/>
<para>  #Максимальный отображаемый размер ресурса (не является ограничителем)</para>
<para>  max disk size = 102400</para>
<para/>
<para>  #Ужесточить политики паролей</para>
<para>  min password length = 8</para>
<para>  null passwords = no</para>
<para/>
<para>  #Использовать PAM (если была добавлена поддержка)</para>
<para>  obey pam restrictions = yes</para>
<para>  pam password change = yes</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Проверьте, что для каждого ресурса выставлены правильные разрешения и не забудьте прочитать <ulink url="http://www.samba.org/">документацию</ulink>. </para>
<para>Теперь перезапустите сервер и добавьте пользователей, которым необходим доступ к этому сервису. Это можно сделать с помощью команды /usr/bin/smbpasswd с параметром -a. </para></sect4><sect4><title>10.k. ssh</title>
<para>Для OpenSSH необходимо лишь одно улучшение — использование более надежного механизма аутентификации, основанного на шифровании с использованием открытого ключа. Очень много сайтов (например, <ulink url="http://www.sourceforge.net/">http://www.sourceforge.net</ulink>, <ulink url="http://www.php.net/">http://www.php.net</ulink> и <ulink url="http://www.apache.org/">http://www.apache.org</ulink>) было подвержено несанкционированному доступу из-за пустых или слабых паролей. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 11: /etc/ssh/sshd_config</para>
</entry>
</row>
<row>
<entry>
<para>#Включаем только версию 2</para>
<para>Protocol 2</para>
<para/>
<para>#Отключаем вход администратора. Пользователи могут использовать su для входа</para>
<para>PermitRootLogin no</para>
<para/>
<para>#Включаем аутентификацию по открытому ключу</para>
<para>PubkeyAuthentication yes</para>
<para>AuthorizedKeysFile      .ssh/authorized_keys</para>
<para/>
<para>#Отключаем .rhost и обычную аутентификацию по паролю</para>
<para>HostbasedAuthentication no</para>
<para>PasswordAuthentication no</para>
<para>PermitEmptyPasswords no</para>
<para/>
<para>#Разрешаем подключаться только пользователям из групп wheel или admin</para>
<para>AllowGroups wheel admin</para>
<para/>
<para>#Из этих групп разрешаем подключаться только следующим пользователям</para>
<para>#@&lt;domainname&gt; не обязательна, но заменяет старую директиву</para>
<para>#AllowHosts</para>
<para>AllowUsers kn@gentoo.org bs@gentoo.org</para>
<para/>
<para>#Вход в систему</para>
<para>SyslogFacility AUTH</para>
<para>LogLevel INFO</para>
<para/>
<para>(Измените адрес на свой)</para>
<para>ListenAddress 127.0.0.1</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Также проверьте, что в конфигурационном файле нет параметра UsePAM yes, который перекрывает механизм аутентификации с помощью открытого ключа. </para>
<para>Теперь создайте для каждого пользователя ключ (на компьютере, с которого они будут регистрироваться) с помощью следующей команды: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 12: Создание пар ключей DSA</para>
</entry>
</row>
<row>
<entry>
<para># /usr/bin/ssh-keygen -t dsa</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>И введите пароль. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 13: Вывод ssh-keygen</para>
</entry>
</row>
<row>
<entry>
<para>Generating public/private dsa key pair.</para>
<para>Enter file in which to save the key (/home/kn/.ssh/id_dsa):[Press enter]</para>
<para>Created directory '/home/kn/.ssh'.</para>
<para>Enter passphrase (empty for no passphrase): [Enter passphrase]</para>
<para>Enter same passphrase again: [Enter passphrase again]</para>
<para>Your identification has been saved in /home/kn/.ssh/id_dsa.</para>
<para>Your public key has been saved in /home/kn/.ssh/id_dsa.pub.</para>
<para>The key fingerprint is:</para>
<para>07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>После этого в каталоге ~/.ssh/ появятся два файла с названием id_dsa и id_dsa.pub. Файл id_dsa является секретным ключом и должен оберегаться от других. Другой файл, id_dsa.pub, должен быть размещен на каждом сервере, к которому необходим доступ. Добавьте этот ключ в каталог ~/.ssh/authorized_keys в домашнем каталоге пользователя. Теперь пользователь должен иметь доступ к подключению: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 14: Adding the id_dsa.pub file to the authorized_keys file</para>
</entry>
</row>
<row>
<entry>
<para>$ scp id_dsa.pub other-host:/var/tmp/currenthostname.pub</para>
<para>$ ssh other-host</para>
<para>password:</para>
<para>$ cat /var/tmp/currenthostname.pub &gt;&gt; ~/.ssh/authorized_keys</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь ваши пользователи должны тщательно оберегать свои секретные ключи. Поместите их на сменный носитель, который они будут всегда носить с собой, или спрячьте их на рабочих станциях пользователей (поместите их под правила <ulink url="http://www.gentoo.org/doc/ru/security/security-handbook.xml?style=printable&amp;full=1#security_policies">паролей</ulink>). </para>
<para>Для дальнейшей информации посетите веб-сайт <ulink url="http://www.openssh.org/">OpenSSH</ulink>. </para></sect4><sect4><title>10.l. Использование xinetd</title>
<para>xinetd является заменой inetd (которого в Gentoo нет), демона сетевых сервисов. Он поддерживает контроль доступа, основанный на адресе удаленного узла и времени доступа. Он также предоставляет расширенные возможности регистрации событий, включая время запуска сервера, адрес удаленного узла, имя удаленного пользователя, время работы сервера и выполненные запросы. </para>
<para>Как в случае с другими сервисами, важно создать хорошую конфигурацию по умолчанию. Но так как xinetd запускается с правами администратора и поддерживает протоколы, о работе которых вы можете не знать, рекомендуется не использовать его. Но если вы все равно хотите использовать его, то вы можете укрепить его безопасность: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 15: Установка xinetd</para>
</entry>
</row>
<row>
<entry>
<para># emerge xinetd tcp-wrappers</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>И отредактируйте конфигурационный файл: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 16: /etc/xinetd.conf</para>
</entry>
</row>
<row>
<entry>
<para>defaults</para>
<para>{</para>
<para> only_from = localhost</para>
<para> instances = 10</para>
<para> log_type = SYSLOG authpriv info</para>
<para> log_on_success = HOST PID</para>
<para> log_on_failure = HOST</para>
<para> cps = 25 30</para>
<para>}</para>
<para/>
<para># Это установит работу pserver (cvs) через xinetd со следующими:</para>
<para># настройками:</para>
<para># максимум 10 обработчиков (10 подключений одновременно)</para>
<para># использовать только TCP</para>
<para># использовать пользователя cvs для запуска сервиса</para>
<para># использовать только 1 IP</para>
<para># разрешать доступ с 10.0.0.*</para>
<para># разработчики могут пользоваться cvs только с 8 до 17 часов</para>
<para># использовать упаковщики tpcd (контроль доступа через</para>
<para># /etc/hosts.allow и /etc/hosts.deny)</para>
<para># max_load для компьютера 1.0</para>
<para># Отключающий флаг для настроек по умолчанию, я предпочитаю,</para>
<para># чтобы он был отключен</para>
<para>service cvspserver</para>
<para>{</para>
<para> socket_type = stream</para>
<para> protocol = tcp</para>
<para> instances = 10</para>
<para> protocol = tcp</para>
<para> wait = no</para>
<para> user = cvs</para>
<para> bind = 10.0.0.2</para>
<para> only_from = 10.0.0.0</para>
<para> access_times = 8:00-17:00</para>
<para> server = /usr/sbin/tcpd</para>
<para> server_args = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver</para>
<para> max_load = 1.0</para>
<para> log_on_failure += RECORD</para>
<para> disable = no</para>
<para>}</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Для большей информации см. man 5 xinetd.conf. </para></sect4><sect4><title>10.m. X</title>
<para>По умолчанию Xorg настроен функционировать в качестве Xserver. Это может быть опасным, так как X использует не зашифрованные TCP-соединения и прослушивает подключения xclient. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Важно: Если вам не нужен этот сервис, отключите его! </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Но если вам требуется использовать рабочую станцию в качестве X-сервера, используйте команду /usr/X11R6/bin/xhost с большой осторожностью. Эта команда позволит клиентам других узлов подключаться к вашему экрану. Это может быть полезно при необходимости запуска приложения X с другого компьютера, и это возможно лишь через сеть, но это может быть использовано и злоумышленником. Синтаксис этой команды — /usr/X11R6/bin/xhost +hostname. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: Не используйте возможность xhost +! Эта возможность позволит любому клиенту подключиться к X-серверу и взять контроль над ним. Если злоумышленник может получить доступ к X, то сможет регистрировать нажатия на клавиши, что позволит ему взять контроль над вашим компьютером. Если вы все же используете ее, то всегда указывайте узел. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Более безопасным решением является полное отключение этой возможности при старте X-сервера с помощью startx -- -nolisten tcp или отключение ее навсегда в файлах конфигурации. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 17: /usr/X11R6/bin/startx</para>
</entry>
</row>
<row>
<entry>
<para>defaultserverargs="-nolisten tcp"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Вы должны защитить startx, чтобы не допустить его перезаписи при установке новой версии Xorg. Добавьте следующую строку в /etc/make.conf: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 18: /etc/make.conf</para>
</entry>
</row>
<row>
<entry>
<para>CONFIG_PROTECT_MASK="/usr/X11R6/bin/startx"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Если вы используете графический диспетчер входа в систему, вам понадобится другой подход. </para>
<para>Для gdm (Gnome Display Manager) </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 19: /etc/X11/gdm/gdm.conf</para>
</entry>
</row>
<row>
<entry>
<para>[server-Standard]</para>
<para>command=/usr/X11R6/bin/X -nolisten tcp</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Для xdm (X Display Manager) и kdm (Kde Display Manager) </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 20: /etc/X11/xdm/Xservers</para>
</entry>
</row>
<row>
<entry>
<para>:0 local /usr/bin/X11/X -nolisten tcp</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4></sect3><sect3><title>11. Изменение корневого каталога и виртуальные серверы</title><sect4><title>11.a. Изменение корневого каталога</title>
<para>Изменение корневого каталога для службы является способом ограничения среды службы (или пользователя), в которой она имеет доступ лишь к необходимым ресурсам. Запущенная служба под пользователем, отличном от суперпользователя (nobody, apache, named) может предоставить злоумышленнику доступ лишь к тем файлам, к которым имеет доступ пользователь, от имени которого запущена служба. Это означает, что злоумышленник не сможет получить права root, даже если служба подвержена различным уязвимостям. </para>
<para>Некоторые службы, например pure-ftpd и bind, могут быть заключены в chroot. Если служба поддерживает эту возможность, используйте ее, иначе вы можете можете создать среду собственноручно. Давайте рассмотрим пример создания chroot. Чтобы изучить работу механизма chroot, мы будем экспериментировать с bash (простейший для изучения случай). </para>
<para>Создайте каталог /chroot, выполнив команду mkdir /chroot. Затем определите, какие динамические библиотеки необходимы для работы bash (если он собран с параметром -static, этот шаг можно пропустить): </para>
<para>Следующая команда создаст список библиотек, необходимых для bash. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1: Получение списка используемых библиотек</para>
</entry>
</row>
<row>
<entry>
<para># ldd /bin/bash</para>
<para>  libncurses.so.5 =&gt; /lib/libncurses.so.5 (0x4001b000)</para>
<para>  libdl.so.2 =&gt; /lib/libdl.so.2 (0x40060000)</para>
<para>  libc.so.6 =&gt; /lib/libc.so.6 (0x40063000)</para>
<para>  /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь создадим изолированную среду для bash. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2: Создание изолированной среды для bash</para>
</entry>
</row>
<row>
<entry>
<para># mkdir /chroot/bash</para>
<para># mkdir /chroot/bash/bin</para>
<para># mkdir /chroot/bash/lib</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Затем скопируем файлы, используемые bash (/lib) в изолированный lib и скопируем файл bash в изолированный каталог bin. Этим мы создадим ту же самую среду, но с ограниченными возможностями. После этого попробуйте выполнить команду chroot /chroot/bash /bin/bash. Если вы получите строку приглашения, гласящую /, то у вас все получилось! Иначе вам сообщат, какого файла не хватает. Некоторые разделяемые библиотеки могут использовать другие файлы. </para>
<para>Как вы можете заметить, внутри изолированной среды ничего, кроме echo, не работает. Это потому что в внутри среды chroot кроме bash нет никаких других команд, а echo является встроенной командой. </para>
<para>Подобным образом вы можете создать службу в изолированной среде. Единственное различие в том, что служба может время от времени обращаться к устройствам и файлам настроек в /etc. Просто скопируйте их (файлы устройств можно скопировать с помощью команды cp -a) в изолированную среду, отредактируйте сценарий инициализации перед тем, как заключить службу в среду. Может быть сложным определить, какие устройства и файлы конфигурации могут понадобиться. Здесь может пригодиться команда strace. Запустите службу вместе с /usr/bin/strace и отследите все вызовы open, read, stat и, возможно, connect. Это подскажет вам, что нужно копировать. Но в большинстве случаев вам понадобится скопировать файл passwd (отредактируйте копию, удалив из него всех пользователей, не нужных для запуска службы), /dev/zero, /dev/log и /dev/random. </para></sect4><sect4><title>11.b. Пользовательский режим Linux</title>
<para>Другим способом создания безопасной среды является запуск виртуальной машины. Виртуальная машина — это процесс, выглядящий как отдельная ОС и работающий в реальной операционной системе, которая предоставляет ему необходимые системные ресурсы. Безопасность достигается в том, что если сервер, запущенный внутри виртуальной машины, будет взломан, то будет затронут только виртуальный сервер, а не родительская установка. </para>
<para>Для дальнейшей информации по установке пользовательского режима Linux, обратитесь к <ulink url="http://www.gentoo.org/doc/ru/uml.xml?style=printable">руководству по пользовательскому режиму Linux</ulink>. </para></sect4></sect3><sect3><title>12. Межсетевые экраны</title><sect4><title>12.a. Межсетевой экран</title>
<para>Люди часто думают, что межсетевой экран окончательно защитит их систему, но они ошибаются. В большинстве случаев плохо настроенный межсетевой экран предоставляет еще меньше безопасен, чем его отсутствие. Он тоже является программой, и с ним нужно обращаться так же, как и с остальными программами, так как он может содержать уязвимости. </para>
<para>А теперь подумайте перед реализацией межсетевого экрана! Так ли он вам нужен? Если да, то вам нужно написать правила, определяющие его работу, тип межсетевого экрана и кто должен им управлять. Но сначала прочитайте это руководство. </para>
<para>Межсетевые экраны используются для двух целей: </para>
<orderedlist>
<listitem>
<para>Для защиты извне (черви/злоумышленники) </para>
</listitem>
<listitem>
<para>Для защиты изнутри (сотрудники/дети) </para>
</listitem>
</orderedlist>
<para>В основном есть три типа межсетевых экранов: </para>
<orderedlist>
<listitem>
<para>Фильтрование пакетов </para>
</listitem>
<listitem>
<para>Прокси </para>
</listitem>
<listitem>
<para>Программный шлюз </para>
</listitem>
</orderedlist>
<para>Межсетевой экран должен работать на выделенном компьютере без лишних запущенных сервисов (или же только с sshd) и обезопасен такими способами, которые описаны в этом руководстве. </para></sect4><sect4><title>12.b. Фильтрование пакетов</title>
<para>Весь сетевой трафик передается в виде пакетов. Непрерывный поток разделяется на маленькие, легко управляемые пакеты, которые собираются в точке назначения. В заголовке каждого пакета содержится информация о способе и месте его назначения. Также эта информация используется работы межсетевого экрана. Фильтрация основана на: </para>
<orderedlist>
<listitem>
<para>разрешении или запрещении пакетов на основании IP-адреса отправителя/получателя </para>
</listitem>
<listitem>
<para>разрешении или запрещении пакетов на основании порта отправителя/получателя </para>
</listitem>
<listitem>
<para>разрешении или запрещении пакетов на основании протокола </para>
</listitem>
<listitem>
<para>разрешении или запрещении пакетов на основании параметров, специфичных для каждого из протоколов </para>
</listitem>
</orderedlist>
<para>Другими словами, фильтрация основана на содержимом заголовка пакета, а не самого пакета. </para>
<para>Недостатки: </para>
<orderedlist>
<listitem>
<para>адрес в пакете может быть ненастоящим адресом IP (или подделанным отправителем) </para>
</listitem>
<listitem>
<para>данные или запросы в пропущенном пакете могут содержать непредвиденные данные, которые злоумышленник может использовать для эксплуатации известных уязвимостей в сервисах, расположенным на межсетевом экране или позади него </para>
</listitem>
<listitem>
<para>критично к сбоям </para>
</listitem>
</orderedlist>
<para>Преимущества: </para>
<orderedlist>
<listitem>
<para>простая реализация </para>
</listitem>
<listitem>
<para>возможность отправки предупреждений о возможных атаках до того, как они произойдут (то есть регистрация сканирования портов) </para>
</listitem>
<listitem>
<para>хорош против предотвращения SYN-атак </para>
</listitem>
</orderedlist>
<para>Вот примеры свободных фильтров пакетов для Linux: </para>
<orderedlist>
<listitem>
<para>
<ulink url="http://www.iptables.org/">Iptables</ulink> </para>
</listitem>
<listitem>
<para>
<ulink url="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html">Ipchains</ulink> </para>
</listitem>
<listitem>
<para>
<ulink url="http://www.smoothwall.org/">SmoothWall</ulink> </para>
</listitem>
</orderedlist>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Рекомендуется использовать iptables. ipchains устарел. </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>12.c. Прокси</title>
<para>Шлюз сеансового уровня является межсетевым экраном, проверяющим соединения перед разрешением обмена данных. Это значит, что он не только разрешает или запрещает пересылку пакетов на основании их заголовка, но и определяет перед открытием сессии на основании настраиваемых правил, что оба адресата реально существуют. Фильтрация основывается на: </para>
<orderedlist>
<listitem>
<para>IP-адресе отправителя/получателя </para>
</listitem>
<listitem>
<para>порте отправителя/получателя </para>
</listitem>
<listitem>
<para>времени </para>
</listitem>
<listitem>
<para>протоколе </para>
</listitem>
<listitem>
<para>пользователе </para>
</listitem>
<listitem>
<para>пароле </para>
</listitem>
</orderedlist>
<para>Весь трафик прослушивается и проверяется, и непрошенный трафик может быть отброшен. </para>
<para>Недостатки: </para>
<orderedlist>
<listitem>
<para>Взаимодействует на транспортном уровне и может потребовать изменения программ, предоставляющих транспортные функции. </para>
</listitem>
</orderedlist></sect4><sect4><title>12.d. Программный шлюз</title>
<para>Шлюзы уровня приложений являются прокси-серверами для приложений, обменивающимися вместо клиентов данными с удаленными системами. Это позволяет находиться вне доступа извне за ДМЗ (демилитаризованной зоной, частью частной сети, видимой сквозь межсетевой экран) или разрешать межсетевому экрану предотвращать соединения извне. Фильтрация основывается на: </para>
<orderedlist>
<listitem>
<para>разрешении или запрещении на основании IP-адреса источника/назначения </para>
</listitem>
<listitem>
<para>на содержимом пакетов </para>
</listitem>
<listitem>
<para>ограничения доступа к файлу на основе типа файла и расширения </para>
</listitem>
</orderedlist>
<para>Преимущества: </para>
<orderedlist>
<listitem>
<para>Может кэшировать файлы, увеличивая производительность сети </para>
</listitem>
<listitem>
<para>Детализированная регистрация всех подключений </para>
</listitem>
<listitem>
<para>Хорошая расширяемость (некотрые прокси могут распределять кэшированные данные между собой) </para>
</listitem>
<listitem>
<para>Нет прямого доступа извне </para>
</listitem>
<listitem>
<para>Может изменять содержимое пакета на лету </para>
</listitem>
</orderedlist>
<para>Недостатки: </para>
<orderedlist>
<listitem>
<para>Конфигурация является комплексной </para>
</listitem>
</orderedlist>
<para>Программные шлюзы принято считать наиболее безопасным решением, так как они не запускаются с правами администратора, и все узлы за ними будут недоступными из интернета. </para>
<para>Пример свободного шлюза: </para>
<orderedlist>
<listitem>
<para>
<ulink url="http://www.squid-cache.org/">Squid</ulink> </para>
</listitem>
</orderedlist></sect4><sect4><title>12.e. Iptables</title>
<para>Для нормального функционирования iptables должен быть включен в ядро. Я включил поддержку iptables модулей (команда iptables загрузит их по мере необходимости) и пересобрал ядро (но вы можете включить их в само ядро, если намереваетесь отказаться от загружаемых модулей ядра, как сказано выше). Для более детальной информации по настройке iptables в ядре обратитесь к странице <ulink url="http://iptables-tutorial.frozentux.net/iptables-tutorial.html#PREPARATIONS">Iptables Tutorial Chapter 5: Preparations</ulink>. После пересборки нового ядра (или во время компиляции) вы должны добавить команду iptables. Для этого просто наберите emerge iptables. </para>
<para>Теперь проверим свою работу, запустив iptables -L. Если команда завершилась ошибкой, значит, что-то не так, поэтому проверьте еще раз настройки. </para>
<para>iptables — новый и весьма улучшенный межсетевой экран в ядрах Linux 2.4.x. Он является наследником ipchains для ядер Linux 2.2.x. Одним из значительных нововведений является то, что iptables способен совершать полноценную фильтрацию пакетов. С ее помощью стало возможным следить за каждым установленным TCP-соединением. </para>
<para>TCP-соединение содержит в себе серию пакетов, содержащих информацию IP-адресе и порте отправителя и получателя, а также последовательное число, поэтому пакеты могут быть воссозданы без потери данных. TCP является протоколом, ориентированном на подключение, в отличии от UDP, который не гарантирует доставку. </para>
<para>Изучая заголовок TCP-пакета, межсетевой экран может может определить, является ли полученный пакет частью уже установленного соединения или нет, и принять решение, принять или отбросить этот пакет. </para>
<para>При использовании межсетевого экрана, не отслеживающего соединения, возможно провести его и заставить с помощью манипулирования заголовками TCP-пакета принимать пакеты, которые необходимо отбросить. Это может быть сделано с помощью установки SYN или других флагов заголовка TCP и создания поддельного пакета, который будет считаться частью уже установленного соединения (ведь межсетевой экран не будет отслеживать состояние соединения). При использовании фильтрации пакетов, отслеживающих соединения, можно отбрасывать подобные пакеты, если они не являются частью уже установленного соединения. Это также предотвратит «stealth-сканирование», разновидности сканирования, с помощью которого сканер отправляет пакеты с такой комбинацией флагов, при которых они не будут зарегистрированы межсетевым экраном, полагающим, что это — обычные SYN-пакеты. </para>
<para>В iptables также есть различные возможности, как например NAT (Network Address Translation, сетевая трансляция адресов) и ограничения по частоте. Ограничение по частоте весьма полезна для предотвращения DoS-атак (Denial of Service, отказ от обслуживания), например SYN-наводнений. </para>
<para>TCP-соединения устанавливаются после так называемого троекратного рукопожатия. При установлении TCP-соединения клиент отправляет серверу пакет с установленным флагом SYN. При получении сервер возвращает клиенту пакет с установленными SYN+ACK. При его получении клиент отвечает третьим пакетом с ACK для подтверждения соединения. </para>
<para>SYN-наводнения основаны на отправке SYN-пакетов с одновременным запретом отправки пакетов SYN+ACK. Клиент может создать пакет с поддельным IP-адресом отправителя, так как ему не нужно на что-либо отвечать. Сервер заполнит очередь подключений полуоткрытыми соединениями, ожидающими окончательного пакета с ACK, до того, как удалит их из очереди. Очередь ограничена определенным числом, и когда она заполнится, то станет невозможным принимать новые подключения. Если пакет с ACK не будет получен по истечении определенного временного интервала, то он будет автоматически удален из очереди. Настройки таймаута могут быть различными, но обычно они находятся в пределах 30—60 секунд или даже больше. Клиент инициирует атаку, создавая множество SYN-пакетов с различных IP-адресов и отправляя их на адрес цели как можно чаще, заполняя тем самым очередь полуоткрытыми соединениями и не позволяя другим клиентам устанавливать легитимные подключения к серверу. </para>
<para>В данном случае может быть полезным ограничение отправки. Можно ограничить частоту отправки принятых SYN-пакетов с помощью -m limit --limit 1/s, тем самым ограничив число SYN-пакетов до одного в секунду и оградив свои ресурсы от SYN-наводнений. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Другим решением, предотвращающим SYN-наводнения является использование <ulink url="http://cr.yp.to/syncookies.html">SYN cookies</ulink>, которые позволят вашему компьютеру отвечать на SYN-пакеты без заполнения очереди подключений. SYN cookies могут быть включены при конфигурировании ядра Linux, однако на данный момент эта поддержка считается экспериментальной. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>А теперь немного практических занятий! </para>
<para>Будучи загруженным в ядро, iptables предоставляет 5 ловушек, в которые вы можете поместить свои правила. Они называются INPUT, OUTPUT, FORWARD, PREROUTING и POSTROUTING. Каждая из них называется цепочкой и содержит список правил. Каждое правило описывает, что если заголовок пакета выглядит как образец, то делать с этим пакетом нужно то-то и то-то. Если правило не подходит под пакет, то пакет переходит к следующему правилу в цепочке. </para>
<para>Вы можете поместить правила в 5 цепочках напрямую или создать новые цепочки и добавлять в них правила таким же способом, как и в обычную цепочку. Iptables поддерживает следующие параметры. </para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>Параметр:</para>
</entry>
<entry>
<para>Описание:</para>
</entry>
</row>
<row>
<entry>
<para>-A</para>
</entry>
<entry>
<para>Добавление</para>
</entry>
</row>
<row>
<entry>
<para>-D</para>
</entry>
<entry>
<para>Удаление</para>
</entry>
</row>
<row>
<entry>
<para>-I</para>
</entry>
<entry>
<para>Вставка</para>
</entry>
</row>
<row>
<entry>
<para>-R</para>
</entry>
<entry>
<para>Замена</para>
</entry>
</row>
<row>
<entry>
<para>-L</para>
</entry>
<entry>
<para>Просмотр</para>
</entry>
</row>
<row>
<entry>
<para>-F</para>
</entry>
<entry>
<para>Удалить все правила в цепочке или все цепочки</para>
</entry>
</row>
<row>
<entry>
<para>-Z</para>
</entry>
<entry>
<para>Обнулить счетчики во всех цепочках</para>
</entry>
</row>
<row>
<entry>
<para>-C</para>
</entry>
<entry>
<para>Проверить этот пакет в цепочке</para>
</entry>
</row>
<row>
<entry>
<para>-N</para>
</entry>
<entry>
<para>Создать новую пользовательскую цепочку</para>
</entry>
</row>
<row>
<entry>
<para>-X</para>
</entry>
<entry>
<para>Удалить пользовательскую цепочку</para>
</entry>
</row>
<row>
<entry>
<para>-P</para>
</entry>
<entry>
<para>Изменить политику цепочки для цели</para>
</entry>
</row>
<row>
<entry>
<para>-E</para>
</entry>
<entry>
<para>Изменить имя цепочки</para>
</entry>
</row>
<row>
<entry>
<para>-p</para>
</entry>
<entry>
<para>протоколе</para>
</entry>
</row>
<row>
<entry>
<para>-s</para>
</entry>
<entry>
<para>Адрес/маска источника</para>
</entry>
</row>
<row>
<entry>
<para>-d</para>
</entry>
<entry>
<para>Адрес/маска назначения</para>
</entry>
</row>
<row>
<entry>
<para>-i</para>
</entry>
<entry>
<para>Входящее имя (имя ethernet)</para>
</entry>
</row>
<row>
<entry>
<para>-o</para>
</entry>
<entry>
<para>Исходящее имя (имя ethernet)</para>
</entry>
</row>
<row>
<entry>
<para>-j</para>
</entry>
<entry>
<para>Перейти (цель для правила)</para>
</entry>
</row>
<row>
<entry>
<para>-m</para>
</entry>
<entry>
<para>Расширенные сравнения (могут использовать внешние расширения)</para>
</entry>
</row>
<row>
<entry>
<para>-n</para>
</entry>
<entry>
<para>Числовой вывод адресов и портов</para>
</entry>
</row>
<row>
<entry>
<para>-t</para>
</entry>
<entry>
<para>Таблица для обработки</para>
</entry>
</row>
<row>
<entry>
<para>-v</para>
</entry>
<entry>
<para>Расширенный режим</para>
</entry>
</row>
<row>
<entry>
<para>-x</para>
</entry>
<entry>
<para>Расширить числа (вывести все значения)</para>
</entry>
</row>
<row>
<entry>
<para>-f</para>
</entry>
<entry>
<para>Проверять только второй и последующие фрагменты</para>
</entry>
</row>
<row>
<entry>
<para>-V</para>
</entry>
<entry>
<para>Версия пакета</para>
</entry>
</row>
<row>
<entry>
<para>--line-numbers</para>
</entry>
<entry>
<para>Указывать номера строк при выводе</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Сначала попробуем заблокировать все ICMP-пакеты, идущие на наш компьютер, просто для того, чтобы познакомиться с iptables поближе. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1: Блокировка всех пакетов ICMP</para>
</entry>
</row>
<row>
<entry>
<para># iptables -A INPUT -p icmp -j DROP</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Сначала мы указываем цепочку, в которую хотим поместить правило, затем протокол проверяемого пакета и в конце цель. Цель может быть именем пользовательской цепочки или одной из специальных целей — ACCEPT, DROP, REJECT, LOG, QUEUE или MASQUERADE. В случае, если мы укажем DROP, то пакет будет отброшен без уведомления клиента. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: LOG является «необрывающей» целью. Если пакет подпадает под правило с целью LOG, то он будет передан следующему правилу в цепочке, а не обработан только этим правилом. Это позволяет регистрировать пакеты и при этом их обрабатывать. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь попробуйте выполнить ping localhost. Вы не должны получить ответа, так как iptables будет отбрасывать все входящие ICMP-сообщения. Вы также не сможете проверить и другие компьютеры, так как ответные ICMP-пакеты тоже будут отбрасываться. А теперь, чтобы вновь получать ICMP, очистим цепочку. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2: Сбросить все правила</para>
</entry>
</row>
<row>
<entry>
<para># iptables -F</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь взглянем на полноценную фильтрацию пакетов с помощью iptables. Если нужно полноценное исследование входящих пакетов на интерфейсе eth0, то выполним следующую команду: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3: Принимать пакеты от уже установленных соединений</para>
</entry>
</row>
<row>
<entry>
<para># iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Это разрешит принимать любой пакет из уже установленного соединения или связанного в цепочке INPUT. Вы можете отбросить любой пакет, не соответствующий состоянию таблицы, выполнив команду iptables -A INPUT -i eth0 -m state --state INVALID -j DROP сразу же после предыдущей. Эта команда включит фильтрацию пакетов на основании состояния, подключив внешнее расширение «state». Если вам необходимо разрешить подключаться клиентам к компьютеру, то вы можете использовать флаг --state NEW. Iptables содержит несколько модулей различного назначения. Вот некоторые из них: </para>
<informaltable frame="all">
<tgroup cols="3"><tbody>
<row>
<entry>
<para>Модуль/сравнение</para>
</entry>
<entry>
<para>Описание</para>
</entry>
<entry>
<para>Расширенные параметры</para>
</entry>
</row>
<row>
<entry>
<para>mac</para>
</entry>
<entry>
<para>Расширение для проверки MAC-адресов входящих пакетов.</para>
</entry>
<entry>
<para>--mac-source</para>
</entry>
</row>
<row>
<entry>
<para>state</para>
</entry>
<entry>
<para>Включение проверки состояния соединения</para>
</entry>
<entry>
<para>--state (состоянием может быть ESTABLISHED,RELATED, INVALID, NEW)</para>
</entry>
</row>
<row>
<entry>
<para>limit</para>
</entry>
<entry>
<para>Частотное ограничение</para>
</entry>
<entry>
<para>--limit, --limit-burst</para>
</entry>
</row>
<row>
<entry>
<para>owner</para>
</entry>
<entry>
<para>Попытка проверить различные характеристики создателя пакета</para>
</entry>
<entry>
<para>--uid-owner userid --gid-owner groupid --pid-owner processid --sid-owner sessionid </para>
</entry>
</row>
<row>
<entry>
<para>unclean</para>
</entry>
<entry>
<para>Различные случайны проверки пакетов на правильность</para>
</entry>
<entry>
<para/>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь попробуем создать пользовательскую цепочку и применить ее для одного из существующих: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4: Создание пользовательской цепочки</para>
</entry>
</row>
<row>
<entry>
<para>(Создаем новую цепочку с одним правилом)</para>
<para># iptables -X mychain</para>
<para># iptables -N mychain</para>
<para># iptables -A mychain -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</para>
<para>(Разрешающая политика по умолчанию для всего исходящего трафика. Входящий будет отброшен.)</para>
<para># iptables -P OUTPUT ACCEPT</para>
<para># iptables -P INPUT DROP</para>
<para>(И добавление ее в цепочку INPUT)</para>
<para># iptables -A INPUT -j mychain</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Применив правило к входящей цепочке, мы получим следующую политику: все исходящие пакеты будут пропущены, а все входящие — отброшены. </para>
<para>Документация может быть найдена по адресу <ulink url="http://www.iptables.org/documentation/index.html#HOWTO">Netfilter/iptables documentation</ulink>. </para>
<para>Теперь взглянем на полный пример. Мои правила для межсетевого экрана/шлюза будут следующими: </para>
<orderedlist>
<listitem>
<para>Подключения к межсетевому экрану разрешены только через SSH (порт 22) </para>
</listitem>
<listitem>
<para>Локальная сеть должна иметь доступ к HTTP, HTTPS и SSH (также должен быть разрешен DNS) </para>
</listitem>
<listitem>
<para>ICMP может содержать постороннюю информацию и не должен быть разрешен. Конечно же, мы разрешаем некоторые ICMP-сообщения. </para>
</listitem>
<listitem>
<para>Сканирование портов должно быть определено и зарегистрировано </para>
</listitem>
<listitem>
<para>SYN-атаки должны быть пресечены </para>
</listitem>
<listitem>
<para>Весь остальной трафик должен быть отброшен и запротоколирован </para>
</listitem>
<listitem>
<para/>
</listitem>
</orderedlist>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5: /etc/init.d/firewall</para>
</entry>
</row>
<row>
<entry>
<para>#!/sbin/runscript</para>
<para>IPTABLES=/sbin/iptables</para>
<para>IPTABLESSAVE=/sbin/iptables-save</para>
<para>IPTABLESRESTORE=/sbin/iptables-restore</para>
<para>FIREWALL=/etc/firewall.rules</para>
<para>DNS1=212.242.40.3</para>
<para>DNS2=212.242.40.51</para>
<para>#inside</para>
<para>IIP=10.0.0.2</para>
<para>IINTERFACE=eth0</para>
<para>LOCAL_NETWORK=10.0.0.0/24</para>
<para>#outside</para>
<para>OIP=217.157.156.144</para>
<para>OINTERFACE=eth1</para>
<para/>
<para>opts="${opts} showstatus panic save restore showoptions rules"</para>
<para/>
<para>depend() {</para>
<para>  need net</para>
<para>}</para>
<para/>
<para>rules() {</para>
<para>  stop</para>
<para>  ebegin "Setting internal rules"</para>
<para/>
<para>  einfo "Setting default rule to drop"</para>
<para>  $IPTABLES -P FORWARD DROP</para>
<para>  $IPTABLES -P INPUT   DROP</para>
<para>  $IPTABLES -P OUTPUT  DROP</para>
<para/>
<para>  #default rule</para>
<para>  einfo "Creating states chain"</para>
<para>  $IPTABLES -N allowed-connection</para>
<para>  $IPTABLES -F allowed-connection</para>
<para>  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT</para>
<para>  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \</para>
<para>      "Bad packet from ${IINTERFACE}:"</para>
<para>  $IPTABLES -A allowed-connection -j DROP</para>
<para/>
<para>  #ICMP traffic</para>
<para>  einfo "Creating icmp chain"</para>
<para>  $IPTABLES -N icmp_allowed</para>
<para>  $IPTABLES -F icmp_allowed</para>
<para>  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \</para>
<para>      time-exceeded -j ACCEPT</para>
<para>  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \</para>
<para>      destination-unreachable -j ACCEPT</para>
<para>  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix "Bad ICMP traffic:"</para>
<para>  $IPTABLES -A icmp_allowed -p icmp -j DROP</para>
<para/>
<para>  #Incoming traffic</para>
<para>  einfo "Creating incoming ssh traffic chain"</para>
<para>  $IPTABLES -N allow-ssh-traffic-in</para>
<para>  $IPTABLES -F allow-ssh-traffic-in</para>
<para>  #Flood protection</para>
<para>  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \</para>
<para>      ALL RST --dport ssh -j ACCEPT</para>
<para>  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \</para>
<para>      ALL FIN --dport ssh -j ACCEPT</para>
<para>  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \</para>
<para>      ALL SYN --dport ssh -j ACCEPT</para>
<para>  $IPTABLES -A allow-ssh-traffic-in -m state --state RELATED,ESTABLISHED -p tcp --dport ssh -j ACCEPT</para>
<para/>
<para>  #outgoing traffic</para>
<para>  einfo "Creating outgoing ssh traffic chain"</para>
<para>  $IPTABLES -N allow-ssh-traffic-out</para>
<para>  $IPTABLES -F allow-ssh-traffic-out</para>
<para>  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT</para>
<para/>
<para>  einfo "Creating outgoing dns traffic chain"</para>
<para>  $IPTABLES -N allow-dns-traffic-out</para>
<para>  $IPTABLES -F allow-dns-traffic-out</para>
<para>  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \</para>
<para>      -j ACCEPT</para>
<para>  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \</para>
<para>     -j ACCEPT</para>
<para/>
<para>  einfo "Creating outgoing http/https traffic chain"</para>
<para>  $IPTABLES -N allow-www-traffic-out</para>
<para>  $IPTABLES -F allow-www-traffic-out</para>
<para>  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT</para>
<para>  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT</para>
<para/>
<para>  #Catch portscanners</para>
<para>  einfo "Creating portscan detection chain"</para>
<para>  $IPTABLES -N check-flags</para>
<para>  $IPTABLES -F check-flags</para>
<para>  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \</para>
<para>      --limit 5/minute -j LOG --log-level alert --log-prefix "NMAP-XMAS:"</para>
<para>  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP</para>
<para>  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \</para>
<para>      5/minute -j LOG --log-level 1 --log-prefix "XMAS:"</para>
<para>  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP</para>
<para>  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \</para>
<para>      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix "XMAS-PSH:"</para>
<para>  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP</para>
<para>  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \</para>
<para>      --limit 5/minute -j LOG --log-level 1 --log-prefix "NULL_SCAN:"</para>
<para>  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP</para>
<para>  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \</para>
<para>      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/RST:"</para>
<para>  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP</para>
<para>  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \</para>
<para>      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/FIN:"</para>
<para>  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP</para>
<para/>
<para>  # Apply and add invalid states to the chains</para>
<para>  einfo "Applying chains to INPUT"</para>
<para>  $IPTABLES -A INPUT -m state --state INVALID -j DROP</para>
<para>  $IPTABLES -A INPUT -p icmp -j icmp_allowed</para>
<para>  $IPTABLES -A INPUT -j check-flags</para>
<para>  $IPTABLES -A INPUT -i lo -j ACCEPT</para>
<para>  $IPTABLES -A INPUT -j allow-ssh-traffic-in</para>
<para>  $IPTABLES -A INPUT -j allowed-connection</para>
<para/>
<para>  einfo "Applying chains to FORWARD"</para>
<para>  $IPTABLES -A FORWARD -m state --state INVALID -j DROP</para>
<para>  $IPTABLES -A FORWARD -p icmp -j icmp_allowed</para>
<para>  $IPTABLES -A FORWARD -j check-flags</para>
<para>  $IPTABLES -A FORWARD -o lo -j ACCEPT</para>
<para>  $IPTABLES -A FORWARD -j allow-ssh-traffic-in</para>
<para>  $IPTABLES -A FORWARD -j allow-www-traffic-out</para>
<para>  $IPTABLES -A FORWARD -j allowed-connection</para>
<para/>
<para>  einfo "Applying chains to OUTPUT"</para>
<para>  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP</para>
<para>  $IPTABLES -A OUTPUT -p icmp -j icmp_allowed</para>
<para>  $IPTABLES -A OUTPUT -j check-flags</para>
<para>  $IPTABLES -A OUTPUT -o lo -j ACCEPT</para>
<para>  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out</para>
<para>  $IPTABLES -A OUTPUT -j allow-dns-traffic-out</para>
<para>  $IPTABLES -A OUTPUT -j allow-www-traffic-out</para>
<para>  $IPTABLES -A OUTPUT -j allowed-connection</para>
<para/>
<para>  #Allow client to route through via NAT (Network Address Translation)</para>
<para>  $IPTABLES -t nat -A POSTROUTING -o $OINTERFACE -j MASQUERADE</para>
<para>  eend $?</para>
<para>}</para>
<para/>
<para>start() {</para>
<para>  ebegin "Starting firewall"</para>
<para>  if [ -e "${FIREWALL}" ]; then</para>
<para>    restore</para>
<para>  else</para>
<para>    einfo "${FIREWALL} does not exists. Using default rules."</para>
<para>    rules</para>
<para>  fi</para>
<para>  eend $?</para>
<para>}</para>
<para/>
<para>stop() {</para>
<para>  ebegin "Stopping firewall"</para>
<para>  $IPTABLES -F</para>
<para>  $IPTABLES -t nat -F</para>
<para>  $IPTABLES -X</para>
<para>  $IPTABLES -P FORWARD ACCEPT</para>
<para>  $IPTABLES -P INPUT   ACCEPT</para>
<para>  $IPTABLES -P OUTPUT  ACCEPT</para>
<para>  eend $?</para>
<para>}</para>
<para/>
<para>showstatus() {</para>
<para>  ebegin "Status"</para>
<para>  $IPTABLES -L -n -v --line-numbers</para>
<para>  einfo "NAT status"</para>
<para>  $IPTABLES -L -n -v --line-numbers -t nat</para>
<para>  eend $?</para>
<para>}</para>
<para/>
<para>panic() {</para>
<para>  ebegin "Setting panic rules"</para>
<para>  $IPTABLES -F</para>
<para>  $IPTABLES -X</para>
<para>  $IPTABLES -t nat -F</para>
<para>  $IPTABLES -P FORWARD DROP</para>
<para>  $IPTABLES -P INPUT   DROP</para>
<para>  $IPTABLES -P OUTPUT  DROP</para>
<para>  $IPTABLES -A INPUT -i lo -j ACCEPT</para>
<para>  $IPTABLES -A OUTPUT -o lo -j ACCEPT</para>
<para>  eend $?</para>
<para>}</para>
<para/>
<para>save() {</para>
<para>  ebegin "Saving Firewall rules"</para>
<para>  $IPTABLESSAVE &gt; $FIREWALL</para>
<para>  eend $?</para>
<para>}</para>
<para/>
<para>restore() {</para>
<para>  ebegin "Restoring Firewall rules"</para>
<para>  $IPTABLESRESTORE &lt; $FIREWALL</para>
<para>  eend $?</para>
<para>}</para>
<para/>
<para>restart() {</para>
<para>  svc_stop; svc_start</para>
<para>}</para>
<para/>
<para>showoptions() {</para>
<para>  echo "Usage: $0 {start|save|restore|panic|stop|restart|showstatus}"</para>
<para>  echo "start)      will restore setting if exists else force rules"</para>
<para>  echo "stop)       delete all rules and set all to accept"</para>
<para>  echo "rules)      force settings of new rules"</para>
<para>  echo "save)       will store settings in ${FIREWALL}"</para>
<para>  echo "restore)    will restore settings from ${FIREWALL}"</para>
<para>  echo "showstatus) Shows the status"</para>
<para>}</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Вот несколько советов при создании правил для межсетевого экрана: </para>
<orderedlist>
<listitem>
<para>Создайте политику межсетевого экрана до того, как ее реализуете </para>
</listitem>
<listitem>
<para>Сделайте ее простой </para>
</listitem>
<listitem>
<para>Знайте принцип работы каждого протокола (прочитайте подходящий <ulink url="http://www.ietf.org/">RFC</ulink>) </para>
</listitem>
<listitem>
<para>Всегда помните, что межсетевой экран — это просто программа, запускаемая с правами администратора. </para>
</listitem>
<listitem>
<para>Проверьте свой межсетевой экран </para>
</listitem>
</orderedlist>
<para>Если вам кажется, что iptables труден для понимания или нужно слишком много времени для настройки межсетевого экрана, то вы можете попробовать <ulink url="http://www.shorewall.net/">Shorewall</ulink>. Для генерации правил межсетевого экрана он использует iptables, но акцентируется на правилах и не указывает протокол. </para></sect4><sect4><title>12.f. Squid</title>
<para>Squid является очень хорошим прокси-сервером. Он может фильтровать трафик на основании времени, регулярных выражений в пути/URI, IP-адреса получателя и отправителя, домена, браузера, имени зарегистрированного пользователя, типа MIME и номера порта (протокола). Некоторые возможности не указаны, но трудно перечислить их всех. </para>
<para>В следующем примере я добавил фильтр баннеров вместо фильтра, основанного на фильтрации порносайтов. По этой причине gentoo.org не должен быть перечислен в списке порносайтов. И я не собираюсь тратить свое время на поиски хороших сайтов для вас. </para>
<para>В данном случае, вот мои правила: </para>
<orderedlist>
<listitem>
<para>Веб-серфинг (HTTP/HTTPS) разрешен только в рабочее время (с понедельника по пятницу с 8 до 17 часов и в субботу с 8 до 13 часов), но если служащие остаются, то они должны работать, а не сидеть в интернете. </para>
</listitem>
<listitem>
<para>Скачивание файлов не разрешено (.exe, .com, .arj, .zip, .asf, .avi, .mpg, .mpeg и так далее) </para>
</listitem>
<listitem>
<para>Нам не нужны баннеры, поэтому они будут отфильтрованы и заменены на прозрачный GIF (здесь пригодится ваша креативность!). </para>
</listitem>
<listitem>
<para>Все остальные подключения в/из Интернета запрещены. </para>
</listitem>
</orderedlist>
<para>Все это реализуется в 4 простых шага. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 6: /etc/squid/squid.conf</para>
</entry>
</row>
<row>
<entry>
<para># Указываем IP и порт</para>
<para>http_port 10.0.2.1:3128</para>
<para/>
<para># Стандартная конфигурация</para>
<para>hierarchy_stoplist cgi-bin ?</para>
<para>acl QUERY urlpath_regex cgi-bin \?</para>
<para>no_cache deny QUERY</para>
<para/>
<para># Добавляем основные списки контроля доступа</para>
<para>acl all src 0.0.0.0/0.0.0.0</para>
<para>acl manager proto cache_object</para>
<para>acl localhost src 127.0.0.1/255.255.255.255</para>
<para/>
<para># Добавляем тех, кто может пользоваться прокси</para>
<para>acl localnet src 10.0.0.0/255.255.0.0</para>
<para/>
<para># Добавляем порты</para>
<para>acl SSL_ports port 443</para>
<para>acl Safe_ports port 80</para>
<para>acl Safe_ports port 443</para>
<para>acl purge method PURGE</para>
<para/>
<para># Добавляем список контроля доступа, основанного на регулярных</para>
<para># выражениях, встречаемых в URL</para>
<para>acl archives urlpath_regex "/etc/squid/files.acl"</para>
<para>acl url_ads url_regex "/etc/squid/banner-ads.acl"</para>
<para/>
<para># Добавляем список контроля доступа, основанного на времени и дате</para>
<para>acl restricted_weekdays time MTWHF 8:00-17:00</para>
<para>acl restricted_weekends time A 8:00-13:00</para>
<para/>
<para>acl CONNECT method CONNECT</para>
<para/>
<para># Разрешаем менеджеру подключаться с localhost</para>
<para>http_access allow manager localhost</para>
<para>http_access deny manager</para>
<para/>
<para># Разрешать очищать запросы только с localhost</para>
<para>http_access allow purge localhost</para>
<para>http_access deny purge</para>
<para/>
<para># Запрещать запросы на неизвестные порты</para>
<para>http_access deny !Safe_ports</para>
<para/>
<para># Запрещать подключение к портам, не относящимся к SSL</para>
<para>http_access deny CONNECT !SSL_ports</para>
<para/>
<para># Мои собственные правила</para>
<para/>
<para># Добавляем страницу, отображаемую на месте</para>
<para># удаленного баннера</para>
<para>deny_info NOTE_ADS_FILTERED url_ads</para>
<para/>
<para># Запрещаем баннеры</para>
<para>http_access deny url_ads</para>
<para/>
<para># Запрещаем любые архивы</para>
<para>http_access deny archives</para>
<para/>
<para># Ограничиваем доступ в рабочим временем</para>
<para>http_access allow localnet restricted_weekdays</para>
<para>http_access allow localnet restricted_weekends</para>
<para/>
<para># Запрещаем все остальное</para>
<para>http_access deny all</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Далее перечислим типы запрещенных к скачиванию файлов. Я добавил zip, viv, exe, mp3, rar, ace, avi, mov, mpg, mpeg, au, ra, arj, tar, gz и z файлы. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 7: /etc/squid/files.acl</para>
</entry>
</row>
<row>
<entry>
<para>\.[Zz][Ii][pP]$</para>
<para>\.[Vv][Ii][Vv].*</para>
<para>\.[Ee][Xx][Ee]$</para>
<para>\.[Mm][Pp]3$</para>
<para>\.[Rr][Aa][Rr]$</para>
<para>\.[Aa][Cc][Ee]$</para>
<para>\.[Aa][Ss][Ff]$</para>
<para>\.[Aa][Vv][Ii]$</para>
<para>\.[Mm][Oo][Vv]$</para>
<para>\.[Mm][Pp][Gg]$</para>
<para>\.[Mm][Pp][Ee][Gg]$</para>
<para>\.[Aa][Uu]$</para>
<para>\.[Rr][Aa]$</para>
<para>\.[Aa][Rr][Jj]$</para>
<para>\.[Tt][Aa][Rr]$</para>
<para>\.[Gg][Zz]$</para>
<para>\.[Zz]$</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Обратите внимание на [] с заглавными и строчными буквами. Это сделано для того, чтобы никто не смог обмануть наш фильтр, пытаясь скачать файл с расширением AvI вместо avi. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Далее добавим регулярные выражения для определения баннеров. Вы, возможно, будете более изобретательнее меня: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 8: /etc/squid/banner-ads.acl</para>
</entry>
</row>
<row>
<entry>
<para>/adv/.*\.gif$</para>
<para>/[Aa]ds/.*\.gif$</para>
<para>/[Aa]d[Pp]ix/</para>
<para>/[Aa]d[Ss]erver</para>
<para>/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$</para>
<para>/[Bb]annerads/</para>
<para>/adbanner.*\.[GgJj][IiPp][FfGg]$</para>
<para>/images/ad/</para>
<para>/reklame/</para>
<para>/RealMedia/ads/.*</para>
<para>^http://www\.submit-it.*</para>
<para>^http://www\.eads.*</para>
<para>^http://ads\.</para>
<para>^http://ad\.</para>
<para>^http://ads02\.</para>
<para>^http://adaver.*\.</para>
<para>^http://adforce\.</para>
<para>adbot\.com</para>
<para>/ads/.*\.gif.*</para>
<para>_ad\..*cgi</para>
<para>/Banners/</para>
<para>/SmartBanner/</para>
<para>/Ads/Media/Images/</para>
<para>^http://static\.wired\.com/advertising/</para>
<para>^http://*\.dejanews\.com/ads/</para>
<para>^http://adfu\.blockstackers\.com/</para>
<para>^http://ads2\.zdnet\.com/adverts</para>
<para>^http://www2\.burstnet\.com/gifs/</para>
<para>^http://www.\.valueclick\.com/cgi-bin/cycle</para>
<para>^http://www\.altavista\.com/av/gifs/ie_horiz\.gif</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>И в заключении мы хотим, чтобы отображался следующий файл вместо удаленного баннера. Он основан половине HTML-файла с прозрачным GIF-изображением размером 4х4. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 9: /etc/squid/errors/NOTE_ADS_FILTERED</para>
</entry>
</row>
<row>
<entry>
<para>&lt;HTML&gt;</para>
<para>&lt;HEAD&gt;</para>
<para>&lt;META HTTP-EQUIV="REFRESH" CONTENT="0; URL=http://localhost/images/4x4.gif"&gt;</para>
<para>&lt;TITLE&gt;ERROR: The requested URL could not be retrieved&lt;/TITLE&gt;</para>
<para>&lt;/HEAD&gt;</para>
<para>&lt;BODY&gt;</para>
<para>&lt;H1&gt;Add filtered!&lt;/H1&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Не закрывайте теги &lt;HTML&gt; и &lt;BODY&gt;. Squid сделает это самостоятельно. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Как вы видите, у Squid есть множество возможностей для очень эффективной фильтрации и кэширования. Можно даже использовать альтернативные прокси-сервера Squid для сегментирования очень больших сетей. Приведенная конфигурация подходит для небольшой сети с 1—20 пользователями. </para>
<para>Однако комбинация межсетевого экрана (iptables) и программного шлюза (Squid), возможно, является наилучшей, особенно если Squid находится где-нибудь в безопасном месте, где никто не может иметь к нему доступ извне. Нам все же стоит позаботиться об атаках изнутри. </para>
<para>Теперь вам необходимо настроить клиентские браузеры для использования прокси-сервера. Шлюз предотвратит попытки пользователей общаться с внешним миром без использования прокси. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: В Mozilla это может быть сделано через Edit-&gt;Preferences-&gt;Advanced-&gt;Proxies. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Также можно настроить прозрачное использование прокси, указав iptables перенаправлять весь исходящий трафик на вход Squid. Это можно сделать, добавив следующее правило на шлюзе: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 10: Разрешить проброс портов для нашего прокси-сервера</para>
</entry>
</row>
<row>
<entry>
<para># iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</para>
<para># iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Если прокси-сервер работает на том же узле, что и межсетевой экран (хотя это не рекомендуется, но может понадобится из-за отсутствия свободных компьютеров), то используйте цель REDIRECT вместо DNAT (REDIRECT направит пакеты на localhost). </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>12.g. Изучено</title>
<para>Мы узнали: </para>
<orderedlist>
<listitem>
<para>Межсетевой экран является опасным сам по себе. Плохо настроенный межсетевой экран хуже, чем его отсутствие. </para>
</listitem>
<listitem>
<para>Как установить простой шлюз и прозрачный прокси-сервер. </para>
</listitem>
<listitem>
<para>Залогом хорошей работы межсетевого экрана заключается в знании протоколов, которые вы собираетесь разрешить. </para>
</listitem>
<listitem>
<para>IP-трафик не всегда содержит законные данные, например пакеты ICMP, которые могут содержать вредоносное содержимое. </para>
</listitem>
<listitem>
<para>Как предотвратить SYN-атаку. </para>
</listitem>
<listitem>
<para>Фильтрация HTTP-трафика предотвратит загрузку нежелательных изображений и вирусов. </para>
</listitem>
<listitem>
<para>Сочетание пакетных фильтров и программных шлюзов дает лучший контроль. </para>
</listitem>
</orderedlist>
<para>Теперь, если вам действительно это нужно, идите и создайте правила межсетевого экрана, отвечающего вашим требованиям. </para></sect4></sect3><sect3><title>13. Обнаружение вторжения</title><sect4><title>13.a. AIDE (Advanced Intrusion Detection Environment)</title>
<para>AIDE — это система обнаружения атак, основанная на узле (Host-Based Intrusion Detection System, HIDS), свободная альтернатива Tripwire (если вы уже работали с Tripwire, то не должны испытывать сложности с конфигурационным файлом AIDE). HIDS используется для обнаружения изменений в важных системных файлах настроек и двоичных файлах с помощью сверки уникальных криптографических контрольных сумм, созданных каждого из файлов и сохраненных в надежном месте. Принцип действия таков: заранее сохраненный и достоверный хеш сравнивается с сгенерированным с текущей копии каждого файла, чтобы определить какой из файлов был изменен. HIDS является великолепным решением для регистрации подозрительных изменений в системе, однако для того, чтобы она заработала, нужно приложить небольшие усилия. </para>
<para>Конфигурационный файл основан на применении регулярных выражений, макросов и правил для файлов и каталогов. Есть следующие макросы: </para>
<informaltable frame="all">
<tgroup cols="3"><tbody>
<row>
<entry>
<para>Макрос</para>
</entry>
<entry>
<para>Описание</para>
</entry>
<entry>
<para>Синтаксис</para>
</entry>
</row>
<row>
<entry>
<para>ifdef</para>
</entry>
<entry>
<para>если определен</para>
</entry>
<entry>
<para>@@ifdef "name"</para>
</entry>
</row>
<row>
<entry>
<para>ifndef</para>
</entry>
<entry>
<para>если не определен</para>
</entry>
<entry>
<para>@@ifndef "name"</para>
</entry>
</row>
<row>
<entry>
<para>define</para>
</entry>
<entry>
<para>определить переменную </para>
</entry>
<entry>
<para>@@define "name" "value"</para>
</entry>
</row>
<row>
<entry>
<para>undef</para>
</entry>
<entry>
<para>удалить переменную</para>
</entry>
<entry>
<para>@@undef "name"</para>
</entry>
</row>
<row>
<entry>
<para>ifhost</para>
</entry>
<entry>
<para>если "hostname"</para>
</entry>
<entry>
<para>@@ifhost "hostname"</para>
</entry>
</row>
<row>
<entry>
<para>ifnhost</para>
</entry>
<entry>
<para>если не "hostname"</para>
</entry>
<entry>
<para>@@ifnhost "hostname"</para>
</entry>
</row>
<row>
<entry>
<para>endif</para>
</entry>
<entry>
<para>endif должен использоваться каждый раз, когда используется любой из вышеприведенных макросов, за исключением define и undef </para>
</entry>
<entry>
<para>@@endif</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Если у вас есть много компьютеров с Gentoo и вы хотите использовать на них AIDE, то макросы будут весьма полезными. Но не на всех компьютерах запускаются одни и те же сервисы или есть одни и те же пользователи. </para>
<para>Теперь необходимо установить флаги проверок для файлов и каталогов. Возможны сочетания прав доступа, свойств файлов и криптографических хешей (контрольных сумм). </para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>Флаг</para>
</entry>
<entry>
<para>Описание</para>
</entry>
</row>
<row>
<entry>
<para>p</para>
</entry>
<entry>
<para>права доступа</para>
</entry>
</row>
<row>
<entry>
<para>i</para>
</entry>
<entry>
<para>inode</para>
</entry>
</row>
<row>
<entry>
<para>n</para>
</entry>
<entry>
<para>количество ссылок</para>
</entry>
</row>
<row>
<entry>
<para>u</para>
</entry>
<entry>
<para>пользователь</para>
</entry>
</row>
<row>
<entry>
<para>g</para>
</entry>
<entry>
<para>группа</para>
</entry>
</row>
<row>
<entry>
<para>s</para>
</entry>
<entry>
<para>размер</para>
</entry>
</row>
<row>
<entry>
<para>b</para>
</entry>
<entry>
<para>число блоков</para>
</entry>
</row>
<row>
<entry>
<para>m</para>
</entry>
<entry>
<para>время последней модификации</para>
</entry>
</row>
<row>
<entry>
<para>a</para>
</entry>
<entry>
<para>время последнего доступа</para>
</entry>
</row>
<row>
<entry>
<para>c</para>
</entry>
<entry>
<para>время изменения</para>
</entry>
</row>
<row>
<entry>
<para>S</para>
</entry>
<entry>
<para>проверка растущего размера</para>
</entry>
</row>
<row>
<entry>
<para>md5</para>
</entry>
<entry>
<para>контрольная сумма MD5</para>
</entry>
</row>
<row>
<entry>
<para>sha1</para>
</entry>
<entry>
<para>контрольная сумма SHA1</para>
</entry>
</row>
<row>
<entry>
<para>rmd160</para>
</entry>
<entry>
<para>контрольная сумма RMD160</para>
</entry>
</row>
<row>
<entry>
<para>tiger</para>
</entry>
<entry>
<para>контрольная сумма Tiger</para>
</entry>
</row>
<row>
<entry>
<para>R</para>
</entry>
<entry>
<para>p+i+n+u+g+s+m+c+md5</para>
</entry>
</row>
<row>
<entry>
<para>L</para>
</entry>
<entry>
<para>p+i+n+u+g</para>
</entry>
</row>
<row>
<entry>
<para>E</para>
</entry>
<entry>
<para>Пустая группа</para>
</entry>
</row>
<row>
<entry>
<para>&gt;</para>
</entry>
<entry>
<para>растущий лог-файл p+u+g+i+n+S</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>А если AIDE собран с поддержкой mhash, то доступны следующие возможности: </para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>Флаг</para>
</entry>
<entry>
<para>Описание</para>
</entry>
</row>
<row>
<entry>
<para>haval</para>
</entry>
<entry>
<para>контрольная сумма HAVAL</para>
</entry>
</row>
<row>
<entry>
<para>gost</para>
</entry>
<entry>
<para>контрольная сумма ГОСТ</para>
</entry>
</row>
<row>
<entry>
<para>crc32</para>
</entry>
<entry>
<para>контрольная сумма CRC32</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь вы можете создать собственные правила, основанные на сочетании вышеперечисленных флагов, например: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1: Создание набора правил для AIDE</para>
</entry>
</row>
<row>
<entry>
<para>All=R+a+sha1+rmd160</para>
<para>Norm=s+n+b+md5+sha1+rmd160</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>И последнее, что нам понадобится для создания собственного конфигурационного файла, — это умение добавлять правило для файла или каталога. Чтобы ввести правило, скомбинируйте файл или каталог с правилом. AIDE добавляет все файлы рекурсивно, если вы не указали обратное в другом правиле. </para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>Флаг</para>
</entry>
<entry>
<para>Описание</para>
</entry>
</row>
<row>
<entry>
<para>!</para>
</entry>
<entry>
<para>Не добавлять этот файл или каталог.</para>
</entry>
</row>
<row>
<entry>
<para>=</para>
</entry>
<entry>
<para>Добавлять этот каталог, но не рекурсивно.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>А теперь взглянем на полный пример: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2: /etc/aide/aide.conf</para>
</entry>
</row>
<row>
<entry>
<para>@@ifndef TOPDIR</para>
<para>@@define TOPDIR /</para>
<para>@@endif</para>
<para/>
<para>@@ifndef AIDEDIR</para>
<para>@@define AIDEDIR /etc/aide</para>
<para>@@endif</para>
<para/>
<para>@@ifhost smbserv</para>
<para>@@define smbactive</para>
<para>@@endif</para>
<para/>
<para># Расположение базы данных для чтения.</para>
<para>database=file:@@{AIDEDIR}/aide.db</para>
<para/>
<para># Расположение базы данных для записи.</para>
<para>database_out=file:aide.db.new</para>
<para/>
<para>verbose=20</para>
<para>report_url=stdout</para>
<para/>
<para># Определение правил</para>
<para>All=R+a+sha1+rmd160</para>
<para>Norm=s+n+b+md5+sha1+rmd160</para>
<para/>
<para>@@{TOPDIR} Norm</para>
<para>!@@{TOPDIR}etc/aide</para>
<para>!@@{TOPDIR}dev</para>
<para>!@@{TOPDIR}media</para>
<para>!@@{TOPDIR}mnt</para>
<para>!@@{TOPDIR}proc</para>
<para>!@@{TOPDIR}root</para>
<para>!@@{TOPDIR}sys</para>
<para>!@@{TOPDIR}tmp</para>
<para>!@@{TOPDIR}var/log</para>
<para>!@@{TOPDIR}var/run</para>
<para>!@@{TOPDIR}usr/portage</para>
<para>@@ifdef smbactive</para>
<para>!@@{TOPDIR}etc/smb/private/secrets.tdb</para>
<para>@@endif</para>
<para>=@@{TOPDIR}home Norm</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>В приведенном примере мы указали некоторые макросы, корневой каталог, с которого будет начинать свою работу AIDE, и каталог, в котором находится AIDE. AIDE сверяется с /etc/aide/aide.db при проверке на целостность. Но при обновлении или создании нового файла она сохраняет информацию в /etc/aide/aide.db.new. Это делается для того, чтобы не переписать старую базу данных. Параметр report_URL пока не реализован, но, согласно автору, он должен отправлять электронную почту или даже запуск сценариев. </para>
<para>Теперь по умолчанию пакет AIDE поставляется вместе с рабочим конфигурационным файлом, сценарием-помощником и сценарием планировщика заданий crontab. Сценарий-помощник содержит множество задач для вас и предоставляет более дружественный интерфейс. Чтобы просмотреть все доступные параметры, попробуйте aide --help. Все что вам нужно, чтобы начать, — запустить aide -i, и теперь сценарий crontab должен найти базу данных и ежедневно отправлять отчеты по электронной почте. Рекомендуется все же пересмотреть файл /etc/aide/aide.conf и удостовериться, что конфигурация подходит для данного компьютера. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: В зависимости от процессора, скорости чтения диска и установленных для файлов флагов, это может занять много времени. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Не забудьте установить алиасы, чтобы получать почту, адресуемую суперпользователю. Иначе вы никогда не узнаете, что пишет для вас в отчетах AIDE. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Все же есть небольшой риск, заключающийся в том, что злоумышленник может (если узнает об установленном AIDE) изменить локальную базу данных файлов, обновить ее или изменить /usr/bin/aide. Поэтому вы должны создать компакт-диск или иной носитель и сохранить на нем копию файла .db и двоичных файлов AIDE. </para>
<para>Дополнительную информацию вы можете найти на сайте проекта <ulink url="http://www.cs.tut.fi/%7Erammer/aide.html">AIDE</ulink> </para></sect4><sect4><title>13.b. Snort</title>
<para>Snort является сетевой системой обнаружения вторжения (Network Intrusion Detection System, NIDS). Чтобы установить и настроить его, воспользуйтесь следующими примерами. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3: /etc/conf.d/snort</para>
</entry>
</row>
<row>
<entry>
<para>PIDFILE=/var/run/snort_eth0.pid</para>
<para>MODE="full"</para>
<para>NETWORK="10.0.0.0/24"</para>
<para>LOGDIR="/var/log/snort"</para>
<para>CONF=/etc/snort/snort.conf</para>
<para>SNORT_OPTS="-D -s -u snort -dev -l $LOGDIR -h $NETWORK -c $CONF"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4: /etc/snort/snort.conf</para>
</entry>
</row>
<row>
<entry>
<para>(Шаг 1)</para>
<para>var HOME_NET 10.0.0.0/24</para>
<para>var EXTERNAL_NET any</para>
<para>var SMTP $HOME_NET</para>
<para>var HTTP_SERVERS $HOME_NET</para>
<para>var SQL_SERVERS $HOME_NET</para>
<para>var DNS_SERVERS [10.0.0.2/32,212.242.40.51/32]</para>
<para>var RULE_PATH ./</para>
<para/>
<para>(Шаг 2)</para>
<para>preprocessor frag2</para>
<para>preprocessor stream4: detect_scans detect_state_problems detect_scans disable_evasion_alerts</para>
<para>preprocessor stream4_reassemble: ports all</para>
<para>preprocessor http_decode:80 8080 unicode iis_alt_unicode double_encode iis_flip_slash full_whitespace</para>
<para>preprocessor rpc_decode: 111 32771</para>
<para>preprocessor bo: -nobrute</para>
<para>preprocessor telnet_decode</para>
<para/>
<para>(Шаг 3)</para>
<para>include classification.config</para>
<para/>
<para>(Шаг 4)</para>
<para>include $RULE_PATH/bad-traffic.rules</para>
<para>include $RULE_PATH/exploit.rules</para>
<para>include $RULE_PATH/scan.rules</para>
<para>include $RULE_PATH/finger.rules</para>
<para>include $RULE_PATH/ftp.rules</para>
<para>include $RULE_PATH/telnet.rules</para>
<para>include $RULE_PATH/smtp.rules</para>
<para>include $RULE_PATH/rpc.rules</para>
<para>include $RULE_PATH/rservices.rules</para>
<para>include $RULE_PATH/dos.rules</para>
<para>include $RULE_PATH/ddos.rules</para>
<para>include $RULE_PATH/dns.rules</para>
<para>include $RULE_PATH/tftp.rules</para>
<para>include $RULE_PATH/web-cgi.rules</para>
<para>include $RULE_PATH/web-coldfusion.rules</para>
<para>include $RULE_PATH/web-iis.rules</para>
<para>include $RULE_PATH/web-frontpage.rules</para>
<para>include $RULE_PATH/web-misc.rules</para>
<para>include $RULE_PATH/web-attacks.rules</para>
<para>include $RULE_PATH/sql.rules</para>
<para>include $RULE_PATH/x11.rules</para>
<para>include $RULE_PATH/icmp.rules</para>
<para>include $RULE_PATH/netbios.rules</para>
<para>include $RULE_PATH/misc.rules</para>
<para>include $RULE_PATH/attack-responses.rules</para>
<para>include $RULE_PATH/backdoor.rules</para>
<para>include $RULE_PATH/shellcode.rules</para>
<para>include $RULE_PATH/policy.rules</para>
<para>include $RULE_PATH/porn.rules</para>
<para>include $RULE_PATH/info.rules</para>
<para>include $RULE_PATH/icmp-info.rules</para>
<para>include $RULE_PATH/virus.rules</para>
<para># include $RULE_PATH/experimental.rules</para>
<para>include $RULE_PATH/local.rules</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 5: /etc/snort/classification.config</para>
</entry>
</row>
<row>
<entry>
<para>config classification: not-suspicious,Not Suspicious Traffic,3</para>
<para>config classification: unknown,Unknown Traffic,3</para>
<para>config classification: bad-unknown,Potentially Bad Traffic, 2</para>
<para>config classification: attempted-recon,Attempted Information Leak,2</para>
<para>config classification: successful-recon-limited,Information Leak,2</para>
<para>config classification: successful-recon-largescale,Large Scale Information Leak,2</para>
<para>config classification: attempted-dos,Attempted Denial of Service,2</para>
<para>config classification: successful-dos,Denial of Service,2</para>
<para>config classification: attempted-user,Attempted User Privilege Gain,1</para>
<para>config classification: unsuccessful-user,Unsuccessful User Privilege Gain,1</para>
<para>config classification: successful-user,Successful User Privilege Gain,1</para>
<para>config classification: attempted-admin,Attempted Administrator Privilege Gain,1</para>
<para>config classification: successful-admin,Successful Administrator Privilege Gain,1</para>
<para/>
<para># NEW CLASSIFICATIONS</para>
<para>config classification: rpc-portmap-decode,Decode of an RPC Query,2</para>
<para>config classification: shellcode-detect,Executable code was detected,1</para>
<para>config classification: string-detect,A suspicious string was detected,3</para>
<para>config classification: suspicious-filename-detect,A suspicious filename was detected,2</para>
<para>config classification: suspicious-login,An attempted login using a suspicious username was detected,2</para>
<para>config classification: system-call-detect,A system call was detected,2</para>
<para>config classification: tcp-connection,A TCP connection was detected,4</para>
<para>config classification: trojan-activity,A Network Trojan was detected, 1</para>
<para>config classification: unusual-client-port-connection,A client was using an unusual port,2</para>
<para>config classification: network-scan,Detection of a Network Scan,3</para>
<para>config classification: denial-of-service,Detection of a Denial of Service Attack,2</para>
<para>config classification: non-standard-protocol,Detection of a non-standard protocol or event,2</para>
<para>config classification: protocol-command-decode,Generic Protocol Command Decode,3</para>
<para>config classification: web-application-activity,access to a potentially vulnerable web application,2</para>
<para>config classification: web-application-attack,Web Application Attack,1</para>
<para>config classification: misc-activity,Misc activity,3</para>
<para>config classification: misc-attack,Misc Attack,2</para>
<para>config classification: icmp-event,Generic ICMP event,3</para>
<para>config classification: kickass-porn,SCORE! Get the lotion!,1</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Дополнительной информация может быть найдена на сайте <ulink url="http://www.snort.org/">Snort</ulink>. </para></sect4><sect4><title>13.c. Обнаружение вредоносных программ с помощью chkrootkit</title>
<para>Система HIDS, как AIDE, является лучшим средством для обнаружения изменений в вашей системе, но хуже не будет, если будет установлен еще один рубеж обороны. chkrootkit — это утилита, которая сканирует системные файлы на наличие руткитов — программ, разработанных для сокрытия присутствия взломщика и сохранения доступа к системе, а также на наличие следов кейлоггеров и прочих вредоносных программ. Хотя chkrootkit (и прочие аналоги, например rkhunter) являются полезными утилитами, как контроля за системой, так и для обнаружения следов вторжения, но они не могут гарантировать, что ваша система в безопасности. </para>
<para>Наилучший способ использовать chkrootkit для обнаружения внедрения — запускать его с помощью cron. Сначала установите app-admin/chkrootkit. chkrootkit может запускаться из командной строки или же с помощью записи в cron следующего вида: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 6: Назначение задания chrootkit в crontab</para>
</entry>
</row>
<row>
<entry>
<para>0 3 * * * /usr/sbin/chkrootkit</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4></sect3><sect3><title>14. Регулярные обновления</title><sect4><title>14.a. Регулярные обновления</title>
<para>После успешной установки и настройки ее безопасности систему, тем не менее, нельзя называть завершенной. Процесс обеспечения безопасности является постоянным по времени, ведь большинство известных взломов является результатом использования известных уязвимостей в устаревших системах. Постоянное обновление системы — наиболее значимый шаг, который вы можете совершить для обеспечения наилучшей безопасности. </para>
<para>Если у вас установлена последняя версия portage, то, предварительно обновив дерево с помощью команды emerge --sync, вы можете запустить команду glsa-check --list, которая проверит вашу систему на наличие известных уязвимостей. glsa-check является частью пакета app-portage/gentoolkit. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1: Пример вывода glsa-check -l</para>
</entry>
</row>
<row>
<entry>
<para># glsa-check -l</para>
<para>WARNING: This tool is completely new and not very tested, so it should not be</para>
<para>used on production systems. It's mainly a test tool for the new GLSA release</para>
<para>and distribution system, it's functionality will later be merged into emerge</para>
<para>and equery.</para>
<para>Please read http://www.gentoo.org/proj/en/portage/glsa-integration.xml</para>
<para>before using this tool AND before reporting a bug.</para>
<para/>
<para>[A] means this GLSA was already applied,</para>
<para>[U] means the system is not affected and</para>
<para>[N] indicates that the system might be affected.</para>
<para/>
<para>200406-03 [N] sitecopy: Multiple vulnerabilities in included libneon ( net-misc/sitecopy )</para>
<para>200406-04 [U] Mailman: Member password disclosure vulnerability ( net-mail/mailman )</para>
<para>.......</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: Утилита glsa-check все еще является экспериментальной, поэтому, если вы действительно ставите безопасность превыше всего, то лучше также свериться с другими источниками. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Все строки, содержащие [A] и [U], могут быть игнорированы, так как они неприменимы для данной системы. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Важно: Не забывайте, что использование emerge -vpuD world не устанавливает все необходимые обновления пакетов. Используйте glsa-check, если хотите быть уверенным, что все GLSA исправлены в вашей системе. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2: Проверка всех GLSA</para>
</entry>
</row>
<row>
<entry>
<para>(Подвержена ли ваша система GLSA?)</para>
<para># glsa-check -t all</para>
<para>WARNING: This tool is completely new and not very tested, so it should not be</para>
<para>used on production systems. It's mainly a test tool for the new GLSA release</para>
<para>and distribution system, it's functionality will later be merged into emerge</para>
<para>and equery.</para>
<para>Please read http://www.gentoo.org/proj/en/portage/glsa-integration.xml</para>
<para>before using this tool AND before reporting a bug.</para>
<para/>
<para>This system is affected by the following GLSA:</para>
<para>200504-06</para>
<para>200510-08</para>
<para>200506-14</para>
<para>200501-35</para>
<para>200508-12</para>
<para>200507-16</para>
<para/>
<para>(Просмотр всех пакетов, подверженных переустановке)</para>
<para># glsa-check -p $(glsa-check -t all)</para>
<para>     (частичный вывод)</para>
<para>Checking GLSA 200504-06</para>
<para>The following updates will be performed for this GLSA:</para>
<para>     app-arch/sharutils-4.2.1-r11 (4.2.1-r10)</para>
<para/>
<para>     **********************************************************************</para>
<para/>
<para>     Checking GLSA 200510-08</para>
<para>     The following updates will be performed for this GLSA:</para>
<para>          media-libs/xine-lib-1.1.0-r5 (1.1.0-r4)</para>
<para/>
<para>(применение необходимых исправлений)</para>
<para># glsa-check -f $(glsa-check -t all)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Если вы обновили запущенный сервис, не забудьте перезапустить его. </para>
<para>Также рекомендуется регулярно <ulink url="http://www.gentoo.org/doc/ru/kernel-upgrade.xml?style=printable">обновлять ядро</ulink>. </para>
<para>Вы можете также подписаться на список рассылки gentoo-announce, чтобы получать уведомления GLSA по электронной почте. Инструкции по подписке могут быть найдены на странице <ulink url="http://www.gentoo.org/main/ru/lists.xml?style=printable">Введение в почтовые рассылки Gentoo Linux</ulink>. </para>
<para>Другим хорошим источником информации по безопасности является <ulink url="http://www.securityfocus.com/archive/1">список рассылки Bugtraq</ulink>. </para></sect4></sect3></sect2></sect1><sect1><title>Hardened Gentoo</title>
<para>Ссылка на оригинал:  <ulink url="http://www.habrahabr.ru/blog/linux/22815.html">http://www.habrahabr.ru/blog/linux/22815.html</ulink>
</para>
<para>Автор: powerman.</para>
<para>С версии: 1.5.</para>
<para/><sect2><title>Описание</title>
<para>Для начала расскажу, зачем я публикую эту статью. Дело в том, что большинство пользователей Gentoo Linux до сих пор не использует <ulink url="http://www.gentoo.org/proj/en/hardened/">Hardened Gentoo</ulink>. И вызвано это обычно тем, что они либо не знают, что это такое, либо считают что это слишком сложно, либо считают что от этого пострадает стабильность, функциональность или производительность системы. Вот эти опасения я и хочу попытаться развеять.</para>
<para>Hardened Gentoo - это несколько изменений в компиляторе и ядре, которые увеличивают общую защищенность системы от взлома. Например, hardened-ядро умеет блокировать массу потенциально опасных операций, а hardened-gcc позволяет защитить компилируемые им программы от взлома типовыми методами а-ля переполнение буфера. Грубо говоря, если у вас стоит "дырявая" версия программы X, и её пытается взломать хакер, то в обычной системе у него это получится, а в hardened - не получится, да ещё и в лог запись пойдёт.</para>
<para/>
<para>Для установки Hardened на обычный Gentoo нужно будет полностью перекомпилировать всю систему - иначе защиты предоставляемые hardened-gcc не будут использоваться. Hardened - это ещё одна система, которую нужно аккуратно настраивать - переборщишь с защищённостью - ничего работать не будет вообще, недоборщишь - зачем тогда вообще Hardened ставить? Некоторые проги с hardened не уживаются (обычно это бинарные пакеты: дрова nVidia/ATI, Java плюс почему-то такой софт как mplayer/xmms) - это не смертельно, просто приходится для этих прог индивидуально отключать часть защит (для этого есть утилитки)... что огорчает. Ядро используется из пакета hardened-sources, и оно обычно на пару версий отстаёт от gentoo-sources.</para>
<para>Итак, Hardened Gentoo это просто объединение нескольких разных, часто независимых друг от друга, проектов:</para>
<orderedlist>
<listitem>
<para/>
</listitem>
<listitem>
<para>Hardened toolchain - специальные патчи на gcc/glibc/binutils:</para>
<para>PIE и SSP не зависят друг от друга, и их можно использовать вместе и по отдельности (после компиляции hardened toolchain можно будет через gcc-config переключаться между всеми вариантами - PIE+SSP, только PIE, только SSP, ничего (т.е. обычный gcc) - например, если какая-то прога не будет компилироваться.</para>
</listitem>
<listitem>
<para>Патчи на ядро. Их бывает много, и разных, :) но в Gentoo есть поддержка только четырёх из них - <ulink url="http://ru.wikipedia.org/wiki/PaX">PaX</ulink>, <ulink url="http://ru.wikipedia.org/wiki/Security-Enhanced_Linux">SeLinux</ulink>, <ulink url="http://en.wikipedia.org/wiki/Grsecurity">GrSecurity</ulink> и <ulink url="http://en.wikipedia.org/wiki/RSBAC">RSBAC</ulink>. Функциональность они добавляют трех типов:</para>
<para/>
<para>Эти три "фичи" тоже не зависят одна от другой. Но сами патчи - SeLinux, GrSecurity и RSBAC обычно между собой не совместимы и нужно использовать только один из них. Впрочем, в Gentoo сумели объединить SeLinux и GrSecurity вместе. Часть GrSecurity, которая занимается третьей фичей (ограничением прав) называется RBAC, и её использовать вместе с SeLinux нельзя - или-или.Итого, варианты есть, например, следующие:</para>
<para>Я выбрал первый (PaX+GrSecurity) т.к. во-первых настройка SeLinux обещает быть кошмаром, в отличие от GrSecurity/RBAC; во-вторых на мой взгляд поддержка RSBAC в Gentoo ещё сыровата; и в-третьих ну понравился мне GrSecurity, понравился. :))</para>
</listitem>
</orderedlist>
<para/>
<para/></sect2><sect2><title>Установка</title>
<para>Процесс установки Hardened Gentoo (точнее, апгрейда текущей Gentoo системы в Hardened) выглядит примерно так:<anchor id="habracut"/>
</para>
<orderedlist>
<listitem>
<para/>
</listitem>
<listitem>
<para>переключаемся на hardened toolchain и пересобираем им всю систему, чтобы все бинарники использовали PIE и SSP (после этого система становится защищена SSP)</para>
</listitem>
<listitem>
<para>устанавливаем hardened-sources (они содержат патчи PaX + GrSecurity + SeLinux + дополнительные от Gentoo) и компилируем их с поддержкой PaX, GrSecurity и GrSecurity/RBAC</para>
</listitem>
<listitem>
<para>перегружаемся с новым ядром (после этого система становится защищена ещё и PaX+PIE и GrSecurity)</para>
</listitem>
<listitem>
<para>некоторое время настраиваем и отлаживаем ограничения доступа (после чего система становится защищена ещё и GrSecurity/RBAC)</para>
</listitem>
</orderedlist>
<para/>
<para>Ожидаемые проблемы:</para>
<orderedlist>
<listitem>
<para/>
</listitem>
<listitem>
<para>не всё может скомпилироваться с PIE+SSP - возможно отдельные пакеты нужно будет патчить или компилировать без одной или обоих из них (мне пока потребовалось через gcc-config переключаться на vanilla gcc только для компиляции X-ов чтобы они работали с ATI-дровами)</para>
</listitem>
<listitem>
<para>не всё может нормально работать, т.к. некоторые программы (обычно упоминают X-ы и java) используют выполнение динамически сгенерированного кода для вполне легальных целей, а теперь при попытке это делать они будут киляться либо SSP либо PIE+PaX - для этих программ нужно будет индивидуально отключать часть защит PaX (для этого есть специальные утилиты, например paxctl) и/или компилировать их без SSP</para>
</listitem>
<listitem>
<para>не всё может работать из-за ограничений "фич" ядра GrSecurity - в этом случае нужно будет часть защит GrSecurity отключать (глобально, в make menuconfig)</para>
</listitem>
<listitem>
<para>настроить ограничения прав доступа может оказаться не просто, и в любой момент когда какая-нить прога сделает что-то, что мы при настройке её прав не учли - она будет прибита ядром... и придётся эти правила в срочном порядке фиксить</para>
</listitem>
</orderedlist>
<para>Ну что, поехали... :)</para>
<para>Слишком сильная оптимизация (-O3) вместе с hardened toolchain может приводить к разным глюкам и сбоям компиляции, поэтому нужно в /etc/make.conf заменить -O3 на -O2, и убрать все прочие -f* оптимизаторские флаги.</para>
<para>Переходим на hardened-профайл. (Теоретически вместо этого можно было просто добавить в USE-флаги: "hardened pie ssp".)</para>
<para>ln -snf ../usr/portage/profiles/hardened/x86/2.6/ /etc/make.profile</para>
<para>После переключения профайла на hardened/x86/2.6/ выключилось несколько нужных мне USE-флагов, которые в обычных профайлах включены автоматически - я их дописал в make.conf (у вас флаги могут быть другие, просто не забудьте этот момент проследить):</para>
<para>avi encode gtk2 jpeg mpeg oss quicktime spell truetype xv bitmap-fonts truetype-fonts type1-fonts</para>
<para>Компиляция hardened-toolchain и пересборка им всех остальных пакетов:</para>
<para>emerge binutils gcc glibc emerge -e world</para>
<para>dispatch-conf</para>
<para>Далее, нужно поставить ещё несколько пакетов:</para>
<para>emerge paxtest paxctl gradm</para>
<para>paxtest можно было поставить и раньше, до перехода на hardened toolchain. Эта утилитка пытается делать разные опасные операции (типа переполнения стека с выполнением кода), которые обычно выполняют эксплойты. Если система защищена, то все её попытки будут пресечены, о чём она и сообщит. В общем, можно её погонять до установки hardened toolchain, после а так-же после перезагрузки с ядром где включён PaX, по приколу. :)</para>
<para>paxtest как свою зависимость так-же установит прогу chpax - это старый способ управлять PaX, вместо которого лучше использовать paxctl. Но некоторые проги, распространяемые без исходников, скомпилированы так, что paxctl с ними работать не может, и приходится юзать chpax.</para>
<para>Ну а gradm нужен для настройки RBAC в GrSecurity - тех самых ограничений прав для процессов и юзеров.</para>
<para>Что касается настроек ядра. Я для начала настроил всё так, как описано в доке Gentoo и GrSecurity - при этом не все защиты включены, но большинство софта при таких настройках будет работать. В процессе разбора с настройками возникло несколько теоретических предположений:</para>
<orderedlist>
<listitem>
<para/>
</listitem>
<listitem>
<para>Если загрузить hardened ядро ДО перекомпилирования системы, то могут возникнуть проблемы если включена эта опция:</para>
<para>PaX -&gt; Non-executable pages -&gt; Disallow ELF text relocations</para>
</listitem>
<listitem>
<para>На сервере, где нет X-ов, можно дополнительно включить: (не забыть перед этим проверить, что от этого не перестало работать что-то кроме X-ов, в частности hwclock):</para>
<para>Grsecurity -&gt; Address Space Protection -&gt; Disable privileged I/O</para>
</listitem>
<listitem>
<para>Кроме того, ещё есть предположение, что некоторые ограничения chroot могут помешать операциям типа инсталляции Gentoo (которая идёт внутри chroot) или попытке починки системы (если, например, для этого загрузиться с CD с таким hardened ядром):</para>
<para>Grsecurity -&gt; Filesystem Protections -&gt; Deny mounts</para>
<para>Grsecurity -&gt; Filesystem Protections -&gt; Deny double-chroots</para>
<para>Grsecurity -&gt; Filesystem Protections -&gt; Deny (f)chmod +s</para>
<para>Grsecurity -&gt; Filesystem Protections -&gt; Deny mknod</para>
</listitem>
</orderedlist>
<para/>
<para/>
<para/></sect2><sect2><title>Настройка</title>
<para>Настройка Hardened состоит из двух частей: настройка ядра, и настройка ролей (RBAC или SELinux). Пример настройки ядра 2.6.20 я сейчас покажу. А RBAC/SELinux я пока не настраивал.</para>
<para>
<anchor id="habracut1"/>Думаю, будет нагляднее всего привести настройки так, как они выглядят в make menuconfig - это за одно позволит оценить "на глаз" возможности PaX и GrSecurity тем, кто с ними до сих пор не сталкивался.</para>
<para>Между разными версиями ядра они немного меняются, но не значительно.</para>
<para/>
<para>PaX ---&gt;</para>
<para>. [*] Enable various PaX features....... PaX Control ---&gt;......... [ ] Support soft mode......... [*] Use legacy ELF header marking......... [*] Use ELF program header marking............. MAC system integration (none) ---&gt;....... Non-executable pages ---&gt;......... [*] Enforce non-executable pages......... [*] . Segmentation based non-executable pages......... [ ] Emulate trampolines......... [*] Restrict mprotect()......... [ ] . Disallow ELF text relocations......... [ ] Enforce non-executable kernel pages....... Address Space Layout Randomization ---&gt;......... [*] Address Space Layout Randomization......... [*] . Randomize kernel stack base......... [*] . Randomize user stack base......... [*] . Randomize mmap() base..... Miscellaneous hardening features ---&gt;....... [ ] Sanitize all freed memory....... [*] Prevent invalid userland pointer dereferenceGrsecurity ---&gt;. Security Level (Custom) ---&gt;. Address Space Protection ---&gt;... [*] Deny writing to /dev/kmem, /dev/mem, and /dev/port... [ ] Disable privileged I/O... [*] Remove addresses from /proc//[smaps|maps|stat]... [*] Deter exploit bruteforcing... [*] Runtime module disabling... [*] Hide kernel symbols. Role Based Access Control Options ---&gt;... [*] Hide kernel processes... (3) Maximum tries before password lockout... (30) Time to wait after max password tries, in seconds. Filesystem Protections ---&gt;... [*] Proc restrictions... [*] . Restrict /proc to user only... [*] Additional restrictions... [*] Linking restrictions... [*] FIFO restrictions... [*] Chroot jail restrictions... [*] . Deny mounts... [*] . Deny double-chroots... [*] . Deny pivot_root in chroot... [*] . Enforce chdir("/") on all chroots... [*] . Deny (f)chmod +s... [*] . Deny fchdir out of chroot... [*] . Deny mknod... [*] . Deny shmat() out of chroot... [*] . Deny access to abstract AF_UNIX sockets out of chroot... [*] . Protect outside processes... [*] . Restrict priority changes... [*] . Deny sysctl writes... [*] . Capability restrictions. Kernel Auditing ---&gt;... [ ] Single group for auditing... [ ] Exec logging... [*] Resource logging... [ ] Log execs within chroot... [ ] Chdir logging... [*] (Un)Mount logging... [ ] IPC logging... [*] Signal logging... [*] Fork failure logging... [ ] Time change logging... [*] /proc//ipaddr support... [ ] ELF text relocations logging (READ HELP). Executable Protections ---&gt;... [*] Enforce RLIMIT_NPROC on execs... [*] Destroy unused shared memory... [*] Dmesg(8) restriction... [ ] Trusted Path Execution (TPE). Network Protections ---&gt;... [*] Larger entropy pools... [ ] Socket restrictions. Sysctl support ---&gt;... [*] Sysctl support... [*] . Turn on features by default. Logging Options ---&gt;... (10) Seconds in between log messages (minimum)... (4) Number of messages in a burst (maximum)[ ] Enable access key retention support[ ] Enable different security models</para>
<para>Абсолютное большинство этих фич работает прозрачно для пользователя. Но есть пара, которые вы можете заметить: во-первых обычные пользователи перестанут видеть процессы других пользователей, а во-вторых они потеряют доступ к некоторым файлам в /proc/, из-за чего вывод команд ifconfig, route, etc. запущенных обычными пользователями станет значительно скромнее.</para>
<para>Надо отметить, что большая часть этих фич может управляться через sysctl. Что, как правило, плохо. А что хорошего в том, что хакер ломает систему наполовину, получает возможность отключить эти защиты через sysctl, после чего доламывает её уже окончательно? К счастью, есть возможность заблокировать изменение настроек GrSecurity через sysctl. Для этого нужно добавить в /etc/sysctl.conf:</para>
<para/>
<para>kernel.grsecurity.disable_modules = 1</para>
<para>kernel.grsecurity.grsec_lock = 1</para>
<para/>
<para>Где первая команда запрещает подгрузку модулей ядра (лучше всего на серверах поддержку модулей даже не включать в ядре, но если это не возможно, то теперь есть выход: подгрузить нужные модули при загрузке системы, а потом с помощью kernel.grsecurity.disable_modules запретить подгрузку модулей - чтобы никто случайно руткит не подгрузил :)), а вторая запрещает изменение любых настроек GrSecurity.</para>
<para>Недостаток этого в том, что если вам нужно будет таки подгрузить модуль или отключить часть фич GrSecurity (например, защиту chroot для сборки нового Gentoo), то придётся редактировать /etc/sysctl.conf и перегружаться.</para>
<para>Собственно, настройка на этом окончена.</para>
<para>В качестве резюме, приведу полный набор команд, которые отконвертируют ваш Gentoo в Hardened:</para>
<para>emerge hardened-sources6# Теперь настройте это ядро (пока не включая фичи# hardened), скомпилируйте и перегрузитесь в него.ln -snf ../usr/portage/profiles/hardened/x86/2.6/ /etc/make.profile# Уберите все флаги оптимизации из CFLAGS в /etc/make.conf# и установите -O2.# Пример: CFLAGS="-march=pentium-m -O2 -pipe"# Очистите ваш $PKGDIR (обычно /usr/portage/packages/) для# ускорения времени пересборки системы используя# опции -b и -k команды emerge.emerge -C linux-headersemerge linux-headers glibc binutils gcc-config gcc# Проделайте все дополнительные операции, которые могут# требоваться при обновлении gcc (см. GCC Upgrade Guide).emerge -b glibc binutils gcc portageemerge -bke systememerge -ke worldglsa-check -l | grep '\[N\]'# Ручками обновите пакеты, которые мог выдать glsa-check.emerge -a --depcleanemerge -uDNa worldemerge paxtest paxctl gradmrevdep-rebuilddispatch-conf# Теперь включите в ядре все фичи Hardened,# соберите его и перегрузитесь.</para>
<para/></sect2><sect2><title>Впечатления</title>
<para>Я <ulink url="http://www.habrahabr.ru/blog/linux/22815.html">начал</ulink> с того, что выразил желание развеять распространённые опасения в том, что Hardened - это слишком сложно, либо от этого cтрадает стабильность, функциональность или производительность системы. Я уже продемонстрировал, что такое Hardened Gentoo в общих чертах, а теперь пройдёмся детальнее по этим опасениям.<anchor id="habracut2"/>
</para><sect3><title>Сложность</title>
<para>Я пока не занимался настройкой системы ролей (RBAC/SELinux) как раз из-за сложности. Возможно, конечно, только кажущейся, и на самом деле там тоже всё просто, не знаю... :) Я, всё-таки, в основном программист, и на администрирование времени вечно не хватает. В общем, если в Hardened и есть что-то сложное и требующее кучу времени и внимания - это настройка ролей.</para>
<para>А вот всё, что я описал до этого, настраивается очень просто, быстро, один раз, и даёт достаточно сильный эффект в виде усиления безопасности системы!</para></sect3><sect3><title>Стабильность</title>
<para>Я уже много лет использую Hardened в описанном виде и дома на workstation, и на всех серверах. Никаких проблем со стабильностью их работы из-за Hardened за это время не возникало, и я не видел жалоб в maillist на эту тему.</para>
<para>Что касается стабильности сборки Gentoo, ведь пакеты постоянно обновляются и компилируются. Пару лет назад была необходимость использовать некоторые workaround-ы - например, чтобы XWindow работали с дровами ATI приходилось их собирать не-hardened gcc (для автоматического переключения gcc в процессе компиляции пакетов был написан простейший скрипт). Ну и ещё по мелочи проблем возникало, но ни одной критичной. Сейчас проблем такого рода нет в принципе. Т.е. вы систему на Hardened перевели, и забыли - можете продолжать всё делать так, как будто ничего не произошло. Только хакать ваш сервер стало сложнее гораздо. :)</para></sect3><sect3><title>Функциональность</title>
<para>Да, для того, чтобы работали некоторые пакеты, до сих пор необходимо использовать утилиты chpax/paxctl, для отключения части hardened-защит для конкретных приложений. Но в Gentoo эта операция давно автоматизирована: для этих приложений chpax/paxctl выполняется на этапе установки пакета. Так что вам об этом беспокоиться уже не нужно. А за исключением этого нюанса (что для некоторых приложений часть защит выключена), все приложения работают в Hardened Gentoo без проблем (по крайней мере с теми настройками ядра, которые я привёл в предыдущей части).</para></sect3><sect3><title>Производительность</title>
<para>Честно скажу - сам я не мерял. Да и что и как мерять - не совсем понятно. Насколько я понял из инета - можно ожидать до 3-4% потери производительности в худшем случае, а обычно это будет меньше процента. Но, опять-же, смотря какие "фичи" включать. Если врубить SeLinux или RBAC - тогда можно эти 3-4% потерять, но до их настройки я пока не добрался. :( Визуально - после перехода на Hardened разницы никакой, ни на домашней машине, ни на серверах. Конечно, сколько-то производительности, вероятно, было потеряно из-за перехода на -O2. Ещё я сталкивался с тем, что при выборе "неправильной" опции при настройке ядра из этих двух:</para>
<para>[ ] Paging based non-executable pages[*] Segmentation based non-executable pagesвозникали заметные тормоза. Сейчас я в ядре вообще не вижу первого варианта (который любил потормозить на некоторых типах процессоров).</para></sect3></sect2><sect2><title>Выводы</title>
<para>В общем, у вас есть реальная возможность значительно увеличить безопасность своих машин, потратив один раз пару часов вашего времени на переход на Hardened и сутки машинного времени (пока будет полностью пересобираться система).</para>
<para>"Думайте сами, решайте сами - иметь, или не иметь." :)</para></sect2></sect1><sect1><title>Обновление Gentoo Linux</title>
<para/><sect2><title>Руководство по обновлению Gentoo</title>
<para/>
<para>Ссылка на оригинал:  <ulink url="http://www.gentoo.org/doc/ru/gentoo-upgrading.xml">http://www.gentoo.org/doc/en/gentoo-upgrading.xml</ulink>
</para>
<para>С версии: 1.2</para>
<para>Перевод:  <ulink url="mailto:vnp@bayarea.net">vnp</ulink>, <ulink url="mailto:mike.spacer">Михаил Ярмиш</ulink>, <ulink url="mailto:achumakov@gentoo.org">Алексей Чумаков</ulink>, <ulink url="mailto:JohnBat26@gmail.com?subject=Обновление%20Gentoo">Батогов Е.В, a.k.a JohnBat26</ulink> </para>
<para>Примечание: Из оригинала включён только самый актуальный материал !</para><sect3><title>1. Gentoo и обновления</title>
<para/>
<para>Философия</para>
<para/>
<para>Здесь, на земле Gentoo, обновление понимается совсем не так, как во всем остальном мире Linux. Вы, вероятно, уже знаете, что в наших дистрибутивах мы никогда не следовали «классическому» способу обновления программ: дождаться нового релиза, скачать его, прожечь, засунуть диск в дисковод и, наконец, следовать установочным инструкциям. </para>
<para>Вы знаете (вы же не зря выбрали Gentoo), как такой процесс раздражает опытного пользователя, стремящегося всегда быть на переднем крае. Учитывая популярность и распространенность инструментов типа apt или apt-rpm, облегчающих быстрые и частые обновления, мы полагаем, что и опытные пользователи других дистрибутивов испытывают те же чувства. Однако ни один дистрибутив не приспособлен для удовлетворения нужд требовательных пользователей лучше Gentoo, поскольку Gentoo с самого начала строился на идее быстрых последовательных обновлений. </para>
<para>В идеале, вы устанавливаете систему однажды, и более никогда не беспокоитесь о выпусках: просто следуйте инструкциям из введения в Portage в настольной книге Gentoo, где описывается, как поддерживать актуальность системы. Хотя обычно такого подхода достаточно, иногда в ядро системы вносятся изменения, требующее установки вручную. </para>
<para/>
<para>Выпуски и профили</para>
<para/>
<para>О процессе выпуска версий Gentoo постоянно задают вопрос: «Зачем нужно часто делать новые выпуски, если они не предназначены для обновления программ у пользователей?". Тому есть ряд причин: </para>
<para>Новый выпуск — это новые исправленные и дополненные установочные диски. </para>
<para>Новый выпуск несет обновленный набор пакетов GRP, так что пользователи, избирающие «быстрый способ» установки (stage3 + заранее скомпилированные пакеты), получают не устаревшую систему. </para>
<para>Наконец, в новых выпусках время от времени реализуются функции, несовместимые с предыдущими выпусками. </para>
<para>Если в выпуск входят возможности, несовместимые с предыдущими, или содержится набор фундаментальных пакетов и установок, сильно меняющих поведение системы, мы говорим, что он задает новый профиль. </para>
<para/>
<para>Профиль — это набор конфигурационных файлов, хранимый в подкаталоге /usr/portage/profiles, описывающий сценарии ebuild системных пакетов, флаги использования (USE) по умолчанию, отображение виртуальных пакетов по умолчанию, а также архитектуру, на которой запускается система. </para>
<para/>
<para>Используемый профиль определяется символьной ссылкой /etc/make.profile, которая указывает на подкаталог в /usr/portage/profiles, содержащий файлы профиля. К примеру, профиль x86 2007.0 по умолчанию находится в /usr/portage/profiles/default-linux/x86/2007.0. Файлы в родительских каталогах также входят в состав профиля (и, таким образом, совместно используются различными подпрофилями). Поэтому мы называем такие профили каскадными профилями. </para>
<para>Профили, устаревающие с появлением новых, хранятся в /usr/portage/profiles наравне с актуальными, но помечены как как нежелательные для использования. Для этого в каталог профиля помещается файл deprecated. Файл содержит имя профиля, на который рекомендуется обновиться. Portage использует эту информацию для автоматического предупреждения о необходимости перехода на новый профиль. </para>
<para>Существуют различные причины для создания нового профиля: выпуск новых несовместимых версий базовых пакетов (таких, как baselayout, gcc, или glibc), изменения в USE-флагах по умолчанию или отображении виртуальных пакетов, или, возможно, серьезные системные изменения. </para>
<para/></sect3><sect3><title>2. Гонка за новыми выпусками</title>
<para/>
<para>Выпуски без изменений в профиле</para>
<para/>
<para>Если объявлен новый выпуск Gentoo, в котором не появился новый профиль, то твердо можно притвориться, что вы его не заметили :). </para>
<para>Ваша система будет в точности соответствовать вновь установленной с нового выпуска, если вы обновите установленные пакеты согласно описанию из Настольной книги Gentoo. </para>
<para/>
<para>Выпуски с изменениями в профиле</para>
<para>Если в выпуске появился новый профиль (как, например, в 2007.0 для x86), у вас есть возможность на него перейти. </para>
<para>Естественно, вы не обязаны это делать, и можете продолжать пользоваться старым профилем, просто обновляя свои пакеты, как описано в Настольной книге Gentoo. </para>
<para>Однако, Gentoo крайне рекомендует обновлять профиль, если он объявляется нежелательным для использования. Когда такое происходит, это означает, что разработчики больше не планируют его поддерживать. В приведенной ниже таблице можно быстро уточнить, какие профили поддерживаются в данный момент. </para>
<para>Переход на новый профиль придется осуществлять вручную. Необходимые действия могут сильно отличаться от выпуска к выпуску, в зависимости от глубины изменений, привносимых в новом профиле. </para>
<para>В простейшем случае, вам просто потребуется изменить символьную ссылку /etc/make.profile, а в худшем — придется перекомпилировать всю систему, тем временем изображая танец вуду. Процесс перехода обычно описывается в замечаниях к выпуску. Кроме того, есть инструкции в конце данного руководства. </para>
<para/>
<para>Поддерживаемые профили</para>
<para>Вы можете увидеть список профилей на Вашей архитектуре, официально поддерживаемой Gentoo когда установите утилиту eselect (emerge eselect) и затем выполните следующую команду:</para>
<para>Листинг 2.1 Просмотр поддерживаемых профилей</para>
<para># eselect profile list</para>
<para/></sect3><sect3><title>3. Инструкции по обновлению профилей</title>
<para/>
<para>Общие инструкции.</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Важно:  Удостоверьтесь в том, что Ваши портэжи обновлены перед выполнением любых изменений с профилями !</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Первое, выполните emerge eselect. Утилита eselect  позволяет Вам просматривать и выбирать профили без необходимости создания или удаления символических ссылок вручную.</para>
<para/>
<para>Листинг 3.1: Выбор профиля с помощью утилиты eselect</para>
<para>(Просмотр доступных профилей)</para>
<para># eselect profile list</para>
<para>(Выберите номер Вашего желаемого профиля из списка)</para>
<para># eselect profile set &lt;номер профиля&gt;</para>
<para/>
<para>Если Вы предпочитаете изменять профили вручную, тогда просто сделайте следующее:</para>
<para/>
<para/>
<para>Листинг 3.2  Изменение профилей вручную.</para>
<para># rm /etc/make.profile</para>
<para># ln -s ../usr/portage/profiles/&lt;выбранный профиль&gt; /etc/make.profile</para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Для большинства архитектур существуют два типа подпрофилей: desktop и server. Внимательно изучите эти профили, так как они могут удовлетворять Вашим нуждам лучше, чем чрезвычайно минимальные профили по умолчанию.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Обновление до 2007.0 или 2006.1</para>
<para>Если Вы намереваетесь обновиться до уровня этих профилей, то Вам следовало бы знать, что  они ожидают что по умолчанию в системе установлена локаль Unicode. Или более точно, должна быть определена  строка UNICODE="yes"  в файле /etc/rc.conf.  Для этоо Вы должны создать Unicode локаль для Вашей системы. Пожалуйста, прочитайте UTF-8 guide чтобы узнать как создать правильную локаль.</para>
<para>Альтернативно, если Вы не желаете устанавливать локаль, тогда Вы можете определить UNICODE="no" в файле  /etc/rc.conf. И переустановить (re-emerge) пакет  baselayout  (или ждите следующего обновления этого пакета) с USE флагом: -unicode. Вы можете установить -unicode только для baselayout или Вы  можете установить его глобально для всех пакетов, добавив Вашу переменную USE в файл </para>
<para>/etc/make.conf.</para>
<para>Листинг 3.3 Опционально: удаление поддержки Unicode.</para>
<para>(Для удаления поддержки Unicode только для baselayout)</para>
<para># echo "sys-apps/baselayout -unicode" &gt;&gt; /etc/portage/package.use</para>
<para># emerge -a baselayout</para>
<para/>
<para>(Для удаления поддержки Unicode для всей системы)</para>
<para># nano -w /etc/make.conf</para>
<para>USE="-unicode"</para>
<para># emerge -a baselayout</para>
<para/>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание:  Если Вы обновляетесь до 2007.0 на архитектуре SPARC, тогда вы должны следовать  <ulink url="http://www.gentoo.org/doc/en/gcc-upgrading.xml">GCC Upgrading Guide</ulink>
</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/></sect3></sect2></sect1><sect1><title>HOWTO Полное обновление системы</title>
<para>Ссылка на оригинал:</para>
<para>
<ulink url="http://ru.gentoo-wiki.com/HOWTO_Полное_обновление_системы">http://ru.gentoo-wiki.com/HOWTO_Полное_обновление_системы</ulink>
</para>
<para>С версии: 1.2</para><sect2><title/><sect3><title>Приведение в порядок /var/lib/portage/world </title>
<para/>
<para>В world должен быть список программ, которые нужно доустановить к тем, которые уже входят в "system" (т.е. в текущий профайл). </para>
<orderedlist>
<listitem>
<para>в world не должно быть никаких библиотек, и т.д., которые не нужны сами по себе, а нужны только для удовлетворения чьих-то зависимостей (чтобы не продолжать устанавливать/обновлять их, если они уже станут не нужны по какой-то причине) ;</para>
</listitem>
<listitem>
<para>программ, которые уже входят в "system", не должно быть в world </para>
</listitem>
<listitem>
<para>в world нельзя указывать определенную версию софта, это лучше делать в /etc/portage/package.mask ;</para>
</listitem>
<listitem>
<para>скрипт regenworld может помочь восстановить world путем анализа /var/log/emerge.log и генерации на его базе файла world (он перезапишет текущий world!) ;</para>
</listitem>
<listitem>
<para>скрипт dep -p -w (входящий в состав пакета udept) поможет найти избыточные записи в world(которые всё-равно нужны другим записям в world или входят в system);</para>
</listitem>
<listitem>
<para>перед серьёзными обновлениями желательно просмотреть /etc/portage/*, т.к. там могут быть уже не актуальные записи мешающие текущему обновлению. </para>
</listitem>
</orderedlist></sect3></sect2><sect2><title/><sect3><title>Обновление profile </title>
<orderedlist>
<listitem>
<para>Не каждый Gentoo release включает в себя новый profile (например, 2004.1 был без profile). </para>
</listitem>
<listitem>
<para>Даже если новый profile есть, то переходить на него не обязательно (если это будет обязательно, то старый профайл будет "протестующий" (deprecated) и emerge об этом должен будет громко кричать). </para>
</listitem>
<listitem>
<para>Инструкции по обновлению profile будут выкладываться здесь: <ulink url="http://www.gentoo.org/doc/ru/gentoo-upgrading.xml">http://www.gentoo.org/doc/ru/gentoo-upgrading.xml</ulink> и как правило сводиться к изменению симлинка /etc/make.profile </para>
</listitem>
</orderedlist></sect3></sect2><sect2><title/><sect3><title> USE-флаги </title>
<orderedlist>
<listitem>
<para>Запустить emerge -uDpv --newuse world и проверить что USE-флаги для всех пакетов выставлены корректно, и при необходимости скорректировать </para>
</listitem>
</orderedlist>
<para>USE-флаги выставляются в /etc/make.conf и /etc/portage/package.use </para></sect3></sect2><sect2><title/><sect3><title>Запуск обновления системы (если не нужно обновлять toolchain) </title>
<orderedlist>
<listitem>
<para>Если </para>
</listitem>
</orderedlist>
<para>        emerge -puDav --newuse world </para>
<para>показывает что будет обновляться пакет входящий в toolchain (linux-headers, glibc, binutils или gcc), то крайне рекомендуется полностью перекомпилировать всю систему - см. следующий пункт - а иначе можно вместо следующего пункта просто запустить: </para>
<para>        emerge -uDav --newuse world </para></sect3></sect2><sect2><title/><sect3><title>Некоторые причины не использовать emerge -U вместо -u </title>
<orderedlist>
<listitem>
<para>Причина 1: Проблемы со SLOT </para>
</listitem>
</orderedlist>
<para>Это, к примеру, происходит потому, что некоторые люди хотели gimp-2 вместо gimp-1.2. Представьте ситуацию, где gimp-1.2 помечен stable и находится в SLOT 1, gimp-2 помечен unstable и находится в SLOT 2. Теперь при выполнении ACCEPT_KEYWORDS=~x86 emerge gimp получите gimp-2. </para>
<para>Позже, когда вы посчитаете, что наступило время обновить свою систему чем-либо похожим на "emerge -U world", эта команда установит gimp-1.2, потому, что gimp находится в world-файле, и флаг "-U" не обрабатывает SLOT должным образом. </para>
<orderedlist>
<listitem>
<para>Причина 2: Проблемы, в случае удаления ebuild-ов с Portage-дерева. </para>
</listitem>
</orderedlist>
<para>Допустим, в Portage находятся 2 версии пакетов foo, foo-1.4 (помеченный как stable) и foo-1.6 (помеченный как unstable). Вы хотите вариант unstable и делаете emerge, как с вышеуказанным gimp. Позже обновляете world как было сказано выше, но в промежутке этого времени вышло критическое обновление для foo-1.6 - foo-1.6.1. Теперь появляется несколько возможностей обработки. </para>
<orderedlist>
<listitem>
<para>foo-1.6 был удален из Portage. Будет установлен foo-1.4, несмотря на "снижение" версии вместо флага "-U" </para>
</listitem>
<listitem>
<para>Ситуация будет еще хуже, если foo-1.6 не был удалён из Portage по какой-либо причине: foo-1.6 (тот, что с критической уязвимостью) будет оставаться на вашей системе до тех пор, пока не будет помечено stable что-либо выше чем foo-1.6. </para>
</listitem>
</orderedlist>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: Не рекомендуется использовать ACCEPT_KEYWORDS=~x86 emerge foo о чем можно почитать здесь http://www.gentoo.org/doc/ru/gentoo-amd64-faq.xml#keyword </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3></sect2><sect2><title/><sect3><title>Обновление одного из пакетов входящих в toolchain </title>
<orderedlist>
<listitem>
<para>Если обновляется хотя-бы один из linux-headers, glibc, binutils или gcc, то рекомендуется пересобрать их дважды, после чего весь system, после чего весь world. </para>
</listitem>
</orderedlist>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Цель двойной компиляции toolchain - получить гарантированно стабильный и корректный toolchain не зависящий от предыдущего. Перекомпилировать system/world после этого жёсткой необходимости нет, по крайней мере если остальной софт продолжает работать (возможно даже используя библиотеки из старого toolchain - см. предыдущие пункты об апгрейде). </para>
<para>Цель перекомпиляции system/world - чтобы весь софт получил потенциальное преимущество от установки нового toolchain. system перекомпилируется перед world из тех-же соображений, т.к. при компиляции программ из world используются утилиты из system. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<orderedlist>
<listitem>
<para>Если увеличивается первая или вторая цифра версии gcc, то перед второй сборкой нужно переключиться на новую версию через gcc-config - иначе новый gcc просто установится параллельно со старым в "новый слот", но по умолчанию использоваться будет старый. </para>
</listitem>
<listitem>
<para>При сборке system после двойной перекомпиляции toolchain нет необходимости опять компилировать toolchain как часть system. Аналогично при сборке world после system нет небходимости опять компилировать пакеты из system как часть world. Это можно попробовать обойти либо вручную, либо используя скрипты <ulink url="http://forums.gentoo.org/viewtopic.php?t=282474">[1]</ulink>, либо через бинарные пакеты и `emerge -k` (я предпочитаю последний вариант). </para>
</listitem>
<listitem>
<para>Итак, рекомендованный набор команд: </para>
</listitem>
</orderedlist>
<para/>
<para>Листинг 1. Рекомендованный набор команд</para>
<para># для того, чтобы безопасно использовать `emerge -k` нужно очистить</para>
<para># каталог с текущими бинарными пакетами</para>
<para># (напр., переместить его в /tmp/portage-packages)</para>
<para/>
<para>pkgdir=$(portageq pkgdir)</para>
<para>mv $pkgdir /tmp/portage-packages1</para>
<para>install -d -o portage -g portage $pkgdir</para>
<para/>
<para># первая сборка toolchain</para>
<para>emerge linux-headers glibc binutils gcc-config gcc</para>
<para/>
<para># выбрать новый gcc если он установился в новый слот</para>
<para>gcc-config имя_или_номер_нового_gcc</para>
<para># см. `gcc-config -l`</para>
<para>source /etc/profile</para>
<para/>
<para># компиляция toolchain с созданием бинарных пакетов</para>
<para>emerge -b glibc binutils gcc portage</para>
<para/>
<para># не компилить glibc, binutils и gcc</para>
<para>emerge -bke system </para>
<para/>
<para># не компилить предыдущие пакеты (включая system)</para>
<para>emerge -bke world</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Чисто теоретически существует пакет binutils-config, который когда-нибудь может потребоваться использовать аналогично gcc-config. </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3></sect2><sect2><title/><sect3><title>Обновление безопасности. </title>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Даже после `emerge -uDav --newuse world` в системе могут оставаться устаревшие пакеты с дырами в безопасности - в слотах! </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>glsa-check -l | grep '\[N\]'</para>
<para>emerge ... # если нужно</para></sect3></sect2><sect2><title/><sect3><title> Удаление неиспользуемых пакетов. </title>
<para>После обновления системы в ней могут оказаться пакеты, которые никто не использует. Эти пакеты желательно удалить, т.к. они не будут в дальнейшем обновляться при `emerge -uDav --newuse world`. </para>
<para>emerge -a depclean # очень осторожно!!!</para>
<orderedlist>
<listitem>
<para>После обновления библиотек может потребоваться перекомпилировать программы, которые эти библиотеки используют: </para>
</listitem>
</orderedlist>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Для glsa-check, revdep-rebuild необходимо установить пакет gentoolkit </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>rm /root/.revdep-rebuild*.?_*</para>
<para>revdep-rebuild -p</para>
<para>revdep-rebuild</para></sect3></sect2><sect2><title/><sect3><title> Обновление конфигов. </title>
<para>dispatch-conf</para>
<orderedlist>
<listitem>
<para>Если используется runit-init и обновлялся пакет baselayout, то нужно восстановить /sbin/init: </para>
</listitem>
</orderedlist>
<para>ls -l /sbin/*init*</para>
<para>if (/sbin/init это бинарник, а не симлинк) {</para>
<para>mv /sbin/init /sbin/init-sysv</para>
<para>ln -s runit-init /sbin/init</para>
<para>}</para>
<orderedlist>
<listitem>
<para>Отслеживание важных сообщений при установке пакетов. </para>
</listitem>
</orderedlist>
<para>В процессе emerge world выдаётся очень много сообщений, причём важные комментарии перемешаны с командами компиляции, и отследить их при сборке нескольких пакетов одновременно невозможно. </para>
<para>Но все эти сообщения можно получить из log-файлов после окончания установки emerge world. Для этого нужно использовать либо enotice, либо portlog-info. </para>
<para/></sect3></sect2><sect2><title>Руководство Gentoo Linux по обновлению GCC</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/gcc-upgrading.xml">http://www.gentoo.org/doc/ru/gcc-upgrading.xml</ulink>
</para>
<para>С версии: 1.0</para><sect3><title>1. Введение</title>
<para/>
<para>Обновление GCC</para>
<para/>
<para>Зачем нужно обновлять? Ну, GCC довольно похож на любой другой пакет в вашей системе, но чуточку более важен. GCC следует обновлять всякий раз, когда в новой версии исправляются какие-нибудь раздражающие вас ошибки, добавляется новые нужные функции, или если вы хотите держать свою систему обновленной. Если ни один из этих случаев к вам не относится, обновление можно спокойно откладывать, пока ваша версия GCC поддерживается разработчиками Gentoo. </para>
<para/>
<para>Если вы устанавливаете новую версию GCC, система не переключается на ее использование автоматически. Вам необходимо явно запросить изменение, потому что в процессе перехода может потребоваться несколько дополнительных шагов. Если вы решите не переключаться, система Portage продолжит использовать более старую версию компилятора, пока вы не передумаете или пока не удалите старый компилятор из своей системы. </para>
<para/>
<para>В этом руководстве описываются необходимые шаги, нужные для полноценного обновления компилятора, используемого вашей системой Gentoo. Отдельный раздел посвящен переходу с GCC 3.3 на 3.4 или более новые версии и проблемам с libstdc++. Другой частный раздел предназначен пользователям, впервые устанавливающим Gentoo из архива третьей стадии (stage3), после выхода новой версии GCC. </para>
<para>Примечание: Необходимо заметить, что обновление с GCC-3.4 до GCC-4.0 или более нового не требует существенных изменений от пользователя, так как GCC-3.4 и GCC-4.0 используют одинаковый двоичный прикладной интерфейс (ABI). Все что нужно, это использовать gcc-config, чтобы выбрать желаемый компилятор. </para>
<para/>
<para/></sect3><sect3><title>2. Общие указания по обновлению</title>
<para/>
<para>Введение</para>
<para/>
<para>Важно: Если вы ищете подробные указания по обновлению с GCC-3.3 на GCC-3.4 или более новый, обратитесь к соответствующему разделу. </para>
<para/>
<para/>
<para>Важно: Если вы ищете подробные указания по обновлению GCC на вновь установленных системах, обратитесь к соответствующему разделу. </para>
<para/>
<para/>
<para>Вообще говоря, переход на версии с исправленными ошибками (bugfix release), как с 3.3.5 на 3.3.6, должен быть довольно безопасен: надо только установить новую версию, переключиться на нее и пересобрать единственный затрагиваемый пакет — libtool. Однако, при некоторых обновлениях GCC нарушается двоичная совместимость, в таких случаях может потребоваться пересборка не только затрагиваемых пакетов, но и даже всего системного набора и пакетов, необходимых для компиляции. </para>
<para/>
<para>Говоря о необходимости ручного переключения на новую версию компилятора, мы сказали, что оно не происходит автоматически. Тем не менее, есть одно исключение — переход на версию с исправленными ошибками (как с 3.3.5 на 3.3.6), если не используется режим «multislot», позволяющий обеим версиям сосуществовать в одной системе. По умолчанию этот режим выключен, ведь большинству пользователей он ничего не даcт. </para>
<para/>
<para>Листинг 2.1: Обновление GCC</para>
<para># emerge -uav gcc</para>
<para/>
<para>(Вместо "i686-pc-linux-gnu-3.4.5" укажите обновленную</para>
<para> версию GCC и настройки CHOST)</para>
<para># gcc-config i686-pc-linux-gnu-3.4.5</para>
<para># source /etc/profile</para>
<para/>
<para>(Пересборка libtool)</para>
<para># emerge --oneshot -av libtool</para>
<para/>
<para/>
<para>Теперь пересоберите набор программ для компиляции, затем world, используя новый компилятор. </para>
<para/>
<para>Листинг 2.2: Пересборка системы</para>
<para># emerge -eav system</para>
<para># emerge -eav world</para>
<para/>
<para/>
<para>Теперь можно без опасений удалить старую версию GCC. Если вы чувствуете такую необходимость, введите следующую команду (как обычно, вместо =sys-devel/gcc-3.3* укажите версию, которую собираетесь удалить): </para>
<para/>
<para>Листинг 2.3: Удаление более старой версии GCC</para>
<para># emerge -aC =sys-devel/gcc-3.3*</para>
<para/>
<para/></sect3><sect3><title>3. Переход с GCC-3.3 на 3.4 или более новый</title>
<para/>
<para>Введение</para>
<para/>
<para>Переход с GCC-3.3 на 3.4 или более новую версию не так гладок, ведь между этими версиями изменился двоичный прикладной интерфейс C++ (ABI). Также придется позаботиться о существующей проблеме с библиотекой libstdc++. </para>
<para/>
<para>Варианты</para>
<para/>
<para>Важно: Если вы обновляете GCC на машине SPARC, вам придется выбрать путь полной пересборки системы из-за некоторых внутренних изменений двоичного интерфейса (ABI) GCC в области передачи параметров функций. </para>
<para/>
<para/>
<para>У вас есть два варианта обновления системы. Первый способ быстрее и требует использования программы revdep-rebuild из пакета gentoolkit, а во втором вся система пересобирается с нуля, чтобы задействовать новые возможности GCC. Ваше дело, какой из способов выбрать. В большинстве случаев первого способа достаточно. </para>
<para/>
<para>Использование revdep-rebuild</para>
<para/>
<para>Если вы выбрали этот способ, нужно сначала установить gentoolkit, если вы еще этого не сделали. Затем обновите GCC и переключите систему на новый компилятор. Также пересоберите пакет libtool, чтобы обеспечить пригодность программ для компиляции. </para>
<para/>
<para>Листинг 3.1: Установка gentoolkit и обновление GCC</para>
<para># emerge -an gentoolkit</para>
<para># emerge -uav gcc</para>
<para>(вместо "i686-pc-linux-gnu-3.4.5" укажите обновленную</para>
<para> версию GCC и настройки CHOST)</para>
<para># gcc-config i686-pc-linux-gnu-3.4.5</para>
<para># source /etc/profile</para>
<para/>
<para>(пересборка libtool)</para>
<para># emerge --oneshot -av libtool</para>
<para/>
<para/>
<para>Теперь посмотрите, какие пакеты собирается пересобирать revdep-rebuild. Затем запустите revdep-rebuild на собственно пересборку. Это займет некоторое время, так что потерпите. </para>
<para/>
<para>Листинг 3.2: Использование revdep-rebuild</para>
<para># revdep-rebuild --library libstdc++.so.5 -- -p -v</para>
<para># revdep-rebuild --library libstdc++.so.5</para>
<para/>
<para>Примечание: Возможно, у вас появятся проблемы с несуществующими версиями пакетов из-за того, что они устарели или замаскированы. В этом случае можно при запуске revdep-rebuild указать параметр --package-names. Это заставит пакеты пересобираться, основываясь на именах пакетов, вместо точного имени и версии. </para>
<para/>
<para/>
<para>Для обеспечения совместимости с более старыми двоичными приложениями C++ и любыми пакетами, которые revdep-rebuild мог пропустить, надо установить пакет sys-libs/libstdc++-v3 до того, как удалять GCC 3.3 из своей системы. </para>
<para/>
<para>Листинг 3.3: Установка libstdc++-v3 и удаление GCC</para>
<para># emerge --oneshot sys-libs/libstdc++-v3</para>
<para># emerge -aC =sys-devel/gcc-3.3*</para>
<para/>
<para/>
<para>Использование emerge -e</para>
<para/>
<para>Этот гораздо более медленный способ пересобирает всю систему, гарантируя, что все пересобирается новым компилятором, и, таким образом, он безопаснее. Сперва потребуется обновить GCC и libtool, и переключить систему на новый компилятор. </para>
<para/>
<para>Листинг 3.4: Обновление GCC</para>
<para># emerge -uav gcc</para>
<para>(вместо "i686-pc-linux-gnu-3.4.5" укажите обновленную</para>
<para> версию GCC и настройки CHOST)</para>
<para># gcc-config i686-pc-linux-gnu-3.4.5</para>
<para># source /etc/profile</para>
<para/>
<para>(пересборка libtool)</para>
<para># emerge --oneshot -av libtool</para>
<para/>
<para/>
<para>Для обеспечения совместимости с более старыми двоичными приложениями C++, надо установить в систему пакет sys-libs/libstdc++-v3. </para>
<para/>
<para>Листинг 3.5: Установка libstdc++-v3</para>
<para># emerge --oneshot sys-libs/libstdc++-v3</para>
<para/>
<para/>
<para>Теперь займемся пересборкой сначала пакетов system, а затем world. Это займет очень длительное время, зависящее от количества установленных пакетов: ведь будут пересобираться все средства компиляции и поддерживающие системные файлы, а затем каждый пакет, находящийся в вашей системе. Это необходимо, чтобы все пакеты были гарантированно скомпилированы уже с новыми средствами компиляции, включая сами эти средства. </para>
<para/>
<para>Листинг 3.6: Пересборка system и world</para>
<para># emerge -e system</para>
<para># emerge -e world</para>
<para/>
<para/>
<para>Теперь можно удалить старые версии GCC, не вызывая проблем: </para>
<para/>
<para>Листинг 3.7: Очистка</para>
<para># emerge -aC =sys-devel/gcc-3.3*</para>
<para/>
<para/></sect3><sect3><title>4. Обновление GCC на новой установке</title>
<para/>
<para>Введение</para>
<para/>
<para>Обновление GCC в системе после установки из архива третьей стадии (stage3)  — дело простое. Отсутствие изобилия установленных программ, которые ссылаются на старую версию GCC — это преимущество пользователей, только что установивших систему. В следующем примере показывается обновление с GCC-3.3 на 3.4 или более новые версии. При обновлении с других версий GCC будут кое-какие отличия. Например, имена библиотек, используемые ниже для revdep-rebuild, относятся к версии GCC 3.3, также, как и необходимость установки libstdc++-v3. </para>
<para/>
<para>Пока пользователь не внес каких-либо изменений в систему, для получения системы с новой версией GCC нужно всего несколько шагов. Также, как и при обновлении с GCC-3.3 до 3.4, у пользователя есть две возможности. Но, в отличие от обновления с GCC-3.3 до 3.4, здесь обновление проще, так как различий между способами меньше. Первый способ быстрее, и задействует программу revdep-rebuild из пакета gentoolkit, подобно вышеописанной процедуре обновления. Использование revdep-rebuild предполагает пересборку только тех пакетов, которые действительно ссылаются на библиотеки GCC, тогда как при втором способе система полностью перекомпилируется с новой версией GCC, что занимает намного больше времени. Второй способ никогда не потребуется, и описан только для полноты картины. </para>
<para/>
<para>Приведенные первые шаги одинаковы для обоих способов, и должны делаться в любом случае. </para>
<para/>
<para>Листинг 4.1: Обновление GCC</para>
<para># emerge -uav gcc</para>
<para>(вместо "i686-pc-linux-gnu-3.4.5" укажите обновленную</para>
<para> версию GCC и настройки CHOST)</para>
<para># gcc-config i686-pc-linux-gnu-3.4.5</para>
<para># source /etc/profile</para>
<para/>
<para>(пересборка libtool)</para>
<para># emerge --oneshot -av libtool</para>
<para/>
<para/>
<para>Для обеспечения совместимости с более старыми двоичными приложениями C++, надо установить в систему пакет sys-libs/libstdc++-v3. </para>
<para/>
<para>Листинг 4.2: Установка libstdc++-v3</para>
<para># emerge --oneshot sys-libs/libstdc++-v3</para>
<para/>
<para/>
<para>Использование revdep-rebuild</para>
<para/>
<para>Этот способ требует, чтобы вы сначала установили пакет gentoolkit, если это еще не сделано. Затем запустите программу revdep-rebuild, чтобы просканировать установленные пакеты, найти и пересобрать нужные. </para>
<para/>
<para>Листинг 4.3: Установка gentoolkit и запуск revdep-rebuild</para>
<para># emerge -an gentoolkit</para>
<para># revdep-rebuild --library libstdc++.so.5 -- -p -v</para>
<para># revdep-rebuild --library libstdc++.so.5</para>
<para/>
<para>Примечание: Возможно, у вас появятся проблемы с несуществующими версиями пакетов из-за того, что они устарели или замаскированы. В этом случае можно при запуске revdep-rebuild указать параметр --package-names. Это заставит пакеты пересобираться, основываясь на именах пакетов, вместо точного имени и версии. </para>
<para/>
<para/>
<para>Использование emerge -e</para>
<para/>
<para>Этот способ, будучи гораздо медленнее, пересобирает всю систему, гарантируя, что все пересобрано новым компилятором. Это необязательно, но допустимо, если вы также изменяете переменную среды CFLAGS или другие переменные make.conf, которые влияют на компиляцию системы. </para>
<para/>
<para>Так как эти действия выполняются сразу после первоначальной установки, не потребуется перекомпилировать world, как мы поступили бы для обновления компилятора в ранее установленной системе. Однако, для пущей уверенности в том, что обновлены все пакеты, можно запустить обновление цели world вместо system. </para>
<para/>
<para>Листинг 4.4: Пересборка system</para>
<para># emerge -e system</para>
<para/>
<para/>
<para>Очистка</para>
<para/>
<para>Теперь можно удалить старые версии GCC, не вызывая проблем. Выражение ВАША-НОВАЯ-ВЕРСИЯ-GCC замените номером версии, на которую вы перешли: </para>
<para/>
<para>Листинг 4.5: Очистка</para>
<para># emerge -aC "&lt;sys-devel/gcc-ВАША-НОВАЯ-ВЕРСИЯ-GCC"</para>
<para/>
<para/></sect3><sect3><title>5. Обычные грабли</title>
<para/>
<para>Важно на время обновления отключить distcc. Смешение версий компилятора на разных узлах вызовет проблемы при сборке. Это не относится к ccache, так как объекты кэша будут в любом случае сделаны недействительными. </para>
<para/>
<para>Всегда используйте одну и ту же версию GCC для своего ядра и дополнительных модулей ядра. Как только вы пересоберете world с новым GCC, внешние модули (например, app-emulation/qemu-softmmu) не смогут загрузиться. Пожалуйста, чтобы это исправить, пересоберите свое ядро новой версией GCC. </para>
<para/>
<para>Если вы обновляете GCC на машине SPARC, обязательно еще раз запустите silo -f после пересборки world, чтобы избежать возможных проблем. </para>
<para/>
<para>Распространенные сообщения об ошибках</para>
<para/>
<para>Если ваша система жалуется на что-то вроде libtool: link: `/usr/lib/gcc-lib/i686-pc-linux-gnu/3.3.6/libstdc++.la' is not a valid libtool archive, запустите /sbin/fix_libtool_files.sh 3.3.6 (замените «3.3.6» на номер версии из сообщения об ошибке). </para>
<para/>
<para>Если вы увидели error: /usr/bin/gcc-config: line 632: /etc/env.d/gcc/i686-pc-linux-gnu-3.3.5: No such file or directory, тогда попробуйте удалить /etc/env.d/gcc/config-i686-pc-linux-gnu и снова запустить gcc-config, следом указав source /etc/profile. Делайте это только тогда, когда у вас не настроены никакие кросс-компиляторы. </para>
<para/>
<para>Если при emerge -e system или emerge -e world не собирается пакет, выполнение можно продолжить командой emerge --resume. Если ошибка появляется снова и снова, пропустите пакет, указав emerge --resume --skipfirst. Не запускайте параллельно другие экземпляры emerge, чтобы не потерять информацию, нужную для возобновления. </para>
<para/>
<para>Если во время обновления компиляторв встретится ошибка spec failure: unrecognized spec option, попробуйте откатиться на свой компилятор по умолчанию, убрать переменную GCC_SPECS и снова обновить компилятор: </para>
<para/>
<para>Листинг 5.1: Восстановление первичной настройки компилятора</para>
<para># gcc-config 1</para>
<para># source /etc/profile</para>
<para># unset GCC_SPECS</para>
<para># emerge -uav gcc</para>
<para/></sect3></sect2></sect1><sect1><title>Gentoo и  X.Org</title>
<para/><sect2><title>Описание настройки МОНОЛИТНОГО X-сервера версий 6.X</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/xorg-config.xml">http://www.gentoo.org/doc/ru/xorg-config.xml</ulink>
</para>
<para>Дата: 13.06.07</para>
<para>С версии: 1.0</para>
<para/><sect3><title>1. Что такое X Window Server?</title>
<para/>
<para>Графический интерфейс против командной строки</para>
<para/>
<para>Обычного пользователя могут испугать мысли о необходимости печатать в командной строке. Почему бы ему не прокладывать свой путь на территории свободы выбора Gentoo (и Linux вообще), просто «водя мышкой»? Ну, *большая улыбка*, конечно, вы сможете это сделать :-). В Linux предлагается широкое разнообразие пользовательских интерфейсов и сред, которые можно установить поверх установленной у вас системы. </para>
<para/>
<para>Это один из самых больших сюрпризов, с которым сталкиваются новички: графический интерфейс пользователя — это всего лишь прикладная программа, выполняемая в системе. Он не является частью ядра Linux или каких-либо других компонентов системы. Это — мощный инструмент, позволяющий полностью задействовать графические возможности вашего компьютера. </para>
<para/>
<para>Так как стандартизация очень важна, для организации прорисовки и перемещения окон по экрану, взаимодействия пользователя с мышью и клавиатурой, а также других важных базовых аспектов, был создан стандарт под названием X Window System, сокращённо X11 или просто X. Он используется в Unix, Linux и других Unix-подобных операционных системах во всем мире. </para>
<para/>
<para>Приложение, которое дает пользователям Linux возможность запускать графические интерфейсы пользователя и использует стандарт X11, называется Xorg-X11, ответвление проекта XFree86. Проектом XFree86 было решено использовать лицензию, возможно, несовместимую с лицензией GPL, поэтому рекомендуется использовать Xorg. Пакет XFree86 больше не поддерживается в официальном дереве портежей. </para>
<para/>
<para>Проект X.org</para>
<para/>
<para>Проектом X.org создана и поддерживается бесплатно распространяемая реализация системы X11 с открытым исходным кодом. Это открытая инфраструктура рабочей станции, основанная на X11. </para>
<para/>
<para>Xorg обеспечивает интерфейс между устройствами вашего компьютера и нужными вам графическими программами. Кроме того, Xorg является полностью сетевым, то есть вы можете запускать программу на одной системе, а отображать ее — на другой. </para>
<para/></sect3><sect3><title>2. Установка Xorg</title>
<para/>
<para>Использование emerge</para>
<para/>
<para>Хватит болтовни, не перейти ли нам к делу? Чтобы установить Xorg, вам просто нужно запустить emerge xorg-x11. Установка Xorg займёт достаточно времени, так что вы можете перекусить, дожидаясь ее завершения. </para>
<para/>
<para>Перед тем, как установить Xorg, в файле /etc/make.conf вам понадобится настроить две очень важные переменные. </para>
<para/>
<para>Первая из них — VIDEO_CARDS, которая используется для выбора драйвера для используемой вами видеокарты, и связана с ее типом и маркой. Одним из распространенных значений является nvidia для карт nVidia или fglrx для карт ATI Radeon. Это — закрытые драйверы, предоставленные nVidia и ATI. Если вы хотите использовать версии с отрытым исходным кодом, используйте nv вместо nvidia, но помните, эта версия не обеспечивает 3D-ускорение. Аналогично, используйте radeon для видеокарт от ATI. В VIDEO_CARDS можно указывать несколько драйверов, разделенных пробелами. </para>
<para/>
<para>Вторая переменная, INPUT_DEVICES, используется для указания драйверов устройств ввода. В большинстве случаев связки keyboard mouse достаточно. </para>
<para/>
<para>Теперь нужно решить, какие драйверы использовать, и добавить нужные параметры в файл /etc/make.conf: </para>
<para/>
<para>Листинг 2.1: Пример строк в make.conf</para>
<para>(для поддержки мыши и клавиатуры)</para>
<para>INPUT_DEVICES="keyboard mouse"</para>
<para>(для видеокарт nVidia)</para>
<para>VIDEO_CARDS="nvidia"</para>
<para>(ИЛИ для видеокарт ATI Radeon)</para>
<para>VIDEO_CARDS="fglrx"</para>
<para/>
<para/>
<para>Дополнительные сведения по настройке карт nVidia и ATI находятся в руководстве по видеокартам nVidia в Gentoo Linux и Gentoo Linux ATI FAQ. Если вы не знаете, какие драйверы выбрать, ознакомьтесь с этими руководствами. </para>
<para>Примечание: Если у вас рекомендуемые настройки не работают, следует запустить emerge -pv xorg-x11, проверить все доступные параметры и указать соответствующие вашей системе. Для различных версий Xorg на различных архитектурах эти переменные могут выводиться командой emerge -pv xorg-server вместо приведенной выше. Например, для архитектуры x86 и xorg-x11-7.0: </para>
<para/>
<para/>
<para>Листинг 2.2: Просмотр всех доступных параметров драйверов</para>
<para># emerge -pv xorg-x11</para>
<para/>
<para>These are the packages that would be merged, in order:</para>
<para/>
<para>Calculating dependencies... done!</para>
<para>[ebuild   R   ] x11-base/xorg-x11-7.0-r1  USE="-3dfx" INPUT_DEVICES="keyboard</para>
<para>mouse -acecad -aiptek -calcomp -citron -digitaledge -dmc -dynapro -elo2300</para>
<para>-elographics -evdev -fpit -hyperpen -jamstudio -joystick -magellan -magictouch</para>
<para>-microtouch -mutouch -palmax -penmount -spaceorb -summa -synaptics -tek4957</para>
<para>-ur98 -vmmouse -void -wacom" VIDEO_CARDS="nvidia -apm -ark -chips -cirrus -cyrix</para>
<para>-dummy -fbdev -fglrx -glint -i128 -i740 -i810 -imstt -mach64 -mga -neomagic -nsc</para>
<para>-nv -r128 -radeon -rendition -s3 -s3virge -savage -siliconmotion -sis -sisusb</para>
<para>-tdfx -tga -trident -tseng -v4l -vesa -vga -via -vmware -voodoo" 0 kB</para>
<para/>
<para/>
<para>После установки всех необходимых переменных можно перейти к установке пакета Xorg. </para>
<para/>
<para>Листинг 2.3: Установка Xorg</para>
<para># emerge xorg-x11</para>
<para/>
<para/>
<para>После завершения установки, чтобы продолжить, вам наверняка придётся обновить некоторые переменные среды. Для установки значений просто запустите env-update, а затем — source /etc/profile. </para>
<para/>
<para/>
<para/>
<para>Листинг 2.4: Обновление переменных среды</para>
<para># env-update</para>
<para># source /etc/profile</para>
<para/>
<para/></sect3><sect3><title>3. Настройка Xorg</title>
<para/>
<para>Файл xorg.conf</para>
<para/>
<para>Конфигурационный файл Xorg называется xorg.conf и находится в папке /etc/X11. В пакет Xorg-X11 входит его пример под названием /etc/X11/xorg.conf.example, который можно использовать при создании своей собственной конфигурации. Он подробно прокомментирован, но если вы нуждаетесь в подробном описании синтаксиса, не стесняйтесь обратиться к страницам справки: </para>
<para/>
<para>Листинг 3.1: Чтение страницы справки xorg.conf</para>
<para># man 5 xorg.conf</para>
<para/>
<para/>
<para>Счастливого чтения всем желающим. Мы, конечно же, не из их числа, поэтому перейдем к выяснению, как можно создать файл автоматически. </para>
<para/>
<para>По умолчанию: автоматическая генерация xorg.conf</para>
<para/>
<para>Xorg способен самостоятельно подобрать большинство параметров за вас. Скорее всего, вам потребуется всего лишь изменить несколько строк, чтобы установить желаемое разрешение экрана. Если вы заинтересованы в более глубокой настройке, обязательно просмотрите ресурсы, указанные в конце этой главы. Но сначала давайте создадим (надеемся, работающий) конфигурационный файл Xorg. </para>
<para/>
<para>Листинг 3.2: Генерация файла xorg.conf</para>
<para># Xorg -configure</para>
<para/>
<para/>
<para>Обязательно прочтите последние строки, выводимые после завершения опроса оборудования Xorg. Если вы увидите, что где-то Xorg не удалось правильно опознать устройства, то вам придётся править файл xorg.conf вручную. Если же всё прошло гладко, Xorg должен сообщить вам, что создан файл и готов для тестирования файл /root/xorg.conf.new. Давайте его испытаем :) </para>
<para/>
<para>Листинг 3.3: Тестирование файла xorg.conf.new</para>
<para># X -config /root/xorg.conf.new</para>
<para/>
<para/>
<para>Если всё в порядке, вы увидите чёрно-белый узор. Проверьте, работает ли мышь, и подходит ли разрешение экрана. Вы вряд ли точно угадаете разрешение, но всё же заметите слишком низкое. Выйти можно в любой момент, нажав комбинацию клавиш Ctrl+Alt+Backspace. </para>
<para/>
<para>Альтернатива: полуавтоматическая генерация xorg.conf</para>
<para/>
<para>В Xorg есть утилита xorgconfig, задающая различные вопросы о вашей системе (о графическом адаптере, клавиатуре и т.п.). Основываясь на ваших ответах, она создаст файл xorg.conf. </para>
<para/>
<para>Листинг 3.4: Полуавтоматическая генерация xorg.conf</para>
<para># xorgconfig</para>
<para/>
<para/>
<para>Другая утилита, также входящая в пакет Xorg — xorgcfg, которая сначала пытается выполнить Xorg -configure, а затем запускает X-сервер для более тонкой настройки. </para>
<para/>
<para>Листинг 3.5: Использование xorgcfg</para>
<para># xorgcfg</para>
<para>(если X даст сбой, или настройка завершится неудачей, попробуйте:)</para>
<para># xorgcfg -textmode</para>
<para/>
<para/>
<para>Копирование в xorg.conf</para>
<para/>
<para>Теперь давайте скопируем xorg.conf.new в /etc/X11/xorg.conf, чтобы не приходилось постоянно запускать Xorg -config: набирать просто X или startx гораздо легче :) </para>
<para/>
<para>Листинг 3.6: Копирование поверх xorg.conf</para>
<para># cp /root/xorg.conf.new /etc/X11/xorg.conf</para>
<para/>
<para/>
<para>Использование startx</para>
<para/>
<para>Теперь попробуйте ввести startx, чтобы запустить свой X-сервер. startx — это сценарий, запускающий сеанс X, то есть серверы X, а поверх них — некоторые графические приложения. Он решает, какие приложения запустить, исходя из следующей логики: </para>
<para>если в домашнем каталоге есть файл с именем .xinitrc, то выполняются команды, перечисленные в нём </para>
<para>в противном случае считывается значение переменной XSESSION и запускается один из указанных в /etc/X11/Sessions/ сеансов (указать значение XSESSION по умолчанию, для всех пользователей системы, можно в файле /etc/rc.conf) </para>
<para>если вышеуказанное завершилось неудачей, производится откат к простейшему диспетчеру окон, обычно twm. </para>
<para/>
<para>Листинг 3.7: Запуск X</para>
<para># startx</para>
<para/>
<para>Если вы увидели уродливый, отвратительный, омерзительный, безобразный диспетчер окон, то это — twm. Чтобы завершить сеанс twm, наберите exit или нажмите Ctrl-D в одном из терминалов xterm. «убить» сеанс X также можно, нажав комбинацию клавиш Ctrl+Alt+Backspace, чтобы «выгнать его с позором» — наверно, такой вариант годится не всегда. Хотя это не причинит тяжёлого вреда :) </para>
<para/></sect3><sect3><title>4. Настройка xorg.conf</title>
<para/>
<para>Установка разрешения экрана</para>
<para/>
<para>Если вы чувствуете, что разрешение экрана неподходящее, вам потребуется проверить два раздела конфигурации. Прежде всего, разделе Screen, где перечисляются варианты разрешения экрана, с которыми может запускаться X-сервер. По умолчанию в этом разделе может вообще не быть никаких строк о разрешении экрана. В таком случае Xorg оценивает допустимое разрешение на основе данных из другого раздела: Monitor. </para>
<para/>
<para>При этом Xorg для вычисления правильных вариантов разрешения использует значения HorizSync (частота строк) и VertRefresh (частота кадров) из раздела Monitor. Пока что оставьте эти параметры как есть. Лишь в том случае, когда изменения в разделе Screen (которые мы опишем чуть ниже) не помогают, вам придется заглянуть в технические характеристики своего монитора и указать правильные значения. Также можно воспользоваться программой, определяющей технические характеристики вашего монитора, например, sys-apps/ddcxinfo-knoppix. </para>
<para/>
<para>Предупреждение: Не меняйте «просто так» значения этих двух относящихся к монитору переменных, не сверившись с техническими характеристиками своего монитора. Неправильные значения могут привести в лучшем случае к срыву синхронизации, а в худшем случае — к сгоревшему монитору. </para>
<para/>
<para>Теперь давайте поменяем значения разрешения. В следующем примере, взятом из /etc/X11/xorg.conf, мы добавим строчки Modes (режимы) и DefaultDepth (цветность), чтобы X-сервер по умолчанию запускался в режиме 24 бит при 1024x768 разрешении экрана. Особо не обращайте внимания на значения — это просто пример и, скорее всего, они будут отличаться от настроек вашей системы. </para>
<para/>
<para>Листинг 4.1: Изменение раздела Screen /etc/X11/xorg.conf</para>
<para>Section "Screen"</para>
<para>  Identifier  "Default Screen"</para>
<para>  Device    "S3 Inc. ProSavage KN133 [Twister K]"</para>
<para>  Monitor   "Generic Monitor"</para>
<para>  DefaultDepth  24</para>
<para>  # несколько строк пропущены для наглядности</para>
<para>  SubSection "Display"</para>
<para>    Depth   24</para>
<para>    Modes   "1024x768"</para>
<para>  EndSubSection</para>
<para>EndSection</para>
<para/>
<para/>
<para>Запустите X (startx), чтобы обнаружить, что сервер использует желаемое разрешение :) </para>
<para/>
<para>Настройка клавиатуры</para>
<para/>
<para>Чтобы настроить X на использование национальных раскладок, найдите раздел InputDevice (устройство ввода), определяющий настройки клавиатуры, и добавьте параметр XkbLayout с указанием необходимой раскладки. Для примера, покажем, как добавить бельгийскую раскладку. Просто измените код страны на свой: </para>
<para/>
<para>Листинг 4.2: Changing the keyboard layout</para>
<para>Section "InputDevice"</para>
<para>  Identifier  "Generic Keyboard"</para>
<para>  Driver    "keyboard"</para>
<para>  Option    "CoreKeyboard"</para>
<para>  Option    "XkbRules"  "xorg"</para>
<para>  Option    "XkbModel"  "pc105"</para>
<para>  Option    "XkbLayout" "be"</para>
<para>EndSection</para>
<para/>
<para/>
<para>Настройка мыши</para>
<para/>
<para>Если ваша мышь не работает, сначала придётся выяснить, обнаружена ли она вообще ядром. Мыши (в качестве устройств) выглядят как /dev/input/mouse0 (или /dev/input/mice, если вы хотите использовать несколько мышек). В некоторых случаях используется название /dev/psaux. В любом случае, вы можете убедиться, что устройство соответствует вашей мыши, просмотрев вывод соответствующего файла устройства, одновременно передвигая мышь. В большинстве случаев на экране должна появиться бессмыслица. Для остановки вывода нажимайте Ctrl-C. </para>
<para/>
<para>Листинг 4.3: Проверка файла устройства</para>
<para># cat /dev/input/mouse0</para>
<para>(не забудьте нажать Ctrl-C для завершения)</para>
<para/>
<para>Если ваша мышь не обнаружена, проверьте, все ли необходимые модули загружены. </para>
<para/>
<para>Если же ваша мышь найдена, впишите устройства в соответствующий раздел InputDevice. В следующем примере видно, как мы устанавливаем еще два параметра: Protocol (определяет протокол, используемый мышью; у большинства пользователей — PS/2 или IMPS/2) и ZAxisMapping (позволяющий задействовать колесико, если есть). </para>
<para/>
<para>Листинг 4.4: Изменение настройки мыши в Xorg</para>
<para>Section "InputDevice"</para>
<para>  Identifier  "TouchPad Mouse"</para>
<para>  Driver    "mouse"</para>
<para>  Option    "CorePointer"</para>
<para>  Option    "Device"    "/dev/input/mouse0"</para>
<para>  Option    "Protocol"    "IMPS/2"</para>
<para>  Option    "ZAxisMapping"    "4 5"</para>
<para>EndSection</para>
<para/>
<para/>
<para/>
<para/>
<para>Запустите startx и порадуйтесь результату :). Поздравляем, теперь (надеемся) у вас есть работающий Xorg. Следующий шаг — удалить этот ужасный облегченный диспетчер окон, и использовать «нафаршированный» возможностями диспетчер окон (или даже рабочую среду), такой как KDE или GNOME, но это не входит в рамки данного руководства :) </para>
<para/></sect3><sect3><title>5. Ресурсы</title>
<para/>
<para>Создание и детальная настройка xorg.conf</para>
<para/>
<para>Прежде всего, в man 5 xorg.conf дается краткое, но полное описание синтаксиса конфигурационного файла. Обязательно держите эту страницу открытой в соседнем терминале при редактировании своего конфигурационного файла! </para>
<para/>
<para>Второй источник информации на вашей системе — каталог /usr/X11R6/lib/X11/doc, где находятся различные описания README для конкретных графических чипсетов. </para>
<para/>
<para>В сети также есть много сведений о настройке xorg.conf. Мы перечислим лишь некоторые из них; обязательно погуглите, чтобы найти другие :). Так как в большинстве параметров xorg.conf и XF86Config (конфигурационного файла для XFree86) используется одинаковый синтаксис, а информации о XFree86 больше, мы ссылаемся и на такие ресурсы. </para>
<para>The XFree Local Multi-User HOWTO </para>
<para>An Introduction to XFree 4.x Криса Хаузера (Chris Houser) </para>
<para/>
<para>Другие источники</para>
<para/>
<para>Если вы хотите обновить свою систему со старым монолитным Xorg на новый модульный Xorg 7, прочтите руководство по переходу на модульный X (англ.) </para>
<para/>
<para>Дальнейшая информация по настройке различных пакетов, для работы в среде X находится в разделе графическая среда Gentoo нашей документации.</para>
<para/></sect3></sect2><sect2><title>Описание настройки МОДУЛЬНОГО X-сервера версий 7.X (Англ.)</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://gentoo-wiki.com/HOWTO_Modular_Xorg">http://gentoo-wiki.com/HOWTO_Modular_Xorg</ulink>
</para>
<para>С версии: 1.0</para><sect3><title>Introduction</title>
<para/>
<para>This is a guide to Modular Xorg, mainly dealing with special circumstances and troubleshooting. </para>
<para>This article is currently being maintained by AllenJB. If you have suggestions for additions or fixes, please post them to the discussion and bugs page. </para>
<para>Please see also the official Modular Xorg Upgrade Guide. </para>
<para/></sect3><sect3><title>Preparation </title>
<para/>
<para>Firstly it'll be useful to know what version of Xorg you're going to be emerging. If you don't know, run emerge -p xorg-x11 to find out. </para>
<para/><sect4><title>Nvidia Drivers </title>
<para/>
<para>The old nvidia-glx and nvidia-kernel packages have been replaced by a single nvidia-drivers package. If you're still using the old packages, you'll want to upgrade to the new package first, as the old ones will not work with modular Xorg, by running: </para>
<para/>
<para> # emerge -Ca nvidia-glx nvidia-kernel</para>
<para> # emerge nvidia-drivers</para>
<para> # eselect opengl set nvidia</para>
<para/></sect4><sect4><title>Masking Xorg 7.1 (optional)</title>
<para/>
<para>If your system is going to install xorg-x11-7.1 and you wish to use xorg-x11-7.0 instead you'll need to add the following to /etc/portage/package.mask (create it if it doesn't exist):</para>
<para> </para>
<para># Mask xorg 7.1</para>
<para>&gt;=x11-base/xorg-x11-7.1</para>
<para>&gt;=x11-base/xorg-server-1.1.0</para>
<para>&gt;=x11-drivers/xf86-input-evdev-1.1.2-r1</para>
<para>&gt;=x11-drivers/xf86-video-vesa-1.2.0</para>
<para>&gt;=x11-drivers/xf86-input-mouse-1.1.1</para>
<para>&gt;=x11-drivers/xf86-input-keyboard-1.1.0</para>
<para>&gt;=x11-drivers/xf86-video-tdfx-1.2.0</para>
<para/></sect4><sect4><title/></sect4><sect4><title>Backup </title>
<para/>
<para>Because Xorg is such a key part of a desktop system, you'll want to backup your current install before continuing. To do this we're going to use the quickpkg command from the gentoolkit package: </para>
<para/>
<para> emerge -a gentoolkit</para>
<para> quickpkg xorg-x11</para>
<para/>
<para>If you want to find out more about the quickpkg tool, run: man quickpkg </para>
<para/>
<para>Additionally, create a list of packages that have files in the Xorg specific directories by running: </para>
<para/>
<para>  if [[ ! -L /usr/X11R6 ]]; \</para>
<para>  then equery belongs /usr/X11R6 &gt; ~/usr-x11r6-packages \</para>
<para>  &amp;&amp; rm -rf /usr/X11R6; fi</para>
<para/>
<para/></sect4><sect4><title>Restoring the backup </title>
<para/>
<para>To restore your backed-up package run: emerge --usepkgonly -a xorg-x11-6.8.2-r8 </para>
<para>If you can't remember the exact version you can find it out by running: ls /usr/portage/packages/All/xorg-x11* </para>
<para>You then want to re-emerge all the packages listed in ~/usr-x11r6-packages. </para>
<para/></sect4><sect4><title>Uninstall old X.org </title>
<para/>
<para>Warning: If you are reading this from the same machine you will be upgrading X on, keep in mind two things: </para>
<para/>
<para>After cleaning out the old X, and before the new X is installed, you will not be able to start any X applications as X is not technically installed. The applications depending on X currently running are just running off the memory of X. Closing them will not enable you to re-open them until the new X is installed. </para>
<para>Programs currently running in X may become unstable during the install. For example, firefox may unexpectedly crash due to not being able to find fonts which are no longer there, or other similar reasons. </para>
<para>It is hence highly recommended that you print out a copy of this guide (or save a tree and open this guide on a console (not in X)) before you begin. Your programs should go back to behaving normally once the install is complete, however you may want to restart X as soon as possible afterwards.</para>
<para/>
<para>Uninstall your current xorg install by running: emerge -Ca xorg-x11 </para>
<para/>
<para>/usr/X11R6 symlink </para>
<para/>
<para>Run ls -l /usr/X11* and check that /usr/X11R6 is a symlink to /usr. It should look something like this</para>
<para>: </para>
<para>lrwxrwxrwx 1 root root 6 Mar 27  2005 /usr/X11R6 -&gt; ../usr</para>
<para/>
<para>If it doesn't, delete it and recreate it by running: cd /usr &amp;&amp; ln -s ../usr X11R6 </para>
<para/>
<para>Remove /usr/lib/X11/xkb </para>
<para/>
<para>The following is a requirement of the xkeyboard-config package. </para>
<para/>
<para>32-bit Users: Run ls -l /usr/lib/X11/xkb and if it exists, delete it with rm -r /usr/lib/X11/xkb </para>
<para/></sect4></sect3><sect3><title>Emerge Modular X.org </title>
<para/><sect4><title>Device Drivers </title>
<para/>
<para>Modular Xorg introduces a new system for managing the driver packages for your devices. You need to set the appropriate VIDEO_CARDS and INPUT_DEVICES flags in /etc/make.conf. To see what flags are available, run emerge -upv xorg-x11. On a typical machine with an Nvidia video card, it might look like this: </para>
<para>File: /etc/make.conf:</para>
<para/>
<para>INPUT_DEVICES="keyboard mouse"</para>
<para>VIDEO_CARDS="nv nvidia vesa"</para>
<para/>
<para/>
<para>The nv driver is the open source unofficial driver that lacks 3D acceleration. The nvidia driver is the official nvidia-drivers package. </para>
<para/>
<para>On an ATI System, the VIDEO_CARDS line should be like this (unless you don't wish to use proprietary drivers fglrx):</para>
<para/>
<para>File: /etc/make.conf </para>
<para>VIDEO_CARDS="radeon fglrx vesa"</para>
<para/>
<para/>
<para>Add the dri USE flag to /etc/make.conf to enable Direct Rendering support, which most graphics drivers use. </para>
<para/></sect4></sect3><sect3><title>Installation </title>
<para/>
<para>Now run emerge -Dvat xorg-x11 to install modular Xorg. </para>
<para/>
<para>A few useful X11 tools that used to be included in the 6.8 build are now their own packages, you can emerge all of them now by running: emerge -DuNav xev xdpyinfo xvinfo xset xdriinfo xprop </para>
<para/>
<para>If you would like some extra fonts, you can emerge them now also: </para>
<para/>
<para/>
<para>emerge -DuNav font-adobe-100dpi font-adobe-75dpi font-adobe-utopia-100dpi \</para>
<para>font-adobe-utopia-75dpi font-bh-100dpi font-bh-75dpi font-bh-type1 \</para>
<para>font-bh-lucidatypewriter-100dpi font-bh-lucidatypewriter-75dpi \</para>
<para>font-bitstream-100dpi font-bitstream-75dpi ttf-bitstream-vera \</para>
<para>corefonts sharefonts freefonts font-ibm-type1</para>
<para/>
<para/>
<para>Keyboard Mappings</para>
<para/>
<para>There may be people who will search for the ca_enhanced keyboard mapping in Xorg 7.0. It has not disappeared, it just changed names to ca(fr), as with this keyboard configuration:</para>
<para/>
<para>File: /etc/X11/xorg.conf: </para>
<para>Section "InputDevice"</para>
<para>    Identifier  "Keyboard1"</para>
<para>    Driver      "kbd"</para>
<para>    Option "AutoRepeat" "500 30"</para>
<para>    Option "XkbRules"   "xorg"</para>
<para>    Option "XkbModel"   "pc105"</para>
<para>    Option "XkbLayout"  "ca(fr)"</para>
<para>EndSection</para>
<para/>
<para/>
<para>Notice that Option "XkbRules" "xfree86" won't work for modular xorg-x11. You have to change it to "xorg", or many keys will not produce the desired effect. </para>
<para/>
<para>In case you defined a custom xkb model (e.g. if you added a diNovo keyboard), check if you modified /usr/share/X11/xkb and not /usr/lib/X11/xkb. </para>
<para/>
<para>If your X server is restarting each time you pressed a non dead key, add the following link: </para>
<para># ln -s /usr/share/X11/XKeysymDB /usr/lib/X11/XKeysymDB</para>
<para/>
<para/>
<para>OpenMotif fails to emerge</para>
<para/>
<para>If building of openmotif fails run: emerge -DuNav --oneshot printproto xbitmaps libXp </para>
<para/>
<para>Then restart the emerge using: emerge --resume </para>
<para/>
<para/></sect3><sect3><title>GL Issues</title>
<para/>
<para>Problems building xorg-server, glx, and other GL-related packages in modular X may be due to a multilib issue. </para>
<para/>
<para>The first thing to try is to update eselect-opengl to at least 1.0.3. </para>
<para/>
<para>Next check your opengl implementation with eselect opengl list. If xorg-x11 isn't the only option, you probably want the alternate option, so change it with: eselect opengl set &lt;implementation&gt; </para>
<para/>
<para/>
<para/>
<para>xorg-server tries to build every single input driver</para>
<para/>
<para>Solution: You need to specify which drivers you want by modifying /etc/make.conf to reflect your hardware. If nothing is specified, it will build them all! </para>
<para/>
<para>Example: File: /etc/make.conf </para>
<para>INPUT_DEVICES="keyboard mouse synaptics evdev"</para>
<para/>
<para/>
<para>Mouse Speed Uncontrollable with evdev Driver </para>
<para/>
<para>Please see TIP Setting Mouse Speed Through Command Line for more information. </para>
<para/>
<para>Mouse Wheel No Longer Works </para>
<para/>
<para>Please see the Modular XOrg section of HOWTO Advanced Mouse for more extensive information. </para>
<para/>
<para/>
<para>Xorg won't start due to fglrx or nvidia module missing</para>
<para/>
<para>Re-emerge the appropriate drivers (ati-drivers or nvidia-drivers) to get X running again after the install. Make sure you recompile the the drivers with same compiler you used for the kernel, otherwise you'll get message about the module format being incompatible when you try to load the fglrx kernel module. </para>
<para/>
<para/>
<para>Matrox G550, Xinerama and mga driver </para>
<para/>
<para>The install script of the binary drivers available from Matrox (v4.4 at the time of writing) copies the driver files to </para>
<para>/usr/lib/modules/drivers</para>
<para/>
<para>instead of </para>
<para>/usr/lib/xorg/modules/drivers</para>
<para/>
<para>Copy the correct files (mga_drv.so/mga_hal_drv.so) manually to get Xinerama working again. </para>
<para/>
<para/>
<para>Problems with the keyboard </para>
<para/>
<para>The AltGr key and/or other national special keys may stop working after an update to modular X. To fix this, unmerge the new xkeyboard-config and re-emerge the xkbdata package which contains correct translations for that key. </para>
<para/>
<para>If the above fix doesn't work, you can also try running: xmodmap -e "keycode 113 = Mode_switch" </para>
<para/>
<para/>
<para>Sometimes it can happen that GNOME / KDE keyboard layout switching doesn't work. To correct this, create xkb as a symbolic link in the /usr/lib64/X11 lib directory with: </para>
<para> cd /usr/lib64/X11</para>
<para> ln -s /usr/share/X11/xkb/ xkb</para>
<para/>
<para>Missing fonts </para>
<para/>
<para>There are X11 fonts that may be in use but not available. See the Xorg and fonts HOWTO and install the listed fonts. </para>
<para/>
<para/></sect3><sect3><title>Configuration file locations have changed </title>
<para/>
<para>All of the configuration files and scripts in Xorg-6.8 were stored in /etc/X11, which was not standard. In modular Xorg, all of the configuration files are in the same place but configuration scripts and default files have moved to /usr/lib/X11/ and /usr/share/X11. </para>
<para>When upgrading, since /etc is config-protected, your old configuration files would not have been removed -- this means you'll have some extra files in there that look right but don't do anything. </para>
<para>Also, these new locations are NOT config-protected, so when making changes to say, app-defaults/XTerm-color, be sure to add CONFIG_PROTECT="/usr/share/X11/app-defaults" to /etc/make.conf. Or when updating the init for xdm, it would be a good idea to copy that file from /usr/lib/X11/xdm/Xsetup_0 to /etc/X11/xdm/ and update /etc/X11/xdm/xdm-config accordingly. </para>
<para/></sect3><sect3><title>Other problems and solutions </title>
<para>Please see Gentoo's bug tracker and the official modular X howto. </para>
<para/>
<para>If none of the above helps generating a new xorg.conf may solve your problems. </para>
<para>X -configure</para></sect3></sect2><sect2><title>XkbOptions</title>
<para>Ссылка на оригинал: <ulink url="http://ru.gentoo-wiki.com/XkbOptions">http://ru.gentoo-wiki.com/XkbOptions</ulink>
</para>
<para>С версии: 1.0</para>
<para>Обновлено: 1.4</para><sect3><title>Параметры "XkbOptions" </title>
<para>Варианты переключателей между языками в файле /etc/X11/xorg.conf </para>
<orderedlist>
<listitem>
<para>grp:toggle - переключение правым Alt; </para>
</listitem>
<listitem>
<para>grp:shift_toggle - двумя клавишами shift; </para>
</listitem>
<listitem>
<para>grp:ctrl_shift_toggle - ctrl+shift; </para>
</listitem>
<listitem>
<para>grp:alt_shift_toggle - alt+shift; </para>
</listitem>
<listitem>
<para>grp:ctrl_alt_toggle - ctrl+alt; </para>
</listitem>
<listitem>
<para>grp:caps_toggle - переключение по CapsLock; </para>
</listitem>
<listitem>
<para>grp:lwin_toggle - переключение по левой "Win" клавише на Windows клавиатуре (для X Window старше 4.2); </para>
</listitem>
<listitem>
<para>grp:rwin_toggle - переключение по правой "Win" клавише на Windows клавиатуре (для X Window старше 4.2); </para>
</listitem>
<listitem>
<para>grp:menu_toggle - переключение по клавише "Контекстное меню" на Windows клавиатуре (для X Window старше 4.2); </para>
</listitem>
<listitem>
<para>grp:lctrl_toggle переключение по левой клавише Control </para>
</listitem>
<listitem>
<para>grp:rctrl_toggle переключение по правой клавише Control </para>
</listitem>
<listitem>
<para>grp:switch - переключение по правому Alt только на момент нажатия </para>
</listitem>
<listitem>
<para>grp:lwin_switch - переключение по левой клавише Windows только на момент нажатия </para>
</listitem>
<listitem>
<para>grp:rwin_switch - переключение по правой клавише Windows только на момент нажатия </para>
</listitem>
<listitem>
<para>grp:win_switch - переключение по любой клавише Windows только на момент нажатия </para>
</listitem>
</orderedlist>
<para>Возможные значения grp_led: </para>
<orderedlist>
<listitem>
<para>grp_led - использовать индикаторы на клавиатуре для показания изменения группы </para>
</listitem>
<listitem>
<para>grp_led:num - индикатор Num_Lock показывает изменения группы </para>
</listitem>
<listitem>
<para>grp_led:caps - индикатор Caps_Lock показывает изменение группы </para>
</listitem>
<listitem>
<para>grp_led:scroll - индикатор Scroll_Lock показывает изменение группы </para>
</listitem>
</orderedlist></sect3><sect3><title>Пример </title>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/X11/xorg.conf </para>
</entry>
</row>
<row>
<entry>
<para>...</para>
<para>Section "InputDevice"</para>
<para>  ...</para>
<para>  Option "XkbOptions" "grp:switch,grp:caps_toggle,grp_led:scroll"</para>
<para>  ...</para>
<para>EndSection</para>
<para>...</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Дополнительная информация: </para>
<para>/etc/X11/xkb/rules/xorg.lst</para>
<para/>
<para>ВАЖНО (от JohnBat26): При использовании библиотек HAL версии &gt;= 0.5.10,  evdev версии &gt;= 1.2.0  и kkbswitch, возникают проблемы с переключением раскладок. <ulink url="http://bugs.gentoo.org/show_bug.cgi?id=200061">Ссылка на bug в bugs.gentoo.org.</ulink> Это происходит из-за того, что теперь X.org запрашивает эти параметры у HAL!! Следовательно вся конфигурация переключения раскладок перемещается в каталог /etc/hal/fdi/policy.  Таким образом, Вам необходимо создать файл такого содержания:</para>
<para>Листинг 1: Конфигурация раскладок через HAL</para>
<para>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; &lt;!-- -*- SGML -*- --&gt;</para>
<para>&lt;match key="info.capabilities" contains="input.keyboard"&gt;</para>
<para>        &lt;merge key="input.x11_driver" type="string"&gt;keyboard&lt;/merge&gt;</para>
<para>        &lt;merge key="input.xkb.layout" type="string"&gt;us,ru&lt;/merge&gt;</para>
<para>        &lt;merge key="input.xkb.model" type="string"&gt;pc101&lt;/merge&gt;</para>
<para>        &lt;merge key="input.xkb.rules" type="string"&gt;xorg&lt;/merge&gt;</para>
<para>        &lt;merge key="input.xkb.variant" type="string"&gt;,winkeys&lt;/merge&gt;</para>
<para>        &lt;merge key="input.xkb.options" type="string"&gt;grp:shift_toggle,grp_led:scroll&lt;/merge&gt;</para>
<para>&lt;/match&gt;</para>
<para/>
<para>назвать его как-нибудь, например keyboard_layout, и положить в указанную выше папку. После этого, раскладка клавиатуры должна переключаться нормально. ;)</para>
<para>Также смотрите: <link linkend="">HOWTO hal и устройства ввода</link>
</para></sect3></sect2><sect2><title>HOWTO Xorg and Fonts (Рус.)</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://gentoo-wiki.com/HOWTO_Xorg_and_Fonts">http://gentoo-wiki.com/HOWTO_Xorg_and_Fonts</ulink>
</para>
<para>Перевод: <ulink url="mailto:johnbat26@gmail.com?subject=По%20поводу%20Вашего%20перевода%20статьи:%20HOWTO%20Xorg%20and%20Fonts">Батогов Е.В. a.k.a. JohnBat26</ulink>
</para>
<para>С версии: 1.3</para>
<para>Дата окончания перевода: 27.10.2007</para>
<para/><sect3><title> Назначение этого HOWTO</title>
<para/>
<para>После изменения названия X сервера с Xfree на X.org, многие люди (включая меня) столкнулись с проблемами, связанными с отрисовкой и сглаживанием шрифтов, особенно это касается тех, кто использует LCD или TFT мониторы. Этот HOWTO делает шрифты значительно более интересными. В дополнение  к этому, этот HOWTO объясняет как надо устанавливать шрифты.</para>
<para/>
<para/></sect3><sect3><title> Общие сведения</title>
<para/>
<para>Компьютерные шрифты в целом, и в Linux (X11) в частности, это довольно запутанное дело. Существует много различных форматов шрифтов, в диапазоне от старых растровых шрифтов до шрифтов Truetype. Помимо этого, много шрифтов имеют проблемы лицензирования и внутренние проблемы (на которые компания  Apple, к счастью, пока не обращает внимания). А если Вы захотите включить сглаживание, то это только добавит путаницы.</para>
<para/>
<para>Многие программы, особенно ghostscript, mozilla, openoffice, и tex,  имеют свои собственные представления о шрифтах и их настройке. Это значит, что информация в этом how-to может быть не эффективна для того, чтобы Ваши шрифты заработали.</para>
<para/>
<para>Смотрите: X11 имеет не одну подсистему шрифтов, а две! Старая "core X font subsystem" использует наименования типа: -misc-fixed-medium-r-normal--10-100-75-75-c-60-iso8859-1. Новая система шрифтов, также известная как  "fontconfig",  работает с библиотекой Xft  и, как обещается, полностью заменит старую систему. К тому же, существует ещё и сервер шрифтов, называющийся "xfs".</para>
<para/></sect3><sect3><title>Замечание по поводу DPI</title>
<para>До настройки любого программного обеспечения, лучшее из того, что Вы можете сделать для получения хорошо выглядящих шрифтов на Linux, это использование LCD/CRT монитора по крайней мере не меньше, чем с 96 dpi (точек на дюйм). Для расчёта этого значения, возьмите горизонтальное разрешение и разделите его на ширину TFT/LCD экрана в дюймах.  Любое значение меньше, чем 96 dpi приведет к значительным проблемам которые нельзя будет устранить. CRT мониторы будут почти всегда отрисовывать шрифты  лучше, чем LCD мониторы потому, что они имеют внутреннее сглаживание от сканирования электронного луча и экрана покрытого люминофором.</para></sect3><sect3><title>Замечание по поводу сравнения шрифтов на Windows/Mac и Linux</title>
<para/>
<para>Шрифты в  Windows (clear type) и в Mac OS  всегда будут выглядеть лучше, чем шрифты в Linux, когда LCD монитор имеет dpi меньше, чем 96. Когда dpi равняется 96 и более, тогда шрифты в Linux будут выглядеть также или лучше, чем в Windows или Mac OS. Конечно, все это верно, если вы установите  пропатченный libXft, доступный в 'xeffects' overlay.</para>
<para/></sect3><sect3><title>Получение необходимых пакетов</title>
<para/>
<para>Я предполагаю, что Вы уже правильно установили X.org (X.org версии 6.8.0-r4 и выше должен быть установлен с включенными USE флагами: truetype и type1). Я также полагаю, что Вы не запускаете X-сервер для множества клиентов и, следовательно, USE флаг: font-server выключен, хотя он может по-прежнему применяться в других случаях.</para>
<para/>
<para>Необходимые пакеты:</para>
<para>    * x11-base/xorg-x11</para>
<para>    * media-libs/freetype</para>
<para>    * media-fonts/corefonts</para>
<para>    * media-fonts/freefonts </para>
<para/>
<para>Тем не менее я советую Вам также установить следующие полезные шрифты</para>
<para>(замечание: media-fonts/unifont блокируют dev-util/eclipse-sdk):</para>
<para/>
<para>    * media-fonts/ttf-bitstream-vera</para>
<para>    * media-fonts/artwiz-fonts</para>
<para>    * media-fonts/sharefonts</para>
<para>    * media-fonts/terminus-font</para>
<para>    * media-fonts/unifont</para>
<para>    * media-fonts/dejavu </para>
<para/>
<para>Замечание: f28: Более красивые шрифты: media-fonts/liberation-fonts-ttf, "A GPL-2 Helvetica/Times/Courier заменяют TrueType font set, с уважением к Red Hat"</para>
<para/>
<para>Активизируйте USE флаги и установите следующие пакеты:</para>
<para/>
<para># euse --enable truetype type1</para>
<para># emerge --newuse --noreplace freetype corefonts freefonts artwiz-fonts sharefonts \</para>
<para>        terminus-font ttf-bitstream-vera unifont dejavu xorg-x11</para>
<para/>
<para>Для тех, кто уже установил Xorg и желает обновить все остальные пакеты, которые уже установлены, я рекомендую изменить файл /etc/make.conf добавив следующие USE флаги:</para>
<para/>
<para>USE="truetype type1"</para>
<para/>
<para>Затем необходимо заново собрать все пакеты которые могут использовать эти флаги:</para>
<para/>
<para># emerge -avuDN world</para>
<para/>
<para>Замечание для Xorg 7.0: Кажется Вам необходимо установить ещё и  пакет</para>
<para> "intlfonts".</para>
<para/>
<para># emerge intlfonts</para>
<para/>
<para>Вы можете также увидеть это в обсуждении:</para>
<para>
<ulink url="http://forums.gentoo.org/viewtopic.php?p=3643250#3643250%20">http://forums.gentoo.org/viewtopic.php?p=3643250#3643250 </ulink>
</para>
<para/>
<para/></sect3><sect3><title>Информация о хинтинге (Hinting)</title>
<para/>
<para>Хинтинг является частью процесса отрисовки шрифта, в общем, хинтинг руководит растеризатором так, что он производит шрифт, гораздо лучше выглядящий на экране (особенно при малых размерах шрифта).</para>
<para/>
<para>Отдавая должное возможным проблемам с патентами, FreeType имеет выбор — собираться с  TrueType's Byte Code Interpreter (или BCI) или нет.</para>
<para/>
<para>Без BCI (по умолчанию), FreeType использует свой собственный автоматический хинтер для улучшения качества отображения шрифтов малых размеров. Этот автохинтер ещё находится в стадии совершенствования и улучшается с каждой версией FreeType. Автохинтер обычно дает великолепные результаты. Однако, многие считают, что родное TrueType BCI производит лучшие результаты, чем автохинтер, т.к. в этом случае используется информация о хинтинге, содержащаяся в шрифте.</para>
<para/>
<para>Если Вы живете в стране, где патенты на программное обеспечение не являются проблемой, Вы можете включить использование BCI, выключая USE флаг: bindist. Дополнительую информацию о freetype и патентах смотрите на: <ulink url="http://freetype.sourceforge.net/patents.html">http://freetype.sourceforge.net/patents.html</ulink>.</para>
<para/>
<para>#echo "media-libs/freetype -bindist" &gt;&gt; /etc/portage/package.use</para>
<para>#emerge -av freetype</para>
<para/>
<para>Если Вы считаете, что шрифты слишком размытые на Вашем LCD мониторе, попытайтесь включить флаг bindist и посмотреть разницу, может быть это будет лучше в Вашем случае.</para>
<para/></sect3><sect3><title>Изменение конфигурационных файлов</title>
<para/>
<para>После установки шрифтов, Вам необходимо изменить конфигурационные файлы в порядке распознавания их системой. Вот эти файлы:</para>
<para/>
<orderedlist>
<listitem>
<para>/etc/fonts/local.conf;</para>
</listitem>
<listitem>
<para>/etc/X11/xorg.conf;</para>
</listitem>
<listitem>
<para>~/.fonts.conf .</para>
</listitem>
</orderedlist>
<para/>
<para>Для проверки того, какие шрифты установлены, Вы можете использовать fc-list и xlsfonts. Для просмотра шрифтов, Вы можете использовать gfontview.</para>
<para/>
<para>Что делать, если Ваши шрифты не показываются утилитой fc-list, что делать если Ваши шрифты не отображаются в xlsfonts, что делать если Ваши шрифты не появляются в OpenOffice. Что, наконец,  делать, если шрифты не показываются в ghostscript и/или в tex:</para>
<para/>
<para>Смотрите файлы: /etc/fonts/local.conf и ~/.fonts.conf</para>
<para/>
<para>Редактируйте конфигурационные файлы для системы шрифтов: Xft. Изменения в файле /etc/fonts/local.conf касаются всей системы; выборочные изменения в пользовательском конфигурационном файле ~/.fonts.conf имеют приоритет над  системными установками в большинстве случаев. Единственная опция, которая не может быть перекрыта в пользовательском файле — это настройка сглаживания (anti-aliasing setting).</para>
<para/>
<para>В файле /etc/fonts/local.conf  нет необходимости устанавливать все директории со шрифтами, кроме тех случаев, когда шрифты устанавливаются в нестандартный каталог. Файл /etc/fonts/fonts.conf включает /usr/share/fonts и некоторые другие директории. Другими словами, Вы не должны изменять этот файл, т.к. Xorg будет просматривать Ваш файл ~/.fonts.conf,  если он имеется.</para>
<para/>
<para>Заметьте то, что файлы /etc/fonts/local.conf и ~/.fonts.conf, являются XML-файлами. И их легко изменять в редакторах, которые поддерживают синтаксис XML . </para>
<para>Следующий пример содержит множество опций, которые Вы можете захотеть использовать:</para>
<para/>
<para>Файл: /etc/fonts/local.conf или ~/.fonts.conf:</para>
<para/>
<para>&lt;?xml version="1.0"?&gt;</para>
<para>&lt;!DOCTYPE fontconfig SYSTEM "fonts.dtd"&gt;</para>
<para>&lt;!-- /etc/fonts/local.conf file to configure system font access --&gt;</para>
<para/>
<para>&lt;fontconfig&gt;</para>
<para/>
<para>&lt;!-- Enable sub-pixel rendering --&gt;</para>
<para/>
<para>&lt;!--</para>
<para>        &lt;match target="font"&gt;</para>
<para>                &lt;test qual="all" name="rgba"&gt;</para>
<para>                        &lt;const&gt;unknown&lt;/const&gt;</para>
<para>                &lt;/test&gt;</para>
<para>                &lt;edit name="rgba" mode="assign"&gt;&lt;const&gt;rgb&lt;/const&gt;&lt;/edit&gt;</para>
<para>        &lt;/match&gt;</para>
<para>--&gt;</para>
<para/>
<para> </para>
<para>&lt;!-- Use the Autohinter --&gt;</para>
<para/>
<para>        &lt;match target="font"&gt;</para>
<para>               &lt;edit name="autohint" mode="assign"&gt;&lt;bool&gt;true&lt;/bool&gt;&lt;/edit&gt;</para>
<para>       &lt;/match&gt;</para>
<para/>
<para>&lt;!-- Disable Autohinting for bold fonts --&gt;</para>
<para/>
<para>        &lt;match target="font"&gt;</para>
<para>                   &lt;test name="weight" compare="more"&gt;</para>
<para>                        &lt;const&gt;medium&lt;/const&gt;</para>
<para>                &lt;/test&gt;</para>
<para>                   &lt;edit name="autohint" mode="assign"&gt;&lt;bool&gt;false&lt;/bool&gt;&lt;/edit&gt;</para>
<para>        &lt;/match&gt;</para>
<para> </para>
<para>&lt;!-- Exclude/Include a range of fonts for Anti Aliasing --&gt;</para>
<para/>
<para>&lt;!--</para>
<para/>
<para>&lt;match target="font"&gt;</para>
<para>        &lt;test qual="any" name="size" compare="more"&gt;</para>
<para>                &lt;double&gt;9&lt;/double&gt;</para>
<para>        &lt;/test&gt;</para>
<para>        &lt;test qual="any" name="size" compare="less"&gt;</para>
<para>                &lt;double&gt;14&lt;/double&gt;</para>
<para>        &lt;/test&gt;</para>
<para>        &lt;edit name="antialias" mode="assign"&gt;</para>
<para>                &lt;bool&gt;true&lt;/bool&gt;</para>
<para>        &lt;/edit&gt;</para>
<para>&lt;/match&gt;</para>
<para/>
<para>--&gt;</para>
<para/>
<para/>
<para>&lt;!-- And/Or disable Anti Aliasing for a range on pixel-based size.</para>
<para>     Disabling this using both methods seems to fix Firefox. --&gt;</para>
<para/>
<para>&lt;!--</para>
<para/>
<para>&lt;match target="font"&gt;</para>
<para>        &lt;test compare="less" name="pixelsize" qual="any"&gt;</para>
<para>                &lt;double&gt;20&lt;/double&gt;</para>
<para>        &lt;/test&gt;</para>
<para>        &lt;edit mode="assign" name="antialias"&gt;</para>
<para>                &lt;bool&gt;false&lt;/bool&gt;</para>
<para>        &lt;/edit&gt;</para>
<para>&lt;/match&gt;</para>
<para/>
<para>--&gt;</para>
<para/>
<para/>
<para>        &lt;dir&gt;/home/johnbat26/extrafonts&lt;/dir&gt;</para>
<para/>
<para>&lt;/fontconfig&gt;</para>
<para/>
<para/>
<para/>
<para>В представленном выше файле опция: "sub-pixel rendering" закомментирована потому, что она используется только на LCD мониторах. Если её включить на CRT мониторе, то это заставит Xorg производить много дополнительной работы по отрисовке. Возможные значения: "none", "rgb", "bgr", "vrgb" и "vbgr". Для большинства LCD мониторов наиболее подходящим значением будет:"rgb", которое и использует приведенный выше пример.</para>
<para/>
<para>Вы конечно захотите использовать какую-нибудь форму хинтинга. Gentoo поддерживает 2 формы хинтинга:</para>
<para/>
<orderedlist>
<listitem>
<para>AutoHinter</para>
<para>         По умолчанию используется auto hinter из пакета FreeType, и это также является установкой по умолчанию в приведенном выше примере конфигурационного файла. Тем не менее, когда используется автохинтинг, тогда Вы можете захотеть выключить его использование на жирных шрифтах, иначе они могут стать слишком широкими. Пример выше как раз и делает это.</para>
<para/>
</listitem>
<listitem>
<para>TrueType Byte Code Interpreter (BCI)</para>
<para>  Если Вы собрали FreeType с активацией интерпретатора байт-кода (TrueType Byte Code Interpreter) (см. выше), и желаете использовать BCI, тогда выключите auto hinter полностью. (Убедитесь, что &lt;edit name="autohint" mode="assign"&gt;&lt;bool&gt;true&lt;/bool&gt;&lt;/edit&gt; использует "false" вместо "true". Существуют патентные проблемы на использование TrueType BCI; если Вы желаете избежать их полностью, тогда не используйте BCI.</para>
</listitem>
</orderedlist>
<para/>
<para>И KDE и GNOME имеют прекрасный графический интерфейс, в котором пользователь может выбрать уровень хинтинга: "легкий", "средний", "сильный" ('light,' 'medium,' and 'strong'). Это позволяет обратиться к FreeType 'auto hinter', а не к BCI.    Другими словами 'легкий,' 'средний,' и 'сильный' хинтинг, позволяют всем шрифтам выглядеть одинаково, когда BCI используется вместо автохинтера (auto hinter). </para>
<para/>
<para>Вторая опция с окончания файла, также закомментирована, так как некоторые люди    предпочитают исключать или включать набор размеров шрифтов для применения сглаживания к ним. Это общий способ, чтобы сделать Ваши шрифты выглядящими очень похоже на шрифты по умолчанию в Windows(R). Когда Вы отключаете сглаживание, убедитесь также, что выключена опция "sub-pixel rendering", - для достижения наилучших шрифтов без сглаживания.</para>
<para/>
<para>Наконец, последняя опция, связанный с пикселом, размер шрифта (pixel-based font sizes)... Пожалуйста, читайте комментарии к это опции!</para>
<para/>
<para>Последняя строка в примере пользовательских шрифтов, это изменение директории по умолчанию (/usr/share/fonts/) для местоположения шрифтов. Скорее всего Вам не нужна данная строка, если так, то можете просто удалить её.</para>
<para/>
<para>Помните, что все изменения в этом файле распространяются на всю систему и будут перекрыты ~/.fonts.conf, исключая только установку  anti-aliasing setting, которая не может быть перекрыта ,если установлена в этом файле. Также заметьте, что синтаксис файла: /etc/fonts/local.conf одинаков с локальным пользовательским конфигурационным файлом: ~/.fonts.conf, и, следовательно, Вы можете копировать глобальный файл, и просто переименовать его.</para>
<para/></sect3><sect3><title>/etc/X11/xorg.conf</title>
<para>Когда Вы настраиваете X ("иксы"), важно убедиться, что они правильно понимают размер Вашего экрана, и так же важно, что Вы запускаете LCD монитор на его родном разрешении, которое используется для вычисления горизонтального и вертикального DPI экрана — шрифты в GTK+ приложениях кажутся особенно безобразными на основе неправильной информации о экране. </para>
<para/>
<para>Это может также привести к неправильному определению размера шрифтов в различных приложениях. Некоторые шрифты будут корректного размера в зависимости от используемого метода, а другие будут иметь неправильные размеры. Я заметил большие различия, когда просматривал страницы в Firefox. Если на странице использовался CSS, то она отображалась хорошо, иначе если использовался чистый HTML, то шрифты получаются либо огромные либо небольшие зависимости от направления неправильной установки DPI. Я также обнаружил, что DPI 96 является хорошим размером.</para>
<para/>
<para>Установка ширины и высоты экрана (в миллиметрах) используя следующую инструкцию:</para>
<para/>
<para>DisplaySize &lt;width&gt; &lt;height&gt;</para>
<para/>
<para>в секции Monitor файла:  /etc/X11/xorg.conf, решает эту проблему.</para>
<para/>
<para>File: /etc/X11/xorg.conf </para>
<para/>
<para>Section "Monitor"</para>
<para>    Identifier          "Monitor0"</para>
<para>    :</para>
<para>    DisplaySize         340 270</para>
<para>    :</para>
<para>EndSection</para>
<para/>
<para/>
<para>Простейший путь для измерения ширины и высоты— это воспользоваться линейкой</para>
<para>Например, монитор в 15 дюймов имеет размеры приблизительно 340мм x 270 мм, а 19 дюймов — 380мм x 305 мм.</para>
<para/>
<para>Значения  DisplaySize могут быть вычислены по формуле  25.4 × width / dpi или,  соответственно, 25.4 × height / dpi, 25,4 мм  на дюйм. Например, если использовать </para>
<para>DPI равным 75 на разрешении 1600x1200, то расчет будет следующий: 25.4 × 1600 / 75 = 542 и 25.4 × 1200 / 75 = 406, и в результате устанавливаем DisplaySize 542 406. </para>
<para/>
<para>Другой способ для подсчёта этих значений, это попросить X сервер вычислить их для Вас. Запустите его используя команду startx -- -dpi 96, где  96  это требуемое значение для DPI, и проверьте размер:</para>
<para/>
<para> #xdpyinfo | grep dimension</para>
<para> dimensions:    1400x1050 pixels (XXXxYYY millimeters)</para>
<para/>
<para>Используйте эти значения: XXX и YYY для параметра DisplaySize.</para>
<para/>
<para>Ещё один способ обнаружить размерность экрана, если Ваше аппаратное обеспечение предоставляет эту информацию (Вам может потребоваться установить emerge -tav xrandr сначала) это использовать: </para>
<para/>
<para># xrandr --query</para>
<para> SZ:    Pixels          Physical       Refresh</para>
<para>*0   1680 x 1050   ( 431mm x 272mm )  *60  </para>
<para>Current rotation - normal</para>
<para>Current reflection - none</para>
<para>Rotations possible - normal </para>
<para>Reflections possible - none</para>
<para/>
<para>Я достиг лучших результатов, используя измерения, полученные с помощью этого калькулятора: <ulink url="http://www.raydreams.com/prog/dpi.aspx">http://www.raydreams.com/prog/dpi.aspx</ulink>
</para>
<para/>
<para>Если вы используете драйверы nVidia, то наилучшим способом следовало бы добавить эти опции в секцию device. Это также намного лучше работает с двумя мониторами: </para>
<para>Файл: /etc/X11/xorg.conf </para>
<para>   ....</para>
<para>   Option   "UseEdidDpi"   "FALSE"</para>
<para>   Option   "DPI"   "96 x 96"</para>
<para>   ....</para>
<para/>
<para>Далее, у нас есть список наших каталогов со шрифтами в файле  /etc/X11/xorg.conf.   </para>
<para>Пути к шрифтам ищутся в том порядке, в котором они расположены в списке, поэтому мы должны сделать небольшие изменения.</para>
<para/>
<para>Достаточно много современных приложений и окружений рабочего стола, таких как Gnome и KDE используют утилиту fontconfig,  так что только шрифты, которые действительно требуются X сервером (или сервером шрифтов) это  fixed и  cursor.</para>
<para/>
<para>/usr/share/fonts/misc:unscaled</para>
<para/>
<para>Первым путем, который мы хотим видеть в нашем списке, является: /usr/share/fonts/misc.  Там находятся все важные fixed и cursor шрифты. Они являются критичными для правильной работы Xorg. Там же находится курсор по умолчанию, и помещение его первым в списке сохраняет Х от использования других </para>
<para>курсоров, которые устанавливают некоторые пакеты шрифтов (artwiz)</para>
<para/>
<para>Опция: :unscaled говорит X использовать  unscaled версии этих шрифтов всякий раз, когда возможно предотвратить pixelation. Эта опция может применяться для любого bitmap  шрифта</para>
<para/>
<para>/usr/share/fonts/75dpi:unscaled</para>
<para>/usr/share/fonts/100dpi:unscaled</para>
<para/>
<para>Это основные bitmap шрифты. Мы обычно хотим загружать шрифты для 75dpi перед 100dpi, так как большинство тем ожидают этого. Тем не менее, большинство современных мониторов имеют более высокое значение dpi, так что если Вы обнаружите у себя косоглазие читая меню, Вы скорее всего захотите поэкспериментировать с переключением порядка в списке шрифтов</para>
<para/>
<para>/usr/share/fonts/Type1</para>
<para>/usr/share/fonts/TTF</para>
<para/>
<para>Type1 и TrueType шрифты.  Порядок не имеет большого значения, но заметьте что оба пакета содержат Luxi Sans/Serif/Mono шрифты. </para>
<para/>
<para>/usr/share/fonts/corefonts</para>
<para>/usr/share/fonts/freefonts</para>
<para>/usr/share/fonts/sharefonts</para>
<para/>
<para>это Microsoft's TrueType core fonts, и набор TrueType  шрифтов и коллекция свободных Type1 Fonts, соответственно. </para>
<para/>
<para>/usr/share/fonts/artwiz</para>
<para>/usr/share/fonts/terminus</para>
<para>/usr/share/fonts/ttf-bitstream-vera</para>
<para>/usr/share/fonts/unifont</para>
<para/>
<para>Если Вы установили пакеты упомянутые выше, то Вам следовало бы добавить эти пути в список шрифтов.</para>
<para/>
<para>/usr/share/fonts/local</para>
<para>/usr/share/fonts/cyrillic</para>
<para/>
<para>эти шрифты обычно не нужны и вероятно пустые или не существуют. Для гарантии, проверьте файл font.dir внутри каждой директории. Если этот файл пуст, тогда этот каталог нет необходимости добавлять в список  путей к шрифтам.</para>
<para/>
<para>/usr/share/fonts/*everythingelse*  </para>
<para/>
<para>все директории новых шрифтов, которые Вы установили. Большинство из них уникальны. Если Вы обеспокоены о каком-нибудь отдельном шрифте, поместите его наверх списка. Вы можете проверить список из доступных шрифтов, посмотрев файл fonts.dir, находящийся в директории шрифта.</para>
<para/>
<para>Теперь сделаем несколько финальных изменений в плане порядка следования путей в списке. Возьмём основные bitmap шрифты и поместим их последними. Это делается потому, что у нас есть намного лучшие TTF или Type1 версии некоторых из этих шрифтов которые мы чаще используем. Также пакет media-fonts/corefonts  содержит большое количество core fonts и его следовало бы поместить повыше в списке.</para>
<para>В результате список должен выглядеть подобно:</para></sect3><sect3><title>Файл: /etc/X11/xorg.conf (Список путей к шрифтам)</title>
<para>...</para>
<para>Section "Files"</para>
<para>    FontPath     "/usr/share/fonts/misc:unscaled"</para>
<para>    FontPath     "/usr/share/fonts/Type1/" </para>
<para>    FontPath     "/usr/share/fonts/TTF/"</para>
<para>    FontPath     "/usr/share/fonts/corefonts"</para>
<para>    FontPath     "/usr/share/fonts/freefonts"</para>
<para>    FontPath     "/usr/share/fonts/sharefonts"        </para>
<para>    FontPath     "/usr/share/fonts/terminus"</para>
<para>    FontPath     "/usr/share/fonts/ttf-bitstream-vera"</para>
<para>    FontPath     "/usr/share/fonts/unifont"</para>
<para>    FontPath     "/usr/share/fonts/75dpi:unscaled" </para>
<para>    FontPath     "/usr/share/fonts/100dpi:unscaled"</para>
<para>    FontPath     "/usr/share/fonts/artwiz"</para>
<para>    FontPath     "/usr/share/fonts/cyrillic"</para>
<para>EndSection</para>
<para>...</para>
<para>Также проверьте в том же файле, что загружается модуль freetype </para>
<para/>
<para>Файл: /etc/X11/xorg.conf </para>
<para/>
<para>Load "freetype"</para>
<para/></sect3><sect3><title>Перезагрузка служб</title>
<para/>
<para>После изменения конфигурационных файлов, Вам необходимо перезагрузить Xorg.  Если Вы используете X display manager, такой как GDM, KDM, XDM и т.д. тогда  просто выйдите из Вашей сессии и перезагрузите X, нажав "Ctrl+Alt+Backspace", находясь на экране входа в систему. Если это не работает, то рестарт Xorg возможен с помощью перезагрузки службы xdm.</para>
<para/>
<para>Кто-то могут заметить подвисание системы, запуская следующие команды в Xorg, так что я советую запускать их в другом терминале, нажав  "CTRL + ALT + F1" и войти в систему. (Нажатие ALT + F7 вернет Вас обратно в X из консоли.)</para>
<para/>
<para># /etc/init.d/xdm restart</para>
<para/>
<para>После выполнения этой команды, Ваш X display manager будет перезагружен. Вновь войдя в систему, Вы должны получить шрифты со сглаживанием (anti-aliased).</para>
<para/>
<para/></sect3><sect3><title>Mozilla Firefox and Thunderbird</title><sect4><title>Mozilla Firefox 1.0+</title>
<para/>
<para>Для активизации шрифтов со сглаживанием в Firefox 1.0. убедитесь, что Вы собрали Firefox c выключенным USE флагом: moznoxft.  Запустите утилиту ufed для этого (не забудьте установить её: emerge ufed).</para>
<para/>
<para>Итак:</para>
<para/>
<para>#emerge mozilla-firefox</para>
<para/>
<para>Необходимо хотя бы один раз запустить Firefox, чтобы он создал профиль в : ~/.mozilla/firefox/default.xxx/.</para>
<para/>
<para>Направляйтесь в about:config  в Вашем браузере, или альтернативно, измените файл user.js в ~/.mozilla/firefox/default.xxx/, где xxx являются буквами или цифрами.</para>
<para/>
<para>Firefox 1.0.4 сохраняет файл:  prefs.js в ~/.mozilla/firefox/xxx.default/, где xxx это строка из цифр и букв.</para>
<para/>
<para>Либо через  диалог  about:config, либо в файле user.js Вы должны вставить следующие строки, как показано ниже:</para>
<para/>
<para/>
<para>Внимание: Установка "font.FreeType2.printing" в true, может вызвать внезапное падение Firefox при попытке печати через.</para>
<para/>
<para/>
<para/>
<para/>
<para>Файл: ~/.mozilla/firefox/___.default/prefs.js</para>
<para/>
<para>// TrueType</para>
<para>user_pref ("font.FreeType2.enable", true);</para>
<para>user_pref ("font.freetype2.shared-library", "libfreetype.so.6");</para>
<para>// if libfreetype was built without hinting compiled in</para>
<para>// it is best to leave hinting off</para>
<para>user_pref ("font.FreeType2.autohinted", true);</para>
<para>user_pref ("font.FreeType2.unhinted", true);</para>
<para>// below a certain pixel size anti-aliased fonts produce poor results</para>
<para>user_pref ("font.antialias.min",        0);</para>
<para>user_pref ("font.embedded_bitmaps.max", 1000000);</para>
<para>// sample user_pref s for TrueType font dirs</para>
<para>user_pref ("font.directory.truetype.1", "/usr/share/fonts/ttf-bitstream-vera");</para>
<para>user_pref ("font.directory.truetype.2", "/usr/share/fonts/TTF");</para>
<para>user_pref ("font.directory.truetype.3", "/usr/share/fonts/corefonts");</para>
<para>user_pref ("font.directory.truetype.4", "/usr/share/fonts/freefont");</para>
<para>user_pref ("font.FreeType2.printing", true);</para>
<para/>
<para>Если Вы следуете этому HOWTO, тогда Вы не будете иметь проблем с перечисленными каталогами, иначе Вы можете изменить их.</para>
<para/>
<para>В Firefox 1.0, следуйте в Edit » Preferences » General » Fonts &amp; Colors.</para>
<para/>
<para>В Firefox 1.5, следуйте в Edit » Preferences » Content » Fonts &amp; Colors » Advanced.</para>
<para/>
<para>Затем, установите эти параметры:</para>
<para/>
<para>    * Proportional: Serif (Size: 16)</para>
<para>    * Serif: Bitstream vera serif</para>
<para>    * Sans-serif: Bitstream vera sans</para>
<para>    * Monospace: Bitstream vera sans mono (Size: 12)</para>
<para>    * Display Resolution: System setting </para>
<para/>
<para>Также проверьте, что опция: "Всегда использовать мои: Шрифты" не выбрана. </para>
<para/>
<para>Затем перезагрузите Firefox и направляйтесь на <ulink url="http://www.gentoo.org/">www.gentoo.org</ulink> со сглаженными шрифтами!</para>
<para/>
<para>Если Вы, используя KDE и Firefox, не получили сглаженных шрифтов после этого, тогда идите в Центр управления KDE /  Внешний вид и темы / Шрифты, выключите сглаживание, нажмите применить, затем включите сглаживание и вновь нажмите применить.</para></sect4><sect4><title>Mozilla Thunderbird 0.7, 1.0.2  и выше</title>
<para>Существует очень мало опций в Thunderbird, которые связаны со шрифтами, таким образом все опции должны быть применены в user.js. Создайте этот файл в  ~/.thunderbird/default/xxxxxxxx.slt/ (или, в новых версиях, ~/.thunderbird/xxxxxxxx.default/). В файле user.js Вы можете вставить те же строки, которые вставляли для Mozilla Firefox: заметьте только, что Вы вставляли в  файл prefs.js ?</para>
<para/>
<para>Файл: ~/.thunderbird/default/xxxxxxxx.slt/user.js</para>
<para/>
<para>// TrueType</para>
<para>user_pref ("font.FreeType2.enable", true);</para>
<para>user_pref ("font.freetype2.shared-library", "libfreetype.so.6");</para>
<para>// if libfreetype was built without hinting compiled in</para>
<para>// it is best to leave hinting off</para>
<para>user_pref ("font.FreeType2.autohinted", true);</para>
<para>user_pref ("font.FreeType2.unhinted", true);</para>
<para>// below a certain pixel size anti-aliased fonts produce poor results</para>
<para>user_pref ("font.antialias.min",        0);</para>
<para>user_pref ("font.embedded_bitmaps.max", 1000000);</para>
<para>user_pref ("font.scale.tt_bitmap.dark_text.min", 0);</para>
<para>user_pref ("font.scale.tt_bitmap.dark_text.gain", "0.0");</para>
<para>// sample user_pref s for TrueType font dirs</para>
<para>user_pref ("font.directory.truetype.1", "/usr/share/fonts/ttf-bitstream-vera");</para>
<para>user_pref ("font.directory.truetype.2", "/usr/share/fonts/TTF");</para>
<para>user_pref ("font.directory.truetype.3", "/usr/share/fonts/corefonts");</para>
<para>user_pref ("font.directory.truetype.4", "/usr/share/fonts/freetype");</para>
<para>user_pref ("font.FreeType2.printing", true);</para>
<para/>
<para>Затем, когда откроете Thunderbird 1.0.2, следуйте в : Edit » Preferences » Fonts Or (on 0.7) Tools » Options » Fonts и установите эти параметры:</para>
<para/>
<para>Proportional: Serif (Size: 16)</para>
<para>Serif: Bits-bitstream vera serif</para>
<para>Sans-serif: Bits-bitstream vera sans</para>
<para>Monospace: Bits-bitstream vera sans mono (Size: 12)</para>
<para>Minimum font size: 9</para>
<para/>
<para>Также проверьте, что выбрана опция: "Позволять сообщениям использовать другие шрифты".</para>
<para/>
<para>Затем перезагрузите Thunderbird и читайте Вашу почту с новыми шрифтами!</para>
<para/></sect4></sect3><sect3><title>Проблемы с размерами шрифтов</title>
<para/>
<para>Если в Ваших приложениях из KDE шрифты имеют неправильный размер, и кроме этого, KDE не было установлено (т.е. Центр управления KDE недоступен :( ), тогда Вам  следует изменить Ваш файл ~/.kde/share/config/kdeglobals следующим образом:</para>
<para/>
<para>Файл: ~/.kde/share/config/kdeglobals</para>
<para/>
<para>[General]</para>
<para> StandardFont=Bitstream Vera Sans,7,-1,5,50,0,0,0,0,0</para>
<para> activeFont=Bitstream Vera Sans,7,-1,5,75,0,0,0,0,0</para>
<para> fixed=Bitstream Vera Sans Mono,7,-1,5,50,0,0,0,0,0</para>
<para> font=Bitstream Vera Sans,7,-1,5,50,0,0,0,0,0</para>
<para> menuFont=Bitstream Vera Sans,7,-1,5,50,0,0,0,0,0</para>
<para> taskbarFont=Bitstream Vera Sans,7,-1,5,50,1,0,0,0,0</para>
<para> toolBarFont=Bitstream Vera Sans,7,-1,5,50,0,0,0,0,0</para>
<para/>
<para>Число после имени шрифта это его размер (Я не знаю, что означают другие числа)</para>
<para/>
<para>Так получилось, что шрифты в меню Firefox получились огромными. Чтобы решить эту проблему просто добавьте следующее в файл:</para>
<para/>
<para/>
<para>Файл: ~/.mozilla/firefox/&lt;yourprofile&gt;/chrome/userChrome.css</para>
<para/>
<para>* {</para>
<para>    font-family: Sans-Serif !important;</para>
<para>    font-size: 8pt !important;</para>
<para>}</para>
<para/>
<para>и сделайте тоже самое для Thunderbird (~/.thunderbird/&lt;profile&gt;/chrome/userChrome.css)</para>
<para/>
<para>В моем случае, после применения всех этих изменений, шрифты для полей ввода  с(кнопок, текстовых полей или выпадающих меню) на некоторых страницах подобным Google или Amazon были слишком большими и использовался один из ужасных шрифтов. Чтобы изменить это, следуйте в userContent.css (он отличается от  файла userChrome.css, который мы только что изменяли), и добавьте следующее:</para>
<para/>
<para>Файл: ~/.mozilla/firefox/&lt;yourprofile&gt;/chrome/userContent.css</para>
<para/>
<para>input, textarea, select, button,</para>
<para>input[type="button"], input[type="reset"], input[type="submit"] {</para>
<para>   font-size: 8pt !important;</para>
<para>   font-family: Verdana !important;</para>
<para>}</para>
<para/></sect3><sect3><title>Что делать, если Linux шрифт  в Konsole не работает.</title>
<para>Пользователи KDE вероятно знакомы с Konsole — эмулятором терминала KDE. Но некоторые пользователи получают следующую ошибку когда они пытаются использовать Linux шрифты: Font `-misc-console-medium-r-normal--16-160-72-72-c-80-iso10646-1' not found</para>
<para>Вы можете решить эту проблему следующими действиями:</para>
<para/>
<orderedlist>
<listitem>
<para>   Запустите kdesu kcmshell kcmfontinst, когда Вы находитесь в KDE.</para>
</listitem>
<listitem>
<para>   Введите пароль root.</para>
</listitem>
<listitem>
<para>   Нажмите на  иконку "add fonts icon" (an @-sign with a +-sign on it)</para>
</listitem>
<listitem>
<para>  Направляйтесь в каталог /usr/kde/3.2/share/fonts/ и добавьте доступные шрифты (files ending in .pcf.gz). </para>
<para/>
</listitem>
</orderedlist></sect3><sect3><title>Что, если Ваши шрифты стали размытыми и не читаемыми</title>
<para>У меня  шрифты временами становились не читаемыми в Gnome 2.12</para>
<para/>
<para>Полное выключение сглаживания (AntiAliasing) (Убирание комментариев со следующих секций в файлах: /etc/fonts/local.conf и ~/.fonts.conf, как они объявлены в примерах выше)  решит эту проблему.</para>
<para>Если это не помогло и Вы используете драйвер  media-video/nvidia-kernel-1.0.8178-r3,</para>
<para>попытайтесь убрать комментарий на опции render acceleration в секции Device  файла  xorg.conf:</para>
<para/>
<para>Option "RenderAccel"</para>
<para/></sect3><sect3><title>Ошибка при запуске startx</title>
<para/>
<para>Если Вы получаете ошибку: "Fontconfig error" когда запускаете startx:</para>
<para/>
<para>"Fontconfig warning: no &lt;cachedir&gt; elements found. Check configuration." </para>
<para>"Fontconfig warning: adding &lt;cachedir&gt;/var/cache/fontconfig&lt;/cachedir&gt;" </para>
<para>"Fontconfig warning: adding &lt;cachedir&gt;~/.fontconfig&lt;/cachedir&gt;</para>
<para/>
<para>Просто исправить её можно запустив:</para>
<para/>
<para>emerge --noconfmem --oneshot fontconfig &amp;&amp; dispatch-conf</para>
<para/></sect3><sect3><title>XEmacs</title>
<para/>
<para>Если после всей проделанной работы, Вы обнаружили, что не  имеете хорошего шрифта для XEmacs (который не поддерживает сглаживание),тогда дополнительно установите следующее:</para>
<para/>
<para>    * x11fonts-jmk </para>
<para/>
<para> emerge x11fonts-jmk</para>
<para/>
<para>Затем добавьте  ещё одну строку FontPath в Ваш файл: xorg.conf:</para>
<para/>
<para> FontPath    "/usr/share/fonts/jmk"</para>
<para/>
<para>Перезагрузите подсистему шрифтов (просто выйдя из X). Затем попытайтесь установить Ваш Xemacs шрифт в  "Neep Alt".  Вы вероятно хотите альтернативный вариант, вместо обычного, для отображения символа амперсанда.</para>
<para/></sect3><sect3><title>Полезные ресурсы</title>
<para>Это ресурсы из которых я брал информацию, когда писал этот HOWTO:</para>
<para/>
<para>    * <ulink url="http://forums.gentoo.org/viewtopic.php?t=23575">How to enable AA in Fluxbox,GKrellM,Abiword,Phoenix etc...</ulink>
</para>
<para>    * <ulink url="http://forums.gentoo.org/viewtopic.php?t=164507">X.Org &amp; Fonts</ulink>
</para>
<para>    * <ulink url="http://forums.gentoo.org/viewtopic.php?t=101970">[xfree] caratteri sfocati</ulink>
</para>
<para>    * <ulink url="http://forums.gentoo.org/viewtopic.php?t=183733">Moz Firefox 0.9 (all versions) general discussion thread. </ulink>
</para></sect3><sect3><title>Смотрите также</title>
<para>    * <ulink url="http://process-of-elimination.net/wiki/Control_Font_DPI_in_X">Control Font DPI in X</ulink>
</para>
<para>    * <ulink url="http://forums.gentoo.org/viewtopic.php?t=187389">Forum Post</ulink>
</para>
<para>    * <ulink url="http://www.tldp.org/HOWTO/archived/FDU/">XFree86 Font De-uglification HOWTO</ulink>
</para>
<para>    * <ulink url="http://www.tldp.org/HOWTO/Font-HOWTO/index.html">Optimal Use of Fonts on Linux</ulink>
</para>
<para>    * <ulink url="http://convexhull.com/mandrake_fonts.html">Mini HOWTO: Getting Perfect Fonts on Mandrake 10.1 </ulink>
</para>
<para/>
<para/>
<para/></sect3><sect3><title>Примечание (от JohnBat26), мой файл: ~/.fonts.conf:</title>
<para/>
<para>&lt;?xml version="1.0"?&gt;</para>
<para>&lt;!DOCTYPE fontconfig SYSTEM "fonts.dtd"&gt;</para>
<para>&lt;fontconfig&gt;</para>
<para>&lt;!-- Info at http://gentoo-wiki.com/HOWTO_Xorg_and_Fonts --&gt;&lt;!-- Replace Courier with a better-looking font --&gt; </para>
<para>  &lt;match target="pattern" name="family" &gt;</para>
<para>  &lt;test name="family" qual="any" &gt;</para>
<para>   &lt;string&gt;Verdana&lt;/string&gt;</para>
<para>  &lt;/test&gt;</para>
<para>  &lt;edit mode="assign" name="family" &gt;</para>
<para>&lt;!-- Other choices - Courier New, Luxi Mono   &lt;string&gt;Bitstream Vera Sans Mono&lt;/string&gt; --&gt;&lt;!-- Other choices - Courier New, Luxi Mono --&gt; </para>
<para>  &lt;string&gt;Verdana&lt;/string&gt;</para>
<para>  &lt;/edit&gt;</para>
<para> &lt;/match&gt;</para>
<para> &lt;match target="font" &gt;</para>
<para>  &lt;edit mode="assign" name="rgba" &gt;</para>
<para>   &lt;const&gt;rgb&lt;/const&gt;</para>
<para>  &lt;/edit&gt;</para>
<para>  &lt;edit mode="assign" name="autohint" &gt;</para>
<para>   &lt;bool&gt;true&lt;/bool&gt;</para>
<para>  &lt;/edit&gt;</para>
<para>  &lt;edit mode="assign" name="antialias" &gt;</para>
<para>   &lt;bool&gt;true&lt;/bool&gt;</para>
<para>  &lt;/edit&gt;</para>
<para>  &lt;edit mode="assign" name="hinting" &gt;</para>
<para>   &lt;bool&gt;true&lt;/bool&gt;</para>
<para>  &lt;/edit&gt;</para>
<para>  &lt;edit mode="assign" name="hintstyle" &gt;</para>
<para>   &lt;const&gt;hintmedium&lt;/const&gt;</para>
<para>  &lt;/edit&gt;</para>
<para> &lt;/match&gt;</para>
<para>&lt;!-- Disable autohint for bold fonts, otherwise they look *too* bold --&gt; &lt;match target="font" &gt;</para>
<para>  &lt;test compare="more" name="weight" &gt;</para>
<para>   &lt;const&gt;medium&lt;/const&gt;</para>
<para>  &lt;/test&gt;</para>
<para>  &lt;edit mode="assign" name="autohint" &gt;</para>
<para>   &lt;bool&gt;false&lt;/bool&gt;</para>
<para>  &lt;/edit&gt;</para>
<para> &lt;/match&gt;</para>
<para>&lt;!-- Reject bitmap fonts in favour of Truetype, Postscript, etc. --&gt; &lt;selectfont&gt;</para>
<para>  &lt;rejectfont&gt;</para>
<para>   &lt;pattern&gt;</para>
<para>    &lt;patelt name="scalable" &gt;</para>
<para>     &lt;bool&gt;false&lt;/bool&gt;</para>
<para>    &lt;/patelt&gt;</para>
<para>   &lt;/pattern&gt;</para>
<para>  &lt;/rejectfont&gt;</para>
<para> &lt;/selectfont&gt;</para>
<para> &lt;match target="font" &gt;</para>
<para>  &lt;edit mode="assign" name="rgba" &gt;</para>
<para>   &lt;const&gt;rgb&lt;/const&gt;</para>
<para>  &lt;/edit&gt;</para>
<para> &lt;/match&gt;</para>
<para> &lt;match target="font" &gt;</para>
<para>  &lt;edit mode="assign" name="hinting" &gt;</para>
<para>   &lt;bool&gt;true&lt;/bool&gt;</para>
<para>  &lt;/edit&gt;</para>
<para> &lt;/match&gt;</para>
<para> &lt;match target="font" &gt;</para>
<para>  &lt;edit mode="assign" name="hintstyle" &gt;</para>
<para>   &lt;const&gt;hintmedium&lt;/const&gt;</para>
<para>  &lt;/edit&gt;</para>
<para> &lt;/match&gt;</para>
<para> &lt;match target="font" &gt;</para>
<para>  &lt;edit mode="assign" name="antialias" &gt;</para>
<para>   &lt;bool&gt;true&lt;/bool&gt;</para>
<para>  &lt;/edit&gt;</para>
<para> &lt;/match&gt;</para>
<para>&lt;/fontconfig&gt;</para>
<para/>
<para> </para></sect3></sect2><sect2><title>Руководство по видеокартам nVidia в Gentoo Linux</title>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/xorg-config.xml">http://www.gentoo.org/doc/ru/nvidia-guide.xml</ulink>
</para>
<para>С версии: 1.0</para>
<para/><sect3><title>1. Введение</title>
<para/>
<para>Компания nVidia выпускает свои собственные драйверы для Linux, отличающиеся хорошей производительностью и поддержкой трехмерного ускорения. В дереве Portage присутствуют два драйвера — nvidia-drivers для новых видеокарт nVidia и nvidia-legacy-drivers для старых.  </para>
<para/>
<para/>
<para/>
<para>Примечание: Раньше в Gentoo было два отдельных пакета — для модуля ядра nVidia(nvidia-kernel) и для библиотек GLX X11 (nvidia-glx). Эти пакеты были удалены из дерева Portage для замены на nvidia-drivers и nvidia-legacy-drivers. Если вы до сих пор используете nvidia-kernel и nvidia-glx, то вы должны перейти на использование новых пакетов. </para>
<para/>
<para/></sect3><sect3><title>2. Настройка карты</title>
<para/><sect4><title>Конфигурирование ядра</title>
<para/>
<para>Как уже было сказано, драйвер nVidia настраивается и запускается для текущего ядра. Он собирается в качестве модуля, поэтому ядро должно поддерживать загрузку модулей. Если вы использовали genkernel для конфигурации ядра, тогда все уже сделано. Если же нет, тогда дважды проверьте конфигурацию вашего ядра на наличие поддержки загружаемых модулей: </para>
<para/>
<para>Листинг 2.1: Включение загрузки модулей ядра</para>
<para>Loadable module support ---&gt;</para>
<para>  [*] Enable loadable module support</para>
<para/>
<para/>
<para>Также вам потребуется включить в ядре Memory Type Range Register: </para>
<para/>
<para>Листинг 2.2: Включение MTRR</para>
<para>Processor and Features ---&gt;</para>
<para>  [*] MTRR (Memory Type Range Register) support</para>
<para/>
<para/>
<para>Также, если у вас AGP-видеокарта, вы можете включить поддержку agpgart в ядре или в виде модуля. Если вы не используете встроенный agpgart, то драйверы будут использовать собственную реализацию agpgart под названием NvAGP. На одних системах эта реализация работает лучше, чем встроенная, на других — хуже. Вам понадобится проверить это на своей собственной системе, чтобы сделать выбор в пользу лучшей производительности. Если вы не хотите экспериментировать, просто используйте встроенный в ядро agpgart: </para>
<para/>
<para>Листинг 2.3: Включение agpgart</para>
<para>Device Drivers ---&gt;</para>
<para>Character devices ---&gt;</para>
<para>&lt;*&gt; /dev/agpgart (AGP Support)</para>
<para/>
<para/>
<para>Замечания к архитектурам</para>
<para>Важно: Что касается процессоров x86 и AMD64, встроенный в ядро драйвер конфликтует с двоичным драйвером, выпускаемым nVidia. Если вы собираете ядро для этих процессоров, следует полностью убрать поддержку встроенного драйвера, как показано ниже: </para>
<para/>
<para/>
<para>Листинг 2.4: Удаление встроенного драйвера</para>
<para>Device Drivers ---&gt;</para>
<para>Graphics Support ---&gt;</para>
<para>&lt; &gt;   nVidia Framebuffer Support</para>
<para>&lt; &gt;   nVidia Riva support</para>
<para/>
<para/>
<para>Хорошей альтернативой кадрового буфера будет VESA: </para>
<para/>
<para>Листинг 2.5: Включение поддержки VESA</para>
<para>Device Drivers ---&gt;</para>
<para>Graphics Support ---&gt;</para>
<para>&lt;*&gt;   VESA VGA graphics support</para>
<para/>
<para/>
<para>Затем в разделе «VESA driver type» выберите либо vesafb, либо vesafb-tng. Если у вас процессор AMD64, вы должны выбрать vesafb, а не vesafb-tng: </para>
<para/>
<para>Листинг 2.6: Выбор типа кадрового буфера</para>
<para>(X) vesafb</para>
<para>( ) vesafb-tng</para>
<para/>
<para/>
<para>Если вы используете vesafb, то дополнительную информацию можно посмотреть в файле /usr/src/linux/Documentation/fb/vesafb.txt, или же найдите нужную документацию по кадровому буферу в каталоге /usr/src/linux/Documentation/fb/. </para>
<para/></sect4><sect4><title>Последующая настройка ядра</title>
<para/>
<para>The nvidia-drivers and nvidia-legacy-drivers ebuilds автоматически определят версию ядра на основании символической ссылки /usr/src/linux. Пожалуйста проверьте правильность конфигурации ядра и что эта ссылка правильно указывает на исходные коды. Обратитесь к разделу «Конфигурирование ядра» из Настольной книги за подробностями конфигурирования ядра. </para>
<para/>
<para>Если вы используете gentoo-sources-2.6.11-r6, каталог /usr/src может выглядеть примерно так: </para>
<para/>
<para>Листинг 2.7: Проверка символической ссылки /usr/src/linux</para>
<para># cd /usr/src</para>
<para># ls -l</para>
<para>(Проверьте, что ссылка linux указывает на нужный каталог)</para>
<para>lrwxrwxrwx   1 root root   22 Apr 23 18:33 linux -&gt; linux-2.6.11-gentoo-r6</para>
<para>drwxr-xr-x   4 root root  120 Apr  8 18:56 linux-2.4.26-gentoo-r4</para>
<para>drwxr-xr-x  18 root root  664 Dec 31 16:09 linux-2.6.10</para>
<para>drwxr-xr-x  18 root root  632 Mar  3 12:27 linux-2.6.11</para>
<para>drwxr-xr-x  19 root root 4096 Mar 16 22:00 linux-2.6.11-gentoo-r6</para>
<para/>
<para/>
<para>В приведенном выводе можно увидеть, что символическая ссылка linux указывает на ядро linux-2.6.11-gentoo-r6. </para>
<para/>
<para>Если ссылка не указывает на правильные исходники, вы должны обновить ее: </para>
<para/>
<para/>
<para/>
<para>Листинг 2.8: Создание или обновление символической ссылки /usr/src/linux</para>
<para># cd /usr/src</para>
<para># ln -snf linux-2.6.11-gentoo-r6 linux</para>
<para/>
<para/>
<para>Необязательный шаг: уточнение поддержки устаревших видеокарт</para>
<para>Примечание: К несчастью, некоторые устаревшие видеокарты не поддерживаются более новыми версиями пакетов nvidia-drivers. У nVidia есть список поддерживаемых видеокарт. Посмотрите этот список, прежде чем будете устанавливать драйверы. </para>
<para/>
<para/>
<para>В следующем списке указаны неподдерживаемые ныне видеокарты: </para>
<para/>
<para>Листинг 2.9: Неподдерживаемые видеокарты</para>
<para>TNT2</para>
<para>TNT2 Pro</para>
<para>TNT2 Ultra</para>
<para>TNT2 Model 64 (M64)</para>
<para>TNT2 Model 64 (M64) Pro</para>
<para>Vanta</para>
<para>Vanta LT</para>
<para>GeForce 256</para>
<para>GeForce DDR</para>
<para>GeForce2 GTS</para>
<para>GeForce2 Pro</para>
<para>GeForce2 Ti</para>
<para>GeForce2 Ultra</para>
<para>GeForce2 MX Integrated graphics</para>
<para>Quadro</para>
<para>Quadro2 Pro</para>
<para>Quadro2 EX</para>
<para/>
<para/>
<para>Если ваша карта присутствует в списке устаревших карт, то для поддержки 3D вам потребуется установить nvidia-legacy-drivers. </para>
<para/></sect4><sect4><title>Установка подходящих драйверов</title>
<para/>
<para>Теперь пора установить драйверы. </para>
<para/>
<para>Листинг 2.10: Установка драйверов nVidia</para>
<para>(если вашей карты нет в списке устаревших карт)</para>
<para># emerge nvidia-drivers</para>
<para>(если ваша карта присутствует в списке устаревших карт)</para>
<para># emerge nvidia-legacy-drivers</para>
<para/>
<para>Важно: Каждый раз, когда вы собираете новое ядро или пересобираете текущее, вам понадобится запускать emerge nvidia-drivers или emerge nvidia-legacy-drivers для переустановки модулей ядра nVidia. </para>
<para/>
<para/>
<para>После завершения установки запустите modprobe nvidia для загрузки модуля в память. </para>
<para/>
<para>Листинг 2.11: Загрузка модуля</para>
<para># lsmod | grep nvidia &amp;&amp; rmmod nvidia</para>
<para># modprobe nvidia</para>
<para/>
<para/>
<para>Чтобы не приходилось вручную загружать модуль после каждой загрузки, вероятно, вам потребуется, чтобы это делалось автоматически при загрузке, поэтому откройте /etc/modules.autoload.d/kernel-2.6 (или kernel-2.4 в зависимости от используемой версии ядра) и добавьте строку nvidia в файл. После этого не забудьте запустить modules-update. </para>
<para>Важно: Если вы собрали agpgart в качестве модуля, то вам понадобиться указать его в /etc/modules.autoload.d/kernel-2.6 (или kernel-2.4, в зависимости от версии ядра). </para>
<para/>
<para/>
<para>Листинг 2.12: Запуск modules-update</para>
<para># modules-update</para>
<para/>
<para/></sect4><sect4><title>Настройка X-сервера</title>
<para/>
<para>Как только необходимые драйверы установлены, вам потребуется настроить X-сервер, чтобы задействовать драйвер nvidia вместо используемого по умолчанию nv. </para>
<para/>
<para>Откройте файл /etc/X11/xorg.conf своим любимым текстовым редактором (как nano или vim) и найдите раздел Device. В этом разделе измените строку Driver: </para>
<para/>
<para>Листинг 2.13: Замена nv на nvidia в файле настроек X-сервера</para>
<para>Section "Device"</para>
<para>  Identifier "nVidia Inc. GeForce2"</para>
<para>  Driver     "nvidia"</para>
<para>  VideoRam   65536</para>
<para>EndSection</para>
<para/>
<para/>
<para>Теперь перейдите в раздел Module и проверьте, что будет загружаться модуль glx, а dri — не будет: </para>
<para/>
<para>Листинг 2.14: Изменение раздела Module</para>
<para>Section "Module"</para>
<para>  (...)</para>
<para>  # Load  "dri"</para>
<para>  Load  "glx"</para>
<para>  (...)</para>
<para>EndSection</para>
<para/>
<para/>
<para>Далее, в разделе Screen проверьте, что каждая из инструкций DefaultDepth установлена в 16 или 24, или что у вас есть только подразделы Display с установленной Depth в 16 или 24. Без этого расширение nVidia GLX не будет запускаться. </para>
<para/>
<para>Листинг 2.15: Обновление раздела Screen</para>
<para>Section "Screen"</para>
<para>  (...)</para>
<para>  DefaultDepth 16</para>
<para>  Subsection "Display"</para>
<para>  (...)</para>
<para>EndSection</para>
<para/>
<para/>
<para>Запустите eselect, чтобы X-сервер использовал GLX-библиотеки nVidia: </para>
<para/>
<para>Листинг 2.16: Запуск eselect</para>
<para># eselect opengl set nvidia</para>
<para/>
<para/></sect4><sect4><title>Добавление пользователей в группу video</title>
<para/>
<para>Добавьте ваших пользователей в группу video, чтобы у них был доступ к файлам устройств nvidia: </para>
<para/>
<para>Листинг 2.17: Добавление пользователя в группу video</para>
<para># gpasswd -a youruser video</para>
<para/>
<para/>
<para>Если вы не используете файловую систему udev, то, в целом, нет необходимости делать шаги, описываемые в следующем разделе, но они ничего не испортят и сделают систему стойкой к переменам. </para>
<para/></sect4><sect4><title>Тестирование карты</title>
<para/>
<para>Для тестирования карты nVidia запустите X и наберите glxinfo | grep direct. Вы должны увидеть, что прямая прорисовка (direct rendering) включена: </para>
<para/>
<para>Листинг 2.18: Проверка статуса прямой прорисовки</para>
<para>$ glxinfo | grep direct</para>
<para>direct rendering: Yes</para>
<para/>
<para/>
<para>Чтобы узнать скорость прорисовки FPS (кадров в секунду), используйте программу glxgears. </para>
<para/></sect4><sect4><title>Включение поддержки nvidia</title>
<para/>
<para>Некоторые пакеты, например, mplayer и xine-lib, используют локальный USE-флаг «nvidia», который разрешает поддержку аппаратного ускорения потока Mpeg (XvMCNVIDIA), полезного при просмотре широкоформатных фильмов. Добавьте «nvidia» к переменной USE в файле /etc/make.conf или добавьте его в качестве USE-флага для media-video/mplayer и/или media-libs/xine-lib в /etc/portage/package.use. </para>
<para/>
<para>Затем запустите emerge -uD --newuse world, чтобы пересобрать приложения, которых коснулось изменение USE-флагов. </para>
<para/></sect4><sect4><title>Использование инструмента nVidia Settings</title>
<para/>
<para>Начиная с версии 1.0.6106, компания nVidia поставляет программу настройки. Эта программа может изменять настройки графики без перезапуска X-сервера и находится в дереве Portage под названием media-video/nvidia-settings. </para>
<para/></sect4></sect3><sect3><title>3. Проблемы</title>
<para/><sect4><title>Работа 2D на компьютерах с ОЗУ 4 ГБ и более</title>
<para/>
<para>Если вы сталкиваетесь с проблемами при 2D-ускорении nVidia, скорее всего, вы не можете установить диапазон совмещения записи (write-combining range) для MTRR. Чтобы проверить это, просмотрите содержимое /proc/mtrr: </para>
<para/>
<para>Листинг 3.1: Включена ли поддержка write-combining</para>
<para># cat /proc/mtrr</para>
<para/>
<para/>
<para>Каждая строка должна содержать «write-back» или «write-combining». Если вы видите строку, содержащую «uncachable», то вам понадобится изменить настройки BIOS, чтобы исправить это. </para>
<para/>
<para>Перезагрузитесь и войдите в BIOS, затем найдите настройки MTRR (возможно в «CPU Settings»). Измените установки с «continuous» на «discrete» и загрузитесь назад в Linux. Теперь вы не нигде не должны увидеть значения «uncachable», и 2D-ускорение должно работать без какого-либо замедления. </para>
<para/></sect4><sect4><title>Пытаясь загрузить модуль ядра, я в ответ получаю «no such device» </title>
<para/>
<para>Обычно это происходит, когда у вас нет подходящей видеокарты. Убедитесь, что ваша видеокарта основана на чипе nVidia (это можно проверить командой lspci). </para>
<para/>
<para>Если вы уверены, что у вас карта nVidia, проверьте BIOS и проверьте, включен ли параметр Assign IRQ to VGA. </para>
<para/></sect4></sect3><sect3><title>4. Настройка для опытных</title><sect4><title>Документация</title>
<para/>
<para>Пакет драйверов nVidia поставляется с исчерпывающей документацией. Она устанавливается в /usr/share/doc, ее можно посмотреть следующей командой: </para>
<para/>
<para>Листинг 4.1: Просмотр документации NVIDIA</para>
<para>(для nvidia-drivers)</para>
<para>$ less /usr/share/doc/nvidia-drivers-*/README.gz</para>
<para>(для nvidia-legacy-drivers)</para>
<para>$ less /usr/share/doc/nvidia-legacy-drivers-*/README.gz</para>
<para/>
<para/></sect4><sect4><title>Параметры модуля ядра</title>
<para/>
<para>Модуль ядра nvidia способен принимать некоторые параметры, с помощью которых вы можете изменять поведение драйвера. Большинство из них описано в документации. Чтобы добавить или изменить эти параметры, отредактируйте файл /etc/modules.d/nvidia. Не забудьте запустить modules-update после изменения этого файла и держите в голове, что вам понадобиться перезагрузить модуль nvidia, чтобы новые настройки подействовали. </para>
<para/>
<para>Листинг 4.2: Изменение параметров nvidia</para>
<para>(Отредактируйте /etc/modules.d/nvidia вашим любимым редактором)</para>
<para># nano -w /etc/modules.d/nvidia</para>
<para>(Обновление информации о модулях)</para>
<para># modules-update</para>
<para>(Выгрузка модуля nvidia...)</para>
<para># modprobe -r nvidia</para>
<para>(...и его загрузка снова)</para>
<para># modprobe nvidia</para></sect4><sect4><title>Расширенная настройка X-сервера</title>
<para/>
<para>GLX-интерфейс также имеет множество настраиваемых параметров. Они управляют настройками TV-вывода, двойных мониторов, определением частоты монитора и т.д. И снова, все доступные параметры подробно описаны в документации. </para>
<para/>
<para>Если вы хотите задействовать любой из этих параметров, то вам нужно перечислить их в соответствующем разделе Device конфигурационного файла X-сервера (обычно /etc/X11/xorg.conf). Например, я хочу отключить всплывающий логотип nVidia при загрузке X-сервера: </para>
<para/>
<para>Листинг 4.3: Расширенная конфигурация nvidia в настройках X-сервера</para>
<para>Section "Device"</para>
<para>  Identifier "nVidia Inc. GeForce2"</para>
<para>  Driver     "nvidia"</para>
<para>  Option     "NoLogo" "true"</para>
<para>  VideoRam   65536</para>
<para>EndSection</para>
<para/></sect4></sect3></sect2><sect2><title>Распространенные вопросы об ATI в Gentoo Linux</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/xorg-config.xml">http://www.gentoo.org/doc/ru/ati-faq.xml</ulink>
</para>
<para>С версии: 1.0</para>
<para/><sect3><title>1. Поддержка устройств</title>
<para/>
<para>Поддерживается ли моя видеоплата ATI?</para>
<para/>
<para>В xorg-x11 поддерживаются многие (но не все) видеоплаты ATI, по крайней мере, поддерживаются их функции ускорения двумерной графики. Поддержка трехмерного ускорения обеспечивается либо проектом DRI, входящим в состав xorg-x11, либо драйверами с закрытым исходным кодом, поставляемыми фирмой ATI. </para>
<para>Графический процессор Распространенное название        Поддержка</para>
<para>Rage128                               Rage128                                                    xorg DRI</para>
<para>R100        Radeon 7xxx,            Radeon 64                                                    xorg DRI</para>
<para>R200, R250, R280        Radeon 8500, Radeon 9000, Radeon 9200        xorg DRI, ATI DRI</para>
<para>R300, R400, R500        Radeon 9500—x800        xorg 2D, ATI DRI</para>
<para/>
<para/>
<para>У меня есть видеоплата All-In-Wonder/Vivo. Поддерживаются ли ее мультимедийные возможности? </para>
<para/>
<para>Мультимедийные возможности этой платы поддерживаются проектом GATOS. Эти драйверы будут в скором времени включены в дерево разработки xorg. </para>
<para/>
<para>Я использую не архитектуру x86. Какие у меня варианты?</para>
<para/>
<para>Поддержка X11 на платформах PPC и Alpha сходна с поддержкой X11 на x86. Однако, драйверы производства ATI с закрытым исходным кодом не поддерживаются на PPC или Alpha, поэтому вы не сможете использовать трехмерные возможности графического процессора (ГП) R300. Если у вас именно такая видеоплата, и вы хотите, чтобы она поддерживалась в X11, свяжитесь с ATI и потребуйте, чтобы они выпустили описание вашего ГП. Для AMD64 уже выпущены закрытые драйверы, поэтому теперь пользователи AMD64 могут наслаждаться теми же возможностями видеоплат, что и пользователи x86. </para>
<para>Важно: Для включения поддержки agpgart на некоторых материнских платах AMD64 вам потребуется отключить поддержку K8 IOMMU. </para>
<para/>
<para/>
<para>У меня есть ноутбук. Поддерживается ли моя модель ATI Mobility?</para>
<para/>
<para>Должна, но у вас может возникнуть проблема с настройкой из-за идентификатора OEM PCI ID, присвоенного изготовителем. В большинстве случаев, вам может потребоваться самостоятельно составить файл конфигурации или использовать утилиту xorgconfig. </para>
<para/></sect3><sect3><title>2. Установка</title>
<para/>
<para>Пакеты</para>
<para>В пакете xorg-x11 представлена реализация X11</para>
<para>В ядрах 2.6.x модули DRI могут собираться вместе с ядром или устанавливаться пакетом x11-drm </para>
<para>В ядрах 2.4.x необходимо использовать пакет x11-drm </para>
<para>В пакете ati-drivers представлены закрытые драйверы ATI для X и модули ядра для ядер как серии 2.4, так и 2.6 </para>
<para/>
<para>Если вы хотите использовать внутреннюю поддержку agpgart производства ATI вместо предоставляемой в ядре Linux, то драйвер agpgart и драйвер материнской платы (в конфигурации вашего ядра) должны быть собраны как модули или вообще не собираться. </para>
<para/>
<para>Листинг 2.1: Установка драйверов</para>
<para>(если нужно установить с X11 только драйверы и модули Rage128)</para>
<para># VIDEO_CARDS="r128" emerge x11-drm</para>
<para/>
<para>(чтобы получить только поддержку Radeon)</para>
<para>(R100, R200, R250, R280, пока без R300)</para>
<para># VIDEO_CARDS="radeon" emerge x11-drm</para>
<para/>
<para>(чтобы установить драйверы фирмы ATI с закрытым исходным кодом)</para>
<para>(R200, R250, R280 и R300)</para>
<para># emerge ati-drivers</para>
<para/>
<para>(чтобы установить X11 без каких-либо модулей ядра)</para>
<para># emerge xorg-x11</para>
<para/>
<para/>
<para>Настройка</para>
<para/>
<para>Для создания конфигурационного файла xorg.conf рекомендуется использовать xorgcfg или xorgconfig. В качестве альтернативы вы можете использовать параметр автоконфигурации Xorg: </para>
<para/>
<para>Листинг 2.2: Автоматическая настройка X</para>
<para># X -configure</para>
<para/>
<para/>
<para>За дополнительной информацией о том, как создать базовый файл конфигурации xorg.conf, пожалуйста обратитесь к описанию настройки X-сервера в Gentoo. </para>
<para/>
<para>Примечание: Если вы установили пакет ati-drivers, вы также сможете использовать fglrxconfig. </para>
<para/>
<para>Важно: У пользователей PPC есть возможность использовать отдельный конфигуратор Xorgautoconfig, установив пакет Xorgautoconfig, но это необязательно. </para>
<para/>
<para/>
<para/>
<para/>
<para/>
<para>Переключение на OpenGL</para>
<para/>
<para>Как только X установлен, настроен и заработал, он способен использовать библиотеки ATI OpenGL: </para>
<para/>
<para>Листинг 2.3: Запуск eselect</para>
<para># eselect opengl set ati</para>
<para/></sect3><sect3><title>3. Дополнительные источники</title>
<para/>
<para>Прочтите Hardware Acceleration Guide для получения дополнительных сведений по настройке своей графической карты ATI. </para>
<para/>
<para>Дополнительные сведения о Gentoo Linux и двоичных драйверах ATI можно прочитать в Wedge Unofficial Gentoo ATI Radeon FAQ.</para>
<para/>
<para/></sect3></sect2></sect1><sect1><title>HOWTO fbsplash</title>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/kde-config.xml">http://ru.gentoo-wiki.com/HOWTO_fbsplash</ulink>
</para>
<para>С версии: 1.2</para>
<para/><sect2><title>Введение </title>
<para>Во первых я хочу выразить благодарность gentoo-разработчику <ulink url="http://dev.gentoo.org/%7Espock/">Spock</ulink> за разработку gensplash (fbsplash and splashutils) и vesafb-tng. Как альтернативу этому how-to, вы можете попробовать Spock's <ulink url="http://dev.gentoo.org/%7Espock/projects/gensplash/gensplash-in-5-easy-steps.php">Gensplash-in-5-easy-steps How-to</ulink>. </para><sect3><title>Что такое gensplash?</title>
<para>Gensplash - это проект основаный <ulink url="http://dev.gentoo.org/%7Espock/">Spock`ом</ulink>, цель которого — создание набора инструментов, способных "обогатить" процесс загрузки Gentoo (отображение сообщений, анимации, полос состояния, и т. д.). </para></sect3><sect3><title>Что такое fbsplash (framebuffer splash)?</title>fbsplash (framebuffer splash)<para>Fbsplash - это часть gensplash проекта. Согласно документации по fbsplash, "framebuffer splash - это особенность ядра которая разрешает отображать фоновые изображения на выбранных консолях и переключать первую консоль в так называемый безмолвный режим (silent mode),в то время когда система загружается/перезагружается/выключается. Доступ до устройства fbsplash осуществляется путем обращения к /dev/fbsplash. Для работы с fbsplash, требуется устройсво поддерживающее framebuffer. </para></sect3><sect3><title>Что такое устройство frame buffer?</title>
<para>Устройство frame buffer обеспечивает уровень абстракции устройствам вывода графики, что обеспечивает буфер кадров некоторых видеоустройств и интерфейс доступа к ним для программного обеспечения, т. е. программе не обязательно знать о существовании низкоуровневых системных вызовов, регистров и т. д. Доступ к устройству осуществляется через определенные файлы, обычно расположенные в ветке /dev дерева каталогов, в частности /dev/fb*. </para>
<para>Существует множество различных frame buffer устройств. </para>
<orderedlist>
<listitem>
<para>Некоторые из них, стандартные поддерживают большинство современных видеокарт: </para>
</listitem>
<listitem>
<para>Другие специфичные, будут работать только с определенными моделями: </para>
</listitem>
</orderedlist>
<para>Предполагается, что Fbsplash будет работать на любом из frame buffer устройств (и вообще на любой видеокарте способной на 8/15/16/24/32 битную цветовую гамму и directcolor/pseudocolor режимы). </para></sect3></sect2><sect2><title>Установка fbsplash и splashutils</title>
<para>В дальнейшем как пример используется vesafb-tng frame buffer устройство. Также подразумевается что вы используете Gentoo дистрибутив. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Emerging splashutils &amp; themes </para>
</entry>
</row>
<row>
<entry>
<para># emerge -va splashutils splash-themes-gentoo splash-themes-livecd</para>
</entry>
</row></tbody></tgroup>
</informaltable><sect3><title>Установка заплат ядра</title>
<para>Во первых убедитесь что fbsplash и vesafb-tng заплаты установлены в вашем ядре. Начиная с версии 2.6.10 ( а может и раньше ) всё это входит в gentoo-sources. Если у вас нет этих заплат вы можете взять их с <ulink url="http://dev.gentoo.org/%7Espock/">Spock's homepage</ulink> </para></sect3><sect3><title>Конфигурация ядра</title>
<para>Во первых нужно включить поддержку vesafb-tng frame buffer в вашем ядре (вы можете пропустить этот шаг если у вас уже настроен framebuffer драйвер отличный от vesa-tng, например i810fb): </para>
<para>Device Drivers ---&gt; Graphics support---&gt;:</para>
<para> &lt;*&gt; Support for frame buffer devices</para>
<para> &lt;*&gt;   VESA VGA graphics support</para>
<para>       VESA driver type (vesafb-tng)</para>
<para> (1280x1024@60) VESA default mode</para>
<para>Еще вам нужна поддержка fbsplash в вашем ядре. </para>
<para>Device Drivers &gt; Graphics support &gt; Console display driver support:</para>
<para> &lt;*&gt; Framebuffer Console support</para>
<para> &lt;*&gt; Support for the framebuffer splash</para>
<para>Если вы хотите загружать initramfs изображение динамически во время загрузки ( смотрите "Загрузка initramfs изображений динамически во время загрузки" раздел этого howto), вы можете включить еще одну специальную опцию. Если вы ещё не знаете что хотите делать, включите её все равно ( это не повредит :) </para>
<para>Device Drivers &gt; Block devices:</para>
<para> &lt;*&gt; RAM disk support</para>
<para> (4096) Default RAM disk size (kbytes) (NEW)</para>
<para> [*]   Initial RAM disk (initrd) support</para>
<para>Initial RAM disk (initrd) support теперь (в ядре 2.6.22) находится в General setup. </para></sect3><sect3><title>Компиляция ядра (Вручную)</title>
<para># cd /usr/src/linux</para>
<para>Вы должны убедится что не осталось файлов после предыдущей компиляции в каталоге вашего ядра: </para>
<para># make mrproper</para>
<para>Теперь настраиваем ядро. </para>
<para># make menuconfig</para>
<para>После того как вы настроили ваше ядро, откомпилируйте (Важно: этот шаг нужно сделать до установки splashutils). "make" скомпилирует одновременно и образ ядра('make bzImage') и модули ('make modules'). </para>
<para># make</para></sect3><sect3><title>Конфигурация / компиляция ядра (Для пользователей genkernel)</title>
<para>Необходимо запустить genkernel со следующими ключами: </para>
<para># genkernel --gensplash=livecd-2006.0 --gensplash-res=1280x1024 --menuconfig all</para>
<para>где ключи означают следующее: </para>
<para>--gensplash=livecd-2006.0 - использовать тему livecd-2006.0 (из пакета splash-themes-livecd), </para>
<para>--gensplash-res=1280x1024 - при загрузке необходимо использовать разрешение 1280x1024, </para>
<para>--menuconfig - необходимо запустить ncurses конфигуратор ядра, </para>
<para>all - компилировать ядро, модули и initrd образ. </para></sect3><sect3><title>Установка splashutils</title>
<para>Теперь настало время для установки splashutils. Splashutils это ПО используемое для загрузки изображений (а также перекодировки jpg, png). </para>
<para># emerge splashutils</para>
<para>Конечно, /usr/src/linux должна ссылаться на исходники с установленными заплатами.. </para></sect3><sect3><title>Конфигурация / компиляция ядра (ручная работа)</title>
<para>Теперь ваше ядро и система подготовлены для того чтобы показать splash screen. Для завершения компиляции и установки вашего нового ядра осталось сделать следующее. </para>
<para>Если /boot расположен на отдельном разделе подмонтируйте его. </para>
<orderedlist>
<listitem>
<para>mount /boot </para>
</listitem>
</orderedlist>
<para>Затем инсталируйте модули и образ ядра. </para>
<orderedlist>
<listitem>
<para>make modules_install </para>
</listitem>
<listitem>
<para>make install </para>
</listitem>
</orderedlist></sect3></sect2><sect2><title>Создание образа initramfs </title>
<para>Приведенных выше инструкций (а также второй части следующего howto, <ulink url="http://gentoo-wiki.com/HOWTO_fbsplash#Configuring_your_bootloader">Configuring your bootloader</ulink>) достаточно, чтобы получить splash screen после того как ядро будет загруженно. Однако если вы хотите чтобы сексапильная девка с пингвином на маечке появлялась раньше (сразу после инициализации - vesafb-tng), вам понадобится initramfs. </para><sect3><title>Что такое initramfs?</title>Что такое initramfs<para>(Цитата <ulink url="http://dev.gentoo.org/%7Espock/">Spock'а</ulink>): "Initramfs (initial ramfs) это кусок кода который распаковывает сжатый cpio образ во время загрузки ядра. </para>
<para>Чтобы использовать initramfs его надо сначала создать.Образ initramfs должен содержать: </para>
<orderedlist>
<listitem>
<para>картинки,которые будут использоваться как фон; </para>
</listitem>
<listitem>
<para>необходимы файлы конфигурации; </para>
</listitem>
<listitem>
<para>утилиту помощника (splash_helper). </para>
</listitem>
</orderedlist>
<para>Изображения и конфигурационные файлы вместе образуют тему gensplash. </para>
<para>Существует два пути для использования initramfs image: </para>
<orderedlist>
<listitem>
<para>компиляция initramfs image непосредственно в ядро; </para>
</listitem>
<listitem>
<para>загрузка initramfs image динамически во время загрузки системы (с использованием 'initial ram disk' - initrd). </para>
</listitem>
</orderedlist>
<para>Вы можете сами выбирать вариант,который вам по душе. . </para></sect3><sect3><title>Компиляция образа initramfs непосредственно в ядро</title>
<para>Сначала удалите старый образ initramfs: </para>
<para># rm /usr/src/linux/usr/initramfs_data.cpio.gz</para>
<para>Теперь создайте новый образ initramfs, содержащий изображения, конфгурационные файлы и userspace helper. Проще всего будет сделать это при помощи splash_geninitramfs (идущим в составе splashutils). Его использование похоже на утилиту 'splash' из пакета bootsplash. </para>
<para># splash_geninitramfs -v -g /usr/src/linux/usr/initramfs_data.cpio.gz -r 1024x768 emergence</para>
<para>При компиляции образа initramfs непосредственно в ядро, вам придется пересобрать ядро (этого недостатка лишен способ с использованием initrd): </para>
<para># cd /usr/src/linux</para>
<para># touch usr/initramfs_data.cpio.gz</para>
<para># make bzImage</para>
<para># mount /boot</para>
<para># make install</para></sect3><sect3><title>Загрузка образа initramfs динамически</title>
<para>Этот вариант практически идентичен сборке образа initramfs вместе с ядром. Различие заключается в том, что вместо создания образа внутри ядра (и последующей сборке его коммандой 'make' и копированием в точку монтирования /boot при помощи 'make install'), вы создадите образ initramfs как отдельный (initrd) файл и вам не придется пересобирать ядро. Однако, придется добавить строчку в конфигурационный файл загрузчика (по которой он найдет initrd файл). Этим мы и займемся в этой части howto </para>
<para>Сначала при помощи splash_geninitramfs создадим initrd файл (который содержит изображения, конфиги и userspace helper): </para>
<para># mount /boot</para>
<para># cd /etc/splash</para>
<para># splash_geninitramfs -v -g /boot/fbsplash-emergence-1024x768  -r 1024x768 emergence</para>
<para>Как видно файл будет создан в точке монтирования(или каталоге) /boot. </para>
<para>К сожалению, по <ulink url="http://forums.gentoo.org/viewtopic.php?p=1488636#1488636">словам Spock'а</ulink>,"вы не сможете дописать новую initramfs информацию к initrd образу". Это означает, что данной возможностью не смогут воспользоваться пользователи genkernel ядер, т. к. genkernel создает собственный образ initrd для процесса загурзки. </para>
<para>solshark [solshark_at_rambler_dot_ru]: genkernel 3.3.6 позволяет сделать так: </para>
<orderedlist>
<listitem>
<para>genkernel --gensplash=DangerGirl initrd </para>
</listitem>
</orderedlist>
<para>Так что теперь и для пользователей genkernel есть возможность воспользоваться данной фишкой. </para>
<para>Если вы не меняете ядро, то просто поменяйте строку описания initrd в grub.conf с: </para>
<para>root=/dev/ram0 real_root=/dev/$ROOT</para>
<para>initrd (hd0,0)/boot/initrd</para>
<para>на: </para>
<para>root=/dev/$ROOT</para>
<para>initrd (hd0,0)/boot/fbsplash-emergence-1024x768</para></sect3><sect3><title>Создание собственных тем для gensplash</title>
<para>Стандартная тема 'emergence' и её конфигурационные файлы находятся в /etc/splash/emergence. </para>
<para>Если хотите создать новую (например с названием 'newtheme'), вам следует: </para>
<para>1. создать для неё каталог в /etc/splash: </para>
<para># mkdir /etc/splash/newtheme</para>
<para>2. создать каталог 'images' в /etc/splash/newtheme: </para>
<para># mkdir /etc/splash/newtheme/images</para>
<para>и скоприовать туда картинки (в форматах png/jpg) которые будут использованы в теме. </para>
<para>3. создать необходимые конфигурационные файлы. Они должны иметь расширение *.cfg и находиться в каталоге темы (/etc/splash/newtheme). Образцы конфигруационных файлов можно посмотреть в теме ('emergence'): </para>
<para># ls -l /etc/splash/emergence/</para>
<para>images/</para>
<para>1024x768.cfg</para>
<para>1280x1024.cfg</para>
<para>800x600.cfg</para>
<para>Очень важно убедиться в том в опциях 'jpeg=' и 'silentjpeg=' (в *.cfg файлах) прописаны корректные ссылки на файлы с изображениями (в каталоге/etc/splash/newtheme/images). Если вы не используете jpeg для создания темы, замените опции на 'pic=' и 'silentpic='. </para>
<para>Для более близкого знакомства с форматом тем fbsplash, изучите документацию пакета splashutils: </para>
<para># less /usr/doc/splashutils-version/theme_format.gz</para></sect3><sect3><title>Перевод тем bootsplash в темы gensplash</title>
<para>Так же Spock сделал удобную утилиту bootsplash2fbsplash (этот скрипт идет в комплекте со splashutils) ,который сделает легким преобразование тем bootsplash формат gensplash. </para>
<para>Например если у вас есть тема 'gentoo-highquality' ,расположенная в /etc/bootsplash ,вам нужно только скомандовать(от рута): </para>
<para># bootsplash2fbsplash gentoo-highquality</para>
<para>и утилита сделает gensplash-совместимую тему в каталоге /etc/splash (/etc/splash/gentoo-highquality) со всеми необходимыми файлами. </para></sect3><sect3><title>Использование собственных тем gensplash</title>
<para>Для создания нового образа из темы которую вы только что сделали(пусть ее имя 'newtheme',а разрешение 1280x1024), вам необходимо использовать splash_geninitramfs. </para>
<para>Если вы решили вкомпилировать образ в ядро(первый вариант): </para>
<para># splash_geninitramfs -v -g /usr/src/linux/usr/initramfs_data.cpio.gz -r 1280x1024 newtheme</para>
<para># cd /usr/src/linux</para>
<para># touch usr/initramfs_data.cpio.gz</para>
<para># make bzImage</para>
<para># mount /boot</para>
<para># make install</para>
<para>Если вы используете initrd (второй вариант): </para>
<para># mount /boot</para>
<para># splash_geninitramfs -v -g /boot/fbsplash-newtheme-1280x1024 -r 1280x1024 newtheme</para>
<para>Вот что означают опции splash_geninitramfs: </para>
<para>-v  splash_geninitramfs выводит дополнительную информацию</para>
<para>-g указывает splash_geninitramfs создать образ initramfs</para>
<para> (/usr/src/linux/usr/initramfs_data.cpio.gz</para>
<para> или /boot/fbsplash-newtheme-1280x1024)</para>
<para>-r говорит splash_geninitramfs использовать разрешение 1280x1024</para>
<para>-'newtheme'указывает splash_geninitramfs искать .cfg файлы</para>
<para> в каталоге /etc/splash/newtheme</para>
<para>Для просмотра описания всех опций splash_geninitramfs' введите: </para>
<para># splash_geninitramfs --help</para>
<para>Последний пункт в этой части how-to,полезный совет из документации splashutils': </para>
<para>Если вы хотите сохранить немного памяти и не планируете использовать </para>
<para>все доступные разрешения вы можете скопировать .cfg файлы</para>
<para>и фоновые картинки только для того разрешения,которое вы используете.</para>
<para>А теперь пришло время настроить ваш загрузчик. </para></sect3></sect2><sect2><title>Настройка загрузчика </title><sect3><title>Параметры ядра</title>
<para>Вот опции,которые необходимо добавить в конфигурационный файлы grub(lilo): </para>
<para>1. Необходимо указание устройства frame buffer.Вот как это может выглядеть например для драйвера vesafb-tng: </para>
<para>video=vesafb:ywrap,mtrr,1024x768-16@85</para>
<para>Вышеприведенный пример указывает на то,что мы хотим использовать разрешение 1024x768, 16 бит цвет и частоту обновления 85Hz. Если вы используете vesafb-tng, вам также необходимо удалить опцию 'vga=' из файла конфигурации вашего загрузчика(эта опция используеться только 'обычными' vesafb frame buffer устройствами): </para>
<para># НЕ СТАВЬТЕ опцию 'vga=' для vesafb-tng (если она стоит,то удалите ее):</para>
<para>vga=791</para>
<para>vga=0x517</para>
<para>2. fbsplash'у необходимы свои параметры: </para>
<para>splash=verbose,theme:emergence</para>
<para>Сначала fbsplash выбирает режим (в примере используется режим 'verbose' ). Вот цитата из документации по fbsplash "fbsplash может работать в двух режимах: verbose и silent. Первый режим подразумевает простую консоль с фоновым рисунком. Режим silent был впервые реализован в bootsplash. Когда этот режим включен, консоль переключается в графический режим. При этом, текст не печатается. Все что будет отображатся в этом режиме зависит от программ, запущенных в пользовательском пространстве. Таким образом, может быть реализован, например, индикатор прогресса загрузки. </para>
<para>Вторая часть парметра fbsplash позволяет указать какую тему нужно использовать (в примере используется стандартная тема 'emergence'). </para>
<para>Для работы fbsplash необходимо указать оба параметра: режим и тему. </para>
<para>3. Если вы решили использовать initrd (посмотрите предыдущую главу - <ulink url="http://gentoo-wiki.com/HOWTO_fbsplash#Loading_the_initramfs_image_dynamically_at_boot_time">Загрузка образа initramfs</ulink>), вам необходимы дополнительные опции в конфигурации загрузчика: </para>
<para>initrd /boot/fbsplash-emergence-1024x768     # Grub</para>
<para>initrd = /boot/fbsplash-emergence-1024x768   # Lilo</para>
<para>В приведенном примере подразумевается?что имя рамдиска fbsplash-emergence-1024x768 (и он размещен в каталоге или разделе /boot). </para>
<para>Следующие примеры для обоих загрузчиков grub и lilo. Используется тема 'newtheme', разрешение 1280x1024, 32 бит цвети частота обновления 70Hz. Указан режим fbsplash 'silent' и используется initrd файл. </para></sect3><sect3><title>Пример конфигурации Grub</title>
<para>title  Gentoo</para>
<para>root (hd0,0)</para>
<para>kernel (hd0,0)/kernel-2.6.8-gentoo-r1 root=/dev/hda3 video=vesafb:ywrap,mtrr,1280x1024-32@70 splash=silent,theme:newtheme</para>
<para>initrd (hd0,0)/fbsplash-newtheme-1280x1024</para>
<para>Замените (hd0,0) своим загрузочным разделом (или,если /boot не на отдельном разделе,используйте корневой раздел добавив '/boot' к путям образа ядра и initrd) </para>
<para>Пользователи genkernel должны использовать что-то типа этого(все в одной строке): </para>
<para>kernel (hd0,0)/kernel-2.6.8-gentoo-r1 init=/linuxrc root=/dev/hda3 video=vesafb:ywrap,mtrr,1280x1024-32@70 splash=silent,theme:newtheme</para></sect3><sect3><title>Пример конфигурации Lilo</title>
<para>image=/boot/kernel-2.6.8-gentoo-r1</para>
<para>label = "Gentoo"</para>
<para>root = /dev/hda3</para>
<para>append="video=vesa:ywrap,mtrr,1280x1024-32@70 splash=silent,theme:newtheme" </para>
<para>read-only</para>
<para>initrd = /boot/fbsplash-newtheme-1280x1024</para>
<para>Не забудьте запустить lilo после изменения lilo.conf: </para>
<para># mount /boot</para>
<para># lilo -v</para>
<para>После ребута и вы получите графическую загрузку. </para></sect3></sect2><sect2><title>Добавление фона на все консоли </title>
<para>Если вы хотите чтобы на всех консолях был сплеш (картинка из режима 'verbose'),а не только на первой,то отредактируйте /etc/conf.d/splash установив нужные опции и и добавьте splash в ваш стандартный уровень запуска: </para>
<para> # rc-update add splash default</para>
<para>Если вы используете bootsplash, удалите его из уровня запуска: </para>
<para> # rc-update del bootsplash</para></sect2><sect2><title>Gensplash для других дистрибутивов </title>
<para>(Jakub) Я думаю этот раздел должен состоять из трех частей: </para>
<para>Вступление: Gensplash работает на других дистрибутивах. </para>
<orderedlist>
<listitem>
<para>Что нужно сделать по-другому (в сравнении с этим руководством) - к примеру из-за отсутствия emerge. Это касается всех дистрибутивов не подобных Gentoo. </para>
</listitem>
<listitem>
<para>Какие дополнительные действия нужно предпринять - например модификация загрузочных скриптов. Тоже для не Gentoo дистрибутивов. </para>
</listitem>
<listitem>
<para>Другая специфика не охваченная предыдущими двумя разделами. </para>
</listitem>
</orderedlist>
<para>Различия </para>
<orderedlist>
<listitem>
<para>Наложение патчей на ядро - необходимо. Мы не используем gentoo-dev-sources (хотя все возможно) </para>
</listitem>
<listitem>
<para>Конфигурация/сборка ядра - из-за невозможности использования genkerel. </para>
</listitem>
<listitem>
<para>Установка splashutils - нет package.keywords, нет emerge. Ручками:). Добавить ссылки. Предложение перейти на Gentoo было бы своевременно. </para>
</listitem>
<listitem>
<para>Добавление splash screen на все терминалы(и удаление bootpslash) - скорее всего зависит от дистрибутива. Способ для Gentoo скорее всего работать не будет (очевидно). </para>
</listitem>
</orderedlist><sect3><title>Дополнительные шаги</title>
<para>Модификация загрузочных скриптов потребуется для работы индикатора прогресса. Два варианта: </para>
<orderedlist>
<listitem>
<para>с использованием bootsplash (простой) </para>
</listitem>
<listitem>
<para>без использования bootsplash (более сложный) </para>
</listitem>
</orderedlist></sect3><sect3><title>Тут должно быть название пункта 3</title>
<para>Вариант для Debian упоминался Spock'ом на forums.gentoo.org. </para></sect3></sect2><sect2><title>Решение проблем </title><sect3><title>Если /usr на отдельном разделе</title>
<para>Если у вас splashutils версии 0.9-pre08 и новее и каталог /usr монтируется с другого раздела, gensplash должен работать "из коробки" (без напильника). Однако, если у вас более древняя версия splashutils и, по каким-либо причинам, нет возможности ее обновить следуйте нижеописанным инструкциям. </para>
<para>Программы и библиотеки, которые нужны splash_util'у чтобы запустить fbset и отобразить вашу сплешку расположены в /usr/bin и /usr/lib. И если эти каталоги находятся на других разделах (например при использовании RAID или LVM2 архитектуры), они могут быть недоступны (не примонтированы)в момент, когда они нужны splash_utils и вы не сможете увидеть свою замечательную сплешку. </para>
<para>Как решить ? Скопируйте их в место где они доступны как описано в (спасибо aslocum и форумам Gentoo) <ulink url="http://forums.gentoo.org/viewtopic.php?t=206778&amp;start=200&amp;postdays=0&amp;postorder=asc&amp;highlight=">Gensplash-How-to with progressbar!!!!!</ulink> треде: </para>
<para># cp /usr/bin/fbset /sbin</para>
<para># cp /usr/lib/libjpeg.so.62 /lib</para>
<para># cp /usr/lib/libpng.so.3 /lib</para>
<para>поправьте /sbin/splash (например при помощи nano, набрав nano -w /sbin/splash) и приведите строку 31 к виду: </para>
<para>res=`/sbin/fbset | grep "^mode" | sed -r 's/mode "([0-9]+x[0-9]+).*/\1/'`</para>
<para>Где надо только прописать /sbin/ перед fbset. Сохраните результат и выйдите из редактора, и ваша сплешка должна появиться. </para></sect3><sect3><title>Установка фона во время загрузки</title>
<para>Вы наверное заметили,что фоновое изображение загружается с небольшой задержкой,даже если вы используете образ initramfs .До этого момента используется разрешение 640x480 и черно-белая цветовая гамма. </para>
<para>Такое положение дел нормально. Единственным выходом (чтобы получил фон как можно раньше) будет использование драйвера vesafb вместо vesafb-tng. Вот <ulink url="http://forums.gentoo.org/viewtopic.php?t=206778">ответ </ulink>
<ulink url="http://forums.gentoo.org/viewtopic.php?t=206778">Spock'а</ulink> по этому поводу: "Образ initramfs используется,чтобы подключить корневую ФС ,и до того как инициализируется кадровый буфер,так что не волнуйтесь по этому поводу.Как вы заметили, компъютер загружается в текстовом режиме,а не в графическом. Графический режим устанавливается после инициализации подсистемы кадрового буфера. Но до этого момента должна произойти инициализация других вещей,а это требует времени.Вот почему в течение секунды-двух вы видите сообщения ядра. Вы наверно скажете,что с vesafb у вас такого не было. И будете правы. Но vesafb исключение,а не правило (его инициализация происходит во время загрузки ядра) . Все остальные кадровые драйверы(vesafb-tng, rivafb, radeonfb)инициализируются с подсистемой fbdev". </para></sect3></sect2><sect2><title>Ссылки</title>
<orderedlist>
<listitem>
<para>
<ulink url="http://dev.gentoo.org/%7Espock/">Домашняя страница Spock'а</ulink> </para>
</listitem>
<listitem>
<para>
<ulink url="http://dev.gentoo.org/%7Espock/projects/gensplash/gensplash-in-5-easy-steps.php">Spock's Gensplash-in-5-easy-steps</ulink> </para>
</listitem>
</orderedlist>
<para>Из форумов Gentoo: </para>
<orderedlist>
<listitem>
<para>
<ulink url="http://forums.gentoo.org/viewtopic.php?t=206778">Gensplash-How-to с прогрессбаром!!!!!</ulink> </para>
</listitem>
</orderedlist>
<para>Оффлайновая документация: </para>
<orderedlist>
<listitem>
<para>Документация по Fbsplash (/usr/src/linux/Documentation/fb/splash.txt). </para>
</listitem>
<listitem>
<para>Документация по кадровым буферам (/usr/src/linux/Documentation/fb/framebuffer.txt). </para>
</listitem>
<listitem>
<para>Документация по splashutils (/usr/share/doc/splashutils-0.9_pre07/). </para>
</listitem>
</orderedlist>
<para/>
<para/></sect2></sect1><sect1><title>Hardware 3D Acceleration Guide (Англ.)</title>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/en/dri-howto.xml">http://www.gentoo.org/doc/en/dri-howto.xml</ulink>
</para>
<para>С версии: 1.0</para>
<para/><sect2><title>1. Introduction</title>
<para/>
<para>What is hardware 3D acceleration and why do I want it?</para>
<para/>
<para>With hardware 3D acceleration, three-dimensional rendering uses the graphics processor on your video card instead of taking up valuable CPU resources drawing 3D images. It's also referred to as "hardware acceleration" instead of "software acceleration" because without this 3D acceleration your CPU is forced to draw everything itself using the Mesa software rendering libraries, which takes up quite a bit of processing power. While Xorg typically supports 2D hardware acceleration, it often lacks hardware 3D acceleration. Three-dimensional hardware acceleration is valuable in situations requiring rendering of 3D objects such as games, 3D CAD and modeling. </para>
<para/>
<para>How do I get hardware 3D acceleration?</para>
<para/>
<para>In many cases, both binary and open-source drivers exist. Open-source drivers are preferable since we're using Linux and open source is one of its underlying principles. Sometimes, binary drivers are the only option, like with nVidia's cards. Binary drivers include x11-drivers/nvidia-drivers and x11-drivers/nvidia-legacy-drivers for nVidia cards and media-video/ati-drivers for ATI cards. Other open-source drivers include media-video/kyro-kernel for KyroII cards and media-video/ati-gatos for ATI cards, which aim to support ATI's video capabilities more fully. </para>
<para/>
<para>What is DRI?</para>
<para/>
<para>The Direct Rendering Infrastructure, also known as the DRI, is a framework for allowing direct access to graphics hardware in a safe and efficient manner. It includes changes to the X server, to several client libraries and to the kernel. The first major use for the DRI is to create fast OpenGL implementations. </para>
<para/>
<para>What is X11-DRM and how does it relate to regular Xorg?</para>
<para/>
<para>X11-DRM is an enhancement to Xorg that adds 3D acceleration for cards by adding the kernel module necessary for direct rendering. </para>
<para/>
<para>Purpose</para>
<para/>
<para>This guide is for people who can't get direct rendering working with just Xorg. X11-DRM works for 3dfx, gamma, i8x0, matrox, rage128, radeon, mach64 and sis300 series drivers. VIA card owners should not use x11-drm, but should instead use the DRI provided in recent kernels (&gt;2.6.13). See the DRI homepage for more info and documentation. </para>
<para/>
<para>Feedback</para>
<para/>
<para>With suggestions, questions, etc., e-mail Donnie Berkholz. </para>
<para/></sect2><sect2><title>2. Install Xorg and configure your kernel</title>
<para/>
<para>Install Xorg</para>
<para/>
<para>Please read our Xorg Configuration Guide to get Xorg up and running. </para>
<para/>
<para>Configure your kernel</para>
<para/>
<para>Probe for your chipset and enable just that one. </para>
<para/>
<para>Code Listing 2.1: Checking your AGP chipset</para>
<para># emerge pciutils; lspci | grep AGP</para>
<para># 00:01.0 PCI bridge: Intel Corp. 440BX/ZX/DX - 82443BX/ZX/DX AGP bridge (rev 03)</para>
<para>(Your output may not match the above due to different hardware.)</para>
<para/>
<para/>
<para>If your chipset is not supported by the kernel you might have some succes by passing agp=try_unsupported as a kernel parameter. This will use Intel's generic routines for AGP support. To add this parameter, edit your bootloader configuration file! </para>
<para/>
<para>Most, if not all, kernels should have these options. This was configured using gentoo-sources-2.4.20-r5. </para>
<para/>
<para>Code Listing 2.2: Configuring the kernel</para>
<para># ls -l /usr/src/linux </para>
<para>lrwxrwxrwx    1 root     root           22 May 29 18:20 /usr/src/linux -&gt; linux-2.4.20-gentoo-r5</para>
<para>(Make sure /usr/src/linux links to your current kernel.)</para>
<para># cd /usr/src/linux</para>
<para># make menuconfig</para>
<para/>
<para/>
<para>Code Listing 2.3: make menuconfig options</para>
<para>Processor type and features ---&gt;</para>
<para>&lt;*&gt; MTRR (Memory Type Range Register) support</para>
<para>Character devices ---&gt;</para>
<para>&lt;M&gt; /dev/agpgart (AGP Support)</para>
<para>[M] Intel 440LX/BX/GX and I815/I820/I830M/I830MP/I840/I845/I850/I860 support</para>
<para>(Enable your chipset instead of the above.)</para>
<para>&lt; &gt; Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)</para>
<para/>
<para/>
<para>Make sure the Direct Rendering Manager (DRM) is off. The X11-DRM package will provide its own. </para>
<para/>
<para>Compile and install your kernel</para>
<para/>
<para>Code Listing 2.4: Compiling and installing kernel</para>
<para>(This example is for a 2.4 kernel)</para>
<para># make dep &amp;&amp; make clean bzImage modules modules_install</para>
<para># mount /boot</para>
<para># cp arch/i386/boot/bzImage /boot</para>
<para/>
<para/>
<para>If you want your kernel to be named something other than bzImage, be sure to copy to /boot/yourname instead. Don't forget to set up grub.conf or lilo.conf and run /sbin/lilo if you use LILO. </para>
<para/></sect2><sect2><title>3. Install X11-DRM and configure direct rendering</title>
<para/>
<para>Install X11-DRM</para>
<para/>
<para>Code Listing 3.1: Installing X11-DRM</para>
<para># emerge x11-drm</para>
<para/>
<para/>
<para>Configure Xorg.conf</para>
<para/>
<para>Some chipsets require you to rebuild xorg-x11 with USE="insecure-drivers". This applies to mach64, unichrome and savage chipsets on xorg-x11-6.8.2, and to mach64 and unichrome on xorg-x11-6.8.99.x. Savage users should not try xorg-x11-6.8.99.x as support for the savage there is broken. </para>
<para/>
<para>Code Listing 3.2: Rebuilding xorg-x11</para>
<para>(Add the insecure-drivers USE flag if you use one of the aforementioned chipsets)</para>
<para># echo "x11-base/xorg-x11 insecure-drivers" &gt;&gt; /etc/portage/package.use</para>
<para/>
<para># emerge xorg-x11</para>
<para/>
<para/>
<para>Open /etc/X11/xorg.conf with your favorite text editor and edit it to enable DRI and GLX. </para>
<para/>
<para>Code Listing 3.3: xorg.conf</para>
<para>...</para>
<para>Section "Module"</para>
<para>  Load "dri"</para>
<para>  Load "glx"</para>
<para>  ...</para>
<para>EndSection</para>
<para>...</para>
<para>Section "Device"</para>
<para>  Driver "radeon"</para>
<para>  ...</para>
<para>EndSection</para>
<para>...</para>
<para>Section "dri"</para>
<para>  Mode 0666</para>
<para>EndSection</para>
<para/>
<para/>
<para>If you are using a different driver, replace "radeon" with yours. </para>
<para/>
<para>Changes to modules.autoload.d</para>
<para/>
<para>You will need to add the module name that your card uses to /etc/modules.autoload.d/kernel-2.6 to ensure that the module is loaded automatically when the system starts up. </para>
<para/>
<para>Code Listing 3.4: Editing /etc/modules.autoload.d/kernel-2.6</para>
<para>(Change module name as required.)</para>
<para>intel-agp</para>
<para/>
<para>Note: If you compiled agpgart as a module, you will also need to add it to /etc/modules.autoload.d/kernel-2.6. </para>
<para/>
<para/></sect2><sect2><title>4. Test 3D acceleration</title>
<para/>
<para>Reboot to the new kernel</para>
<para/>
<para>Reboot your computer to your new kernel and login as a normal user. It's time to see if you have direct rendering and how good it is. </para>
<para/>
<para>Code Listing 4.1: Testing rendering</para>
<para>$ startx</para>
<para>(No need to load modules for your driver or agpgart, even if you compiled them as a module.)</para>
<para>(They will be loaded automatically.)</para>
<para>$ glxinfo | grep rendering</para>
<para>direct rendering: Yes</para>
<para>(If it says "No", you don't have 3D acceleration.)</para>
<para>$ glxgears</para>
<para/>
<para>(Test your frames per second (FPS) at the default size. The number should be )</para>
<para>(significantly higher than before installing x11-drm. Do this while the CPU is as idle as possible.)</para>
<para/>
<para/></sect2><sect2><title>5. Using the CVS sources</title>
<para>Warning: Don't do this if the package worked. </para>
<para/>
<para/>
<para>Do you need the CVS?</para>
<para/>
<para>First you have to check whether the x11-drm package works. If it doesn't and you have checked your logs to verify it's not a configuration error, you might want to consider the CVS sources. There are also daily driver snapshots available if you do not wish to build the full CVS. </para>
<para/>
<para>Do the CVS sources support your card?</para>
<para/>
<para>Check the DRI supported cards list to see if the CVS supports your card. Even if it doesn't, but it supports a similar card, try it. </para>
<para/>
<para>Follow the CVS Instructions</para>
<para/>
<para>The DRI project has a document about CVS compiling themselves. Please read the document and follow the instructions up to the Installing for X.org part. </para>
<para/>
<para>Install the CVS</para>
<para/>
<para>Verify that the DRI kernel module(s) for your system were built: </para>
<para/>
<para>Code Listing 5.1: Verification</para>
<para># cd ~/DRI-CVS/build/xc/programs/Xserver/hw/xfree86/os-support/linux/drm/kernel; ls</para>
<para/>
<para/>
<para>For the 3dfx Voodoo, you should see tdfx.o. For the Matrox G200/G400, you should see mga.o. For the ATI Rage 128, you should see r128.o. For the ATI Radeon, you should see radeon.o. For the Intel i810, you should see i810.o. If the DRI kernel module(s) failed to build, you should verify that you're using the right version of the Linux kernel. The most recent kernels are not always supported. </para>
<para/>
<para>Install over your X.org installation. You may wish to back up xorg-x11. </para>
<para/>
<para>Code Listing 5.2: Backing up Xorg</para>
<para># quickpkg xorg-x11</para>
<para>(This backs up your Xorg-X11 package.)</para>
<para># make install</para>
<para/>
<para/>
<para>Follow the "Configure Xorg" section above. </para>
<para/>
<para>To load the appropriate DRM module in your running kernel, copy the kernel module to /lib/modules/`uname -r`/kernel/drivers/char/drm/ then run modules-update and restart your X server. If you're not running the kernel you'll be using it in, instead of `uname -r`, use that kernel's name. </para>
<para>Warning: Make sure you first unload any older DRI kernel modules that might be already loaded. Note that some DRM modules require that the agpgart module be loaded first. </para>
<para/>
<para/></sect2><sect2><title>6. Tweak your performance</title>
<para/>
<para>Get the most out of direct rendering</para>
<para/>
<para>A few options may increase performance by up to 30 percent (or more) over the default. Set them in /etc/X11/xorg.conf. However, you will first need to check that your motherboard and video card support these options. </para>
<para/>
<para>First, let's see if your video card can support fast writes. We'll do this by closely inspecting the output from lspci. Specifically, we are looking at the "VGA compatible controller" information. </para>
<para/>
<para>Code Listing 6.1: Video card check</para>
<para># lspci -vv</para>
<para>01:00.0 VGA compatible controller: ATI Technologies Inc Radeon Mobility M6 LY (prog-if 00 [VGA])</para>
<para>. . .</para>
<para>Capabilities: [58] AGP version 2.0</para>
<para>    Status: RQ=48 Iso- ArqSz=0 Cal=0 SBA+ ITACoh- GART64- HTrans- 64bit- FW+ AGP3- Rate=x1,x2,x4</para>
<para/>
<para/>
<para>While quite a lot of information is produced, we are looking for FW in the "Status" subsection of the AGP "Capabilities" section. If FW+ is present in the "Status" line, it means the card supports fast writes. We can now check if the motherboard supports fast writes. </para>
<para>Important: If you do not see FW+, but instead see FW-, you cannot enable fast writes in xorg.conf. Your card does not support fast writes. </para>
<para/>
<para/>
<para>Now let's make sure the motherboard supports fast writes as well. This time, look at the "Host bridge" section of your lspci output. </para>
<para/>
<para>Code Listing 6.2: Motherboard check</para>
<para># lspci -vv</para>
<para>00:00.0 Host bridge: Intel Corporation 82830 830 Chipset Host Bridge (rev 02)</para>
<para>. . .</para>
<para>Capabilities: [a0] AGP version 2.0</para>
<para>    Status: RQ=32 Iso- ArqSz=0 Cal=0 SBA+ ITACoh- GART64- HTrans- 64bit- FW+ AGP3- Rate=x1,x2,x4</para>
<para/>
<para/>
<para>Again, examine the "Status" subsection of your AGP "Capabilities" section. Look for FW. If you see FW+, your motherboard supports fast writes. </para>
<para>Important: Remember, both your video card information and your motherboard information must show the same FW capability. If either device shows FW- in "Status", you cannot enable fast writes in xorg.conf. </para>
<para/>
<para/>
<para>Assuming that all has gone well and both your motherboard and video card support fast writes, let's enable this option in /etc/X11/xorg.conf and get the best performance out of your hardware. </para>
<para/>
<para>Code Listing 6.3: xorg.conf</para>
<para>Section "Device"</para>
<para>  Option     "AGPMode" "4"</para>
<para>  (This increased FPS from 609 to 618.)</para>
<para>  Option     "AGPFastWrite" "True"</para>
<para>  (This had no measurable effect, but it may increase instability of your computer.)</para>
<para>  (You may also need to set it in your BIOS.)</para>
<para>  Option     "EnablePageFlip" "True"</para>
<para>  (This improved FPS from 618 to 702. It also is "risky" but few people have reported problems.)</para>
<para>  ...</para>
<para>EndSection</para>
<para/>
<para>Warning: Enabling AGPFastWrite on a VIA chipset will very likely cause your machine to lock up. VIA chipsets do not play nicely with fast writes, so use this setting at your own risk. </para>
<para/>
<para>Note: Remember, if you want fast writes to work properly, you will have to first enable the appropriate option in your BIOS. </para>
<para/>
<para/>
<para>If you want to set even more features, check out the feature matrix on the DRI web site or the features listing on Sourceforge. </para>
<para/></sect2><sect2><title>7. Troubleshooting</title>
<para/>
<para>It doesn't work. I just recompiled my kernel or switched to a new one.</para>
<para/>
<para>Whenever you rebuild your kernel or switch to another kernel, you'll have to rebuild the kernel module. Note that you don't need to remerge xorg-x11, but you will need to remerge x11-drm. </para>
<para/>
<para>It doesn't work. I don't have rendering, and I can't tell why.</para>
<para/>
<para>Try insmod radeon before you start the X server. Also, try building agpgart into the kernel instead of as a module. </para>
<para/>
<para>When I startx, I get this error: "[drm] failed to load kernel module agpgart"</para>
<para/>
<para>That's because you compiled agpgart into the kernel instead of as a module. Ignore it unless you're having problems. </para>
<para/>
<para>Direct rendering doesn't work, and in /var/log/Xorg.0.log I have an error about driver version too low.</para>
<para/>
<para>You aren't using the x11-drm driver. Check if you compiled DRM and the driver into the kernel; you shouldn't have. </para>
<para/>
<para>I have a Radeon, and I want TV-Out.</para>
<para/>
<para>Check out ati-gatos drivers. emerge -s gatos. </para>
<para/>
<para>It doesn't work. My card is so incredibly new and cool that it isn't supported at all.</para>
<para/>
<para>Try out the binary drivers. For ati-drivers, a listing is at http://www.schneider-digital.de/html/download_ati.php. If those don't support it, use fbdev. It's slow, but it works. </para>
<para/>
<para>I have a PCI card and it doesn't work. Help!</para>
<para/>
<para>In section "Device" enable ForcePCIMode. </para>
<para/>
<para>Code Listing 7.1: Enabling ForcePCIMode</para>
<para>Option "ForcePCIMode" "True"</para>
<para/>
<para/></sect2><sect2><title>8. Acknowledgments</title>
<para>Christopher Webber for suggesting a troubleshooting question about changing or recompiling kernels </para>
<para>Steve, for suggesting consistency between the cases of dri and DRI in XF86Config </para>
<para/></sect2><sect2><title>9. References</title>
<orderedlist>
<listitem>
<para>
<ulink url="http://forums.gentoo.org/viewtopic.php?t=46681">http://forums.gentoo.org/viewtopic.php?t=46681</ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://forums.gentoo.org/viewtopic.php?t=46681">http://forums.gentoo.org/viewtopic.php?t=29264</ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://dri.freedesktop.org/">http://dri.freedesktop.org/</ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://www.retinalburn.net/linux/dri_status.html">http://www.retinalburn.net/linux/dri_status.html</ulink>
</para>
</listitem>
</orderedlist>
<para/>
<para/>
<para/></sect2></sect1><sect1><title>Gentoo и  KDE</title>
<para/><sect2><title>HOWTO по настройке KDE версии 3.x.x</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/kde-config.xml">http://www.gentoo.org/doc/ru/kde-config.xml</ulink>
</para>
<para>С версии: 1.0</para><sect3><title>1. Что же такое K Desktop Environment?</title>
<para>Проект</para>
<para/>
<para>Проект KDE - проект открытого программного обеспечения посвящённый разработке KDE, графической рабочей среде для рабочих станций Linux и Unix. Разработкой занимаются несколько сотен разработчиков со всего мира, преданных разработке бесплатного программного обеспечения. Смотрите также Что из себя представляет проект KDE. </para>
<para/>
<para>Программное обеспечение</para>
<para/>
<para>K Desktop Environment - это простая рабочая среда построенная на хорошо продуманной прикладной структуре (application framework), которая предоставляет функциональную совместимость, drag 'n drop и многое другое. Кроме необходимых компонентов, KDE предоставляет готовые к использованию приложения для всех мыслимых задач: файловый менеджер, интернет-браузер, офис приложения, email-клиент и т.д. И всё это относится к KDE проекту. </para>
<para/>
<para>KDE доступен более чем на 70 языках и охватывает огромное количество пользователей. Для тех, кто интересуется, есть много скриншотов. Для большей информации о KDE, читайте статью Что такое KDE? на KDE.org. </para>
<para/>
<para>Сообщество</para>
<para/>
<para>Существует много сайтов KDE сообществ. На KDEnews.org вы найдёте последние новости про KDE вообще. KDE developers.org специализируется на разработке KDE, а KDE-форум больше подходит для широкой массы. Больше ссылок можно найти на Странице семейства KDE. </para>
<para/></sect3><sect3><title>2. Установка KDE</title>
<para/>
<para>Что вам нужно?</para>
<para/>
<para>Прежде всего, если вы заинтересованы в установке KDE (или поддержке kde), вам придётся убедиться, что переменная USE содержит kde и qt флаги. Для тех, кто не знает, Qt - графическая библиотека элементов управления (graphical widget library), которую использует KDE. </para>
<para/>
<para>Во-вторых, вам нужно подумать над тем, что вы хотите установить из дистрибутива KDE. Как ранее упоминалось, KDE очень богат возможностями и включает в себя много программ. Для этого вам не обязательно верить нашим словам -- сами проверьте :) </para>
<para/>
<para>Листинг 2.1: Перечисляем все пакеты KDE</para>
<para># emerge --pretend kde | less</para>
<para/>
<para/>
<para>Если вы не заинтересованы в установке всех этих пакетов, вы можете поставить лишь некоторые из них. Очевидно, что вам понадобится kdebase, так как он содержит основные и необходимые программы. Следующая таблица показывает несколько пакетов, которые вы можете установить.</para>
<para/>
<para/>
<para>Таблица: Пакеты KDE.</para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>Пакет</para>
</entry>
<entry>
<para>Описание</para>
</entry>
</row>
<row>
<entry>
<para>kdeaccessibility</para>
</entry>
<entry>
<para>Программы для людей с ограниченными возможностями разрабатываются Проектом KDE Accessibility</para>
</entry>
</row>
<row>
<entry>
<para>kdeadmin</para>
</entry>
<entry>
<para>Административные утилиты, такие как KCron (Планирование задач), KUser (Управление пользователями) и KDat (Управление резервными копиями) </para>
</entry>
</row>
<row>
<entry>
<para>kdeartwork</para>
</entry>
<entry>
<para>Некоторые программы, связанные с искусством, включая хранители экрана и темы. Также смотрите artist.kde.org. </para>
</entry>
</row>
<row>
<entry>
<para>kdeedu</para>
</entry>
<entry>
<para>Образовательные KDE приложения для школьников от 3 до 18 лет. Также смотрите Проект KDE Edu. </para>
</entry>
</row>
<row>
<entry>
<para>kdegames</para>
</entry>
<entry>
<para>KDE игры. Больше информации можно найти по ссылке KDE центр игр.</para>
</entry>
</row>
<row>
<entry>
<para>kdegraphics</para>
</entry>
<entry>
<para>Графические приложения для KDE, плюс KSnapshot (Программа для снятия скриншотов), KPain (Простой графический редактор), Kpdf (Для просмотра PDF), KIconEdit (Icon Editor) и KPovModeler (Создание 3D моделей). </para>
</entry>
</row>
<row>
<entry>
<para>kde-i18n</para>
</entry>
<entry>
<para>Этот пакет включает поддержку для многих языков (также валют, форматов чисел и дат, ...) и документации. Больше информации по ссылке Проект KDE i18n. </para>
</entry>
</row>
<row>
<entry>
<para>kdemultimedia</para>
</entry>
<entry>
<para>Мультимедийные приложения, включая поддержку CD, MP3, DVD, форматов, звуковых и видео приложений. Больше информации по ссылке Проект KDE Multimedia website. </para>
</entry>
</row>
<row>
<entry>
<para>kdenetwork</para>
</entry>
<entry>
<para>Сетевые приложения, такие как kppp (Dial-In) и lisa (networking). Заметьте, что konqueror (файловый менеджер и веб-браузер) часть пакета kdebase! </para>
</entry>
</row>
<row>
<entry>
<para>kdepim</para>
</entry>
<entry>
<para>Личные Информационные инструментальные средства Управления, такие как KOrganizer (Журнал), KAddressbook (Адресная книга), Kontact (Программное обеспечение для коллективной работы) и KMail (E-mail). Больше информации по ссылке Проект KDE PIM. </para>
</entry>
</row>
<row>
<entry>
<para>kdesdk</para>
</entry>
<entry>
<para>Основные инструменты разработки, включая KBabel (Утилита для перевода), KBugBuster (Front end для отслеживания ошибок KDE) и Kompare (GUI для просмотра разницы между файлами). </para>
</entry>
</row>
<row>
<entry>
<para>kdetoys</para>
</entry>
<entry>
<para>Различные безделушки, которыми можно позабавится, в ожидании, пока доставят вашу пиццу. В этом пакете вы найдёте такие апплеты, как eyesapplet и fifteenapplet, а также стильные утилиты как amor, которые ничего не делают, кроме как пожирают ресурсы :)</para>
</entry>
</row>
<row>
<entry>
<para>kdeutils</para>
</entry>
<entry>
<para>Графические системные утилиты как kcalc (Калькулятор), kdessh (SSH терминал), kfloppy (производит действия связанные с floppy), и другие. </para>
<para/>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para/>
<para/>
<para>К примеру, чтобы поставить KDE только с сетевыми и административными приложениями: </para>
<para/>
<para>Листинг 2.2: Пример установки индивидуальных компонентов KDE</para>
<para># emerge kdebase kdenetwork kdeadmin</para>
<para/>
<para/>
<para>Если вам интересно знать: компиляция KDE занимает очень много времени :) </para>
<para/>
<para>Первые ощущения</para>
<para/>
<para>Теперь давайте взглянем на результаты. Твоя мама наверное говорила тебе никогда не работать под root-ом. Ну что ж, последуем маминому совету и запустим KDE под пользователем. Зайдите под вашим пользователем и настройте вашу сессию так, чтобы загружался KDE после выполнения команды startx. Вы можете это сделать добавив строчку exec startkde в ~/.xinitrc: </para>
<para/>
<para>Листинг 2.3: Настраиваем локальную сессию</para>
<para>$ echo "exec startkde" &gt; ~/.xinitrc</para>
<para/>
<para/>
<para>Теперь выполните команду startx для загрузки вашей графической среды. </para>
<para/>
<para>Листинг 2.4: Запускаем KDE</para>
<para>$ startx</para>
<para/>
<para/>
<para>Вас встретит приложение под названием KPersonalizer. Поздравляем, теперь давайте посмотрим, как можно настроить KDE... </para>
<para/></sect3><sect3><title>3. Настройка KDE</title>
<para/>
<para>KPersonalizer</para>
<para/>
<para>KPersonalizer - приложение, которое настроит KDE за вас. Это очень полезный мастер, который помогает быстро изменить KDE под ваши нужды. KPersonalizer автоматически появится при первой загрузке KDE. </para>
<para/>
<para>Первое, о чём спросит вас KPersonalizer будет страна и язык на ваш выбор. Так как мы не устанавливали никаких языковых пакетов, выбор языков будет небольшим -- очевидно в списке будет только английский. Не волнуйтесь, мы сменим язык позже (если вы конечно захотите этого). </para>
<para/>
<para>Потом вам нужно будет выбрать System Behaviour. Эта настройка включает в себя активацию окна, выбор мыши, и другое. При выборе определённого поведения, можно увидеть его описание. Если вы не уверены что выбрать, не паникуйте -- всегда можно будет поменять настройки. </para>
<para/>
<para>Далее KPersonalizer спросит о количестве разнообразных эффектов. Чем больше эффектов вы активируете, тем моднее будет KDE, но и процессор будет более загружен. Однако, не стоит так переживать из-за этого -- на компьютере с процессором в 600 Mhz с 128 Mb памяти разрешение всех эффектов не особо не повлияет на быстродействие системы. </para>
<para/>
<para>Наконец, остаётся выбрать стиль. Стиль определяет декорацию окон, тему, вид кнопок, и другое. Попробуйте несколько стилей, чтобы выбрать тот, который вам понравится. Я ещё не говорил вам, что KDE полностью настраиваемый? </para>
<para/>
<para>Откиньтесь на спинку кресла и наслаждайтесь -- запустится KDE и вас встретит милая, чистая и функциональная интерактивная рабочая среда. </para>
<para/>
<para>Установка языковых пакетов</para>
<para/>
<para>Если ваш родной язык не английский или вы хотите работать в KDE на другом языке, тогда читайте дальше. Мы установим языковые пакеты для языков, которые вам нужны. </para>
<para/>
<para>Все языковые пакеты содержатся в одном kde-i18n пакете. Чтобы поставить только нужные пакеты, а не все, нужно присвоить значение переменной LINGUAS. Рекомендуется прописать переменную в /etc/make.conf. </para>
<para/>
<para>Листинг 3.1: Прописываем переменную LINGUAS в /etc/make.conf</para>
<para># nano -w /etc/make.conf</para>
<para>(К примеру, мы поставим языковые пакеты для русского (ru) </para>
<para> и французского (fr))</para>
<para>LINGUAS="ru fr"</para>
<para/>
<para/>
<para>Теперь выполните команду emerge kde-i18n. Когда установка закончится, запускайте KDE и KDE центр управления (Control Center) (K-menu &gt; Settings &gt; Control Center). Это приложение, где можно изменить намного больше настроек KDE, чем в KPersonalizer. </para>
<para/>
<para>Чтобы изменить язык, идите в Regional &amp; Accessibility, Country/Region &amp; Languages. Потом добавьте язык на ваш выбор и перезагрузите KDE. </para>
<para/>
<para>Графический вход в систему</para>
<para/>
<para>Если вы хотите использовать kdm как менеджер графического входа в систему (что значит, что вам не придётся каждый раз набивать на клавиатуре команду startx) сначала загляните в /etc/X11/Sessions, чтобы узнать, как называется KDE сессия: </para>
<para/>
<para>Листинг 3.2: Узнаем название KDE сессии</para>
<para># ls /etc/X11/Sessions</para>
<para>Xsession  fluxbox  kde-3.2.1</para>
<para/>
<para/>
<para>В примере выше, KDE сессия называется kde-3.2.1. Давайте добавим её в /etc/rc.conf в переменную XSESSION. Также измените значение переменной DISPLAYMANAGER на kdm. </para>
<para/>
<para>Листинг 3.3: Изменяем значение переменной XSESSION в /etc/rc.conf</para>
<para># nano -w /etc/rc.conf</para>
<para>(Измените две следующие переменные)</para>
<para>XSESSION="kde-3.2.1"</para>
<para>DISPLAYMANAGER="kdm"</para>
<para/>
<para/>
<para>Завершаем добавив xdm в default runlevel: </para>
<para/>
<para>Листинг 3.4: Добавляем xdm в default runlevel</para>
<para># rc-update add xdm default</para>
<para/>
<para/>
<para>После перезагрузки системы, как графический вход в систему будет использоваться KDM.</para>
<para/></sect3></sect2><sect2><title>Способы переключения раскладок клавиатуры в KDE (3в1)</title>
<para>Ссылка на оригинал: <ulink url="http://gentoo.blog.ru/3638115.html">http://gentoo.blog.ru/3638115.html</ulink>
</para>
<para>Авторы: <ulink url="http://gentoo.blog.ru/profile">gentoo</ulink>
</para>
<para>С версии: 1.4</para>
<para>Дата: 18.12.2007</para>
<para/>
<para>Читая <ulink url="http://runix.org/">Планету блогов о *NIX</ulink> (нагло пиарю) наткнулся на несколько постов о настройке переключения раскладок клавиатуры. Кто-то советует править xorg.conf, кто-то - поставить kkbswitch, самые пытливые заставляют завестись встроенное средство переключения раскладок в KDE. Сам использовал в основном kkbswitch (сейчас включил встроенный kxkb), только в SuSE переключался средствами xorg.conf - не нашёл kkbswitch в репах. Недостаток использования переключения из xorg.conf - раскладка для всех окон всегда одна. Встроенная переключалка KDE работает неплохо, если настроить, но... в русской раскладке не срабатывают хоткеи (решено, спасибо комраду Fallen). У kkbswitch изъянов мной замечено не было, с тремя языками работает (кого волнует этот вопрос). Кстати, он читает xorg.conf и соответствующим образом настраивает себя, так что для начала потребуется настроить xorg.conf.</para>
<para>1. /etc/X11/xorg.conf</para>
<para>Section "InputDevice"</para>
<para>    Identifier  "Keyboard0"</para>
<para>    Driver      "kbd"</para>
<para>    Option      "XkbRules" "xorg"</para>
<para>    Option      "XkbModel" "pc104"</para>
<para>    Option      "XkbLayout" "us,ru"</para>
<para>    Option      "XkbOptions" "grp:ctrl_shift_toggle"</para>
<para>    Option      "XkbVariant" ",winkeys"</para>
<para>    Option      "AutoRepeat" "250 30"</para>
<para>EndSection</para>
<para>Добавление: Option "XkbOptions" "grp_led:caps"будет включать/выключать индикатор CapsLock'а при переключении языков.2. Поставить <ulink url="http://kkbswitch.sourceforge.net/">kkbswitch</ulink>. Берёт инфо о языках и клавишах переключения из xorg.conf. Пример для 3х языков:</para>
<para>Section "InputDevice"</para>
<para>    Identifier  "Keyboard0"</para>
<para>    Driver      "kbd"</para>
<para>    Option      "XkbRules" "xorg"</para>
<para>    Option      "XkbModel" "pc104"</para>
<para>    Option      "XkbLayout" "us,de,ru"</para>
<para>    Option      "XkbOptions" "grp:ctrl_shift_toggle"</para>
<para>    Option      "XkbVariant" ",,winkeys"</para>
<para>    Option      "AutoRepeat" "250 30"</para>
<para>EndSection</para>
<para>Перед winkeys в данном случае две запятые (т.к. русский язык теперь третий по счёту). Языки переключаются по-кругу по Ctrl+Shift.Один нюанс - в этом случае при трёх языках у меня почему-то не срабатывает переход в текстовую консоль по Ctrl+Alt+F1-6, хм.3. Включение встроенного средства переключения раскладок клавиатуры KDE.</para>
<para>Достичь окончательного (?) просветления в этом вопросе помог пост "<ulink url="http://tolikzilla.blogspot.com/2007/12/kde.html">Переключение раскладок KDE в комиксах</ulink>". В настройке переключения есть как минимум две неочевидные вещи. Рассмотрю два варианта: настройка для двух языков и для трёх, а в качестве кнопок переключения - Ctrl+Shift (как наиболее популярный вариант у иммигрантов с Windows).а) Настройка для двух языков (Англ/Рус).Центр Управления - Региональные и спец. возможности - Раскладка клавиатуры1я закладка (Раскладка):Добавляем две раскладки - Англ и Русскую, причём для русской ставим галку "Включить латинскую раскладку" (иначе в русской раскладке не будут работать хоткеи):</para>
<para>
<!-- inlinegraphic fileref="embedded:Графический объект15" width="10.584cm" depth="8.341cm"/-->
</para>
<para>2я закладка (Параметры переключения):по вкусу</para>
<para>
<!-- inlinegraphic fileref="embedded:Графический объект16" width="10.584cm" depth="8.341cm"-->
</para>
<para>3я закладка (Параметры XKB):Выбираем "Ctrl+Shift переключает группу" и, ниже, можно выбрать "ScrollLock показывает альтернативную группу" (учтите, что хоткеи, в которых используется комбинация "Ctrl+Shift+some_key" больше не будут работать).</para>
<para>
<!--<inlinegraphic fileref="embedded:Графический объект17" width="10.584cm" depth="11.685cm"/>
--></para>
<para>Первая неочевидная вещь заключается в том, что "Настройка переключения групп" на данной закладке - это отнюдь не переключатель раскладок (!), это переключатель групп языков в конкретной раскладке. Поэтому идём к пункту четыре:4й шаг: Центр Управления - Региональные и спец. возможности - Комбинации клавиш:В самом низу нужно назначить клавиши для "Переключиться на следующую раскладку клавиатуры" - здесь и задаётся желаемая комбинация, в нашем случае - попробуем задать Ctrl+Shift. Для основной комбинации нажимаем левые Ctrl+Shift, для альтернативной - правые.</para>
<para>
<!--inlinegraphic fileref="embedded:Графический объект18" width="10.584cm" depth="12.278cm"-->
</para>
<para>Скорей всего вы увидите "Ctrl+ISO_Prev_Group; Ctrl+ISO_Next_Group", проверяем переключаются ли раскладки. Не переключаются? И у меня нет. В справке проблема описана так: "Если kxkb не переключает с помощью комбинации клавиш, когда вы переключаетесь на какую либо раскладку, но переключает при использовании мыши, возможно ваша раскладка не содержит клавишу, назначенную в комбинации".Можно исправить вручную так:$ nano ~/.kde/share/config/kdeglobalsНайти строку "Switch to Next Keyboard Layout=..." и изменить её на:Switch to Next Keyboard Layout=Ctrl+Shift_L;Ctrl+Shift_R(кстати, для варианта переключения по левой клавише "Win" такие ухищрения не будут нужны, и хоткеи "Ctrl+Shift+some_key" будут работать)Идём снова в "Раскладка клавиатуры", отключаем и вночь включаем:[x] Включить переключение раскладок клавиатурыВсё, теперь должно работать.б) Настройка для трёх языков (Англ/Рус/Укр). Настраивается практически аналогично:1я закладка (Раскладка):Добавляем три раскладки - Англ, Русскую, Украинскую. Для русской и украинской ставится галка "Включить латинскую раскладку" (здесь это важно не столько для отрабатывания хоткеев, сколько для удобства работы с тремя языками).2я закладка (Параметры переключения):пока не включаем опцию "Переключение между основными раскладками".3я закладка (Параметры XKB):То же самое что и для варианта двух раскладок, без каких-либо изменений (если настраиваете на три раскладки после того, как настраивали для двух, то, возможно придётся отключить и вновь включить здесь "Использовать переключатели XKB").4й шаг:$ nano ~/.kde/share/config/kdeglobalsНайти строку "Switch to Next Keyboard Layout=..." и изменить её на:Switch to Next Keyboard Layout=Ctrl+Shift_L(заметьте, альтернативная комбинация не задана)Идём снова в "Раскладка клавиатуры", отключаем и вночь включаем:[x] Включить переключение раскладок клавиатурыСмотрим, что получилось. А получиться должно вот что:При нажатии левых Ctrl+Shift изменяется текущая раскладка (и соотв. флажок в трее изменяется по кругу - Англ-Рус-Укр).При нажатии правых Ctrl+Shift изменяется текущая группа раскладки (флажок остаётся прежним). Вот так выглядит структура раскладок и групп:Английская раскладка   - англ. группаРусская раскладка   - русская группа   - англ. группаУкраинская раскладка   - украинская группа   - англ. группаТо есть, переключившись левыми Ctrl+Shift на русскую раскладку, для набора английских букв не надо снова дважды жать левые Ctrl+Shift, можно правыми переключить текущую группу на английскую, набрать что требовалось, и правыми же переключиться опять на русский язык.в) Настройка для трёх языков (Англ/Рус/Укр) с использованием опции "Основных раскладок".Всё то же самое, только:2я закладка (Параметры переключения):Включаем опцию [x] "Переключение между основными раскладками".Количество основных раскладок: 2При таком варианте по левому Ctrl+Shift будет происходить переключение только между Англ и Рус раскладками. На третий язык (Укр) можно переключиться только выбрав его мышкой. Причём после выбора будет происходить переключение между Англ и Украинскими раскладками (для всей системы или только для текущего окна - в зависимости от настройки).Вот, наверное, и всё.Какой вариант удобнее - каждый решает для себя сам.PS: в Fedora8 по-умолчанию могут отсутствовать флажки языков, можно взять из другого дистрибутива по адресу /usr/share/locale/l10n/ru/flag.png (.../us/flag.png), либо, цитирую: "Небольшое уточнение: в Fedora 8 есть флажки стран, только входят они в пакет wordtrans и находятся в /usr/share/wordtrans/flags/".PPS: включение этого средства отключает настройки раскладок xorg.conf, при выключении для возрата к использованию настроек xorg.conf необходимо перезапустить X'сы.</para>
<para>Для переключения языков в текстовой консоли в Gentoo редактируется файл /etc/conf.d/keymaps.</para>
<para/>
<para/>
<para/></sect2><sect2><title>Gentoo KDE 4.0 Guide (Рус.)</title>)<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/proj/en/desktop/kde/kde4.xml">http://www.gentoo.org/proj/en/desktop/kde/kde4.xml</ulink>
</para>
<para>Авторы: <ulink url="mailto:ingmar@gentoo.org">Ingmar Vanhassel </ulink>
<ulink url="mailto:ingmar@gentoo.org"> , </ulink>
<ulink url="mailto:mark_alec@gentoo.org">Mark Kowarsky</ulink> </para>
<para>Перевод: <ulink url="mailto:JohnBat26@gmail.com?subject=По%20поводу%20вашего%20перевода%20статьи%20о%20KDE%204.0">Батогов Е.В. a.k.a. JohnBat26</ulink>
</para>
<para>С версии: 1.4</para>
<para>Обновлено в: 1.5</para>
<para>Дата: 28.02.2008</para>
<para>Дата окончания перевода: 27.03.2008</para>
<para/><sect3><title>1. Установка</title>
<para>Удаление всех, предшествующих официальной версии, ebuilds.</para>
<para/>
<para>Если Вы использовали <ulink url="http://genkdesvn.mailstation.de/">the genkdesvn overlay</ulink>, тогда рекомендуется удалить все версии KDE, предшествующие официальной версии, перед обновлением. Большинства пользователей достаточно будет выполнить: layman -d kde. Кроме того, если Вы изменяли какие-либо файлы, связанные с KDE, в каталоге /etc/env.d, тогда Вам необходимо вручную удалить их.</para>
<para/>
<para>Включение необходимых USE-флагов</para>
<para/>
<para>KDE 4.0 требует не просто Qt версии 4 (x11-libs/qt:4), но и то чтобы она была собрана с минимальным набором USE-флагов. Добавьте следующую строку в Ваш файл /etc/portage/package.use. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1.1: Установка необходимых USE-флагов для x11-libs/qt:4</para>
</entry>
</row>
<row>
<entry>
<para>x11-libs/qt:4 accessibility dbus gif jpeg png qt3support ssl zlib</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Удаление маскирования и прописывание ключевых слов</para>
<para/>
<para>В настоящее время (24.01.2008) KDE версии 4.0.0. жестко замаскирован (hard masked), поэтому Вы должны удалить эти маски перед его установкой. Пользователям с ACCEPT_KEYWORDS="~x86" или ACCEPT_KEYWORDS="~amd64", нет необходимости выполнять какие-либо другие шаги. Всем остальным пользователям необходимо поместить необходимые пакеты в фа package.keywords.</para>
<para>Так как /etc/portage/package.unmask/ и /etc/portage/package.keywords/ могут быть директориями, Вы можете просто сохранить следующие примеры файлов в эти директории для снятия маскирования и прописывания ключевых слов для  KDE 4.0.0.</para>
<para>Листинг 1.2 Пример<ulink url="https://www2.mailstation.de/gitweb/?p=genkde4svn-pub.git;a=blob_plain;f=Documentation/package.unmask-4.0.0;hb=HEAD"> package.unmask</ulink> :</para>
<para># Unmask KDE 4.0.0</para>
<para>kde-base/amor:kde-4</para>
<para>kde-base/ark:kde-4</para>
<para>kde-base/blinken:kde-4</para>
<para>kde-base/bovo:kde-4</para>
<para>kde-base/cervisia:kde-4</para>
<para>kde-base/dolphin:kde-4</para>
<para>kde-base/drkonqi:kde-4</para>
<para>kde-base/gwenview:kde-4</para>
<para>kde-base/juk:kde-4</para>
<para>kde-base/kalgebra:kde-4</para>
<para>kde-base/kalzium:kde-4</para>
<para>kde-base/kamera:kde-4</para>
<para>kde-base/kanagram:kde-4</para>
<para>kde-base/kappfinder:kde-4</para>
<para>kde-base/kapptemplate:kde-4</para>
<para>kde-base/kate:kde-4</para>
<para>kde-base/katomic:kde-4</para>
<para>kde-base/kbattleship:kde-4</para>
<para>kde-base/kblackbox:kde-4</para>
<para>kde-base/kbounce:kde-4</para>
<para>kde-base/kbruch:kde-4</para>
<para>kde-base/kbugbuster:kde-4</para>
<para>kde-base/kcachegrind:kde-4</para>
<para>kde-base/kcalc:kde-4</para>
<para>kde-base/kcharselect:kde-4</para>
<para>kde-base/kcheckpass:kde-4</para>
<para>kde-base/kcminit:kde-4</para>
<para>kde-base/kcmshell:kde-4</para>
<para>kde-base/kcolorchooser:kde-4</para>
<para>kde-base/kcontrol:kde-4</para>
<para>kde-base/kcron:kde-4</para>
<para>kde-base/kde:kde-4</para>
<para>kde-base/kdeaccessibility:kde-4</para>
<para>kde-base/kdeaccessibility-colorschemes:kde-4</para>
<para>kde-base/kdeaccessibility-iconthemes:kde-4</para>
<para>kde-base/kdeaccessibility-meta:kde-4</para>
<para>kde-base/kdeaccounts-plugin:kde-4</para>
<para>kde-base/kdeadmin:kde-4</para>
<para>kde-base/kdeadmin-meta:kde-4</para>
<para>kde-base/kdeartwork:kde-4</para>
<para>kde-base/kdeartwork-colorschemes:kde-4</para>
<para>kde-base/kdeartwork-emoticons:kde-4</para>
<para>kde-base/kdeartwork-iconthemes:kde-4</para>
<para>kde-base/kdeartwork-kscreensaver:kde-4</para>
<para>kde-base/kdeartwork-kworldclock:kde-4</para>
<para>kde-base/kdeartwork-meta:kde-4</para>
<para>kde-base/kdeartwork-sounds:kde-4</para>
<para>kde-base/kdeartwork-styles:kde-4</para>
<para>kde-base/kdeartwork-wallpapers:kde-4</para>
<para>kde-base/kdebase:kde-4</para>
<para>kde-base/kdebase-data:kde-4</para>
<para>kde-base/kdebase-kioslaves:kde-4</para>
<para>kde-base/kdebase-meta:kde-4</para>
<para>kde-base/kdebase-startkde:kde-4</para>
<para>kde-base/kdebugdialog:kde-4</para>
<para>kde-base/kdeedu:kde-4</para>
<para>kde-base/kdeedu-meta:kde-4</para>
<para>kde-base/kdegames:kde-4</para>
<para>kde-base/kdegames-meta:kde-4</para>
<para>kde-base/kdegraphics:kde-4</para>
<para>kde-base/kdegraphics-meta:kde-4</para>
<para>kde-base/kde-l10n:kde-4</para>
<para>kde-base/kdelibs:kde-4</para>
<para>kde-base/kde-menu:kde-4</para>
<para>kde-base/kde-menu-icons:kde-4</para>
<para>kde-base/kde-meta:kde-4</para>
<para>kde-base/kdemultimedia:kde-4</para>
<para>kde-base/kdemultimedia-kioslaves:kde-4</para>
<para>kde-base/kdemultimedia-meta:kde-4</para>
<para>kde-base/kdenetwork:kde-4</para>
<para>kde-base/kdenetwork-filesharing:kde-4</para>
<para>kde-base/kdenetwork-meta:kde-4</para>
<para>kde-base/kdepasswd:kde-4</para>
<para>kde-base/kdepimlibs:kde-4</para>
<para>kde-base/kdesdk:kde-4</para>
<para>kde-base/kdesdk-kioslaves:kde-4</para>
<para>kde-base/kdesdk-meta:kde-4</para>
<para>kde-base/kdesdk-misc:kde-4</para>
<para>kde-base/kdesdk-scripts:kde-4</para>
<para>kde-base/kdessh:kde-4</para>
<para>kde-base/kdesu:kde-4</para>
<para>kde-base/kdetoys:kde-4</para>
<para>kde-base/kdetoys-meta:kde-4</para>
<para>kde-base/kdeutils:kde-4</para>
<para>kde-base/kdeutils-meta:kde-4</para>
<para>kde-base/kde-wallpapers:kde-4</para>
<para>kde-base/kdf:kde-4</para>
<para>kde-base/kdialog:kde-4</para>
<para>kde-base/kdm:kde-4</para>
<para>kde-base/kdnssd:kde-4</para>
<para>kde-base/keditbookmarks:kde-4</para>
<para>kde-base/kfile:kde-4</para>
<para>kde-base/kfind:kde-4</para>
<para>kde-base/kfloppy:kde-4</para>
<para>kde-base/kfourinline:kde-4</para>
<para>kde-base/kgamma:kde-4</para>
<para>kde-base/kgeography:kde-4</para>
<para>kde-base/kget:kde-4</para>
<para>kde-base/kgoldrunner:kde-4</para>
<para>kde-base/kgpg:kde-4</para>
<para>kde-base/khangman:kde-4</para>
<para>kde-base/khelpcenter:kde-4</para>
<para>kde-base/khotkeys:kde-4</para>
<para>kde-base/kig:kde-4</para>
<para>kde-base/kioclient:kde-4</para>
<para>kde-base/kiriki:kde-4</para>
<para>kde-base/kiten:kde-4</para>
<para>kde-base/kjots:kde-4</para>
<para>kde-base/kjumpingcube:kde-4</para>
<para>kde-base/klettres:kde-4</para>
<para>kde-base/klines:kde-4</para>
<para>kde-base/klipper:kde-4</para>
<para>kde-base/kmag:kde-4</para>
<para>kde-base/kmahjongg:kde-4</para>
<para>kde-base/kmenuedit:kde-4</para>
<para>kde-base/kmilo:kde-4</para>
<para>kde-base/kmimetypefinder:kde-4</para>
<para>kde-base/kmines:kde-4</para>
<para>kde-base/kmix:kde-4</para>
<para>kde-base/kmousetool:kde-4</para>
<para>kde-base/kmouth:kde-4</para>
<para>kde-base/kmplot:kde-4</para>
<para>kde-base/knetattach:kde-4</para>
<para>kde-base/knetwalk:kde-4</para>
<para>kde-base/knetworkconf:kde-4</para>
<para>kde-base/knewsticker:kde-4</para>
<para>kde-base/knewstuff:kde-4</para>
<para>kde-base/knotify:kde-4</para>
<para>kde-base/kolf:kde-4</para>
<para>kde-base/kolourpaint:kde-4</para>
<para>kde-base/kompare:kde-4</para>
<para>kde-base/konqueror:kde-4</para>
<para>kde-base/konquest:kde-4</para>
<para>kde-base/konsole:kde-4</para>
<para>kde-base/kopete:kde-4</para>
<para>kde-base/kpasswdserver:kde-4</para>
<para>kde-base/kpat:kde-4</para>
<para>kde-base/kpercentage:kde-4</para>
<para>kde-base/kppp:kde-4</para>
<para>kde-base/kquitapp:kde-4</para>
<para>kde-base/krdc:kde-4</para>
<para>kde-base/kreadconfig:kde-4</para>
<para>kde-base/kreversi:kde-4</para>
<para>kde-base/krfb:kde-4</para>
<para>kde-base/kruler:kde-4</para>
<para>kde-base/krunner:kde-4</para>
<para>kde-base/ksame:kde-4</para>
<para>kde-base/kscd:kde-4</para>
<para>kde-base/kscreensaver:kde-4</para>
<para>kde-base/kshisen:kde-4</para>
<para>kde-base/ksmserver:kde-4</para>
<para>kde-base/ksnapshot:kde-4</para>
<para>kde-base/kspaceduel:kde-4</para>
<para>kde-base/ksplash:kde-4</para>
<para>kde-base/ksquares:kde-4</para>
<para>kde-base/kstars:kde-4</para>
<para>kde-base/kstart:kde-4</para>
<para>kde-base/kstartupconfig:kde-4</para>
<para>kde-base/kstyles:kde-4</para>
<para>kde-base/ksudoku:kde-4</para>
<para>kde-base/ksysguard:kde-4</para>
<para>kde-base/ksystraycmd:kde-4</para>
<para>kde-base/kteatime:kde-4</para>
<para>kde-base/ktimer:kde-4</para>
<para>kde-base/ktimezoned:kde-4</para>
<para>kde-base/ktip:kde-4</para>
<para>kde-base/ktouch:kde-4</para>
<para>kde-base/ktraderclient:kde-4</para>
<para>kde-base/kttsd:kde-4</para>
<para>kde-base/ktuberling:kde-4</para>
<para>kde-base/kturtle:kde-4</para>
<para>kde-base/ktux:kde-4</para>
<para>kde-base/kuiserver:kde-4</para>
<para>kde-base/kuiviewer:kde-4</para>
<para>kde-base/kurifilter-plugins:kde-4</para>
<para>kde-base/kuser:kde-4</para>
<para>kde-base/kwallet:kde-4</para>
<para>kde-base/kweather:kde-4</para>
<para>kde-base/kwin:kde-4</para>
<para>kde-base/kwordquiz:kde-4</para>
<para>kde-base/kworldclock:kde-4</para>
<para>kde-base/kwrite:kde-4</para>
<para>kde-base/libkcddb:kde-4</para>
<para>kde-base/libkcompactdisc:kde-4</para>
<para>kde-base/libkdeedu:kde-4</para>
<para>kde-base/libkdegames:kde-4</para>
<para>kde-base/libkmahjongg:kde-4</para>
<para>kde-base/libkonq:kde-4</para>
<para>kde-base/libkscan:kde-4</para>
<para>kde-base/libkworkspace:kde-4</para>
<para>kde-base/libplasma:kde-4</para>
<para>kde-base/libtaskmanager:kde-4</para>
<para>kde-base/lilo-config:kde-4</para>
<para>kde-base/lskat:kde-4</para>
<para>kde-base/marble:kde-4</para>
<para>kde-base/nepomuk:kde-4</para>
<para>kde-base/nsplugins:kde-4</para>
<para>kde-base/okular:kde-4</para>
<para>kde-base/parley:kde-4</para>
<para>kde-base/phonon:kde-4</para>
<para>kde-base/plasma:kde-4</para>
<para>kde-base/poxml:kde-4</para>
<para>kde-base/qimageblitz</para>
<para>kde-base/secpolicy:kde-4</para>
<para>kde-base/solid:kde-4</para>
<para>kde-base/soliduiserver:kde-4</para>
<para>kde-base/strigi-analyzer:kde-4</para>
<para>kde-base/superkaramba:kde-4</para>
<para>kde-base/svgpart:kde-4</para>
<para>kde-base/sweeper:kde-4</para>
<para>kde-base/systemsettings:kde-4</para>
<para>kde-base/umbrello:kde-4</para>
<para>Листинг 1.3 Пример<ulink url="https://www2.mailstation.de/gitweb/?p=genkde4svn-pub.git;a=blob_plain;f=Documentation/package.keywords.4.0.0;hb=HEAD"> package.keywords</ulink> :</para>
<para># Masked qca-2.0 and dependencies for further testing, bug #129536</para>
<para>app-crypt/qca:2 **</para>
<para>app-crypt/qca-cyrus:2 **</para>
<para>app-crypt/qca-gnupg:2 **</para>
<para>app-crypt/qca-logger:2 **</para>
<para>app-crypt/qca-ossl:2 **</para>
<para>app-crypt/qca-pkcs11:2 **</para>
<para/>
<para># KDE 4 dependencies</para>
<para>app-misc/strigi **</para>
<para>dev-libs/libzip **</para>
<para>dev-libs/soprano **</para>
<para>sci-libs/indilib **</para>
<para>sci-mathematics/gmm **</para>
<para/>
<para># Unmask KDE 4.0.0</para>
<para>kde-base/amor:kde-4 **</para>
<para>kde-base/ark:kde-4 **</para>
<para>kde-base/blinken:kde-4 **</para>
<para>kde-base/bovo:kde-4 **</para>
<para>kde-base/cervisia:kde-4 **</para>
<para>kde-base/dolphin:kde-4 **</para>
<para>kde-base/drkonqi:kde-4 **</para>
<para>kde-base/gwenview:kde-4 **</para>
<para>kde-base/juk:kde-4 **</para>
<para>kde-base/kalgebra:kde-4 **</para>
<para>kde-base/kalzium:kde-4 **</para>
<para>kde-base/kamera:kde-4 **</para>
<para>kde-base/kanagram:kde-4 **</para>
<para>kde-base/kappfinder:kde-4 **</para>
<para>kde-base/kapptemplate:kde-4 **</para>
<para>kde-base/kate:kde-4 **</para>
<para>kde-base/katomic:kde-4 **</para>
<para>kde-base/kbattleship:kde-4 **</para>
<para>kde-base/kblackbox:kde-4 **</para>
<para>kde-base/kbounce:kde-4 **</para>
<para>kde-base/kbruch:kde-4 **</para>
<para>kde-base/kbugbuster:kde-4 **</para>
<para>kde-base/kcachegrind:kde-4 **</para>
<para>kde-base/kcalc:kde-4 **</para>
<para>kde-base/kcharselect:kde-4 **</para>
<para>kde-base/kcheckpass:kde-4 **</para>
<para>kde-base/kcminit:kde-4 **</para>
<para>kde-base/kcmshell:kde-4 **</para>
<para>kde-base/kcolorchooser:kde-4 **</para>
<para>kde-base/kcontrol:kde-4 **</para>
<para>kde-base/kcron:kde-4 **</para>
<para>kde-base/kde:kde-4 **</para>
<para>kde-base/kdeaccessibility:kde-4 **</para>
<para>kde-base/kdeaccessibility-colorschemes:kde-4 **</para>
<para>kde-base/kdeaccessibility-iconthemes:kde-4 **</para>
<para>kde-base/kdeaccessibility-meta:kde-4 **</para>
<para>kde-base/kdeaccounts-plugin:kde-4 **</para>
<para>kde-base/kdeadmin:kde-4 **</para>
<para>kde-base/kdeadmin-meta:kde-4 **</para>
<para>kde-base/kdeartwork:kde-4 **</para>
<para>kde-base/kdeartwork-colorschemes:kde-4 **</para>
<para>kde-base/kdeartwork-emoticons:kde-4 **</para>
<para>kde-base/kdeartwork-iconthemes:kde-4 **</para>
<para>kde-base/kdeartwork-kscreensaver:kde-4 **</para>
<para>kde-base/kdeartwork-kworldclock:kde-4 **</para>
<para>kde-base/kdeartwork-meta:kde-4 **</para>
<para>kde-base/kdeartwork-sounds:kde-4 **</para>
<para>kde-base/kdeartwork-styles:kde-4 **</para>
<para>kde-base/kdeartwork-wallpapers:kde-4 **</para>
<para>kde-base/kdebase:kde-4 **</para>
<para>kde-base/kdebase-data:kde-4 **</para>
<para>kde-base/kdebase-kioslaves:kde-4 **</para>
<para>kde-base/kdebase-meta:kde-4 **</para>
<para>kde-base/kdebase-startkde:kde-4 **</para>
<para>kde-base/kdebugdialog:kde-4 **</para>
<para>kde-base/kdeedu:kde-4 **</para>
<para>kde-base/kdeedu-meta:kde-4 **</para>
<para>kde-base/kdegames:kde-4 **</para>
<para>kde-base/kdegames-meta:kde-4 **</para>
<para>kde-base/kdegraphics:kde-4 **</para>
<para>kde-base/kdegraphics-meta:kde-4 **</para>
<para>kde-base/kde-l10n:kde-4 **</para>
<para>kde-base/kdelibs:kde-4 **</para>
<para>kde-base/kde-menu:kde-4 **</para>
<para>kde-base/kde-menu-icons:kde-4 **</para>
<para>kde-base/kde-meta:kde-4 **</para>
<para>kde-base/kdemultimedia:kde-4 **</para>
<para>kde-base/kdemultimedia-kioslaves:kde-4 **</para>
<para>kde-base/kdemultimedia-meta:kde-4 **</para>
<para>kde-base/kdenetwork:kde-4 **</para>
<para>kde-base/kdenetwork-filesharing:kde-4 **</para>
<para>kde-base/kdenetwork-meta:kde-4 **</para>
<para>kde-base/kdepasswd:kde-4 **</para>
<para>kde-base/kdepimlibs:kde-4 **</para>
<para>kde-base/kdesdk:kde-4 **</para>
<para>kde-base/kdesdk-kioslaves:kde-4 **</para>
<para>kde-base/kdesdk-meta:kde-4 **</para>
<para>kde-base/kdesdk-misc:kde-4 **</para>
<para>kde-base/kdesdk-scripts:kde-4 **</para>
<para>kde-base/kdessh:kde-4 **</para>
<para>kde-base/kdesu:kde-4 **</para>
<para>kde-base/kdetoys:kde-4 **</para>
<para>kde-base/kdetoys-meta:kde-4 **</para>
<para>kde-base/kdeutils:kde-4 **</para>
<para>kde-base/kdeutils-meta:kde-4 **</para>
<para>kde-base/kde-wallpapers:kde-4 **</para>
<para>kde-base/kdf:kde-4 **</para>
<para>kde-base/kdialog:kde-4 **</para>
<para>kde-base/kdm:kde-4 **</para>
<para>kde-base/kdnssd:kde-4 **</para>
<para>kde-base/keditbookmarks:kde-4 **</para>
<para>kde-base/kfile:kde-4 **</para>
<para>kde-base/kfind:kde-4 **</para>
<para>kde-base/kfloppy:kde-4 **</para>
<para>kde-base/kfourinline:kde-4 **</para>
<para>kde-base/kgamma:kde-4 **</para>
<para>kde-base/kgeography:kde-4 **</para>
<para>kde-base/kget:kde-4 **</para>
<para>kde-base/kgoldrunner:kde-4 **</para>
<para>kde-base/kgpg:kde-4 **</para>
<para>kde-base/khangman:kde-4 **</para>
<para>kde-base/khelpcenter:kde-4 **</para>
<para>kde-base/khotkeys:kde-4 **</para>
<para>kde-base/kig:kde-4 **</para>
<para>kde-base/kioclient:kde-4 **</para>
<para>kde-base/kiriki:kde-4 **</para>
<para>kde-base/kiten:kde-4 **</para>
<para>kde-base/kjots:kde-4 **</para>
<para>kde-base/kjumpingcube:kde-4 **</para>
<para>kde-base/klettres:kde-4 **</para>
<para>kde-base/klines:kde-4 **</para>
<para>kde-base/klipper:kde-4 **</para>
<para>kde-base/kmag:kde-4 **</para>
<para>kde-base/kmahjongg:kde-4 **</para>
<para>kde-base/kmenuedit:kde-4 **</para>
<para>kde-base/kmilo:kde-4 **</para>
<para>kde-base/kmimetypefinder:kde-4 **</para>
<para>kde-base/kmines:kde-4 **</para>
<para>kde-base/kmix:kde-4 **</para>
<para>kde-base/kmousetool:kde-4 **</para>
<para>kde-base/kmouth:kde-4 **</para>
<para>kde-base/kmplot:kde-4 **</para>
<para>kde-base/knetattach:kde-4 **</para>
<para>kde-base/knetwalk:kde-4 **</para>
<para>kde-base/knetworkconf:kde-4 **</para>
<para>kde-base/knewsticker:kde-4 **</para>
<para>kde-base/knewstuff:kde-4 **</para>
<para>kde-base/knotify:kde-4 **</para>
<para>kde-base/kolf:kde-4 **</para>
<para>kde-base/kolourpaint:kde-4 **</para>
<para>kde-base/kompare:kde-4 **</para>
<para>kde-base/konqueror:kde-4 **</para>
<para>kde-base/konquest:kde-4 **</para>
<para>kde-base/konsole:kde-4 **</para>
<para>kde-base/kopete:kde-4 **</para>
<para>kde-base/kpasswdserver:kde-4 **</para>
<para>kde-base/kpat:kde-4 **</para>
<para>kde-base/kpercentage:kde-4 **</para>
<para>kde-base/kppp:kde-4 **</para>
<para>kde-base/kquitapp:kde-4 **</para>
<para>kde-base/krdc:kde-4 **</para>
<para>kde-base/kreadconfig:kde-4 **</para>
<para>kde-base/kreversi:kde-4 **</para>
<para>kde-base/krfb:kde-4 **</para>
<para>kde-base/kruler:kde-4 **</para>
<para>kde-base/krunner:kde-4 **</para>
<para>kde-base/ksame:kde-4 **</para>
<para>kde-base/kscd:kde-4 **</para>
<para>kde-base/kscreensaver:kde-4 **</para>
<para>kde-base/kshisen:kde-4 **</para>
<para>kde-base/ksmserver:kde-4 **</para>
<para>kde-base/ksnapshot:kde-4 **</para>
<para>kde-base/kspaceduel:kde-4 **</para>
<para>kde-base/ksplash:kde-4 **</para>
<para>kde-base/ksquares:kde-4 **</para>
<para>kde-base/kstars:kde-4 **</para>
<para>kde-base/kstart:kde-4 **</para>
<para>kde-base/kstartupconfig:kde-4 **</para>
<para>kde-base/kstyles:kde-4 **</para>
<para>kde-base/ksudoku:kde-4 **</para>
<para>kde-base/ksysguard:kde-4 **</para>
<para>kde-base/ksystraycmd:kde-4 **</para>
<para>kde-base/kteatime:kde-4 **</para>
<para>kde-base/ktimer:kde-4 **</para>
<para>kde-base/ktimezoned:kde-4 **</para>
<para>kde-base/ktip:kde-4 **</para>
<para>kde-base/ktouch:kde-4 **</para>
<para>kde-base/ktraderclient:kde-4 **</para>
<para>kde-base/kttsd:kde-4 **</para>
<para>kde-base/ktuberling:kde-4 **</para>
<para>kde-base/kturtle:kde-4 **</para>
<para>kde-base/ktux:kde-4 **</para>
<para>kde-base/kuiserver:kde-4 **</para>
<para>kde-base/kuiviewer:kde-4 **</para>
<para>kde-base/kurifilter-plugins:kde-4 **</para>
<para>kde-base/kuser:kde-4 **</para>
<para>kde-base/kwallet:kde-4 **</para>
<para>kde-base/kweather:kde-4 **</para>
<para>kde-base/kwin:kde-4 **</para>
<para>kde-base/kwordquiz:kde-4 **</para>
<para>kde-base/kworldclock:kde-4 **</para>
<para>kde-base/kwrite:kde-4 **</para>
<para>kde-base/libkcddb:kde-4 **</para>
<para>kde-base/libkcompactdisc:kde-4 **</para>
<para>kde-base/libkdeedu:kde-4 **</para>
<para>kde-base/libkdegames:kde-4 **</para>
<para>kde-base/libkmahjongg:kde-4 **</para>
<para>kde-base/libkonq:kde-4 **</para>
<para>kde-base/libkscan:kde-4 **</para>
<para>kde-base/libkworkspace:kde-4 **</para>
<para>kde-base/libplasma:kde-4 **</para>
<para>kde-base/libtaskmanager:kde-4 **</para>
<para>kde-base/lilo-config:kde-4 **</para>
<para>kde-base/lskat:kde-4 **</para>
<para>kde-base/marble:kde-4 **</para>
<para>kde-base/nepomuk:kde-4 **</para>
<para>kde-base/nsplugins:kde-4 **</para>
<para>kde-base/okular:kde-4 **</para>
<para>kde-base/parley:kde-4 **</para>
<para>kde-base/phonon:kde-4 **</para>
<para>kde-base/plasma:kde-4 **</para>
<para>kde-base/poxml:kde-4 **</para>
<para>kde-base/qimageblitz-0.0.4 **</para>
<para>kde-base/secpolicy:kde-4 **</para>
<para>kde-base/solid:kde-4 **</para>
<para>kde-base/soliduiserver:kde-4 **</para>
<para>kde-base/strigi-analyzer:kde-4 **</para>
<para>kde-base/superkaramba:kde-4 **</para>
<para>kde-base/svgpart:kde-4 **</para>
<para>kde-base/sweeper:kde-4 **</para>
<para>kde-base/systemsettings:kde-4 **</para>
<para>kde-base/umbrello:kde-4 **</para><sect4><title>Непосредственно установка </title>
<para>Теперь Вы можете запустить одну из следующих команд emerge, для установки KDE.</para>
<orderedlist>
<listitem>
<para>Первая установит Вам все из состава KDE 4.0.0, собранное из отдельных ebuilds.</para>
</listitem>
<listitem>
<para>Вторая установит Вам минимальное окружение KDE 4.0.0 как базу для добавления только тех программ, которые Вы хотите.</para>
</listitem>
</orderedlist>
<para/>
<para>Листинг 1.4: Установка KDE 4.0.0</para>
<para>emerge -avD kde-base/kde-meta:kde-4</para>
<para>emerge -avD kde-base/kdebase-startkde:kde-4</para>
<para/>
<para/></sect4></sect3><sect3><title>2. Изменения по сравнению с KDE 3.5</title>
<para>KDE 4 вносит впечатляющие изменения в архитектуру рабочего стола в сравнении с KDE 3. Одним из таких изменений является переход от autotools к cmake. Это означает, что теперь Вы можете видеть прогресс компиляции KDE в процентах.</para>
<para/>
<para>Скрипт startkde</para>
<para>Не рекомендуется позволять KDE 3.5 и KDE 4.0  использовать одни и те же файлы конфигурации. Для предотвращения этого скрипты startkde перезапишут символическую ссылку ~./kde во время старта KDE. Это означает, что когда Вы будете находиться в сессии KDE 4.0, Ваша конфигурация для KDE 3.5 будет недоступна и наоборот.</para>
<para>Исходя из этого, Вам не следует запускать две разный версии KDE под одним пользователем в одно время. (Войдя в KDE 4.0, KDE .3.5 остается запущенной в фоне, под тем же пользователем ! )</para>
<para/>
<para>Выбор менеджера входа в систему</para>
<para>По умолчанию, самая последняя версия kde-base/kdm которая у Вас установлена, будет запускаться в момент входа с систему. Для настройки этого, откройте файл  /etc/conf.d/xdm в Вашем любимой текстовом редакторе и измените переменную DISPLAYMANAGER на kdm-3.5 или kdm-4.0. Вы можете посмотреть возможные версии kdm, запустив ls /usr/kde в консоли.</para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.1: Добавьте следующее в файл /etc/conf.d/xdm</para>
</entry>
</row>
<row>
<entry>
<para>DISPLAYMANAGER=kdm-3.5</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3><sect3><title>3. FAQ (Часто задаваемые вопросы)</title>
<para>В: Могу я установить KDE 4.0 и KDE 3.5 одновременно?</para>
<para>О: Да, обе версии помещаются по слотам, и могут  быть установлены одновременно. Обе версии KDE используют различные KDEHOME, таким образом Вы можете попробовать KDE 4.0 под тем же пользователем, без перезаписи Ваших настроек их KDE 3.5.</para>
<para/>
<para>В: Вы сказали, что я могу установить вместе  KDE 3.5 и KDE 4.0, но они блокируют  друг друга !? </para>
<para>О: Вам необходимо установить последнюю ревизию (не версию!) пакета kde-base/kdebase (если Вы используете монолитные ebuilds) или kde-base/kdebase-startkde (если Вы используете раздельные ebuilds). Эти ревизии включают патчи, позволяющие множествам версиям KDE сосуществовать.</para>
<para>Примечание: Эти ревизии пока не были стабилизированы, таким образом Вам необходимо прописать ключевые слова для них. </para>
<para/>
<para>В: Почему KDE 4.0.0  жестко замаскирован (hard-masked)?</para>
<para>О: KDE 4.0.0 является очень технологической версией. Он пока не предназначен для полной замены серии KDE 3. Множество возможностей отсутствуют и множество ошибок ещё будет найдено. Только когда KDE 4.x  перейдет на стадию, которая предложит полноценное обновление для пользователей, тогда с него будет снят статус: жестко замаскирован!</para>
<para>В: Почему KDE 4.0.0  замаскирован EAPI?</para>
<para>О: Ebuilds KDE 4.0.0  используют slot dependencies, такие как kde-base/kdebase-startkde:kde-4,  с синтаксисом зависимости. Вам необходима версия портежей, которая понимает это. Если вы получаете сообщение о маске, тогда Вам следует просто обновить портежи до новой версии.</para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para> Листинг 3.1: Обновление до версии portage, которая поддерживает EAPI=1</para>
</entry>
</row>
<row>
<entry>
<para># emerge --oneshot &gt;=sys-apps/portage-2.1.3.12</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>В: Где монолитные KDE ebuilds?</para>
<para>О: Мы обнаружили, что иметь оба типа ebuild: раздельные и монолитные часто вводит пользователей в замешательство, а также ненужная никому сложность в eclasses и бесцельное дублирование усилий для команды. Так как теперь KDE использует cmake, то основное недостаток раздельных ebuilds  (долгое время компиляции, потому что дублируется ./configure-runs) незначителен.  По причинам указанным выше, мы решили сопровождать только раздельные ebuilds. Для переключения от монолитных к раздельным ebuilds, удалите все установленные монолитные ebuilds:</para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para> Листинг 3.2: Удаление монолитных ebuilds KDE4</para>
</entry>
</row>
<row>
<entry>
<para>emerge -C ~kde-base/kde{,accessibility,admin,artwork,base,edu,games,graphics,multimedia,network,sdk,toys,utils,webdev}-4.0.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Потом, установите раздельные ebuilds, как объяснено ранее в этом руководстве.</para>
<para/>
<para>В:  Где  KDE-PIM в KDE 4?</para>
<para>О: KDE-PIM  пока не был выпущен с KDE 4.0.0, поэтому, к сожалению,  пока вы не найдете его в дереве портежей. Вы, конечно, можете использовать, версии 3.5 kmail, akregator и их друзей совместно с KDE 4.0.0.</para>
<para/>
<para>В:  Я попробовал KDE4 и осознал, что пока не хочу его использовать. Что мне следует делать в этом случае?</para>
<para>О: Удалите KDE 4 из Ваших файлов: package.keywords и package.unmask, затем удалите пакеты, которые вы установили. Не забудьте обновить Вашу переменную DISPLAYMANAGER  если Вы ранее изменяли её на  kde-4.0.</para>
<para/>
<para>В:  Означает ли это, что KDE 3.5 будет убран?</para>
<para>О: Вовсе НЕТ! KDE 3.5 — это очень стабильная версия, и она имеет очень мало ошибок. Несмотря на то, что мы не увидим новых возможностей в KDE 3.5, мы планируем ещё долгое время сопровождать его.</para>
<para/></sect3></sect2></sect1><sect1><title>Руководство по настройке GNOME</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/kde-config.xml">http://www.gentoo.org/doc/ru/gnome-config.xml</ulink>
</para>
<para>С версии: 1.2</para><sect2><title/><sect3><title>1. Что такое GNOME?</title>
<para>О проекте</para>
<para>
<ulink url="http://www.gnome.org/">GNOME</ulink> - это свободное ПО. Проект посвящен разработке GNOME - рабочего стола и пакет разработчика для Unix/Linux систем. <ulink url="http://foundation.gnome.org/">GNOME Foundation</ulink> координирует разработку и другие аспекты проекта GNOME. </para>
<para>О Програмном обеспечении</para>
<para>GNOME представляет собой рабочую среду а также платформу для разработчиков. Это "открытое ПО" используется в качестве рабочей среды для рабочих станций, некоторыми промышленными лидерами. Эта среда представляет интерес, как для бизнес пользователей, домашних пользователей так и разработчиков. </para>
<para>Сообщество</para>
<para>Как и любого большого открытого проекта, у Gnome очень большое количество разработчиков, а также большая пользовательская база. <ulink url="http://www.gnomedesktop.org/">Footnotes</ulink> содержит новости для пользователей GNOME Desktop; <ulink url="http://planet.gnome.org/">GnomePlanet</ulink> предназначена для хакеров/помощников, а <ulink url="http://developer.gnome.org/">Developer.Gnome.Org</ulink> для разработчиков. </para></sect3></sect2><sect2><title/><sect3><title>2. Установка GNOME</title>
<para>Что вам понадобится?</para>
<para>Перед тем как устанавливать GNOME, вы может быть захотите отредактировать переменные USE. Убедитесь что gtk и gnome прописаны как переменные USE в /etc/make.conf. Если вы не планируете использовать KDE (другая подобная рабочая среда) тогда, удалите qt и kde. </para>
<para>Листинг 2.1: Пример использования переменных USE в /etc/make.conf</para>
<para>USE="-qt -kde gtk gnome"</para>
<para/>
<para/>
<para>После этого, начните установку GNOME с помощью emerging gnome и xscreensaver: </para>
<para>Листинг 2.2: Установка GNOME</para>
<para># emerge gnome xscreensaver</para>
<para/>
<para/>
<para/>
<para>Это займет какое-то время, за это время вы можете прочитать все те книги которые для вас приготовила мам, и которые вы никогда в жизни не открывали. Готово? Отлично, теперь вы должны обновить переменные рабочей среды. </para>
<para>Листинг 2.3: Обновление зависимостей рабочей среды</para>
<para># env-update &amp;&amp; source /etc/profile</para>
<para/>
<para/>
<para>Если вы были внимательны, то после завершения выполнения команды emerge, вам предлагают добавить famd по умолчанию, чтобы nautilus и gnome-vfs могли отслеживать изменения файлов: </para>
<para>Листинг 2.4: Добавление famd по умолчанию</para>
<para># /etc/init.d/famd start</para>
<para># rc-update add famd default</para>
<para/>
<para/>
<para>Первые впечатления</para>
<para>Давай для начала посмотрим что у нас получилось. Выйдите из root shell и зайдите в систему как обычный пользователь. Сейчас мы сконфигурируем сессию GNOME с помощью команды startx: </para>
<para>Листинг 2.5: Использование рабочей среды GNOME по умолчанию</para>
<para>$ echo "exec gnome-session" &gt; ~/.xinitrc</para>
<para/>
<para/>
<para>Запускаем графическую среду, набрав команду startx: </para>
<para/>
<para>Листинг 2.6: Запуск GNOME</para>
<para>$ startx</para>
<para/>
<para/>
<para>Если все сделано правильно, GNOME приветствует вас. Поздравляем. Теперь давайте попробуем сконфигурировать рабочую среду GNOME. </para>
<para>3. Настройка GNOME</para>
<para>Графический менеджеры GNOME входа в систему</para>
<para>Если вы хотите, чтобы GNOME Display Manager (GDM) запускался автоматически при загрузке (таким образом вы сможете зайти в систему с помощью графического интерфейса), то вы должны установить xdm в default runlevel. </para>
<para>Листинг 3.1: Установка запуска xdm по умолчанию </para>
<para># rc-update add xdm default</para>
<para/>
<para/>
<para>Проверьте содержание /etc/X11/Sessions: </para>
<para>Листинг 3.2: Проверка содержания /etc/X11/Sessions /etc/X11/Sessions</para>
<para># ls /etc/X11/Sessions</para>
<para>Xsession Gnome</para>
<para/>
<para>Как видите, теперь доступна сессия gnome. Теперь отредактируйте /etc/rc.conf и измените 2 переменные: DISPLAYMANAGER (должно быть gdm) и XSESSION (должно быть Gnome): </para>
<para>Листинг 3.3: Редактирование /etc/rc.conf</para>
<para>DISPLAYMANAGER="gdm"</para>
<para>XSESSION="Gnome"</para>
<para/>
<para>После перезагрузки, GNOME Display Manager спросит имя пользователя и пароль. GNOME будет рабочей средой по умолчанию (конечно же здесь есть возможность выбора). </para></sect3></sect2></sect1><sect1><title>Использование UTF-8 в Gentoo</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/kde-config.xml">http://www.gentoo.org/doc/ru/utf-8.xml</ulink>
</para>
<para>С версии: 1.0</para><sect2><title>1. Предупреждение или Напутствие переводчика</title>
<para/>
<para>Путь Юникода в русском Gentoo-сообществе сложен. Мы постоянно сталкивались с проблемами неполной поддержки или же неподдержки вовсе отдельными приложениями стандарта UTF-8. </para>
<para/>
<para>Но всё меняется к лучшему. Большинство приложений так или иначе стало поддерживать региональные настройки UTF-8. А для не поддерживающих уже разработаны способы исправления этого недостатка. Но всё же, если у вас возникли трудности с настройкой Юникода в Gentoo, то вы всегда найдете помощь и поддержку (иногда сквозь стиснутые зубы :)) на следующих страницах: </para>
<para/>
<orderedlist>
<listitem>
<para>
<ulink url="http://ru.gentoo-wiki.com/HOWTO_ru_RU.utf8_Gentoo_way">Статья в gentoo-wiki о поддержке Юникода</ulink>
<ulink url="http://gentoo.ru/forum"> </ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://gentoo.ru/forum">Форум русского сообщества Gentoo</ulink> </para>
</listitem>
<listitem>
<para>
<ulink url="http://forums.gentoo.org/viewforum-f-43.html">Русскоязычный форум на официальном сайте Gentoo</ulink> </para>
</listitem>
</orderedlist>
<para/>
<para>Если вы заметили неточность или хотите дополнить данное руководство, пожалуйста свяжитесь переводчиком или одним из редакторов перевода. </para>
<para/></sect2><sect2><title>2. Кодировки</title>
<para>Что такое кодировка?</para>
<para/>
<para>Компьютеры неспособны воспринимать текст. Вместо этого они каждый символ представляют как число. Традиционно каждый набор чисел, соответствующий алфавиту и символам (известный как кодировка или набор символов), ограничен в размере в силу ограничений оборудования. </para>
<para/>
<para>История кодировок символов</para>
<para/>
<para>Самой распространенной (или наиболее принятой повсеместно) кодировкой является ASCII (Американский стандартный код для обмена информацией, American Standard Code for Information Interchange). Повсеместное использование говорит о том, что ASCII — наиболее успешный программный стандарт современности. Нынешний ASCII стандартизован в 1986 году (ANSI X3.4, RFC 20, ISO/IEC 646:1991, ECMA-6) Американским национальным институтом по стандартизации (American National Standards Institute, ANSI). </para>
<para/>
<para>ASCII является строго семибитной кодировкой, из чего следует, что она использует семь двоичных цифр, то есть интервал от 0 до 127. ASCII начинается с 32 невидимых управляющих символов (с кодами от 0 до 31) и заканчивается управляющим символом DEL (или delete) с кодом 127. Символы в диапазоне от 32 до 126 видимы — это пробел, знаки препинания, латинские буквы и цифры. </para>
<para/>
<para>Восьмой бит в ASCII изначально использовался как бит целостности для проверки ошибок при передаче информации. Если не указывалось особо, он всегда равнялся 0. Это означает, что в ASCII каждый символ равняется одному байту. </para>
<para/>
<para>Хотя ASCII было достаточно для передачи информации на английском, для других европейских языков, содержащих символы с ударениями, это было не так просто. Для них был разработаны стандарты семейства ISO 8859. Они были обратно совместимы с ASCII, но также использовали восьмой бит для дополнения таблицы дополнительными 127 символами для каждой кодировки. Ограничения ISO 8859 были незначительными, поэтому стандарт получил распространение. На данный момент существует 15 вариантов стандарта ISO 8859 (от 8859-1 до 8859-15). Однако для каждого символа вне ASCII-совместимого диапазона между этими стандартами возникал конфликт. Чтобы еще больше усилить конфликт между различными кодировками, для восточноевропейских языков корпорацией Microsoft был введен набор Windows-1252, использованный в ранних версиях Windows. Этот набор является надстройкой ISO 8859-1, обладающий собственными изменениями. Однако все же эти наборы были совместимы с ASCII. </para>
<para/>
<para>Необходимость разработки совершенно отличных от ASCII однобайтовых кодировок для нелатинских алфавитов, как например EUC (Extended Unix Coding), используемый в японском и корейском (и в меньшей степени китайском) алфавитах, породила еще большую неразбериху с кодировками, из-за чего ряд операционных систем все еще использует различные наборы символов для одного и того же языка, например японские Shift-JIS и ISO-2022-JP. А пользователи, желающие видеть кириллицу, вынуждены были выбирать между KOI8-R (для русского и болгарского языков) и KOI8-U (для украинского языка), неудачной ISO 8859-5 и популярной Windows-1251. Все три семейства кодировок не полностью совместимы с ASCII (хотя в KOI8 фонетически созвучные кириллические символы расположены так же, как и латинские, благодаря чему даже при отбрасывании восьмого бита текст оставался читабельным в ASCII-терминалах в виде транслита). </para>
<para/>
<para>Все это привело к путанице и полной невозможности многоязычного общения, в особенности с использованием различных алфавитов. Переходим к Юникоду. </para>
<para/>
<para>Что такое Юникод?</para>
<para/>
<para>Юникод отбрасывает лимит традиционных однобайтовых кодировок. Он использует 17 «плоскостей», содержащих по 65 536 кодов символов. Таким образом, максимальное возможное число символов равно 1 114 112. Поскольку в первой плоскости («Basic Multilingual Plane» или BMP) содержится почти всё, что вам может понадобиться, многие ошибочно посчитали, что Юникод — это 16-битный набор символов. </para>
<para/>
<para>Юникод реализован несколькими способами, но распространены только два — UTF (Unicode Transformation Format) и UCS (Universal Character Set). Число после UTF обозначает число бит на каждый символ, когда как число после UCS обозначает число байт. UTF-8 стала наиболее распространенной при обмене текста Юникод из-за малых (сравнительно) потерь при хранении текста, Поэтому она и является основной темой данного документа. </para>
<para/>
<para>UTF-8</para>
<para/>
<para>UTF-8 — это кодировка переменной длины. Это означает, что для каждого символа она может использовать от одного до четырех байт. Первый байт UTF-8 используется для кодирования ASCII, благодаря чему UTF-8 полностью обратно совместима с ASCII. UTF-8 подразумевает, что ASCII и латинские символы равнозначны с небольшим увеличением размера данных, так как используется только первый байт. Пользователи восточных кодировок (например, японского), которым назначены старшие диапазоны, не так рады, так как в результате их данные разбухают на 50 %. </para>
<para/>
<para>Что UTF-8 может сделать для вас</para>
<para/>
<para>UTF-8 позволяет вам работать в совместимой со всеобщими стандартами и принятой по всему миру многоязычной среде, правда с небольшими потерями при обработке данных. UTF-8 — это наилучший способ для передачи не-ASCII символов через интернет, будь то электронная почта, IRC-сети или что-нибудь еще. Несмотря на это, множество людей расценивают использование UTF-8 при передаче данных неприличным и неуважительным. Всегда следует выяснять, поддерживает ли определенный канал, группа Usenet или список рассылки UTF-8 перед тем, как использовать символы из не-ASCII диапазона UTF-8. </para>
<para/></sect2><sect2><title>3. Включение UTF-8 в Gentoo Linux</title>
<para/>
<para>Поиск или создание локалей UTF-8</para>
<para/>
<para>Теперь, когда вы поняли основы Юникода, вы готовы начать использование UTF-8 в вашей системе. </para>
<para/>
<para>Главным требованием для UTF-8 является наличие установленной библиотеки glibc с поддержкой национального языка. При этом рекомендуется использовать файл /etc/locale.gen. Описание использования этого файла, однако, выходит за рамки данного документа. Его использование описано в Руководстве по локализации Gentoo. </para>
<para/>
<para>Далее, нужно определить, доступна ли нам локаль UTF-8 для нашего языка или придётся её создать. </para>
<para/>
<para>Листинг 3.1: Поиск существующей локали UTF-8</para>
<para>(Замените "ru_RU" своим регионом)</para>
<para># locale -a | grep 'ru_RU'</para>
<para>ru_RU</para>
<para>ru_RU.UTF-8</para>
<para/>
<para/>
<para>На выходе этой команды мы должны получить хотя бы одну строку, содержащую суффикс .UTF-8. Если таковых нет, то нам придётся создать локаль, совместимую с UTF-8. </para>
<para>Примечание: Запускайте следующую команду, если у вас нет UTF-8 локали для вашего языка. </para>
<para/>
<para/>
<para>Листинг 3.2: Создание локали UTF-8</para>
<para>(Замените "ru_RU" своим регионом)</para>
<para># localedef -i ru_RU -f UTF-8 ru_RU.UTF-8</para>
<para/>
<para/>
<para>Другим способом включить локаль UTF-8 является добавление её в файл /etc/locale.gen и генерация нужных локалей командой locale-gen. </para>
<para/>
<para>Листинг 3.3: Одна из строк в /etc/locale.gen</para>
<para>ru_RU.UTF-8/UTF-8</para>
<para/>
<para/>
<para>Настройка локали</para>
<para/>
<para>Есть одна переменная среды, которую необходимо установить, чтобы использовать UTF-8 локали: LANG (эту переменную также можно перезаписывать переменной LC_ALL). Есть множество способов сделать это. Некоторые люди предпочитают использовать UTF-8 только для определенного пользователя, поэтому они устанавливают эту переменную в своём ~/.profile (если используется /bin/sh), ~/.bash_profile или ~/.bashrc (если используется /bin/bash). </para>
<para/>
<para>Другие предпочитают установить локаль глобально. Есть по крайней один весомый аргумент в пользу этого подхода — при использовании /etc/init.d/xdm, так как сценарии инициализации запускают диспетчер окон до того, как будут загружены конфигурационные файлы командной оболочки. </para>
<para/>
<para>При установке глобальной локали должен быть использован файл /etc/env.d/02locale. Он должен выглядеть следующим образом: </para>
<para/>
<para>Листинг 3.4: Вид /etc/env.d/02locale</para>
<para>(Как и всегда, замените "ru_RU.UTF-8" вашей локалью)</para>
<para>LANG="ru_RU.UTF-8"</para>
<para/>
<para>Примечание: Вы можете также указывать LC_ALL вместо LANG. Так локаль устанавливается для всех категорий, включая числовые и денежные значения. На небольшом количестве систем это может вызывать некоторые проблемы. Однако, большинство пользователей может использовать LC_ALL без проблем. За дополнительными сведениями о категориях, затронутых использованием LC_ALL, пожалуйста, обращайтесь к странице локалей GNU. </para>
<para/>
<para/>
<para>Далее следует обновить среду. </para>
<para/>
<para>Листинг 3.5: Обновление среды</para>
<para># env-update</para>
<para>&gt;&gt;&gt; Regenerating /etc/ld.so.cache...</para>
<para> * Caching service dependencies ...</para>
<para># source /etc/profile</para>
<para/>
<para/>
<para>Теперь запустите locale без аргументов, чтобы увидеть, что у вас верные переменные среды: </para>
<para/>
<para/>
<para/>
<para/>
<para>Листинг 3.6: Проверка новой применённой локали</para>
<para># locale</para>
<para>LANG=</para>
<para>LC_CTYPE="ru_RU.UTF-8"</para>
<para>LC_NUMERIC="ru_RU.UTF-8"</para>
<para>LC_TIME="ru_RU.UTF-8"</para>
<para>LC_COLLATE="ru_RU.UTF-8"</para>
<para>LC_MONETARY="ru_RU.UTF-8"</para>
<para>LC_MESSAGES="ru_RU.UTF-8"</para>
<para>LC_PAPER="ru_RU.UTF-8"</para>
<para>LC_NAME="ru_RU.UTF-8"</para>
<para>LC_ADDRESS="ru_RU.UTF-8"</para>
<para>LC_TELEPHONE="ru_RU.UTF-8"</para>
<para>LC_MEASUREMENT="ru_RU.UTF-8"</para>
<para>LC_IDENTIFICATION="ru_RU.UTF-8"</para>
<para>LC_ALL=ru_RU.UTF-8</para>
<para/>
<para/>
<para>Вот и всё. Теперь вы используете локаль UTF-8, и следующим этапом является настройка повседневно используемых вами приложений. </para>
<para/></sect2><sect2><title>4. Поддержка приложениями</title>
<para/>
<para>Пока Юникод делает первые шаги в мире программного обеспечения, и многобайтовые кодировки еще не включены в языки программирования, наподобие C, и множество повседневно используемых программ. Даже сейчас некоторые программы не способны работать с UTF-8 как надо. К счастью, таких не так много! </para>
<para/>
<para>Имена файлов, NTFS и FAT</para>
<para/>
<para>В в конфигурационном меню ядра Linux есть множество параметров NLS, но главное — не паниковать! В большинстве случаев всё, что вам нужно — включить поддержку UTF-8 NLS в ваше ядро и изменить NLS по умолчанию на utf8. </para>
<para/>
<para>Листинг 4.1: Конфигурация ядра для UTF-8 NLS</para>
<para>File Systems --&gt;</para>
<para>  Native Language Support --&gt;</para>
<para>    (utf8) Default NLS Option</para>
<para>    &lt;*&gt; NLS UTF8</para>
<para>    (также &lt;*&gt; для других кодировок, используемых в ФС FAT или Joilet CD-ROM)</para>
<para/>
<para/>
<para>Если вы планируете монтировать разделы NTFS, то вам понадобиться указать параметр при монтировании nls=. Если вы будете монтировать разделы FAT, вам понадобится указать при монтировании параметр codepage=. Также вы можете установить для FAT кодовую страницу по умолчанию при конфигурации ядра. Помните, что параметр codepage, указываемый при монтировании, будет иметь приоритет над настройками ядра. </para>
<para/>
<para>Листинг 4.2: Настройки FAT при конфигурировании ядра</para>
<para>File Systems --&gt;</para>
<para>  DOS/FAT/NT Filesystems  --&gt;</para>
<para>    (866) Default codepage for fat</para>
<para/>
<para/>
<para>Не устанавливайте Default iocharset for fat в UTF-8, так как это не рекомендуется. Вместо этого укажите параметр utf8=true при монтировании раздела FAT. Для более детальной информации, смотрите man mount и документацию по ядру /usr/src/linux/Documentation/filesystems/vfat.txt. </para>
<para/>
<para>Чтобы сменить кодировку имен файлов, используйте app-text/convmv. </para>
<para/>
<para>Листинг 4.3: Пример использования convmv</para>
<para># emerge --ask app-text/convmv</para>
<para>(Формат команды)</para>
<para># convmv -f &lt;current-encoding&gt; -t utf-8 &lt;filename&gt;</para>
<para>(Замените koi8-r кодировкой, с которой хотите конвертировать)</para>
<para># convmv -f koi8-r -t utf-8 filename</para>
<para/>
<para/>
<para>Для изменения содержимого файлов, используйте утилиту iconv, поставляемую вместе с glibc: </para>
<para/>
<para>Листинг 4.4: Пример использования iconv</para>
<para>(Замените koi8-r кодировкой, с которой хотите конвертировать)</para>
<para>(Проверка верности вывода)</para>
<para># iconv -f koi8-r -t utf-8 filename</para>
<para>(Конвертация файла, вы должны указать другое имя файла)</para>
<para># iconv -f koi8-r -t utf-8 filename &gt; newfile</para>
<para/>
<para/>
<para>Также для этой цели может быть использована утилита app-text/recode. </para>
<para/>
<para>Системная консоль</para>
<para/>
<para>Важно: Вам необходим &gt;=sys-apps/baselayout-1.11.9 для поддержки Юникода в консоли. </para>
<para/>
<para>Для включения UTF-8 в консоли вы должны отредактировать /etc/rc.conf и установить переменную UNICODE="yes". Также прочтите комментарии в этом файле — важно, чтобы в системе были шрифты с нужным диапазоном символов (если вы хотите выжать из Юникода всё). </para>
<para/>
<para>В файле /etc/conf.d/keymaps переменной KEYMAP должна соответствовать раскладка Unicode. </para>
<para/>
<para>Листинг 4.5: Пример файла /etc/conf.d/keymaps</para>
<para>(Замените "ru4" на вашу любимую раскладку)</para>
<para>(Для русского языка нужен ключ -u — прим. переводчика)</para>
<para>KEYMAP="-u ru4"</para>
<para>(Подмена кодировки для русского языка — прим. переводчика)</para>
<para>DUMPKEYS_CHARSET="koi8-r"</para>
<para/>
<para>Важно: Помните, что для правильного отображения вам понадобятся шрифты с поддержкой Юникода. Подробнее смотрите раздел X11 и шрифты этого руководства. </para>
<para/>
<para>А теперь выберем подходящий шрифт, поддерживающий Юникод. </para>
<para/>
<para>Листинг 4.6: Файл /etc/conf.d/consolefont</para>
<para>(Отредактируйте переменную CONSOLEFONT)</para>
<para>CONSOLEFONT="ter-k14n" # шрифт из пакета terminus-font)</para>
<para/>
<para/>
<para>ncurses и slang</para>
<para/>
<para>Примечание: Если вы не устанавливали или не использует slang, не принимайте во внимание упоминания о нём в этом разделе. </para>
<para/>
<para/>
<para>Будет хорошим решением добавить unicode к глобальным USE-флагам в файле /etc/make.conf, а затем при необходимости пересобрать sys-libs/ncurses и sys-libs/slang. Portage это сделает автоматически при обновлении системы: </para>
<para/>
<para>Листинг 4.7: Обновление системы</para>
<para># emerge --update --deep --newuse world</para>
<para/>
<para/>
<para>Также понадобится пересобрать пакеты, зависящие от них, раз изменения USE вступили в силу. Используемая утилита (revdep-rebuild) входит в пакет gentoolkit. </para>
<para/>
<para>Листинг 4.8: Пересборка программ, скомпонованных с ncurses или slang</para>
<para># revdep-rebuild --soname libncurses.so.5</para>
<para># revdep-rebuild --soname libslang.so.1</para>
<para/>
<para/>
<para>KDE, GNOME и Xfce</para>
<para/>
<para>Все основные графические оболочки полностью совместимы с Юникодом и не требуют дополнительной настройки, кроме той, что описана в этом документе. Все это благодаря тому, графические библиотеки (Qt и GTK+2) совместимы с UTF-8. Следовательно, все приложения, работающие на основе этих библиотек, также должны поддерживать UTF-8 без дополнительных настроек. </para>
<para/>
<para>Исключением в этом правиле является Xlib и GTK+1. GTK+1 требует iso-10646-1 FontSpec в ~/.gtkrc, например -misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1. Также приложения, использующие Xlib или Xaw, нуждаются в подобной FontSpec, иначе они не буду работать. </para>
<para>Примечание: Если у вас установлен Центр управления gnome1, используйте его. Воспользуйтесь любым из шрифтов семейства iso10646-1. </para>
<para/>
<para/>
<para>Листинг 4.9: Пример ~/.gtkrc (для GTK+1), определяющий Юникод-совместимый шрифт</para>
<para>style "user-font"</para>
<para>{</para>
<para>    fontset="-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1"</para>
<para>}</para>
<para>widget_class "*" style "user-font"</para>
<para/>
<para>Важно: В Xorg 6.8.2 для славянских языков эта проблема подобным образом не решается. Обратитесь к руководствам на сайтах Fantoo или Gentoo-wiki для решения данной проблемы либо откатите Xorg до версии 6.8.0. </para>
<para/>
<para/>
<para>Если приложение одинаково поддерживает Qt и GTK+2, то обычно GTK+2 GUI выдает лучшие результаты при работе с Юникодом. </para>
<para/>
<para>X11 и шрифты</para>
<para>Важно: По сравнению с XFree86 x11-base/xorg-x11 лучше поддерживает Юникод, и поэтому настоятельно рекомендуется использовать именно его. </para>
<para/>
<para>Шрифты TrueType обычно совместимы с Юникодом, и большинство шрифтов, поставляемых с Xorg, имеют великолепную поддержку кодировок, хотя не все глифы Юникода могут быть отображены для конкретного шрифта. Чтобы собрать шрифты с поддержкой Восточноазиатских алфавитов (включающие набор Bitstream Vera) для X-сервера, добавьте USE-флаг cjk. Много приложений используют этот флаг, поэтому неплохо бы внести его как постоянный флаг. </para>
<para/>
<para>Также несколько пакетов шрифтов в Portage совместимы с Юникодом. </para>
<para/>
<para>Листинг 4.10: Необязательно: установка некоторых Юникод-совместимых шрифтов</para>
<para># emerge terminus-font intlfonts freefonts cronyx-fonts corefonts</para>
<para/>
<para/>
<para>Диспетчеры окон и терминальные эмуляторы</para>
<para/>
<para>Диспетчеры окон, не использующие GTK или Qt, обычно очень хорошо поддерживают Юникод, так как чаще всего для отображения шрифтов используют библиотеку Xft. Если ваш диспетчер окон не использует Xft, то вы все еще можете использовать FontSpec, указанный в предыдущем разделе в качестве шрифта Юникода. </para>
<para/>
<para>Эмуляторы терминала, использующие Xft, в большинстве случаев поддерживают Юникод. Кроме Konsole и gnome-terminal, лучшим выбором в Portage будет x11-terms/rxvt-unicode, xfce-extra/terminal, gnustep-apps/terminal, x11-terms/mlterm или чистый x11-terms/xterm, собранный с USE-флагом unicode и запускаемый как uxterm. app-misc/screen тоже поддерживает UTF-8, если запускается с параметром screen -U, или внесите следующее в файл ~/.screenrc: </para>
<para/>
<para>Листинг 4.11: ~/.screenrc с UTF-8</para>
<para>defutf8 on</para>
<para/>
<para/>
<para>Vim, Emacs, Xemacs и Nano</para>
<para/>
<para>Vim полностью поддерживает UTF-8 и к тому же автоматически определяет файлы с UTF-8. Для более детальной информации используйте в Vim :help mbyte.txt. </para>
<para/>
<para>Emacs 22.x и выше полностью поддерживает UTF-8. Xemacs 22.x ещё не поддерживает различные кодировки. </para>
<para/>
<para>Более старшим версиям Emacs и/или Xemacs понадобятся пакеты app-emacs/mule-ucs и/или app-xemacs/mule-ucs и добавление следующих строчек в файл ~/.emacs для поддержки CJK-языков в UTF-8: </para>
<para/>
<para>Листинг 4.12: Emacs с поддержкой CJK UTF-8</para>
<para>(require 'un-define)</para>
<para>(require 'jisx0213)</para>
<para>(set-language-environment "Japanese")</para>
<para>(set-default-coding-systems 'utf-8)</para>
<para>(set-terminal-coding-system 'utf-8)</para>
<para/>
<para/>
<para>Nano полностью поддерживает UTF-8 начиная с версии 1.3.6. </para>
<para/>
<para>Командные оболочки</para>
<para/>
<para>На данный момент только bash полностью поддерживает Юникод через библиотеку GNU readline. Пользователи оболочки Z находятся в промежуточном положении — пока ни одна из составных оболочки еще поддерживает Юникод, хотя на данный момент ведутся усиленные работы для поддержки многобайтовых кодировок. </para>
<para/>
<para>Оболочки C, tcsh и ksh не поддерживают UTF-8. </para>
<para/>
<para>Irssi</para>
<para/>
<para>Irssi полностью поддерживает UTF-8, хотя для этого требуется дополнительная настройка пользователем. </para>
<para/>
<para>Листинг 4.13: Включение UTF-8 в Irssi</para>
<para>/set term_charset UTF-8</para>
<para/>
<para/>
<para>Для каналов, где не-ASCII символы чаще всего передаются в не-UTF-8 кодировках, может пригодиться команда /recode для перекодировки символов. Наберите /help recode для большей информации. </para>
<para/>
<para>Mutt</para>
<para/>
<para>Почтовый агент Mutt очень хорошо справляется с Юникодом. Чтобы использовать UTF-8 для Mutt, вам нет необходимости что-либо добавлять в конфигурационные файлы. Mutt будет работать с Юникодом без модификации, при условии, что все ваши конфигурационные файлы (включая подпись) сохранены в UTF-8. </para>
<para>Примечание: Вы всё ещё можете видеть знаки вопроса при чтении почты с помощью Mutt. Это случается из-за того, что некоторые люди используют почтовые клиенты, не устанавливающие используемую кодировку письма. Вы ничего больше не можете сделать, кроме как попросить их правильно настроить свои клиенты. </para>
<para/>
<para/>
<para>См.<ulink url="http://wiki.mutt.org/index.cgi?MuttFaq/Charset">Mutt Wiki </ulink>для большей информации. </para>
<para/>
<para>Man</para>
<para/>
<para>Man-страницы являются неотъемлемой частью любой системы Linux. Чтобы удостовериться, что все страницы отображаются верно, отредактируйте /etc/man.conf и замените следующую строку. </para>
<para/>
<para>Листинг 4.14: Изменения man.conf для поддержки Юникода</para>
<para>(Это старая строка)</para>
<para>NROFF           /usr/bin/nroff -Tascii -c -mandoc</para>
<para>(Замените ее этой)</para>
<para>NROFF           /usr/bin/nroff -mandoc -c</para>
<para/>
<para/>
<para>elinks и links</para>
<para/>
<para>Это самые популярные текстовые браузеры, и вы узнаете, как установить поддержку UTF-8 для них. В elinks и links есть два способа сделать это — через меню Setup (Установки) браузера или отредактировав конфигурационный файл. Чтобы настроить параметры в самом браузере, откройте какой-нибудь сайт с помощью elinks или links и нажмите Alt+S. Вы попадете в меню настроек (Setup Menu), после чего выберите параметры терминала (Terminal options), или нажмите T. Пролистайте вниз и выберите последний параметр — UTF-8 I/O, нажав на Enter. После сохраните и выйдите из меню. В links вы можете сделать то же самое, нажав Alt+S, а затем S для сохранения. Пример конфигурационного файла показан ниже. </para>
<para/>
<para>Листинг 4.15: Включение UTF-8 в elinks/links</para>
<para>(Для elinks добавьте в /etc/elinks/elinks.conf или ~/.elinks/elinks.conf следующую строку)</para>
<para>set terminal.linux.utf_8_io = 1</para>
<para/>
<para>(Для links добавьте ~/.links/links.cfg следующую строку)</para>
<para>terminal "xterm" 0 1 0 us-ascii utf-8</para>
<para/>
<para/>
<para>Samba</para>
<para/>
<para>Samba — это набор программ, реализующих протокол SMB (Server Message Block) для UNIX-систем (Mac, Linux и FreeBSD). Этот протокол также иногда упоминается как Common Internet File System (CIFS). Samba содержит также систему NetBIOS, используемую для предоставления доступа к файлам в Windows-сетях. </para>
<para/>
<para>Листинг 4.16: Включение UTF-8 в Samba</para>
<para>(Отредактируйте /etc/samba/smb.conf и добавьте следующее в раздел [global])</para>
<para>dos charset = 866</para>
<para>unix charset = UTF-8</para>
<para>display charset = UTF-8</para>
<para/>
<para/>
<para>Проверка работоспособности</para>
<para/>
<para>Есть множество сайтов, проверяющих UTF-8. net-www/w3m, net-www/links, net-www/elinks, net-www/lynx, все браузеры, основанные на движке Mozilla (включая Firefox) поддерживают UTF-8. Konqueror и Opera тоже полностью поддерживают UTF-8. </para>
<para/>
<para>При использовании текстовых браузеров, удостоверьтесь, что используете совместимый с Юникодом терминал. </para>
<para/>
<para>Если вы видите символы, отображаемые как квадратики с буквами или цифрами внутри, то это значит, что в ваших шрифтах нет соответствующего глифа для символа. Вместо этого, они отображают квадрат с шестнадцатиричным кодом символа UTF-8. </para>
<para/>
<orderedlist>
<listitem>
<para>
<ulink url="http://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html">Тестовая страница W3C с UTF-8</ulink>
<ulink url="http://titus.uni-frankfurt.de/indexe.htm?/unicode/unitest.htm"> </ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://titus.uni-frankfurt.de/indexe.htm?/unicode/unitest.htm">Тестовая страница Франкфуртского университета</ulink> </para>
</listitem>
</orderedlist>
<para/>
<para/>
<para>Ввод символов</para>
<para/>
<para>Dead keys могут быть использованы для ввода символов, не отображенных на клавиатуре, в X-сервере. Для этого нужно, удерживая правый Alt (в некоторых странах он называется AltGr), нажать на дополнительную неалфавитную клавишу с символом, не являющимся буквой или цифрой (модификатор), а затем нажать на необходимую букву. Dead key изменит ее. Ввод может быть изменен также с помощью Shift при нажатых AltGr и модификаторе. </para>
<para/>
<para>Чтобы включить dead keys в X, нужно иметь раскладку, поддерживающую их. Большинство европейских раскладок уже имеют dead keys по умолчанию. Тем не менее, они не являются настоящими североамериканскими раскладками. Хотя существуют незначительные отличия между различными раскладками, простейшим решением будет использование раскладки «en_US» вместо просто «us». Раскладка указывается в /etc/X11/xorg.conf: </para>
<para/>
<para>Листинг 4.17: Пример раздела /etc/X11/xorg.conf</para>
<para>Section "InputDevice"</para>
<para>    Identifier "Keyboard0"</para>
<para>    Driver     "kbd"</para>
<para>    Option     "XkbLayout" "en_US" # Вместо просто "us"</para>
<para>    (Другие параметры Xkb)</para>
<para>EndSection</para>
<para/>
<para>Примечание: Эти изменения нужны только в том случае, если вы используете североамериканскую раскладку либо любую другую, в которой dead keys не работают. Европейским пользователям нет нужны что-либо менять. </para>
<para/>
<para/>
<para>Изменения вступят в силу только при перезагрузке X-сервера. Чтобы изменения вступили немедленно, используйте утилиту setxkbmap, например, setxkbmap en_US. </para>
<para/>
<para>Рассмотрим действия dead keys на примерах. Хотя результат зависит от текущей локали, сам принцип действия должен работать в нее зависимости от нее. Примеры содержат символы Юникода, так что убедитесь, что ваш браузер корректно отображает их. </para>
<para/>
<para>При нажатии единожды нажатых AltGr и [, а затем нажатой «a» мы получаем «a». При единожды нажатых AltGr и [, а затем нажатой «e», получаем «e». Нажав на AltGr и ;, мы получим «a», а нажав AltGr и ;, а затем на «e», получаем «e». </para>
<para/>
<para>Нажав на AltGr, Shift и [, отпустив их и нажав «a», мы получим скандинавскую «a». Также при нажатии AltGr, Shift и [, отпускании только [ и повторном ее нажатии мы получим только «?». Хотя этот символ (U+02DA) и похож на символ градуса (U+00B0), на самом деле он им не является. Подобным образом работают и другие модификаторы — нажатие AltGr and [, отпускание [ и повторное нажатие выводят «?». </para>
<para/>
<para>AltGr может быть использована вместе с одной из алфавитных клавиш. Например, комбинация AltGr и m выводит греческую строчную букву мю: «ч». AltGr и s выводит немецкий символ эсцет: «?». Множество европейцев захотят установить сочетание AltGr и 4 (или E в зависимости от клавиатурный таблицы), выводящее символ Евро, «?» (так как на их клавиатурах он нанесен). </para>
<para/></sect2></sect1><sect1><title>Руководство по русской локализации Gentoo Linux</title>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/kde-config.xml">http://www.gentoo.org/doc/ru/guide-localization.xml</ulink>
</para>
<para>С версии: 1.0</para><sect2><title>1. Введение</title>
<para/>
<para>Что такое русская локализация</para>
<para/>
<para>В понятие локализации входит обеспечение вывода и ввода символов национальных языков (в случае использования набора символов, отличных от чистого латинского) и определение переменных окружения, зависящих от страны, языка и набора символов (то есть собственно установка locale). В число таких переменных, кроме страны, языка и набора символов, входят также представление даты и времени, разделителей десятичных дробей, денежных единиц и так далее. </para>
<para/>
<para>Вследствие различия подходов в этом документе будут отдельно рассмотрены локализация текстового (то есть Linux-консоли) и графического (оконной системы X) режимов. </para>
<para/>
<para>О кириллических кодировках</para>
<para/>
<para>В условиях России и некоторых других стран бывшего СССР локализация осложняется множественностью наборов символов (charsets), используемых для представления алфавитов, основанных на кириллице. Причём для Unix-систем получили распространение минимум три таких набора, в просторечии именуемых кодировками: традиционная для свободных Unix-клонов (в том числе и Linux) кодировка KOI8-R, кодировка ISO-8859-5 (именуемая кодировкой ГОСТ), используемая в проприетарных Unix-системах, и кодировка CP1251 (или кодировка Windows). Кроме того, для обеспечения экранного вывода используется кодировка CP866 (или кодировка DOS). Наконец, в последнее время всё большую популярность получает кодировка UTF-8. </para>
<para/>
<para>В Gentoo Linux штатно (как говорится, из коробки) поддерживается кодировка KOI8-R, и всё сказанное ниже относится именно к ней. Локализацию для кодировок ISO-8859-5 или CP1251 пользователь может выполнить самостоятельно, получив из независимых источников некоторые дополнительные компоненты. О локализации для кодировки UTF-8, призванной унифицировать подход к интернационализации, будет говориться в следующих версиях этого документа, когда использование её станет общепринятым. </para></sect2><sect2><title>2. Базовая кириллизация консоли</title>
<para/>
<para>Введение</para>
<para/>
<para>Итак, базовая локализация консоли включает обеспечение вывода национальных символов на экран и ввода их с клавиатуры. Однако в случае кириллической локализации вследствие особенностей наборов символов и аппаратных особенностей PC для ввода и для вывода используются, как правило, разные кодировки. И это требует еще двух дополнительных шагов — установки карты соответствия между наборами символов ввода и вывода, и активизация её на каждой из виртуальных консолей. </para>
<para/>
<para>Установка экранного шрифта</para>
<para/>
<para>Экранный шрифт, загружаемый по умолчанию при старте системы, определяется в файле /etc/rc.conf строкой </para>
<para/>
<para>Листинг 2.1: Строка, определяющая экранный шрифт</para>
<para>CONSOLEFONT="default8x16"</para>
<para/>
<para>Для вывода русских букв "умолчальное" значение следует заменить на имя какого-либо файла шрифта с поддержкой кириллицы, например, cp866-8x16 для представления кодировки DOS или koi8r-8x16 — для кодировки KOI8-R. Например, </para>
<para/>
<para>Листинг 2.2: Определение экранного шрифта для кодировки cp866</para>
<para>CONSOLEFONT="cp866-8x16"</para>
<para>Или — </para>
<para>Листинг 2.3: Определение экранного шрифта для кодировки KOI8-R</para>
<para>CONSOLEFONT="koi8r-8x16"</para>
<para/>
<para>Примечание: Файлы шрифтов (и не только кириллических) находятся в каталоге /usr/share/consolefonts/ и имеют вид *.gz, *.psf.gz или *.psfu.gz. При стандартном их размещении и форме ни полного пути, ни "расширения" имени указывать не обязательно.</para>
<para/>
<para>Важно: В кириллическом Linux'е для экранного вывода, как правило, используется кодировка cp866 (вне зависимости от того, какой набор символов принят для клавиатурного ввода). О причинах этого говорить можно было бы долго — достаточно указать, что в любом ином случае программы, использующие псевдографику (например, Midnight Commander) приобретут весьма уродливый вид. </para>
<para/>
<para>Экранные кириллические шрифты, поставляемые с Gentoo Linux, далеки от эстетического совершенства (справедливости ради заметим, что это относится почти ко всем Unix-клонам). И потому в качестве источника дополнительных шрифтов можно рекомендовать пакет console-tools-cyrillic Виктора Вагнера. В результате приведенная выше в качестве примера строка может принять вид вроде </para>
<para/>
<para>Листинг 2.4: Один из лучших кириллических шрифтов для консоли</para>
<para>CONSOLEFONT="UniCyr-sans"</para>
<para/>
<para>Установка раскладки клавиатуры</para>
<para/>
<para>Загружаемая по умолчанию раскладка клавиатуры также определяется в файле /etc/rc.conf строкой </para>
<para/>
<para>Листинг 2.5: Строка, определяющая раскладку клавиатуры</para>
<para>KEYMAP="us"</para>
<para/>
<para/>
<para>По аналогии с предыдущим случаем легко догадаться, что значение us следует заменить на имя файла какой-либо кириллической (на этот раз уже в кодировке KOI8-R) раскладки. Место этих файлов (имеющих вид *.map.gz) — в каталоге /usr/share/keymaps/i386/qwerty, где для русской кодировки KOI8-R имеется несколько раскладок, например, ru1-ru4. Различия между ними — в соответствии различной маркировке клавиш (DOS или Windows — не путать с одноименными кодировками) и положении переключателя латиница/кириллица. Рискну взять на себя смелость рекомендовать раскладку ru4 — для Windows-маркированных клавиатур, в которой переключателем служит CapsLock (при этом фиксация верхнего регистра обеспечивается одновременным нажатием клавиш Shift+CapsLock). То есть строка примет вид: </para>
<para/>
<para>Листинг 2.6: Один из примеров определения кириллической раскладки</para>
<para>KEYMAP="ru4"</para>
<para/>
<para>Примечание: Как и в случае с экранными шрифтами, при стандартном расположении файлов раскладок указывать полный путь к ним и "расширение" имени нет необходимости. </para>
<para/>
<para>Предупреждение: При желании вы можете выбрать и раскладку клавиатуры для кодировки cp1251 (например, ru_win). Однако в этом случае придётся отыскать или самостоятельно изготовить таблицу перекодировки (mapscreen) cp1251-&gt;cp866. </para>
<para/>
<para>Примечание: Нет ничего более уродливого, чем программы, использующие псевдографику, при экранном представлении в кодировке cp1251. </para>
<para/>
<para/>
<para>Установка карты соответствия (mapscreen)</para>
<para/>
<para>Теперь остаётся только обеспечить соответствие между кодировками ввода (KOI8-R) и вывода (cp866), то есть загрузить соответствующую таблицу перекодировки (mapscreen). Для этого снова обращаемся к файлу /etc/rc.conf. Строка в нём, отвечающая за эту операцию, имеет по умолчанию такой вид: </para>
<para/>
<para>Листинг 2.7: Строка, определяющая раскладку клавиатуры</para>
<para>#CONSOLETRANSLATION="cp437_to_iso01"</para>
<para/>
<para/>
<para>Необходимо, сняв с неё символ комментария (#), заменить "умолчальное" значение на необходимое нам, и подсмотреть его можно в каталоге /usr/share/consoletrans — это koi2alt: </para>
<para/>
<para>Листинг 2.8: Установка таблицы соответствия cp866-&gt;KOI8-R</para>
<para>CONSOLETRANSLATION="koi2alt"</para>
<para/>
<para>Предупреждение: Пожалуйста, не забудьте снять символ комментария со строки CONSOLETRANSLATION — кто только на моей памяти не наступал на эти грабли :-) </para>
<para/>
<para>Примечание: Если вы по каким-либо причинам остановились на представлении экранных шрифтов в кодировке KOI8-R, загрузка и активизация карты соответствия, разумеется, не нужна. </para>
<para/>
<para/>
<para>Активизация карты соответствия</para>
<para/>
<para>Результатом выполненной операции будет то, что после перезагрузки машины мы получили бы нормальный вывод кириллического текста (записанного в кодировке KOI8-R), но только — на первой (т.н. системной) консоли. Чтобы иметь то же самое на остальных виртуальных консолях (а в Gentoo Linux их по умолчанию еще 5), та же карта соответствия должна быть активизирована на каждой из них с помощью направления Escape-последовательности \033(K (символ \ в данном случае показывает, что следующие за ним символы рассматриваются как специальные). Достигнуть этого можно разными способами. Например, создать в каталоге /etc/init.d/ файл consoletrans и в любом текстовом редакторе внести в него следующие строки: </para>
<para/>
<para>Листинг 2.9: Сценарий активизации mapscreen</para>
<para>for i in 1 2 3 4 5 6; do</para>
<para>echo -ne '\033(K' &gt; /dev/vc/$i</para>
<para>done</para>
<para/>
<para>Примечание: Это — для случая 6-ти консолей по умолчанию. Если количество их изменялось пользователем, значения in, очевидно, должны быть приведены в соответствие с реальностью. </para>
<para/>
<para>Примечание: Следует отметить, что начиная с baselayout-1.8.x необходимость в этом отпала, поскольку этот код был встроен в /etc/init.d/consolefont. </para>
<para/>
<para/>
<para>Теперь командой chmod a+x /etc/init.d/consoletrans созданному скрипту следует присвоить бит исполнения, после чего он добавляется к уровню исполнения по умолчанию (default runlevel): </para>
<para/>
<para>Листинг 2.10: Сценарий активизации mapscreen</para>
<para># rc-update add consoletrans default</para>
<para/>
<para>Примечание: Механизм автоматического обновления стартовых скриптов подробно описан в соответствующем разделе документации. </para>
<para/>
<para/>
<para>Вот теперь после перезагрузки машины мы получим полноценно локализованную консоль. </para>
<para>Примечание: Все действия, описанные в данной главе, могут быть выполнены как на заключительных шагах (final steps) установки Gentoo Linux, так и в произвольный момент времени в дальнейшем. </para>
<para/></sect2><sect2><title>3. Установка русской locale</title>
<para/>
<para>Установка locale ru_RU.KOI8-R</para>
<para/>
<para>Установить локально-зависимые переменные можно различными способами, в том числе и просто в профильных файлах отдельных пользователей. Однако в Gentoo Linux предусмотрен автоматический механизм установки любых переменных окружения в качестве общесистемных — env-update, подробно описанный в соответствующих разделах документации. </para>
<para/>
<para>Для использования этого механизма следует в файл /etc/env.d/02locale добавить строку </para>
<para/>
<para>Листинг 3.1: Установка переменной LANG</para>
<para>LANG="ru_RU.KOI8-R"</para>
<para/>
<para>которая определяет не только язык locale, но и все остальные локально-зависимые переменные. Далее выполняем команду env-update, дополняющую глобальный профильный файл /etc/profile, после чего остаётся только перечитать последний командой source /etc/profile. Теперь в ответ на команду locale последует вывод </para>
<para/>
<para>Листинг 3.2: Вывод команды locale после установки переменной LANG</para>
<para>LANG=ru_RU.KOI8-R</para>
<para>LC_CTYPE="ru_RU.KOI8-R"</para>
<para>LC_NUMERIC="ru_RU.KOI8-R"</para>
<para>LC_TIME="ru_RU.KOI8-R"</para>
<para>LC_COLLATE="ru_RU.KOI8-R"</para>
<para>LC_MONETARY="ru_RU.KOI8-R"</para>
<para>LC_MESSAGES="ru_RU.KOI8-R"</para>
<para>LC_PAPER="ru_RU.KOI8-R"</para>
<para>LC_NAME="ru_RU.KOI8-R"</para>
<para>LC_ADDRESS="ru_RU.KOI8-R"</para>
<para>LC_TELEPHONE="ru_RU.KOI8-R"</para>
<para>LC_MEASUREMENT="ru_RU.KOI8-R"</para>
<para>LC_IDENTIFICATION="ru_RU.KOI8-R"</para>
<para>LC_ALL=</para>
<para/>
<para/>
<para>свидетельствующий, что все локально зависимые переменные приняли значения для страны России (ru), русского языка (_RU) и набора символов KOI8-R. Те же значения этих переменных будут устанавливаться и в сеансах всех пользователей, вошедших в систему после выполнения команды env-update. </para>
<para>Предупреждение: Механизм env-update однозначно работает в том случае, если пользовательской оболочкой (login shell) является /bin/bash. При использовании иных командных оболочек могут потребоваться некоторые дополнительные действия. Например, если в качестве login shell выступает оболочка zsh, следует отказаться от создания файла ~/.zshenv в домашнем каталоге пользователя. </para>
<para/>
<para>Важно: Переменная LANG=ru_RU.KOI8-R должна быть установлена в любом случае, даже если вы не любите сообщений на русском языке: в противном случае во многих программах (в том числе для XFree86) окажется просто невозможным, например, ввод символов кириллицы. </para>
<para/>
<para>Как уже сказано, установка переменной LANG автоматически определяет и все прочие локально-зависимые переменные. Что в ряде случаев может быть нежелательным. Например, некоторые программы расчетного характера требуют, чтобы в качестве десятичного разделителя использовался символ точки, как в locale POSIX, а не запятой, как это принято в locale ru_*. Чтобы добиться этого, достаточно в конец файла /etc/env.d/02locale, после определения LANG, добавить строку вида: </para>
<para/>
<para>Листинг 3.3: Установка переменной LC_NUMERIC</para>
<para>LC_NUMERIC="POSIX"</para>
<para/>
<para/>
<para>Аналогичным образом могут поступить пользователи, испытывающие стойкую неприязнь к русскоязычным меню и сообщениям программ: </para>
<para/>
<para>Листинг 3.4: Установка переменной LC_NUMERIC</para>
<para>LC_MESSAGES="POSIX"</para></sect2><sect2><title>4. Установка часового пояса</title>
<para/>
<para>Системные часы по Гринвичу</para>
<para/>
<para>Если системные часы машины в BIOS Setup установлены на время по Гринвичу (UTC), для настройки часового пояса достаточно создать символическую ссылку /etc/localtime на файл, описывающий данный часовой пояс. Например, для установки московского времени это будет выглядеть так: </para>
<para/>
<para>Листинг 4.1: Установка московского времени</para>
<para>ln -sf /usr/share/zoneinfo/Europe/Moscow /etc/localtime</para>
<para/>
<para>Примечание: Точное обозначение часовых поясов для России можно посмотреть в каталогах /usr/share/zoneinfo/Europe (имеет силу также для Украины и Белоруссии) и /usr/share/zoneinfo/Asia (для азиатской части России). Например, пользователям из Петропавловска-Камчатского указанная команда потребуется в следующем виде: </para>
<para/>
<para/>
<para>Листинг 4.2: Установка времени для Петропавловска-Камчатского</para>
<para>ln -sf /usr/share/zoneinfo/Asia/Kamchatka /etc/localtime</para>
<para/>
<para>Системные часы по местному времени</para>
<para/>
<para>Если системные часы данной машины установлены по местному времени, кроме создания указанной ссылки потребуется внести еще и изменения в файл /etc/rc.conf, а именно: строку CLOCK="UTC" заменить на CLOCK="local". </para>
<para/></sect2><sect2><title>5. Локализация оконной системы X</title>
<para/>
<para>Введение</para>
<para/>
<para>Локализация оконной системы X (конкретно — её свободной реализации XFree86) может быть выполнена двумя путями: с помощью специальных утилит конфигурирования (обычно — xf86config, используемой для настройки графического режима вообще) или прямым редактированием конфигурационного файла /etc/X11/XF86Config. </para>
<para/>
<para>Локализация с использованием утилиты xf86config</para>
<para/>
<para>Утилита xf86config в большинстве случаев позволяет корректно выполнить кириллизацию системы XFree86 уже на стадии начальной её настройки. Для этого необходимо дать (в консольном режиме) одноименную команду и правильно ответить на вопросы, относящиеся к определению языково-зависимых параметров, и следующие после указания выбора типа клавиатуры. </para>
<para/>
<para>Первый из таких вопросов — выбор страны (Enter a number to choose the country), ответ на который, на самом деле, определяет базовую раскладку клавиатуры. Очевидными ответами являются 8 Belarusian для Белоруссии и 70 Ukrainian для Украины, тогда как для России предлагается два варианта: 53 Russian и 54 Russian (cyrillic phonetic). Первый — это традиционная раскладка qwerty, второй же — фонетическая раскладка ywerti, в которой символы кириллицы расположены на месте созвучных латинских. Она использовалась на старых терминалах и ныне практически не встречается. Так что на самом деле и тут выбор 53 Russian практически однозначен. </para>
<para/>
<para>Далее следует предложение указать вариант русской раскладки (Please enter a variant name for 'ru' layout). Если, просто нажав Enter, отказаться от этого, будет установлен так называемый DOS-вариант раскладки (вернее, маркировки клавиш); маркированные таким образом клавиатуры практически вышли из употребления, поэтому следует, введя winkeys, выбрать Windows-вариант (не следует путать его с Windows-кодировкой, иначе говоря — cp1251). </para>
<para/>
<para>Затем, введя y, следует положительно ответить на вопрос об указании дополнительных опций расширения XKB (Do you want to select additional XKB options (group switcher, group indicator, etc.)?): это позволит определить переключатель латиница/кириллица (в силу исторических причин русская раскладка клавиатуры в XFree86 по умолчанию такового не имеет вообще). </para>
<para/>
<para>В результате следующим шагом будет предложение выбрать клавишу или клавишную комбинацию для такого переключателя. Возможные варианты включают: </para>
<para/><sect3><title>Листинг 5.1: Варианты выбора переключателя латиница/кириллица</title>
<para>  1  R-Alt switches group while pressed                </para>
<para>  2  Left Win-key switches group while pressed         </para>
<para>  3  Right Win-key switches group while pressed        </para>
<para>  4  Both Win-keys switch group while pressed          </para>
<para>  5  Right Alt key changes group                       </para>
<para>  6  Caps Lock key changes group                       </para>
<para>  7  Menu key changes group                            </para>
<para>  8  Left Win-key changes group                        </para>
<para>  9  Right Win-key changes group                       </para>
<para> 10  Both Shift keys together change group             </para>
<para> 11  Control+Shift changes group                       </para>
<para> 12  Alt+Control changes group                         </para>
<para> 13  Alt+Shift changes group                           </para>
<para/>
<para>Из них следует выбирать, руководствуясь своими предпочтениями. Однако по вполне понятным причинам можно рекомендовать, чтобы переключатель раскладок был идентичен для текстового (консольного) и графического режимов. ИМХО, лучше всего на эту роль подходит клавиша CapsLock (для этого в консоли должна быть установлена раскладка ru4). При этом первичная функция этой клавиши (фиксация верхнего регистра), как и в консоли, будет выполняться одновременным нажатием Shift+CapsLock </para>
<para>Примечание: Не менее удобным представляется и использование в качестве переключателя какой-либо из т.н. Windows-клавиш, имеющихся на всех современных клавиатурах. Однако при этом для достижения идентичности переключения в консоли и в XFree86 потребуются расширенные раскладки клавиатуры из упомянутого выше пакета console-tools-cyrillic. </para>
<para/>
<para>Следующие несколько вопросов позволяют указать переключатель для третьей клавиатурной раскладки, дополнительные позиции управляющей клавиши Control, индикацию текущей раскладки (например, индикаторами CapsLock или ScrollLock) и ещё некоторые опции. Если в них нет необходимости — ответы на эти вопросы можно просто пропустить, нажимая клавишу Enter. </para>
<para/>
<para>Покончив с настройкой клавиатуры, следует завершить конфигурирование XFree86 (включая настройку видеорежимов) и выйти из программы xf86config с сохранением результатов в файле /etc/X11/XF86Config. </para>
<para/>
<para>Установка кириллических шрифтов</para>
<para/>
<para>Программа xf86config обеспечивает настройку клавиатурного ввода, но не подключает по умолчанию шрифтов с символами кириллицы — это достигается редактированием файла /etc/X11/XF86Config. Его следует открыть в любом текстовом редакторе и отыскать в Section "Files" описание путей к шрифтовым файлам. </para>
<para>Предупреждение: При вызове файла /etc/X11/XF86Config необходимо отключить режим переноса строк в используемом редакторе. </para>
<para>Пути к файлам шрифтов описываются следующим образом: </para>
<para>Листинг 5.2: Описание путей к файлам шрифтов</para>
<para>FontPath   "/usr/X11R6/lib/X11/fonts/local/"</para>
<para>FontPath   "/usr/X11R6/lib/X11/fonts/misc/"</para>
<para>FontPath   "/usr/X11R6/lib/X11/fonts/75dpi/:unscaled"</para>
<para>FontPath   "/usr/X11R6/lib/X11/fonts/100dpi/:unscaled"</para>
<para>FontPath   "/usr/X11R6/lib/X11/fonts/Type1/"</para>
<para>FontPath   "/usr/X11R6/lib/X11/fonts/Speedo/"</para>
<para>FontPath   "/usr/X11R6/lib/X11/fonts/75dpi/"</para>
<para>FontPath   "/usr/X11R6/lib/X11/fonts/100dpi/"</para>
<para/>
<para>В этот список следует внести путь к файлам шрифтов с поддержкой кириллицы. По умолчанию в любой современной версии XFree86 имеется один набор кириллических шрифтов — Cronyx, расположенный в каталоге /usr/X11R6/lib/X11/fonts/cyrillic/. И потому первая строка указанной секции должна принять вид </para>
<para/>
<para>Листинг 5.3: Описание пути к файлам кириллических шрифтов</para>
<para>FontPath   "/usr/X11R6/lib/X11/fonts/cyrillic/"</para>
<para/>
<para>Важно: Строка с кириллическими шрифтами должна быть первой в списке путей, дабы именно они обнаруживались бы любыми программами в первую очередь при совпадении их имен или псевдонимов с таковыми шрифтов, не имеющих символов кириллицы. </para>
<para/>
<para>Примечание: Шрифты производства Cronyx содержат ограниченное число гарнитур. Кроме того, они являются растровыми и вообще далеки от эстетического совершенства. Поэтому их по возможности лучше дополнить (или заменить) шрифтами от независимых производителей. В качестве таковых можно рекомендовать коллекцию масштабируемых (TTF и ATM) лицензионно чистых шрифтов Валентина Филиппова, входящих в российскую сборку OpenOffice и в последние версии дистрибутивов Altlinux. </para>
<para/>
<para/>
<para>Ручная настройка клавиатуры для ввода кириллицы</para>
<para/>
<para>К кириллизации XFree86 посредством программы xf86config целесообразно прибегать только при начальной настройке этой системы. Если же в ходе использования Gentoo Linux возникнет необходимость дополнительного конфигурирования (например, изменения положения переключателя раскладок), проще обратиться к прямому редактированию файла /etc/X11/XF86Config. </para>
<para/>
<para>За настройку клавиатуры в нём отвечает Section "InputDevice". В ней, после указания идентификатора клавиатуры (а оконная система X в состоянии поддерживать, даже на локальной машине, более одной физической клавиатуры) и её драйвера, следует описание т.н. правил (rules), определяющих раскладку клавиатуры. Оно имеет вид вроде следующего: </para>
<para/>
<para>Листинг 5.4: Описание раскладки клавиатуры</para>
<para>Option "XkbRules"   "xfree86"</para>
<para>Option "XkbModel"   "pc105"</para>
<para>Option "XkbLayout"  "ru"</para>
<para>Option "XkbVariant" "winkeys"</para>
<para>Option "XkbOptions" "grp:caps_toggle,grp_led:caps"</para>
<para/>
<para/>
<para>Здесь, разумеется, можно изменить всё, что угодно. Однако практически имеет смысл рассмотреть только возможные варианты значений для строки Option "XkbOptions". Значение, приведенное в примере, соответствует переключателю раскладок CapsLock (grp:caps_toggle) и индикатору Capslock как показателю включения русской раскладки (grp_led:caps). И то, и другое можно изменить, если не устраивает. Доступные значения содержатся (вместе с их краткими описаниями) в секции ! option файла /usr/X11R6/lib/X11/xkb/rules/xfree86.lst</para></sect3></sect2></sect1><sect1><title>Руководство Gentoo Linux ALSA</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/kde-config.xml">http://www.gentoo.org/doc/ru/alsa-guide.xml</ulink>
</para>
<para>С версии: 1.0</para>
<para>Обновлено:  1.2</para><sect2><title>1. Введение</title>
<para/>
<para>Что такое ALSA?</para>
<para/>
<para>ALSA, или Advanced Linux Sound Architecture — продвинутая звуковая архитектура Linux, позволяет работать аудио и MIDI (Musical Instrument Digital Interface — Цифровой интерфейс музыкальных инструментов) в операционной системе Linux. ALSA является основной звуковой подсистемой в ядрах 2.6, заменяя собой OSS (Open Sound System — Открытая звуковая система), которая использовалась в ядрах 2.4. </para>
<para>Главные преимущества ALSA включают эффективную поддержку всех типов аудио интерфейсов, начиная от широко распространённых аудио карт и заканчивая профессиональным звуковым оборудованием, полностью модульные драйверы, поддержку многопроцессорных систем и потоковую безопасность, обратную совместимости с OSS, а также пользовательскую библиотеку alsa-lib, делающую разработку приложений лёгкой. </para>
<para/>
<para/>
<para>ALSA в Gentoo</para>
<para/>
<para>Одна из сильных сторон Gentoo заключается в предоставлении пользователю максимального контроля над тем, как система установлена/сконфигурирована. ALSA в Gentoo следует этому принципу. Существуют два способа, с помощью которых вы можете установить и запустить ALSA на вашей системе. Мы подробно рассмотрим их в следующей главе.</para>
<para/></sect2><sect2><title>2. Установка ALSA</title>
<para/>
<para>Варианты</para>
<para/>
<para>Предупреждение: Способы, описываемые ниже, являются взаимно исключающими. Вы не можете одновременно собрать ALSA в ядре и установить media-sound/alsa-driver. Это не получится. </para>
<para/>
<para>Два варианта установки ALSA драйверов: </para>
<orderedlist>
<listitem>
<para>Использовать ALSA драйверы, предоставляемые вашим ядром. Этот метод предпочтительный и рекомендуемый. </para>
</listitem>
<listitem>
<para>Использовать пакет media-sound/alsa-driver. </para>
</listitem>
</orderedlist>
<para>Драйверы, предоставляемые ядром, могут немного отличаться от предоставляемых пакетом alsa-driver; возможности и исправления одного могут оказаться всё ещё не включёнными в другой. Разработчики ALSA осознают ситуацию, но эти два драйвера по существу являются отдельными ветвями проекта ALSA; они не идентичны. Вы должны понимать, что они могут по-разному функционировать, поэтому если один из них у вас не работает, попробуйте другой! Мы бегло рассмотрим оба варианта перед принятием окончательного решения. </para>
<para>Преимущества и недостатки использования ALSA драйверов, предоставляемых ядром: </para>
<para> ALSA в ядре        за и против</para>
<para>+        Нет необходимости устанавливать ещё один пакет; драйверы включены в         ядро</para>
<para>+        Единое решение, никаких повторных команд emerge</para>
<para>-        Может немного отличаться от alsa-driver</para>
<para/>
<para/>
<para>А если вы выберете alsa-driver, то: </para>
<para/>
<para>Драйверы ALSA        за и против</para>
<orderedlist>
<listitem>
<para/>
</listitem>
</orderedlist>
<para>+        Самые свежие драйверы от проекта ALSA</para>
<para>+        Удобно, если вы собираетесь разрабатывать драйверы для аудио устройств</para>
<para>-        Каждая пересборка ядра требует повторной переустановки alsa-driver</para>
<para>-        Определенные параметры конфигурации ядра дожны быть отключены</para>
<para/>
<para/>
<para>Итак...</para>
<para/>
<para>Как сказано выше, отличия между драйверами из пакета alsa-driver и ALSA драйверами, поставляемыми с ядром, очень незначительны. Так как между ними нет большой разницы, сначала попробуйте ALSA драйвера, поставляемые ядром, так как их проще использовать. Перед тем как сообщить о любой проблеме, связанной со звуком, в <ulink url="https://bugs.gentoo.org/">Gentoo Bugzilla</ulink>, пожалуйста, попробуйте её воспроизвести, используя alsa-driver, и создайте запрос об ошибке вне зависимости от результата.</para>
<para/>
<para>Перед тем как вы продолжите</para>
<para/>
<para/>
<para>Какие драйверы использует ваша карта. В большинстве случаев звуковые карты (встроенные и подключаемые) основаны на PCI, и lspci поможет вам раскопать необходимую информацию. Пожалуйста, если вы ещё не установили lspci, установите командой emerge sys-apps/pciutils. Если у вас USB звуковая карта, вам может помочь lsusb из sys-apps/usbutils. Для карт ISA попробуйте sys-apps/isapnptools. Кроме того, следующие ресурсы могут помочь владельцам ISA звуковых карт: </para>
<orderedlist>
<listitem>
<para>
<ulink url="http://www.roestock.demon.co.uk/isapnptools/">Страница ISAPNPTOOLS</ulink> </para>
</listitem>
<listitem>
<para>
<ulink url="http://www2.linuxjournal.com/article/3269">Статья о PnP в LinuxJournal</ulink> </para>
</listitem>
<listitem>
<para>
<ulink url="http://www.tldp.org/HOWTO/Sound-HOWTO/x320.html">TLDP Sound HOWTO</ulink> </para>
</listitem>
</orderedlist>
<para/>
<para>Примечание: Ради простоты в оставшейся части руководства мы предположим, что у пользователя звуковая карта, основанная на PCI. </para>
<para>Теперь мы попробуем найти информацию о звуковой карте. </para>
<para/>
<para/>
<para>Теперь мы попробуем найти информацию о звуковой карте. </para>
<para/>
<para>Листинг 2.1: Подробности звуковой карты</para>
<para># lspci -v | grep -i audio</para>
<para>0000:00:0a.0 Multimedia audio controller: Creative Labs SB Live! EMU10k1 (rev 06)</para>
<para/>
<para>Теперь мы знаем, что звуковая карта, установленная в компьютере, — Sound Blaster Live!, а производителем является Creative Labs. Зайдём на страницу с <ulink url="http://bugtrack.alsa-project.org/main/index.php/Matrix:Main">таблицой звуковых карт ALSA</ulink> и выберем Creative Labs из списка. В результате вы попадёте на страницу, содержащую таблицу продуктов Creative Labs, из которой вы можете узнать, что SB Live! использует модуль emu10k1. Эта та информация, которая нам и нужна. Если вам интересна более подробная информация, то вы можете перейти по ссылке «Details» на страницу, посвящённую emu10k1. </para>
<para>Если вы намереваетесь использовать MIDI, то перед установкой любых пакетов ALSA необходимо добавить midi к USE-флагам в файле /etc/make.conf. Ниже в руководстве мы продемонстрируем, как <ulink url="http://www.gentoo.org/doc/ru/alsa-guide.xml#midi">настроить MIDI</ulink>. </para>
<para/>
<para>Использование ALSA драйверов, предоставляемых ядром</para>
<para/>
<para/>
<para>Если вам нравится идти по пути наименьшего сопротивления, то этот способ для вас.</para>
<para/>
<para>Примечание: Начиная с выпуска 2005.0, Gentoo Linux в качестве основного ядра использует ядра ветки 2.6. Пожалуйста, удостоверьтесь, что у вас ядро ветки 2.6. Этот способ не применим для ядер ветки 2.4. </para>
<para/>
<para/>
<para>А теперь давайте сконфигурируем ядро так, чтобы включить в нём ALSA.</para>
<para/>
<para>Важно: Пользователи genkernel должны запустить genkernel --menuconfig all и следовать инструкциям из раздела <ulink url="http://www.gentoo.org/doc/ru/alsa-guide.xml#doc_chap2_pre3">Параметры ядра для ALSA</ulink>.</para>
<para/>
<para>Листинг 2.2: Погружение в исходные коды</para>
<para># cd /usr/src/linux</para>
<para># make menuconfig</para>
<para/>
<para>Примечание: В только что приведённом примере предполагалось, что символическая ссылка /usr/src/linux указывает на исходные коды используемого вами ядра. Пожалуйста, перед тем как продолжить, проверьте, что у вас так оно и есть. </para>
<para/>
<para/>
<para>Теперь рассмотрим часть параметров конфигурации ядра 2.6, которые гарантируют работоспособность ALSA с нашей звуковой картой. </para>
<para>Обратите внимание, что во всех примерах мы собираем ALSA модулями. Мы советуем вам поступать так же, так как в дальнейшем это позволит использовать alsaconf, упрощающую настройку звуковой карты. Пожалуйста, не пропустите раздел <ulink url="http://www.gentoo.org/doc/ru/alsa-guide.xml#alsa-config">Настройка</ulink>. Если вы всё же решаете не использовать модули, удостоверьтесь, что вы соответствующим образом изменили вашу конфигурацию. </para>
<para/>
<para/>
<para>Листинг 2.3: Параметры ядра для ALSA</para>
<para>Device Drivers  ---&gt;</para>
<para>   Sound  ---&gt;</para>
<para/>
<para>(Это необходимо включить)</para>
<para>&lt;M&gt; Sound card support</para>
<para/>
<para>(Убедитесь, что OSS отключена)</para>
<para>Open Sound System   ---&gt;</para>
<para>   &lt; &gt; Open Sound System (DEPRECATED)</para>
<para/>
<para>(Вернитесь на шаг назад и войдите в раздел ALSA)</para>
<para>Advanced Linux Sound Architecture  ---&gt;</para>
<para>   &lt;M&gt; Advanced Linux Sound Architecture</para>
<para>   (Выберите, если вам нужен MIDI sequencing и routing)</para>
<para>   &lt;M&gt; Sequencer support</para>
<para>   (Поддержка старых /dev/mixer* и /dev/dsp*. Рекомендуется.)</para>
<para>   &lt;M&gt; OSS Mixer API</para>
<para>   &lt;M&gt; OSS PCM (digital audio) API</para>
<para/>
<para>(Теперь вы можете выбрать устройства, поддержка которых вам требуется.</para>
<para>Обычно в системе есть только одна звуковая карта. Если у вас их несколько,</para>
<para>включите поддержу для каждой.)</para>
<para/>
<para>(Для тестирования и разработки, обычным пользователям они не требуются,</para>
<para>только если вы знаете, что делаете...)</para>
<para>Generic devices  ---&gt;</para>
<para/>
<para>(Для звуковых карт ISA)</para>
<para>ISA devices   ---&gt;</para>
<para>(Если у вас Gravis, включите этот параметр)</para>
<para>   &lt;M&gt; Gravis UltraSound Extreme</para>
<para/>
<para>(Перейдите на один уровень назад и войдите в раздел PCI-устройств.</para>
<para>Большинство современных звуковых карт являются таковыми)</para>
<para>PCI devices   ---&gt;</para>
<para>   (Теперь выберем драйвер emu10k1 для нашей карты)</para>
<para>   &lt;M&gt; Emu10k1 (SB Live!, Audigy, E-mu APS)</para>
<para>   (Или для карты Intel)</para>
<para>   &lt;M&gt; Intel/SiS/nVidia/AMD/ALi AC97 Controller</para>
<para>   (А может у вас карта на чипсете VIA?)</para>
<para>   &lt;M&gt; VIA 82C686A/B, 8233/8235 AC97 Controller</para>
<para/>
<para>(Вернитесь на один уровень назад и, если у вас звуковая карта USB, включите)</para>
<para>USB Devices   ---&gt;</para>
<para/>
<para/>
<para>Теперь параметры вашего ядра установлены, и вы можете пересобрать ядро. Поддержка ALSA для вашей карты будет доступной сразу, после того как вы загрузитесь с новым ядром. Чтобы использовать новое ядро, не забудьте обновить конфигурацию вашего загрузчика. Теперь, чтобы проверить, что всё работает как должно, переходите к разделу <ulink url="http://www.gentoo.org/doc/ru/alsa-guide.xml#alsa-utilities">Утилиты ALSA</ulink>.</para>
<para/>
<para>Использование пакета драйверов ALSA</para>
<para/>
<para/>
<para>Итак, вы решили использовать пакет alsa-driver. Тогда начнём. Нужно выполнить несколько небольших действий для того, чтобы был скомпилирован только необходимый вашей аудио карте драйвер. Хотя это и не требуется, это сократит количество лишних драйверов, которые в противном случае были бы собраны. </para>
<para>Если вы не знаете, какие драйверы для звуковой карты вам могут понадобиться, ознакомьтесь с разделом, посвящённым <ulink url="http://www.gentoo.org/doc/ru/alsa-guide.xml#lspci">lspci</ulink> этого руководства. Как только вы узнаете имя драйвера (emu10k1 в нашем примере), добавьте переменную ALSA_CARDS в файл /etc/make.conf. </para>
<para/>
<para/>
<para/>
<para>Листинг 2.4: Добавление ALSA_CARDS в make.conf</para>
<para>(Для одной звуковой карты)</para>
<para>ALSA_CARDS="emu10k1"</para>
<para>(Для нескольких карт разделите имена пробелами)</para>
<para>ALSA_CARDS="emu10k1 via82xx"</para>
<para/>
<para/>
<para>Если вы уже собирали своё ядро и хотите использовать alsa-driver, пожалуйста, удостоверьтесь в следующем, перед тем как продолжить, иначе alsa-driver, скорее всего, не установится. Следующий перечень поможет вам провести проверку.</para>
<para/>
<para>Примечание: Пользователи genkernel могут продолжить с <ulink url="http://www.gentoo.org/doc/ru/alsa-guide.xml#doc_chap2_pre6">установки alsa-driver</ulink>, так как конфигурация их обновлённого ядра по умолчанию соответствует нижеприведённой. </para>
<para/>
<orderedlist>
<listitem>
<para>CONFIG_SOUND включён. (Общая поддержка звука включена)</para>
</listitem>
<listitem>
<para>CONFIG_SOUND_PRIME выключен. (Встроенная поддержка OSS отключена) </para>
</listitem>
<listitem>
<para>CONFIG_SND выключен. (Встроенная поддержка ALSA отключена) </para>
</listitem>
<listitem>
<para>Символическая ссылка /usr/src/linux указывает на то ядро, в котором ALSA будет работать. </para>
</listitem>
</orderedlist>
<para/>
<para/>
<para/>
<para>Листинг 2.5: .config checks</para>
<para>(Проверяем, что символическая ссылка указывает на нужное ядро.)</para>
<para># cd /usr/src/linux</para>
<para># grep SOUND .config</para>
<para>(Первый пункт выполнен)</para>
<para>CONFIG_SOUND=y</para>
<para>(Второй пункт выполнен)</para>
<para>CONFIG_SOUND_PRIME is not set</para>
<para># grep SND .config</para>
<para>(Третий пункт выполнен)</para>
<para>CONFIG_SND is not set</para>
<para/>
<para/>
<para>Теперь всё, что вам нужно сделать, это набрать магические слова... нет, не абракадабру. </para>
<para/>
<para/>
<para/>
<para>Листинг 2.6: Установка alsa-driver</para>
<para># emerge alsa-driver</para>
<para/>
<para>Важно: Помните, что вам придётся выполнять emerge alsa-driver каждый раз после (пере)сборки ядра, так как предыдущие драйверы будут удалены. Чтобы упростить эту задачу, вы можете воспользоваться пакетом module-rebuild, который будет вести учёт всем пакетам с модулями ядра и по необходимости пересобирать их. Сначала, чтобы создать список пакетов, выполните module-rebuild populate, а затем после (пере)сборки ядра просто запускайте module-rebuild rebuild, и все внешние модули ядра будут пересобраны.</para>
<para/>
<para/></sect2><sect2><title>3. Настройка/тестирование ALSA</title>
<para/>
<para>Утилиты ALSA</para>
<para/>
<para>Пакет alsa-utils составляет неотъемлемую часть ALSA и содержит множество крайне полезных программ, в том числе и сценарий инициализации ALSA. Поэтому мы настоятельно советуем вам установить alsa-utils.</para>
<para/>
<para>Листинг 3.1: Установка alsa-utils</para>
<para># emerge alsa-utils</para>
<para/>
<para>Примечание: Eсли вы включили поддержку ALSA в вашем <ulink url="http://www.gentoo.org/doc/ru/alsa-guide.xml#kernel">ядре</ulink>, а не собрали её в качестве модулей, пожалуйста, перейдите в раздел <ulink url="http://www.gentoo.org/doc/ru/alsa-guide.xml#initscript">сценарий инициализации ALSA</ulink>. Всё, что осталось сделать всем остальным, это настроить ALSA. Сделать это очень просто благодаря утилите, входящей в состав alsa-utils — alsaconf. </para>
<para/>
<para/>
<para>Настройка</para>
<para/>
<para>Последние версии udev (&gt;=udev-103) в некоторой степени предоставляют автоматическое конфигурирование вашей аудио карты на уровне ядра. По возможности старайтесь полагаться на автоматическую настройку и позвольте ядру настроить вашу звуковую карту. В противном случае, чтобы настроить карту, используйте alsaconf, как это показано ниже.</para>
<para/>
<para>Примечание: Пожалуйста, завершите все программы, которые могут обратиться к звуковой карте во время работы alsaconf.</para>
<para/>
<para>Чтобы настроить вашу звуковую карту просто наберите alsaconf в командной оболочке с правами root. </para>
<para/>
<para>Листинг 3.2: Запуск alsaconf</para>
<para># alsaconf</para>
<para/>
<para/>
<para>Вы увидите изящный управляемый с помощью меню интерфейс программы, которая автоматически исследует ваши устройства и попробует найти вашу звуковую карту. Вас попросят выбрать вашу звуковую карту из списка. Как только это будет сделано, вас спросят разрешения автоматически сделать необходимые изменения в /etc/modules.d/alsa. После этого программа изменит настройки громкости на оптимальный уровень, выполнит update-modules и запустит службу /etc/init.d/alsasound. Как только alsaconf завершит работу, вы сможете продолжить с настройки сценария инициализации ALSA.</para>
<para/>
<para>Сценарий инициализации ALSA</para>
<para/>
<para>Мы почти завершили настройку. Вне зависимости от выбранного вами способа установки ALSA, вам понадобится что-то, что будет загружать модули или инициализировать ALSA и восстанавливать настройки громкости при загрузке системы. Сценарий инициализации ALSA, называемый alsasound, сделает всё это для вас. Добавьте его в загрузочный уровень исполнения.</para>
<para/>
<para>Листинг 3.3: Добавление ALSA в загрузочный уровень исполнения</para>
<para># rc-update add alsasound boot</para>
<para> * alsasound added to runlevel boot</para>
<para> * rc-update complete.</para>
<para/>
<para/>
<para>Теперь проверьте файл /etc/conf.d/alsasound и убедитесь, что переменная SAVE_ON_STOP установлена в значение yes, тогда ваши настройки звука при выключении системы будут сохраняться.</para>
<para/>
<para>Группа audio</para>
<para/>
<para>Перед тем как начать проверку звука, необходимо сделать одну последнюю важную вещь. Главное правило в операционных системах *nix гласит: «не запускай ничего с правами root, если этого не требуется». И в данной ситуации это правило тоже применимо ;) Каким образом? Пожалуй, большую часть времени вы будете работать под учётной записью пользователя, при этом слушать музыку или иметь доступ к звуковой карте. Чтобы вы могли это делать, вы должны быть в группе audio. Тут то мы и добавим пользователей в эту группу, чтобы у них не было проблем с доступом к аудио устройствам. Мы воспользуемся gpasswd, так что вы должны иметь права root, чтобы сделать это. </para>
<para> </para>
<para>Листинг 3.4: Добавление пользователей в группу audio</para>
<para>(Замените &lt;имя_пользователя&gt; на необходимое имя)</para>
<para># gpasswd -a &lt;имя_пользователя&gt; audio </para>
<para>Adding user &lt;имя_пользователя&gt; to group audio</para>
<para/>
<para/>
<para>Проверка громкости!</para>
<para/>
<para/>
<para>Теперь все настройки и необходимые предпосылки выполнены, так что давайте заставим ALSA работать. Если вы запускали утилиту alsaconf, то можете пропустить этот шаг, так как alsaconf уже всё сделал за вас.</para>
<para/>
<para>Листинг 3.5: Запуск сервиса</para>
<para>/etc/init.d/alsasound start</para>
<para/>
<para/>
<para>Теперь мы позаботились обо всём, что может быть необходимым, нам нужно проверить громкость, так как в определённых случаях звук выключен. Для этого мы воспользуемся alsamixer.</para>
<para/>
<para>Листинг 3.6: Запуск alsamixer</para>
<para>(Откройте в терминале. Будут отображены только необходимые настройки)</para>
<para># alsamixer</para>
<para/>
<para>Важно: Если у вас проблемы с запуском alsamixer и вы получаете ошибки, подобные этой: «alsamixer: function snd_ctl_open failed for default: No such file or directory», то, скорее всего, проблема в том, как демон udev инициализировал устройства. Выполните killall udevd; udevstart для перезагрузки устройств в /dev и попробуйте снова alsamixer. Это должно решить проблему.</para>
<para/>
<para/>
<para>Вот так может выглядеть микшер ALSA при первом запуске. Обратите внимание, что уровни каналов Master и PCM занижены и что под ними буквы MM. Это означает, что они выключены. Если вы попробуете что-нибудь проиграть, в то время пока alsamixer в таком состоянии, то вы ничего не услышите из ваших динамиков.</para>
<para/>
<para>Для начала включим каналы и установим необходимые уровни громкости.</para>
<para/>
<para>Предупреждение: Оба канала Master и PCM должны быть включены и установлены в слышимый уровень громкости, если вы хотите услышать что-нибудь из ваших динамиков. </para>
<para/>
<orderedlist>
<listitem>
<para>Для перемещения между каналами используйте клавиши влево и вправо. (&lt;- и -&gt;). </para>
</listitem>
<listitem>
<para>Для того чтобы выключить/включить канал, например Master, выберите его и нажмите клавишу m. </para>
</listitem>
<listitem>
<para>Чтобы увеличить или уменьшить уровень громкости, используйте клавиши вверх и вниз. </para>
</listitem>
</orderedlist>
<para>Примечание: Будьте осторожны при установке значений для Bass и Treble. Обычно для обоих оптимально значение 50. Слишком высокие значения Bass могут вызвать дребезжание неспособных воспроизводить глубокие басы динамиков.</para>
<para/>
<para/>
<para/>
<para>После того как вы всё сделаете, ваш микшер ALSA должен выглядеть, так, как это показано ниже. Заметьте, что вместо MM стоит 00 и уровни громкости в оптимальном значении.</para>
<para/>
<para/>
<para>Проверка звука!</para>
<para/>
<para>Наконец-то. Какие-нибудь звуки. Если всё прошло успешно, то теперь вы сможете услышать музыку. Быстрый способ проверить — это воспользоваться консольной командой, наподобие media-sound/madplay. Вы также можете использовать что-нибудь более известное, например, mpg123. Если вы поклонник формата OGG, используйте программу ogg123 из пакета media-sound/vorbis-tools. Используйте любой удобный для вас плеер. Как всегда, emerge — всё что вам нужно.</para>
<para/>
<para>Листинг 3.7: Получение программ</para>
<para>(Установка необходимых приложений)</para>
<para># emerge madplay mpg123</para>
<para>(Для проигрывания ogg-файлов)</para>
<para># emerge vorbis-tools</para>
<para/>
<para/>
<para>А теперь проиграем ваш любимый саундтрек... </para>
<para/>
<para>Листинг 3.8: Проигрывание музыки</para>
<para># madplay -v /mnt/shyam/Music/Paul\ Oakenfold\ -\ Dread\ Rock.mp3</para>
<para>MPEG Audio Decoder 0.15.2 (beta) - Copyright (C) 2000-2004 Robert Leslie et al.</para>
<para>          Title: Dread Rock</para>
<para>         Artist: Paul Oakenfold</para>
<para>          Album: Matrix Reloaded</para>
<para>           Year: 2003</para>
<para>          Genre: Soundtrack</para>
<para>                 Soundtrack</para>
<para> 00:04:19 Layer III, 160 kbps, 44100 Hz, joint stereo (MS), no CRC</para>
<para/>
<para># ogg123 Paul\ Oakenfold\ -\ Dread\ Rock.ogg</para>
<para>Audio Device:   Advanced Linux Sound Architecture (ALSA) output</para>
<para/>
<para>Playing: Paul Oakenfold - Dread Rock.ogg</para>
<para>Ogg Vorbis stream: 2 channel, 44100 Hz</para>
<para>Genre: Soundtrack</para>
<para>Transcoded: mp3;160</para>
<para>Title: Dread Rock</para>
<para>Artist: Paul Oakenfold</para>
<para>Date: 2003</para>
<para>Album: Matrix Reloaded</para>
<para>Time: 00:11.31 [04:28.75] of 04:40.06  (200.6 kbps)  Output Buffer  96.9%</para>
<para/>
<para/><sect3><title>ALSA и USE</title>
<para/>
<para>Теперь, для того чтобы приложения, поддерживающие ALSA, были собраны с поддержкой оной, вам нужно добавить USE-флаг alsa в файл /etc/make.conf. Некоторые архитектуры, например, x86 и amd64, включают этот флаг по умолчанию.</para>
<para/>
<para>Проблемы?</para>
<para/>
<para>Если по каким-либо причинам вы не слышите звука, перво-наперво проверьте настройки <ulink url="http://www.gentoo.org/doc/ru/alsa-guide.xml#doc_chap3_pre6">alsamixer</ulink>. 80% всех проблем заключаются в выключенных каналах или низкой громкости. Кроме того, проверьте звуковой апплет вашего оконного менеджера и удостоверьтесь, что громкости каналов установлены на слышимом уровне. </para>
<para>/proc — ваш друг. В этом случае, /proc/asound — ваш лучший друг. Мы бегло просмотрим, сколько полезной информации доступно нам здесь. </para>
<para/>
<para/>
<para>Листинг 3.9: Развлечение с /proc/asound</para>
<para>(Прежде всего, если /proc/asound/cards отображает вашу карту, то ALSA</para>
<para>распознала вашу звуковую карту.)</para>
<para># cat /proc/asound/cards</para>
<para>0 [Live           ]: EMU10K1 - Sound Blaster Live!</para>
<para>                     Sound Blaster Live! (rev.6, serial:0x80271102) at 0xb800, irq 11</para>
<para/>
<para>(Следующая команда оторбразит текущую версию ALSA)</para>
<para># cat /proc/asound/version</para>
<para>Advanced Linux Sound Architecture Driver Version 1.0.8 (Thu Jan 13 09:39:32 2005 UTC).</para>
<para/>
<para>(Подробности эмуляции OSS в ALSA)</para>
<para># cat /proc/asound/oss/sndstat</para>
<para>Sound Driver:3.8.1a-980706 (ALSA v1.0.8 emulation code)</para>
<para>Kernel: Linux airwolf.zion 2.6.11ac1 #2 Wed May 4 00:35:08 IST 2005 i686</para>
<para>Config options: 0</para>
<para/>
<para>Installed drivers:</para>
<para>Type 10: ALSA emulation</para>
<para/>
<para>Card config:</para>
<para>Sound Blaster Live! (rev.6, serial:0x80271102) at 0xb800, irq 11</para>
<para/>
<para>Audio devices:</para>
<para>0: EMU10K1 (DUPLEX)</para>
<para/>
<para>Synth devices: NOT ENABLED IN CONFIG</para>
<para/>
<para>Midi devices:</para>
<para>0: EMU10K1 MPU-401 (UART)</para>
<para/>
<para>Timers:</para>
<para>7: system timer</para>
<para/>
<para>Mixers:</para>
<para/>
<para/>
<para>Другой очень распространённой проблемой среди пользователей является странная ошибка «Unknown symbol in module» («Неизвестный символ в модуле»). Пример её появления показан ниже.</para>
<para/>
<para>Листинг 3.10: Ошибка: неизвестный символ в модуле</para>
<para># /etc/init.d/alsasound start</para>
<para> * Loading ALSA modules ...</para>
<para> *   Loading: snd-card-0 ...                                              [ ok ]</para>
<para> *   Loading: snd-pcm-oss ...</para>
<para>WARNING: Error inserting snd_mixer_oss</para>
<para>(/lib/modules/2.6.12-gentoo-r6/kernel/sound/core/oss/snd-mixer-oss.ko): Unknown</para>
<para>symbol in module, or unknown parameter (see dmesg) FATAL: Error inserting</para>
<para>snd_pcm_oss</para>
<para>(/lib/modules/2.6.12-gentoo-r6/kernel/sound/core/oss/snd-pcm-oss.ko): Unknown</para>
<para>symbol in module, or unknown parameter (see dmesg)</para>
<para>                                                                          [ !! ]</para>
<para> *   Loading: snd-mixer-oss ...</para>
<para>FATAL: Error inserting snd_mixer_oss</para>
<para>(/lib/modules/2.6.12-gentoo-r6/kernel/sound/core/oss/snd-mixer-oss.ko): Unknown</para>
<para>symbol in module, or unknown parameter (see dmesg)</para>
<para>                                                                          [ !! ]</para>
<para> *   Loading: snd-seq ...                                                 [ ok ]</para>
<para> *   Loading: snd-emu10k1-synth ...                                       [ ok ]</para>
<para> *   Loading: snd-seq-midi ...                                            [ ok ]</para>
<para> * Restoring Mixer Levels ...                                             [ ok ]</para>
<para>                                       </para>
<para/>
<para>И если, как советуют, просмотреть вывод dmesg, то, скорее всего, можно увидеть следующее:</para>
<para/>
<para>Листинг 3.11: Вывод dmesg</para>
<para>(Показаны только относящиеся к делу части вывода)</para>
<para># dmesg | less</para>
<para>ACPI: PCI Interrupt 0000:02:06.0[A] -&gt; Link [APC3] -&gt; GSI 18 (level, low) -&gt; IRQ 209</para>
<para>snd_mixer_oss: Unknown symbol snd_unregister_oss_device</para>
<para>snd_mixer_oss: Unknown symbol snd_register_oss_device</para>
<para>snd_mixer_oss: Unknown symbol snd_mixer_oss_notify_callback</para>
<para>snd_mixer_oss: Unknown symbol snd_oss_info_register</para>
<para>snd_pcm_oss: Unknown symbol snd_unregister_oss_device</para>
<para>snd_pcm_oss: Unknown symbol snd_register_oss_device</para>
<para>snd_pcm_oss: Unknown symbol snd_mixer_oss_ioctl_card</para>
<para>snd_pcm_oss: Unknown symbol snd_oss_info_register</para>
<para>snd_mixer_oss: Unknown symbol snd_unregister_oss_device</para>
<para>snd_mixer_oss: Unknown symbol snd_register_oss_device</para>
<para>snd_mixer_oss: Unknown symbol snd_mixer_oss_notify_callback</para>
<para>snd_mixer_oss: Unknown symbol snd_oss_info_register</para>
<para/>
<para/>
<para/>
<para>Эта проблема вызвана переключением с alsa-driver на драйверы, предоставляемые ядром, потому что когда вы удаляете alsa-driver, то файлы модулей сохраняются системой защиты конфигурации. И поэтому, когда вы переходите на встроенные в ядро драйверы, попытка modprobe выдаст вам смесь модулей из alsa-driver и встоенных в ядро, вызывая приведённые выше ошибки. </para>
<para>Решение очень простое. Удалите вызывающий проблемы каталог после удаления alsa-driver. Проверьте, что удаляете модули правильной, но не текущей версии ядра! </para>
<para/>
<para/>
<para>Листинг 3.12: Удаление модулей alsa-driver</para>
<para># rm -rf /lib/modules/$(uname -r)/alsa-driver</para>
<para/>
<para/>
<para>Другой причиной подобных сообщений может являться файл в /etc/modules.d, содержащий параметр device_mode, в то время как он не требуется. Проверьте, так ли это, и выясните, какой файл является источником проблем.</para>
<para/>
<para>Листинг 3.13: Подтверждение проблемы и поиск device_mode</para>
<para>(Проверим вывод dmesg для идентификации проблемы)</para>
<para># dmesg | grep device_mode</para>
<para>snd: Unknown parameter `device_mode'</para>
<para>(И теперь найдём источник проблемы)</para>
<para># grep device_mode /etc/modules.d/*</para>
<para/>
<para/>
<para>Обычно это файл с именем alsa, в котором присутствует строка options snd device_mode=0666. Удалите эту строку и перезапустите службу alsasound. Это должно решить проблему.</para>
<para/></sect3></sect2><sect2><title>4. Другие возможности ALSA</title>
<para/>
<para>Настройка поддержки MIDI</para>
<para/>
<para>Сначала проверьте, что у вас включён USE-флаг midi в файле /etc/make.conf. Если вы до сих пор этого не сделали, то сделайте это сейчас. Помимо этого вам потребуется пересобрать все пакеты ALSA, использующие флаг midi: alsa-lib, alsa-utils и alsa-driver. </para>
<para>Если ваша карта имеет встроенный MIDI синтезатор и вы хотите слушать *.mid файлы, вам придётся установить пакет awesfx, содержащий основной набор программ для управления драйвером AWE32. Сначала вам надо установить его. Если у вас нет синтезатора, вы можете использовать виртуальный. Обратитесь к разделу <ulink url="http://www.gentoo.org/doc/ru/alsa-guide.xml#vsynth">виртуальные синтезаторы</ulink> для дополнительной информации.</para>
<para/>
<para>Листинг 4.1: Установка awesfx</para>
<para># emerge awesfx</para>
<para/>
<para>Примечание: Вам понадобится скопировать файлы банка звуков (SoundFont: SF2) с компакт-диска с драйверами для вашей звуковой карты или установленные в Windows в каталог /usr/share/sounds/sf2/. Например, файл банка звуков для карты Creative SBLive! может называться 8MBGMSFX.SF2.</para>
<para/>
<para/>
<para>После копирования файлов банка звуков мы сможем проигрывать midi-файлы. Также, для того чтобы банк звуков загружался каждый раз при загрузке системы, вы можете добавить команду asfxload в /etc/conf.d/local.start.</para>
<para/>
<para>Примечание: Использованные ниже пути, начинающиеся с /mnt, не применимы для вашего компьютера. Они являются примерами. Пожалуйста, будьте осторожны при изменении путей на соответствующие вашей системе.</para>
<para/>
<para/>
<para>Листинг 4.2: Загрузка сэмплов</para>
<para>(Сначала копируем файл с банком звуков)</para>
<para># cp /mnt/win2k/Program\ Files/CreativeSBLive2k/SFBank/8MBGMSFX.SF2 /usr/share/sounds/sf2/</para>
<para>(Или берём его с компакт-диска SoundBlaster)</para>
<para># cp /mnt/cdrom/AUDIO/ENGLISH/SFBANK/8MBGMSFX.SF2 /usr/share/sounds/sf2/</para>
<para>(Загружаем определённый банк звуков)</para>
<para># asfxload /usr/share/sounds/sf2/8MBGMSFX.SF2</para>
<para/>
<para>Теперь вы можете проигрывать midi-файлы, используя программу, подобную aplaymidi. Запустите aplaymidi -l, чтобы получить список доступных портов, а затем задействуйте один из них для проигрывания файла.</para>
<para/>
<para>Листинг 4.3: Проигрывание MIDI</para>
<para>(Проверка открытых портов)</para>
<para># aplaymidi -l</para>
<para> Port    Client name                      Port name</para>
<para> 64:0    EMU10K1 MPU-401 (UART)           EMU10K1 MPU-401 (UART)</para>
<para> 65:0    Emu10k1 WaveTable                Emu10k1 Port 0</para>
<para> 65:1    Emu10k1 WaveTable                Emu10k1 Port 1</para>
<para> 65:2    Emu10k1 WaveTable                Emu10k1 Port 2</para>
<para> 65:3    Emu10k1 WaveTable                Emu10k1 Port 3</para>
<para>(Выбираем порт и проигрываем mid-файл)</para>
<para>#  aplaymidi --port=65:0 /mnt/shyam/music/midi/mi2.mid</para>
<para/>
<para/>
<para/>
<para>Виртуальные синтезаторы</para>
<para/>
<para>Если у вашей карты отсутствует встроенный синтезатор, вы можете использовать виртуальный, например, timidity++. Установка происходит на одном дыхании.</para>
<para/>
<para>Листинг 4.4: Установка timidity++</para>
<para># emerge timidity++</para>
<para/>
<para/>
<para>Чтобы timidity воспроизводил звуки, ему нужен набор сэмплов (или банк звуков). К счастью, вместе с пакетом устанавливаются несколько банков звуков. Есть ещё несколько пакетов с банками звуков в Portage, например, timidity-freepats и timidity-eawpatches. Вы можете установить несколько банков звуков, а также можете разместить собственный банк звуков в каталог /usr/share/timidity/. Для переключения timidity между разными банками звуков используйте eselect. </para>
<para>Листинг 4.5: Изменение конфигураций</para>
<para># eselect timidity list</para>
<para># eselect timidity set eawpatches</para>
<para/>
<para/>
<para>Не забудьте добавить timidity в основной уровень исполнения.</para>
<para/>
<para>Листинг 4.6: Добавление timidity в основной уровень исполнения</para>
<para># rc-update add timidity default</para>
<para># /etc/init.d/timidity start</para>
<para/>
<para/>
<para>Теперь вы можете попробовать <ulink url="http://www.gentoo.org/doc/ru/alsa-guide.xml#doc_chap4_pre3">проиграть MIDI</ulink> файлы.</para>
<para/>
<para>Утилиты и Firmware</para>
<para/>
<para>Для некоторых звуковых карт могут быть полезны утилиты из пакетов alsa-tools и alsa-firmware. Вы можете установить любой из этих пакетов, просто запустив emerge. </para>
<para>Листинг 4.7: Установка утилит ALSA</para>
<para># emerge alsa-tools</para>
<para/>
<para>Несколько звуковых карт</para>
<para>Вы можете использовать больше одной звуковой карты, при условии что вы собрали ALSA как модули ядра (или из пакета alsa-driver). Сначала в файле /etc/modules.d/alsa вам следует лишь указать, какая из карт должна быть запущена первой. В этом файле карты идентифицируются по именам своих драйверов. 0 означает первую карту, 1 — вторую, и так далее. Вот пример для системы, в которой присутствуют две звуковые карты. </para>
<para>Листинг 4.8: Две карты в файле /etc/modules.d/alsa</para>
<para>options snd-emu10k1 index=0</para>
<para>options snd-via82xx index=1</para>
<para/>
<para/>
<para>Или если у вас две карты, использующие один и тот же драйвер, то их следует указать на одной строке, разделяя цифры запятой. Ниже приведён пример системы, в которой установлено три звуковые карты, две из которых являются картами Intel High Definition Audio. </para>
<para>Листинг 4.9: Несколько звуковых карт в /etc/modules.d/alsa</para>
<para>options snd-ymfpci index=0</para>
<para>options snd-hda-intel index=1,2</para>
<para/>
<para/>
<para/>
<para>Модули расширения</para>
<para>Для расширения возможностей ALSA вы можете установить дополнительные расширения. Пакет alsa-plugins является собранием полезных модулей расширения, который включает: модуль вывода PulseAudio, конвертер частоты дискретизации, jack (аудио сервер с малым временем задержки) и кодек, позволяющий вам выводить шестиканальный звук через цифровой S/PDIF-вывод (оптический или коаксиальный). Вы можете выбрать те расширения, которые вы хотите установить, добавив соответствующие USE-флаги в /etc/portage/package.use. </para>
<para>Листинг 4.10: Установка alsa-plugins</para>
<para># emerge -avt alsa-plugins</para>
<para/>
<para/>
<para>Огромное спасибо вам всем...</para>
<para>Всем, кто принимал участие в написании ранних версий руководства ALSA в Gentoo: Vincent Verleye, Grant Goodyear, Arcady Genkin, Jeremy Huddleston, John P. Davis, Sven Vermeulen, Benny Chuang, Tiemo Kieft и Erwin. А также Dr][aM за перевод ранней версии руководства на русский язык. </para>
<para>Ссылки</para>
<orderedlist>
<listitem>
<para>
<ulink url="http://www.alsa-project.org/">Домашняя страница проекта ALSA</ulink> </para>
</listitem>
<listitem>
<para>
<ulink url="http://linux-sound.org/">Linux Sound/MIDI Software</ulink> </para>
</listitem>
</orderedlist>
<para/></sect2></sect1><sect1><title>
<ulink url="http://lxj.endofinternet.net/column/gentoo-tips/">Советы пользователям Gentoo (вариант 2)</ulink>
</title>
<ulink url="http://lxj.endofinternet.net/column/gentoo-tips/">Советы пользователям Gentoo (вариант 2)</ulink>
<para>Ссылка на оригинал: <ulink url="http://ylsoftware.com/?action=news&amp;na=viewfull&amp;news=130">http://lxj.endofinternet.net/column/gentoo-tips/</ulink>
</para>
<para>C версии: 1.5</para>
<para>Автор: <ulink url="mailto:gotletter@gmail.com?subject=По%20поводу%20вашей%20статьи:%20Советы%20пользователям%20Gentoo%20">Алексеев Алексей</ulink>
</para>
<para>Дата: 12.02.2008</para>
<para/>
<para>В своё время я написал две статьи для Linux.com с советами для пользователей Gentoo (<ulink url="http://www.linux.com/articles/56270">Gentoo Portage secrets</ulink> и <ulink url="http://www.linux.com/articles/58503">Tips for new Gentoo users</ulink>), при чём вторая <ulink url="http://dumponline.blogspot.com/2006/11/blog-post.html">оказалась такой удачной</ulink>, что не только <ulink url="http://digg.com/linux_unix/Tips_for_new_Gentoo_users">попала в топ digg’а</ulink>, но и была в тот же день переведена на русский язык!</para>
<para>Я решил собрать в одной статье всю актуальную информацию из обеих статей (они, в принципе, остались актуальными на 90%), и добавить немного нового материала. Ну и перевести, в конце концов, так, как я считаю нужным :)<anchor id="more-4"/>
</para><sect2><title>Если вы только собираетесь начать работу с Gentoo</title>
<para>Приготовьтесь читать много документации, особенно поначалу. Собственно, вы и установить Gentoo не сможете, не изучив <ulink url="http://www.gentoo.org/doc/en/handbook/index.xml">Gentoo Handbook</ulink>.</para>
<para>Есть, конечно, графический инсталлятор, есть <ulink url="http://sabayon.org/">Sabayon</ulink>, но без понимания основ вы далеко не уйдёте. Да и вообще, при работе с Gentoo не рассчитывайте на графические средства настройки — зато консольные средства настройки и организация конфигурационных файлов в Gentoo весьма удобны.</para>
<para>Handbook освещает установку и основы работы с Gentoo. Когда придёт время настраивать иксы и ALSA, переходите к <ulink url="http://www.gentoo.org/doc/en/list.xml">Gentoo Documentation Resources</ulink>. Если вы не нашли информации по интересующей вас теме и там, то она скорее всего есть в <ulink url="http://gentoo-wiki.com/Main_Page">Gentoo wiki</ulink>.</para>
<para>Найти что-либо, что не описано в Gentoo wiki довольно сложно, так что не забывайте туда заглянуть, прежде чем посетить официальный <ulink url="http://forums.gentoo.org/">форум</ulink> и <ulink url="http://www.gentoo.org/main/en/irc.xml">IRC-каналы</ulink>.</para>
<para>Выше я приводил ссылки на англоязычные источники, как и в оригинале статьи. Если у вас нет проблем с английским языком, то лучше их и придерживаться, когда вы что-либо ищите — англоязычная документация практически всегда более актуальная и более полная. Но и документации на русском есть немало: и <ulink url="http://www.gentoo.org/doc/ru/handbook/">Handbook</ulink>, и <ulink url="http://www.gentoo.org/doc/ru/">официальный перевод прочей документации</ulink>, <ulink url="http://ru.gentoo-wiki.com/">русскоязычный раздел Gentoo Wiki</ulink>. Большой русскоязычный форум о Gentoo вы можете найти на <ulink url="http://gentoo.ru/">Gentoo.ru</ulink> (там же вы найдёте ссылки на IRC-каналы), ну и крупнейший русскоязычный форум о Linux — <ulink url="http://linuxforum.ru/">LinuxForum</ulink>.</para><sect3><title>Основы Portage</title>
<para>Шутка. Тут этот раздел вообще не нужен. Вы ведь прочли Handbook, как это было сказано в предыдущем разделе? Хотя в оригинальную статью этот раздел по настоятельной просьбе редакторов пришлось всё-таки включить.</para></sect3><sect3><title>Настройка Portage</title>
<para>Первое правило Gentoo — внимательно следите за вашими USE-флагами. Множество глупых вопросов снимается, если вы перепроверите свои USE-флаги. Почему Midnight Commander тянет за собой в зависимостях X.org? Потому что у вас установлен флаг X. Почему вместе с KDE не установился KPDF? Потому что вы забыли про флаг pdf. <emphasis>(Почему же всё-таки был установлен KGhostScript? Понятия не имею, да и вообще — KDE4 на носу)</emphasis>
</para>
<para>Для того, чтобы увидеть, с какими флагами будет установлен новый пакет, запускайте emerge с параметрами –ask и –verbose (-av) (–ask лучше –pretend тем, что зависимости не пересчитываются лишний раз). Обязательно установите пакет gentoolkit — среди прочих полезностей, он содержит утилиту euse, которая облегчает управление USE-флагами. Запустите euse -i flag, чтобы увидеть описание флага, и узнать, актвирован ли он. Прочитайте man euse, чтобы узнать о всех возможностях этой команды (нет, правда, прочитайте — там немного).</para>
<para>Чтобы установить какую-либо программу с другими USE-флагами, иногда советуют запустить USE="some flags" emerge moo, но ни в коем случае так не делайте: при следующем обновлении пакет будет перекомпилирован со старым набором флагов. Для настройки USE-флагов для отдельных пакетов используйте /etc/portage/package.use (это или файл, или каталог с файлами, см. ниже). То есть если вы хотите установить пакет moo категории category с флагами some flags, то наберите echo "category/moo some flags" &gt;&gt; /etc/portage/package.use перед установкой.</para>
<para>То же самое относится и к ACCEPT_KEYWORD — используйте /etc/portage/package.keywords. Начиная с версии Portage 2.1, вы можете хранить такие настройки не в одном большом файле package.keywords, а создать несколько небольших файлов, и положить их в каталог /etc/portage/package.keywords. Это относится ко всем файлам в /etc/portage.</para></sect3><sect3><title>Когда нужно использовать оверлеи</title>
<para>Иногда бывает нужно установить пакет (или версию пакета), которого ещё (или уже) нет в Portage. На пример, вы можете найти ebuild, который уже был удалён из официального дерева в <ulink url="http://www.gentoo.org/cgi-bin/viewcvs.cgi/">CVS-репозитории</ulink>. Или же вы нашли ebuild для нового пакета в <ulink url="http://bugs.gentoo.org/">Gentoo Bugzilla</ulink>. А может быть, вас чем-то не устраивает официальный ebuild, и вы решили внести в него свои изменения.</para>
<para>В таком случае, вы должны создать собственный локальный оверлей, и положить свои ebuild’ы туда. Оверлей — это набор ebuild’ов, которые вы хотите «подмешать» к основной базе Portage. Ни в коем случае не храните свои ebuild’ы в /usr/portage — при первой же синхронизации они будут удалены. Создайте каталог для своего оверлея, и создайте в нём структуру каталогов, подобную /usr/portage. Расположите ваши ebuild’ы соответственно. Затем откройте /etc/make.conf, и добавьте строчку PORTDIR_OVERLAY="/path/to/local/overlay".</para>
<para>Обычное место для оверлеев — /usr/local/overlays, так что свой оверлей вы можете сделать в /usr/local/overlays/local. Что ещё может оказаться в /usr/local/overlays?</para>
<para>Есть множество неофициальных оверлеев, с которыми можно синхронизироваться. Для любого из них можно создать оверлей в /usr/local/overlays, и синхронизировать их (по тому же принципу, как вы синхронизируете официальное дерево Portage, когда запускаете emerge --sync). Разные неофициальные оверлеи используют для синхронизации утилиты rsync, svn или git, что оговаривается в описании оверлея.</para>
<para>В прочем, большинство из этих оверлеев вы можете использовать при помощи утилиты layman. В таком случае вам не нужно самомостоятельно создавать каталог для оверлея и запускать rsync/svn/git для получения обновлений — вы просто вводите layman -a название-оверлея, чтобы «подключиться» к оверлею — то есть, чтобы layman сам создал каталог, скачал туда нужные файлы и добавил путь в файл настройки; а затем запускаете layman -S, чтобы обновить все оверлеи.</para>
<para>Подробнее об управлении оверлеями, об установке layman и о том, какие вообще есть полезные оверлеи, можно узнать <ulink url="http://gentoo-wiki.com/Portage_Overlay">на Gentoo wiki</ulink>. Оверлеи, как правило, обсуждаются в разделе <ulink url="http://forums.gentoo.org/viewforum-f-51.html">Unsupported software</ulink> официальных форумов Gentoo.</para></sect3><sect3><title>Как часто нужно обновляться?</title>
<para>Не стоит запускать emerge --sync и layman -S чаще раза в сутки. Да и этого, как правило, более чем достаточно. Вы можете отслеживать появление интересующих вас пакетов на сайтах <ulink url="http://packages.gentoo.org/">http://packages.gentoo.org/</ulink> или <ulink url="http://gentoo-portage.com/">http://gentoo-portage.com/</ulink> (или же подписавшись на соответствующие RSS-ленты), и, таким образом, синхронизировать дерево Portage и обновлять пакеты только тогда, когда в официальном дереве появятся новые версии используемого вами ПО.</para>
<para>Чтобы не пропускать важные обновления безопасности, используйте утилиту <ulink url="http://forums.vpslink.com/archive/index.php/t-745.html">glsa-check</ulink> из пакета gentoolkit. В настоящее время эта функциональность ещё дорабатывается, но в будущем glsa-check станет частью Portage. Чтобы узнать, есть ли уязвимости среди установленных пакетов, запустите glsa-check -l affected. Выполнив glsa-check -d &lt;код уязвимости&gt;, вы увидите подробную информацию по определённой уязвимости (вы можете также сразу запустить glsa-check -d affected)</para>
<para>В то же время, не обновляетесь слишком редко. Если вы не будете обновлять систему больше месяца, то когда вы в конце концов соберётесь обновляться, у вас возникнет множество проблем.</para>
<para>Не забывайте читать <ulink url="http://www.gentoo.org/news/en/gmn/">Gentoo Monthly Newsletter</ulink>, практически все важные вопросы связанные с нетривиальными обновлениями, там всегда освещаются. Да и вообще подписаться на RSS-ленту новостей с gentoo.org (или хотя бы gentoo.ru) — это очень хорошая идея.</para>
<para>
<ulink url="http://forums.gentoo.org/viewtopic-t-546828.html">Этот скрипт</ulink> с простым названием update упрощает процедуру обновления:</para>
<orderedlist>
<listitem>
<para>на экран не выводятся сообщения от компилятора — только сообщения от emerge; </para>
</listitem>
<listitem>
<para>если какой-то пакет не удаётся установить, то выполнение обновления не прерывается: скрипт в конце работы пытается ещё раз установить этот пакет, затем выводит список всех пакетов, которые так и не удалось установить; </para>
</listitem>
<listitem>
<para>в некоторых случаях автоматически разрешаются блокировки пакетов (пакет А версии ниже X блокируют установку пакета B версии Y: обычно emerge не сможет продолжить работу, пока вы сами не обновите пакет A, а update это делает сам) </para>
</listitem>
</orderedlist></sect3><sect3><title>Держите «мир» в чистоте</title>
<para>Каждый раз, когда вы устанавливаете какой-либо пакет, его название записывается в /var/lib/portage/world. Когда вы обновляете ваши пакеты, вы запускаете что-то вроде emerge --update --deep world — именно тогда этот список и используется. Старайтесь, чтобы он был как можно короче; только программы, которые вы используете напрямую, должны туда попадать. Если какой-либо пакет установлен как зависимость другого, то он скорее всего не должен попадать в world.</para>
<para>Например, когда вы устанавливаете пакет, использующий библиотеку wxWidgets, то она автоматически устанавливается среди прочих зависимостей этого пакета, но не добавляется в world. Если вы удалите все пакеты, которые зависят от wxWidgets, то она перестанет обновляться при emerge --update (...) world; и будет удалена из системы, если вы запустите emerge --depclean. Только если вы сами разрабатываете программы с использованием wxWidgets, вы захотите, чтобы она входила в world.</para>
<para>Утилита udept может помочь вам удалить лишние пакеты из списка world:</para>
<para>emerge udept</para>
<para>dep -aw</para>
<para>Чтобы установить или обновить пакет напрямую, но без добавления его в этот список, используйте опцию –oneshot (-1). Это может быть полезно, на пример, для временной установки какого-либо пакета.</para></sect3><sect3><title>Об удалении пакетов.</title>
<para>Не забывайте, что emerge --unmerge не проверяет, используется ли удаляемый пакет другими пакетами. Также будьте осторожны с emerge --depclean, так как иногда она может удалить пакеты, которые вам нужны.</para>
<para>Иногда при обновлении одного пакета, перестаёт работать другой, который, хоть и не требует для установки первый пакет, но включает его в свои необязательные зависимости. В таких случаях необходимо просто переустановить второй пакет, чтобы он скомпилировался без связей с первым. Чтобы выявить все такие пакеты, вы можете использовать утилиту revdep-rebuild из пакета gentoolkit.</para></sect3><sect3><title>Логи Portage</title>
<para>Все ваши действия с emerge отражаются в /var/log/emerge.log. К примеру, чтобы узнать, какой пакет сейчас компилируется, запустите tail /var/log/emerge.log. Преобразовать временные отметки в читаемый формат поможет простой <ulink url="http://lxj.endofinternet.net/files/other/formatlog">python-скрипт</ulink> (с его использованием необходимо запустить tail /var/log/emerge.log | formatlog).</para>
<para>Утилита genlop (emerge genlop) позволяет извлечь статистическую информацию из этого лог-файла. На пример, genlop -c скажет, какой пакет сейчас компилируется и как долго, и оценит количество оставшегося до конца установки времени.</para>
<para>Дополнительно стоит также включить так называемые elog. При установке многих пакетов показываются важные уведомления, которые вы можете пропустить, если не следите за выполнением emerge. Добавьте в make.conf следующие строки:</para>
<para># This sets what to log</para>
<para>PORTAGE_ELOG_CLASSES="warn error log"</para>
<para># And this is how to do it</para>
<para>PORTAGE_ELOG_SYSTEM="save"</para>
<para>и создайте каталог /var/log/portage/elog. Теперь уведомления для каждого пакета будут сохраняться в отдельном файле в созданном каталоге. Если вы хотите узнать больше о настройке elog, то изучите файл /etc/make.conf.example. Существуют также <ulink url="http://sourceforge.net/projects/elogviewer/">графические утилиты</ulink> для просмотра этих логов.</para></sect3><sect3><title>Удаление временных файлов</title>
<para>Если установка программы прервана ошибкой, в /var/tmp/portage остаётся временный каталог. Он будет автоматически удалён только после успешной установки этой программы, или же вы можете очистить этот каталог сами.</para>
<para>Также через некоторое время довольно много файлов может оказаться в /usr/portage/distfiles. Используйте утилиту eclean из пакета gentoolkit, чтобы удалить дистрибутивы, которые вам больше не нужны. Эта утилита также удаляет старые бинарные пакеты, если вы их создавали (запускайте как eclean-dist и eclean-pkg соответственно). В странице руководства рассказывается о дополнительных параметрах.</para></sect3><sect3><title>Быстрый поиск пакетов</title>
<para>Чтобы найти нужный пакет в локальном дереве Portage (и/или оверлеях), вы можете использовать emerge --search или emerge --searchdesc, но этот способ очень медленный. Поэтому лучше использовать <ulink url="http://dev.croup.de/proj/eix">eix</ulink>. Eix индексирует список пакетов после каждой синхронизации (для этого необходимо набрать update-eix), а затем очень быстро выполняет поиск по пакетам (к примеру, eix moo выдаст список всех пакетов, которые содержат moo в названии). К тому же, вывод eix более информативен, чем вывод emerge.</para>
<para>Eix позволяет искать по названию пакета, категории или описанию, использовать регулярные выражения, неточный поиск, ограничивать область поиска только установленными пакетами и многое другое. Как обычно, читайте man.</para></sect3><sect3><title>Уменьшение использования трафика</title>
<para>Обновление системы может быть связано с тратой большого количества сетевого трафика. Но есть способы уменьшить аппетиты Portage. Наиболее эффективно в этом преуспеет знаменитая утилита <ulink url="http://deltup.sourceforge.net/">Deltup</ulink>, которая позволяет загружать не весь архив с исходными кодами, а только разность между новой и старой версией. Такой подход экономит до 90% размера загрузок. Установка Deltup <ulink url="http://ru.gentoo-wiki.com/HOWTO_Экономия_трафика_с_помощью_deltup">описана</ulink> в Gentoo Wiki.</para>
<para>У Deltup, конечно, есть свои недостатки. Эта утилита не поддерживает докачку, а кроме того, вы зависите от загруженности сервера, генерирующего новые патчи (помнится, были плохие времена у deltup, когда дождаться очереди на генерацию было практически невозможно. Потом стало лучше, а после этого я уже давно deltup не пользуюсь — как там сейчас, не знаю). Также иногда Deltup «путается» в версиях некотрых пакетов, если у них запутанная система нумерации версий. Ну и конечно, пересоздание нового пакета требует процессорного времени. Однако же, никаких катастрофических последствий использование deltup иметь не может, так что если вы нуждаетесь в экономии трафика — обязательно её попробуйте.</para>
<para>Похожий подход, но для синхронизации дерева Portage использует утилита emerge-delta-webrsync: она загружает ежедневные патчи для обновления вашей локальной копии дерева, что гораздо экономнее, чем emerge --sync (особенно если у вас уже есть архив с копией дерева портежей — вроде того, который вы исполоьзовали при установке). Просто запустите emerge emerge-delta-webrsync, а затем emerge-delta-webrsync для синхронизации дерева портежей (мне всё ещё надо напоминать, что подробности — в man’е?).</para>
<para>На Gentoo wiki есть <ulink url="http://gentoo-wiki.com/TIP_Gentoo_for_dialup_users">специальный раздел</ulink> с советами для пользователей с плохим интернет-соединением.</para>
<para>Ещё одна возможность не уменьшит использование трафика, но позволит уменьшить время загрузки пакетов: добавьте parallel-fetch в переменную FEATURES в /etc/make.conf, чтобы emerge скачивал дистрибутив следующего пакета, устанавливая предыдущие в очереди. Это уменьшит время установки, если вы запускаете emerge для установки сразу нескольких пакетов.</para></sect3><sect3><title>Ускорение компиляции</title>
<para>Компиляция из исходных кодов — основной способ установки программ в Gentoo. Неудивительно, что появились средства, позволяющие ускорить этот процесс.</para>
<para>На пример, <ulink url="http://www.gentoo.org/doc/en/distcc.xml">Distcc</ulink> позволяет распределить задачи по компиляции на несколько компьютеров в сети. Даже компьютеры с Windows <ulink url="http://gentoo-wiki.com/HOWTO_Distcc_server_on_Windows">сгодятся</ulink> для этого!</para>
<para>
<ulink url="http://gentoo-wiki.com/Ccache">Ccache</ulink> кэширует результаты компиляции, таким образом, ускоряя компиляцию одинаковых участков кода.</para>
<para>Упомянутые здесь утилиты можно использовать не только с emerge, но и вообще при любых компиляциях. Подробнее читайте в документации <ulink url="http://distcc.samba.org/">Distcc</ulink> и <ulink url="http://ccache.samba.org/">Ccache</ulink>.</para></sect3><sect3><title>Обновление конфигурационных файлов</title>
<para>После установки новых версий пакетов иногда необходимо обновить их конфигурационные файлы. В Handbook описана эта процедура с использованием утилиты etc-update, но существует более удобная и продвинутая утилита — <ulink url="http://gentoo-wiki.com/Dispatch-conf">dispatch-conf</ulink>. Эта утилита имеет возможность автоматически обновлять конфигурационные файлы, в которых произошли простые изменения (на пример, изменились только комментарии), вы также можете указать ей автоматически обновлять конфигурационные файлы, в которые не вносились изменения пользователем. При этом конфигурационное файлы помещаются в контроль системой контроля версий, чтобы вы с лёгкостью могли откатить все изменения.</para>
<para>Ну и <ulink url="http://bash.org/?464385">цитата</ulink> из bash.org’а напоследок:</para>
<para>&lt;@insomnia&gt; it only takes three commands to install Gentoo &lt;@insomnia&gt; cfdisk /dev/hda &amp;&amp; mkfs.xfs /dev/hda1 &amp;&amp; mount /dev/hda1 /mnt/gentoo/ &amp;&amp; chroot /mnt/gentoo/ &amp;&amp; env-update &amp;&amp; . /etc/profile &amp;&amp; emerge sync &amp;&amp; cd /usr/portage &amp;&amp; scripts/bootsrap.sh &amp;&amp; emerge system &amp;&amp; emerge vim &amp;&amp; vi /etc/fstab &amp;&amp; emerge gentoo-dev-sources &amp;&amp; cd /usr/src/linux &amp;&amp; make menuconfig &amp;&amp; make install modules_install &amp;&amp; emerge gnome mozilla-firefox openoffice &amp;&amp; emerge grub &amp;&amp; cp /boot/grub/grub.conf.sample /boot/grub/grub.conf &amp;&amp; vi /boot/grub/grub.conf &amp;&amp; grub &amp;&amp; init 6&lt;@insomnia&gt; that’s the first one</para>
<para>
<ulink url="http://gentoo.blog.ru/6345603.html"/>
</para></sect3></sect2></sect1><sect1><title>
<ulink url="http://gentoo.blog.ru/6345603.html">Ещё раз о главном - жизнь после установки</ulink>
</title>
<ulink url="http://gentoo.blog.ru/6345603.html">Ещё раз о главном - жизнь после установки</ulink>
<para>Ссылка на оригинал: <ulink url="http://ylsoftware.com/?action=news&amp;na=viewfull&amp;news=130">http://gentoo.blog.ru/6345603.html#comments</ulink>
</para>
<para>C версии: 1.5</para>
<para>Автор: gentoo</para>
<para>
<ulink url="http://gentoo.blog.ru/6345603.html">Дата:</ulink>
<ulink url="http://gentoo.blog.ru/6345603.html"> 21.02.2008</ulink>
</para>
<para>
<ulink url="http://gentoo.blog.ru/6345603.html"/>
</para>
<para>Пост навеян аськой (да, я гентушник, и я не пользуюсь джаббером)), а точнее до боли знакомой фразой "привет! я читал твой блог! Есть вопрос!")) Нет, я совсем не против новых знакомств, у самого когда-то была туча вопросов, и спасибо всем тем, кто терпеливо отвечал и помогал мне в своё время во всём разобраться ;) Но на одних подсказках далеко не уедешь, нужно (нужно!) читать хендбук (благо он на русском) и другие материалы. Хотя по себе знаю, что решения возникшей проблемы всегда хочется "здесь и сейчас", а стоит открыть хендбук и увидеть СКОЛЬКО много там букв, как уже всякое желание читать пропадает)) Напишу здесь ещё несколько советов, которые могут помочь сориентироваться новичкам, может где-то повторюсь, неважно.</para>
<para>Итак, предположим, вы удачно установили систему и загрузились в неё. Может быть вы уже обновили дерево портежей (по emerge --sync), и может быть пересобрали все пакеты системы (по emerge -epv world). Вобщем готовы двигаться дальше, ставить Х'сы, биться с дровами за direct rendering, компилировать свой любимый DE/WM. Но стоп. Если вы смутно представляете, зачем нужны use-флаги, что такое eix, elogv, как обновлять мир, то вам сначала под кат =)</para><sect1 id="fav_43:6345603"><para/><sect2 id="post_6345603_cut_1"><para>Совет: Не стоит выбирать профиль "desktop", который включает в себя несколько десятков use-флагов, предположительно подходящих для любой desktop-системы. Все необходимые флаги в любом случае пропишем постепенно в процессе установок пакетов, а добавление на начальном этапе этой кучи флагов из профиля desktop приведёт к большим зависимостям, и вы просто замучаетесь просматривать сто пакетов (и их use-флаги), потянувшихся по зависимостям за установкой всего одного-единственного необходимого вам пакета.</para>
<para>Совет: Перед установкой любого пакета, запускать команду emerge сначала с дополнительными ключами "pv" (или "av" - кому как больше нравится). Это даст возможность оценить предстоящий процесс установки, проверить и по необходимости включить (отключить) интересующие USE-флаги устанавливаемых пакетов.</para>
<title>Полезные пакеты и команды:</title>
<para># emerge emerge-delta-webrsync - теперь обновлять дерево портежей будет гораздо быстрее (за счёт экономии трафика), минус - дерево портежей после обновления будет актуально на вчерашний день включительно (изменения за сегодня вы получите только завтра).</para>
<para># emerge eix - с помощью этого пакета гораздо удобнее (и быстрее) работать с поиском по дереву портежей.</para>
<para># eix-sync -Wv - этой командой удобно обновлять дерево портежей, она сделает emerge-delta-webrsync &amp;&amp; update-eix и выведет в конце список изменений в дереве portage (что добавилось, что исчезло, что готово проапгрейдиться).</para>
<para># emerge -uDNvp world (или -uDNva) - предлагаю эту команду для обновления мира (если не придумаете свою, более удобную). Совсем не обязательно обновляться как только хотя бы один пакет появится в выводе этой команды. Я, например, обновляю лишь некоторые пакеты, выборочно и достаточно редко.</para>
<para># emerge elogv - позволит просматривать информационные сообщения всех устанавливаемых пакетов после их установки, но сначала необходимо его настроить. Как настроить - читаем в строках после установки, у меня настроено так (/etc/make.conf):</para>
<para>PORTAGE_ELOG_CLASSES="warn error log qa"</para>
<para>PORTAGE_ELOG_SYSTEM="save"</para>
<para>А если также добавить строку:</para>
<para>PORT_LOGDIR=/var/log/portage, то вся информация выводимая на экран во время компиляции пакета будет помещаться в указанный каталог (на случай, если вас не устроит elogv).</para>
<para>Совет: не пренебрегайте этой командой, после установки крупных вещей (Х'сы, Gnome, KDE) обязательно запустите elogv и внимательно просмотрите сообщения всех пакетов, что устанавливались. В выводе некоторых могут встречаться важные инструкции, которые необходимо будет выполнить. Удалить текущую запись из журнала elogv - dd, помощь — F1.</para>
<para># emerge gentoolkit - сюда входят eclean, equery, eread, euse, glsa-check, а главное - revdep-rebuild. Must have.</para>
<title>Обновление конфигов.</title>
<para>При обновлении некоторых пакетов может потребоваться вручную обновить их конфиги. Если после установки какого-либо пакета вы видите на экране такое сообщение:</para>
<para> * IMPORTANT: 2 config files in '...' need updating.</para>
<para>значит некоторые конфиги ждут своего обновления. Обновить их можно либо с помощью etc-update, либо с помощью dispatch-conf. Рекоменду�тся использовать вторую команду, как более мощную, а при соответствующей настройке, умеющую сохранять историю изменений. В любом случае здесь рекомендуется включать мозг и внимательно изучать, какие строчки будут удалены, а какие - добавлены. Если обновляется какой-либо конфиг, где вы вносили свои корректировки, они могут быть предложены к удалению - поэтому нужно быть внимательным (сам по-первости попался - обновил конфиги не глядя, а потом удивлялся, почему настройки, которые я терпеливо прописывал в несколько файлов вдруг заменились на дефолтные).</para>
<title>USE-флаги</title>
<para>&gt;с флагами я не совсем разобрался... зачем их прописывать, если проги и без них поставятся?</para>
<para>Предположим, ставим мы с тобой kopete (IM-клиент). Ты не включаешь никакие флаги и ставишь пакет, а я включаю "irc" и "yahoo". Так вот мой копете будет поддерживать также протоколы irc и yahoo, а твой - не будет.</para>
<para>&gt;т.е. прогу надо будет заново ставить?</para>
<para>Да, тебе придётся прописать флаги и пересобрать пакет. USE-флаги нужны для того, чтобы включать некоторый функционал в собираемом пакете.</para>
<para>&gt;вот мы дали команду emerge gnome -pv</para>
<para>&gt;там появились строки..красного, синего и желтого цвета...что это все означает?</para>
<para>Жёлтым выделены изменения в наборе флагов пакета. Флаги, больше недействительные (удалённые) для новой версии пакета будут взяты в скобки, новые (добавленные) флаги, появившиеся для новой версии, будут без скобок. Красные - включенные флаги. </para>
<para>Синие - соответственно не включенные (идут по минусу).</para>
<para>Зелёные* - флаг был включен в системе после сборки пакета, пакет был собран без этого флага, готов к пересборке с ним.</para>
<para/>
<para>Например:</para>
<para>[ebuild     UD] app-emulation/wine-0.9.49 [0.9.57]</para>
<para/>
<para>предлагает понизить версию пакета wine (я ставил тестовую 0.9.57, у которой были доступны новые use-флаги "gecko" и "samba", и которых не будет, если пересобрать пакет в версию 0.9.49).</para>
<para>Флаг "java" я включил в системе только что, и поэтому он подсветился во всех пакетах, где он может использоваться, зелёным цветом.USE-флаги добавляются (включаются) в системе по мере необходимости.</para>
<para/>
<para>&gt;ну вот я и пытаюсь узнать..как определить необходимость?</para>
<para>К примеру, поставил ты систему, чист твой /etc/make.conf, включено только несколько обязательных флагов (прописаны в профиле). Теперь хочешь установить Пакет_А, по-хорошему пишешь:</para>
<para># emerge &lt; Пакет_А &gt; -pv</para>
<para>и смотришь use-флаги всех пакетов, что будут устанавливаться. Какие флаги тебе кажутся нужными - включаешь (прописываешь). И ещё раз перезапускаешь команду (могут появиться новые зависимости со своими флагами). Процесс повторять до полного удовлетворения =)</para>
<para>Если прописываешь флаги в make.conf - то они будут действовать глобально для всех пакетов, где встретятся. Если в /etc/portage/package.use в формате: категория/пакет флаг [флаг -флаг] (app-misc/mc 7zip -X -gpm -ncurses slang) то тогда эти флаги будут включены только для этого пакета.</para>
<para>Обычно в make.conf находится некоторое количество глобальных флагов (X, kde, gnome, alsa, etc...) и много-много строк в package.use. Так постепенно use-флаги и накапливаются. А если ты сразу пропишешь в make.conf "Х, kde, gnome, samba" и т.д. (думая, что "вот сейчас я пропишу всё что мне надо и забуду про эти флаги"), то установка какого-нибудь mc потянет за собой столько пакетов по зависимостям... что ты будешь совсем не рад =) Причём, есть вероятность, что всё зациклится и выпадет ошибка.</para>
<para>Смотреть, что означает конкретный флаг удобно в другой консоли в ufed.</para>
<para/>
<para>В make.conf можно прописать дефолтные опции, которые всегда будут ставится после emerge, к примеру, так: EMERGE_DEFAULT_OPTS="--ask --verbose" </para>
<para>Еще стоит отметить, как более правильно распределять флаги между make.conf и package.use. У меня сейчас глобальные флаги, описывающие всю мою систему, в make.conf, а более локальные - относящиеся к конкретным программам - в package.use. Так наверно более удобно. Вообще я как-то стремлюсь сократить число флагов в make.conf.</para>
<para/>
<para>Полезный пакет:</para>
<para># emerge ufed - интерактивный ncurses-based редактор use-флагов. В нём флаги можно включать (отключать) и ufed будет прописывать их в /etc/make.conf. Конечно информация о флагах здесь не настолько подробная, как хотелось бы (особенно для новичка), но всё же лучше чем ничего.</para>
<para/>
<para>&gt;но ведь можно сделать так:</para>
<para>&gt;USE="флаг" emerge &lt; пакет &gt;</para>
<para>А при обновлении мира, флаг у этого пакета потеряется, ибо нигде не прописан, то есть при пересборке (обновлении пакета) получится </para>
<para>USE="-флаг" emerge &lt; пакет &gt;и пакет потеряет часть функциональности.</para>
<para/>
<para>&gt;понял, а как быть, если прога тянет за собой другие, а у тех свои зависимости?</para>
<para>Смотришь их флаги, включаешь, а они после этого потянут ещё что-нибудь... смотришь теперь и их флаги)) пока не остановится процесс разрастания))</para>
<para/>
<para>Если не планируется использовать deltup, можно прописать зеркало yandex в make.conf:</para>
<para>GENTOO_MIRRORS="<ulink url="http://mirror.yandex.ru/gentoo-distfiles/">http://mirror.yandex.ru/gentoo-distfiles/</ulink>
<ulink url="http://mirror.yandex.ru/gentoo-distfiles/%22">"</ulink>;</para>
<para>(хотя эта строка и при дельтапе не помешает).</para>
<para/>
<title>Поддержание системы в чистоте и порядке =)</title>
<para>При установке пакета А, он прописывается в world (/var/lib/portage/world), все пакеты B C D, которые он потянул за собой по зависимостям никуда не прописываются, но они нужны пакету А и поэтому не болтаются в системе мёртвым грузом. Соответственно команда </para>
<para>"# emerge -a —depclean"</para>
<para> не сообщает ни о каких бесхозных пакетах.</para>
<para>Пакет А нам надоел и мы его удаляем: "# emerge -C пакет_А"</para>
<para>Но пакеты B C D всё ещё остаются в системе, совершенно ненужные никому. Удалить их можно лишь точно зная их имена, либо с помощью команды "# emerge -a —depclean".</para>
<title>Проверка целостности системы:</title>
<para># revdep-rebuild - команда проверит целостность зависимостей системы, и при необходимости (найденных ошибках) переустановит (доустановит) необходимые пакеты. Рекомендуется запускать всегда после выполнения команды </para>
<para>"emerge -a —depclean".</para>
<para/>
<para>"Masked" пакеты.</para>
<para>&gt;а еще один вопрос - хочу проставить rawstudio </para>
<para>&gt;а это программа под маской </para>
<para>&gt;как правильно снять маску на эту программу</para>
<para>&gt;в хелпе написано, что они могут быть замаскированны несколькими путями</para>
<para>По умолчанию используется стабильная ветвь ПО. Большое количество пакетов (версий) могут находиться в тестовой ветви. Это не означает, что эти пакеты ужасно нестабильные, отнюдь, вполне возможно, что они будут стабильно работать у вас 364 дня в году ;) Чтобы использовать такие пакеты, есть два варианта:</para>
<para>1. Можно перейти полностью на тестовую ветвь и иметь всегда последние версии ПО.</para>
<para>2. Либо можно комбинировать стабильную ветвь с некоторыми пакетами из тестовой.</para>
<para>В данном случае видим:</para>
<para># eix rawstu</para>
<para>* media-gfx/rawstudio</para>
<para>     Available versions:  ~0.6 ~0.7</para>
<para>     Homepage:            <ulink url="http://rawstudio.org/">http://rawstudio.org</ulink>
</para>
<para>     Description:         a program to read and manipulate raw images from digital cameras.</para>
<para/>
<para>Обе версии пакетов замаскированы тильдой, т.е. относятся к тестовой ветви ПО. Снять такую маску можно прописав "категория/пакет ~x86" в /etc/portage/package.keywords, например:</para>
<para>media-gfx/rawstudio ~x86</para>
<para>(вместо ~x86 может быть ~amd64, либо **)</para>
<para/>
<para>Второй случай: [M] - пакет заблокирован.</para>
<para># eix kde-meta</para>
<para>* kde-base/kde-meta</para>
<para>     Available versions:</para>
<para>        (3.5)   3.5.8 ~3.5.9</para>
<para>        (kde-4) [M]~4.0.1 [M]~4.0.2</para>
<para/>
<para>Здесь kde-4 помечен как находящийся в тестовой ветви (~), плюс к тому же заблокирован от использования (M), т.е. разработчики не рекомендуют пока его использовать - обязательно будут ошибки. Но если очень хочется... ;) то можно разблокировать, прописав "категория/пакет" в /etc/portage/package.unmask, например:</para>
<para>kde-base/kde-meta</para>
<para>(и в данном случае нужно будет также снять тильду, как описано выше).</para>
<para/>
<title>Установка пакетов. Х'сы, DE.</title>
<para/>
<para>Опишу свои личные соображения. Так как система будет использоваться на десктопе для повседневной работы, то обязательно понадобятся Х'сы, какое-то DE, различные кодеки и прочие приложения. Можно сказать "emerge gnome" или "emerge kde" и потом долго ковыряться в use-флагах нескольких сотен пакетов - а их будет много, ибо потянутся и Х'сы, а если повезёт, то захватятся и кодеки. Зато, если хватит сил, вся система будет установлена одной командой =)</para>
<para/>
<para>Я же предпочитаю разбивать этот процесс на подпроцессы:</para>
<para># emerge xorg-x11 - ставим только Х'сы, драйвер на видеокарту, добиваемся его работы и direct rendering'а.</para>
<para># emerge ffmpeg imagemagick xine-lib mplayer - в каком порядке не особо важно, главное не одновременно (а то опять увязнете в сотне-другой зависимостей). После установки этих пакетов и всех нужных зависимостей, в системе будут стоять все необходимые видео/аудио кодеки, а также будет поддержка графических форматов. Здесь же может потянуться в зависимостях samba и cups.</para>
<para>И уже последним делом:</para>
<para># emerge gnome (или kde-meta) - Гном, KDE, либо что вам там нравится.</para>
<para>Наблюдать за процессом установки можно в другой консоли, запустив: </para>
<para>tail -f /var/log/emerge.log</para>
<para/>
<para>Надеюсь, эта информация помогла вам разобраться хоть в каких-то вопросах =)Внимание! Этот пост не отменяет прочтение хендбука, так что вам теперь сюда: <ulink url="http://www.gentoo.org/doc/ru/handbook/">http://www.gentoo.org/doc/ru/handbook/</ulink>
</para></sect2><para>
<ulink url="http://www.gentoo.org/doc/ru/handbook/">HandBook 2006.1 ru</ulink>, <ulink url="http://www.gentoo.org/doc/en/handbook/">HandBook 2007.0 en</ulink>, <link linkend="">Советы пользователям Gentoo</link>
</para></sect1><sect2><title>Полезные пакеты и команды:</title>Полезные пакеты и команды:<para># emerge emerge-delta-webrsync - теперь обновлять дерево портежей будет гораздо быстрее (за счёт экономии трафика), минус - дерево портежей после обновления будет актуально на вчерашний день включительно (изменения за сегодня вы получите только завтра).</para>
<para># emerge eix - с помощью этого пакета гораздо удобнее (и быстрее) работать с поиском по дереву портежей.</para>
<para># eix-sync -Wv - этой командой удобно обновлять дерево портежей, она сделает emerge-delta-webrsync &amp;&amp; update-eix и выведет в конце список изменений в дереве portage (что добавилось, что исчезло, что готово проапгрейдиться).</para>
<para># emerge -uDNvp world (или -uDNva) - предлагаю эту команду для обновления мира (если не придумаете свою, более удобную). Совсем не обязательно обновляться как только хотя бы один пакет появится в выводе этой команды. Я, например, обновляю лишь некоторые пакеты, выборочно и достаточно редко.</para>
<para># emerge elogv - позволит просматривать информационные сообщения всех устанавливаемых пакетов после их установки, но сначала необходимо его настроить. Как настроить - читаем в строках после установки, у меня настроено так (/etc/make.conf):</para>
<para>PORTAGE_ELOG_CLASSES="warn error log qa"</para>
<para>PORTAGE_ELOG_SYSTEM="save"</para>
<para>А если также добавить строку:</para>
<para>PORT_LOGDIR=/var/log/portage, то вся информация выводимая на экран во время компиляции пакета будет помещаться в указанный каталог (на случай, если вас не устроит elogv).</para>
<para>Совет: не пренебрегайте этой командой, после установки крупных вещей (Х'сы, Gnome, KDE) обязательно запустите elogv и внимательно просмотрите сообщения всех пакетов, что устанавливались. В выводе некоторых могут встречаться важные инструкции, которые необходимо будет выполнить. Удалить текущую запись из журнала elogv - dd, помощь — F1.</para>
<para># emerge gentoolkit - сюда входят eclean, equery, eread, euse, glsa-check, а главное - revdep-rebuild. Must have.</para></sect2><sect2><title>Обновление конфигов.</title>
<para>При обновлении некоторых пакетов может потребоваться вручную обновить их конфиги. Если после установки какого-либо пакета вы видите на экране такое сообщение:</para>
<para> * IMPORTANT: 2 config files in '...' need updating.</para>
<para>значит некоторые конфиги ждут своего обновления. Обновить их можно либо с помощью etc-update, либо с помощью dispatch-conf. Рекомендуется использовать вторую команду, как более мощную, а при соответствующей настройке, умеющую сохранять историю изменений. В любом случае здесь рекомендуется включать мозг и внимательно изучать, какие строчки будут удалены, а какие - добавлены. Если обновляется какой-либо конфиг, где вы вносили свои корректировки, они могут быть предложены к удалению - поэтому нужно быть внимательным (сам по-первости попался - обновил конфиги не глядя, а потом удивлялся, почему настройки, которые я терпеливо прописывал в несколько файлов вдруг заменились на дефолтные).</para></sect2><sect2><title>USE-флаги</title>
<para>&gt;с флагами я не совсем разобрался... зачем их прописывать, если проги и без них поставятся?</para>
<para>Предположим, ставим мы с тобой kopete (IM-клиент). Ты не включаешь никакие флаги и ставишь пакет, а я включаю "irc" и "yahoo". Так вот мой копете будет поддерживать также протоколы irc и yahoo, а твой - не будет.</para>
<para>&gt;т.е. прогу надо будет заново ставить?</para>
<para>Да, тебе придётся прописать флаги и пересобрать пакет. USE-флаги нужны для того, чтобы включать некоторый функционал в собираемом пакете.</para>
<para>&gt;вот мы дали команду emerge gnome -pv</para>
<para>&gt;там появились строки..красного, синего и желтого цвета...что это все означает?</para>
<para>Жёлтым выделены изменения в наборе флагов пакета. Флаги, больше недействительные (удалённые) для новой версии пакета будут взяты в скобки, новые (добавленные) флаги, появившиеся для новой версии, будут без скобок. Красные - включенные флаги. </para>
<para>Синие - соответственно не включенные (идут по минусу).</para>
<para>Зелёные* - флаг был включен в системе после сборки пакета, пакет был собран без этого флага, готов к пересборке с ним.</para>
<para/>
<para>Например:</para>
<para>[ebuild     UD] app-emulation/wine-0.9.49 [0.9.57]</para>
<para/>
<para>предлагает понизить версию пакета wine (я ставил тестовую 0.9.57, у которой были доступны новые use-флаги "gecko" и "samba", и которых не будет, если пересобрать пакет в версию 0.9.49).</para>
<para>Флаг "java" я включил в системе только что, и поэтому он подсветился во всех пакетах, где он может использоваться, зелёным цветом.USE-флаги добавляются (включаются) в системе по мере необходимости.</para>
<para/>
<para>&gt;ну вот я и пытаюсь узнать..как определить необходимость?</para>
<para>К примеру, поставил ты систему, чист твой /etc/make.conf, включено только несколько обязательных флагов (прописаны в профиле). Теперь хочешь установить Пакет_А, по-хорошему пишешь:</para>
<para># emerge &lt; Пакет_А &gt; -pv</para>
<para>и смотришь use-флаги всех пакетов, что будут устанавливаться. Какие флаги тебе кажутся нужными - включаешь (прописываешь). И ещё раз перезапускаешь команду (могут появиться новые зависимости со своими флагами). Процесс повторять до полного удовлетворения =)</para>
<para>Если прописываешь флаги в make.conf - то они будут действовать глобально для всех пакетов, где встретятся. Если в /etc/portage/package.use в формате: категория/пакет флаг [флаг -флаг] (app-misc/mc 7zip -X -gpm -ncurses slang) то тогда эти флаги будут включены только для этого пакета.</para>
<para>Обычно в make.conf находится некоторое количество глобальных флагов (X, kde, gnome, alsa, etc...) и много-много строк в package.use. Так постепенно use-флаги и накапливаются. А если ты сразу пропишешь в make.conf "Х, kde, gnome, samba" и т.д. (думая, что "вот сейчас я пропишу всё что мне надо и забуду про эти флаги"), то установка какого-нибудь mc потянет за собой столько пакетов по зависимостям... что ты будешь совсем не рад =) Причём, есть вероятность, что всё зациклится и выпадет ошибка.</para>
<para>Смотреть, что означает конкретный флаг удобно в другой консоли в ufed.</para>
<para/>
<para>В make.conf можно прописать дефолтные опции, которые всегда будут ставится после emerge, к примеру, так: EMERGE_DEFAULT_OPTS="--ask --verbose" </para>
<para>Еще стоит отметить, как более правильно распределять флаги между make.conf и package.use. У меня сейчас глобальные флаги, описывающие всю мою систему, в make.conf, а более локальные - относящиеся к конкретным программам - в package.use. Так наверно более удобно. Вообще я как-то стремлюсь сократить число флагов в make.conf.</para>
<para/>
<para>Полезный пакет:</para>
<para># emerge ufed - интерактивный ncurses-based редактор use-флагов. В нём флаги можно включать (отключать) и ufed будет прописывать их в /etc/make.conf. Конечно информация о флагах здесь не настолько подробная, как хотелось бы (особенно для новичка), но всё же лучше чем ничего.</para>
<para/>
<para>&gt;но ведь можно сделать так:</para>
<para>&gt;USE="флаг" emerge &lt; пакет &gt;</para>
<para>А при обновлении мира, флаг у этого пакета потеряется, ибо нигде не прописан, то есть при пересборке (обновлении пакета) получится </para>
<para>USE="-флаг" emerge &lt; пакет &gt;и пакет потеряет часть функциональности.</para>
<para/>
<para>&gt;понял, а как быть, если прога тянет за собой другие, а у тех свои зависимости?</para>
<para>Смотришь их флаги, включаешь, а они после этого потянут ещё что-нибудь... смотришь теперь и их флаги)) пока не остановится процесс разрастания))</para>
<para/>
<para>Если не планируется использовать deltup, можно прописать зеркало yandex в make.conf:</para>
<para>GENTOO_MIRRORS="<ulink url="http://mirror.yandex.ru/gentoo-distfiles/">http://mirror.yandex.ru/gentoo-distfiles/</ulink>
<ulink url="http://mirror.yandex.ru/gentoo-distfiles/%22">"</ulink>;</para>
<para>(хотя эта строка и при дельтапе не помешает).</para>
<para/></sect2><sect2><title>Поддержание системы в чистоте и порядке =)</title>Поддержание системы в чистоте и порядке<para>При установке пакета А, он прописывается в world (/var/lib/portage/world), все пакеты B C D, которые он потянул за собой по зависимостям никуда не прописываются, но они нужны пакету А и поэтому не болтаются в системе мёртвым грузом. Соответственно команда </para>
<para>"# emerge -a —depclean"</para>
<para> не сообщает ни о каких бесхозных пакетах.</para>
<para>Пакет А нам надоел и мы его удаляем: "# emerge -C пакет_А"</para>
<para>Но пакеты B C D всё ещё остаются в системе, совершенно ненужные никому. Удалить их можно лишь точно зная их имена, либо с помощью команды "# emerge -a —depclean".</para></sect2><sect2><title>Проверка целостности системы:</title>
<para># revdep-rebuild - команда проверит целостность зависимостей системы, и при необходимости (найденных ошибках) переустановит (доустановит) необходимые пакеты. Рекомендуется запускать всегда после выполнения команды </para>
<para>"emerge -a —depclean".</para>
<para/>
<para>"Masked" пакеты.</para>
<para>&gt;а еще один вопрос - хочу проставить rawstudio </para>
<para>&gt;а это программа под маской </para>
<para>&gt;как правильно снять маску на эту программу</para>
<para>&gt;в хелпе написано, что они могут быть замаскированны несколькими путями</para>
<para>По умолчанию используется стабильная ветвь ПО. Большое количество пакетов (версий) могут находиться в тестовой ветви. Это не означает, что эти пакеты ужасно нестабильные, отнюдь, вполне возможно, что они будут стабильно работать у вас 364 дня в году ;) Чтобы использовать такие пакеты, есть два варианта:</para>
<para>1. Можно перейти полностью на тестовую ветвь и иметь всегда последние версии ПО.</para>
<para>2. Либо можно комбинировать стабильную ветвь с некоторыми пакетами из тестовой.</para>
<para>В данном случае видим:</para>
<para># eix rawstu</para>
<para>* media-gfx/rawstudio</para>
<para>     Available versions:  ~0.6 ~0.7</para>
<para>     Homepage:            <ulink url="http://rawstudio.org/">http://rawstudio.org</ulink>
</para>
<para>     Description:         a program to read and manipulate raw images from digital cameras.</para>
<para/>
<para>Обе версии пакетов замаскированы тильдой, т.е. относятся к тестовой ветви ПО. Снять такую маску можно прописав "категория/пакет ~x86" в /etc/portage/package.keywords, например:</para>
<para>media-gfx/rawstudio ~x86</para>
<para>(вместо ~x86 может быть ~amd64, либо **)</para>
<para/>
<para>Второй случай: [M] - пакет заблокирован.</para>
<para># eix kde-meta</para>
<para>* kde-base/kde-meta</para>
<para>     Available versions:</para>
<para>        (3.5)   3.5.8 ~3.5.9</para>
<para>        (kde-4) [M]~4.0.1 [M]~4.0.2</para>
<para/>
<para>Здесь kde-4 помечен как находящийся в тестовой ветви (~), плюс к тому же заблокирован от использования (M), т.е. разработчики не рекомендуют пока его использовать - обязательно будут ошибки. Но если очень хочется... ;) то можно разблокировать, прописав "категория/пакет" в /etc/portage/package.unmask, например:</para>
<para>kde-base/kde-meta</para>
<para>(и в данном случае нужно будет также снять тильду, как описано выше).</para>
<para/></sect2><sect2><title>Установка пакетов. Х'сы, DE.</title>
<para/>
<para>Опишу свои личные соображения. Так как система будет использоваться на десктопе для повседневной работы, то обязательно понадобятся Х'сы, какое-то DE, различные кодеки и прочие приложения. Можно сказать "emerge gnome" или "emerge kde" и потом долго ковыряться в use-флагах нескольких сотен пакетов - а их будет много, ибо потянутся и Х'сы, а если повезёт, то захватятся и кодеки. Зато, если хватит сил, вся система будет установлена одной командой =)</para>
<para/>
<para>Я же предпочитаю разбивать этот процесс на подпроцессы:</para>
<para># emerge xorg-x11 - ставим только Х'сы, драйвер на видеокарту, добиваемся его работы и direct rendering'а.</para>
<para># emerge ffmpeg imagemagick xine-lib mplayer - в каком порядке не особо важно, главное не одновременно (а то опять увязнете в сотне-другой зависимостей). После установки этих пакетов и всех нужных зависимостей, в системе будут стоять все необходимые видео/аудио кодеки, а также будет поддержка графических форматов. Здесь же может потянуться в зависимостях samba и cups.</para>
<para>И уже последним делом:</para>
<para># emerge gnome (или kde-meta) - Гном, KDE, либо что вам там нравится.</para>
<para>Наблюдать за процессом установки можно в другой консоли, запустив: </para>
<para>tail -f /var/log/emerge.log</para>
<para/>
<para>Надеюсь, эта информация помогла вам разобраться хоть в каких-то вопросах =)Внимание! Этот пост не отменяет прочтение хендбука, так что вам теперь сюда: <ulink url="http://www.gentoo.org/doc/ru/handbook/">http://www.gentoo.org/doc/ru/handbook/</ulink>
</para>
<para>
<ulink url="http://www.gentoo.org/doc/ru/handbook/">HandBook 2006.1 ru</ulink>, <ulink url="http://www.gentoo.org/doc/en/handbook/">HandBook 2007.0 en</ulink>, <link linkend="">Советы пользователям Gentoo</link>
</para>
<para>
<ulink url="http://gentoo.blog.ru/6345603.html"/>
</para>
<para/></sect2></sect1><sect1><title>Gentoo и Java</title>Gentoo<para/><sect2><title>Руководство по настройке Java в Gentoo</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/en/java.xml">http://www.gentoo.org/doc/en/java.xml</ulink>
<ulink url="http://www.gentoo.org/doc/en/java.xml"> </ulink>
</para>
<para>
<inlinegraphic fileref="images/Java.png" width="2.352cm" depth="4.375cm"/>                              +  <ulink url="http://ru.wikipedia.org/wiki/Java">http://ru.wikipedia.org/wiki/Java</ulink>
</para>
<para>Перевод + дополнения: <ulink url="mailto:JohnBat26@gmail.com?subject=По%20поводу%20вашего%20перевода%20статьи:%20Gentoo%20Java%20Guide">Батогов Е.В a.k.a. JohnBat26</ulink> </para>
<para>С версии: 1.0.</para>
<para>Обновлено в: 1.4</para>
<para>Дата оригинала:  01.01.2008</para>
<para>Дата перевода: 28.01.2008</para>
<para/>
<para/><sect3><title>1. Что такое Java ?</title><sect4><title>Введение</title>
<para/>
<para>
<ulink url="http://ru.wikipedia.org/wiki/Java">Java</ulink> — (произносится <ulink url="http://ru.wikipedia.org/wiki/Международный_фонетический_алфавит">/ˈdʒɑːvə/</ulink>) — <ulink url="http://ru.wikipedia.org/wiki/Объектно-ориентированный_язык_программирования">объектно-ориентированный язык программирования</ulink>, разрабатываемый компанией <ulink url="http://ru.wikipedia.org/wiki/Sun_Microsystems">Sun Microsystems</ulink> с <ulink url="http://ru.wikipedia.org/wiki/1991_год">1991 года</ulink> и официально выпущенный <ulink url="http://ru.wikipedia.org/wiki/23_мая">23 мая</ulink> <ulink url="http://ru.wikipedia.org/wiki/1995_год">1995 года</ulink>. Многие люди, говоря на русском, называют язык «Ява» по аналогии с <ulink url="http://ru.wikipedia.org/wiki/Ява">географическим названием</ulink>.</para>
<para>Изначально новый язык программирования назывался Oak (<ulink url="http://ru.wikipedia.org/w/index.php?title=James_Gosling&amp;action=edit">James Gosling</ulink>) и разрабатывался для бытовой электроники, но впоследствии был переименован в Java и стал использоваться для написания <ulink url="http://ru.wikipedia.org/wiki/Апплет">апплетов</ulink>, приложений и <ulink url="http://ru.wikipedia.org/wiki/Сервер">серверного</ulink> программного обеспечения.</para>
<para>Этот объектно-ориентированный  язык, разработанный для запуска на множестве платформ без необходимости повторной компиляции кода для каждой платформы. Хотя программа, написанная на Java, может быть скомпилирована как родная для конкретной платформы, наибольшую популярность Java принесла её переносимость, наряду с другими функциями, такими как сборка мусора (garbage collection).</para>
<para>Программы на Java могут быть <ulink url="http://ru.wikipedia.org/wiki/Трансляция">транслированы</ulink> в <ulink url="http://ru.wikipedia.org/wiki/Байт-код">байт-код</ulink>, выполняемый на <ulink url="http://ru.wikipedia.org/wiki/Виртуальная_машина">виртуальной джава-машине</ulink> (JVM) — программе, обрабатывающей байтовый код и передающей инструкции оборудованию, как <ulink url="http://ru.wikipedia.org/wiki/Интерпретатор">интерпретатор</ulink>, но с тем отличием, что байтовый код в отличие от текста обрабатывается значительно быстрее.</para>
<para>Достоинство подобного способа выполнения программ — в полной независимости байт-кода от <ulink url="http://ru.wikipedia.org/wiki/Операционная_система">ОС</ulink> и оборудования, что позволяет выполнять Java приложения на любом устройстве, которое поддерживает виртуальную машину. Другой важной особенностью технологии Java является гибкая система безопасности, благодаря тому, что исполнение программы полностью контролируется виртуальной машиной. Любые операции, которые превышают установленные полномочия программы (например, попытка несанкционированного доступа к данным или соединения с другим компьютером) вызывают немедленное прерывание. Это позволяет пользователям загружать программы, написанные на Java, на их компьютеры (или другие устройства, например, мобильные телефоны) из неизвестных источников, при этом не опасаясь заражения вирусами, пропажи ценной информации, и т. п.</para>
<para>Часто к недостаткам этого подхода относят то, что исполнение байт-кода виртуальной машиной может снижать производительность программ и алгоритмов, реализованных на языке Java. Данное утверждение справедливо для первых версий виртуальной машины Java, однако в последнее время оно практически потеряло актуальность. Этому способствовал ряд усовершенствований: применение технологии JITs (Just-In-Time compiler), позволяющей переводить байт-код в машинный код во время исполнения программы с возможностью сохранения версий класса в машинном коде, широкое использование native-кода в стандартных библиотеках, а также аппаратные средства, обеспечивающие ускоренную обработку байт-кода (например, технология <ulink url="http://ru.wikipedia.org/wiki/Jazelle">Jazelle</ulink>, поддерживаемая некоторыми процессорами фирмы <ulink url="http://ru.wikipedia.org/wiki/ARM">ARM</ulink>).</para>
<para>Внутри Java существуют 3 основных семейства технологий:</para>
<orderedlist>
<listitem>
<para>
<ulink url="http://ru.wikipedia.org/wiki/J2EE">J2EE</ulink> или Java EE (начиная с v1.5) — Java Enterprise Editon, для создания программного обеспечения уровня предприятия; </para>
</listitem>
<listitem>
<para>
<ulink url="http://ru.wikipedia.org/wiki/J2SE">J2SE</ulink> или Java SE (начиная с v1.5) — Java Standard Editon, для создания пользовательских приложений, в первую очередь — для настольных систем; </para>
</listitem>
<listitem>
<para>
<ulink url="http://ru.wikipedia.org/wiki/J2ME">J2ME</ulink>, Java ME или Java Micro Edition, для использования в устройствах, ограниченных по вычислительной мощности, в том числе <ulink url="http://ru.wikipedia.org/wiki/Мобильный_телефон">мобильных телефонах</ulink>, PDA, встроенных системах </para>
</listitem>
</orderedlist>
<para>Последней версией является <ulink url="http://java.sun.com/javase/6/">версия 1.6</ulink>, в которой было произведено улучшение системы безопасности, улучшение поддержки XML и скриптового языка Mozilla Rhino, улучшена интеграция с рабочим столом, добавлены некоторые новые возможности в создании графических интерфейсов.</para>
<para>Таким образом байт-код запускается на так называемой JRE (Java Runtime Environment —  Java-окружение времени выполнения ), а не напрямую  операционной системой. Следовательно, для выполнения Java-байткода мы нуждаемся в установленной JDK(Java Runtime Environment). JRE включает в себя основные библиотеки, независимую от платформы - виртуальную Java-машину, плагины для браузеров и многое другое.  JDK (Java Development Kit — набор для Java-разработчика) добавляет средства программирования, такие как  компилятор байткода и отладчик.</para>
<para/></sect4></sect3><sect3><title>2.  Перед тем как начать</title>2.<para/>
<para>Если у Вас уже установлена Java, тогда удостоверьтесь, что Вы следовали <link linkend="">Java Upgrade Guide</link>.</para>
<para>Новая установка не требует дополнительных приготовлений.</para>
<para/></sect3><sect3><title>3. Установка виртуальной машины</title><sect4><title>Варианты</title>
<para>Gentoo сопровождает многочисленные Runtime Environments (JREs) и Development Kits (JDKs). Среди всех предлагаемых вариантов имеются:</para>
<para/>
<para/>
<para/>
<para/>
<informaltable frame="all">
<tgroup cols="3"><tbody>
<row>
<entry>
<para>Поставщик</para>
</entry>
<entry>
<para>JDK</para>
</entry>
<entry>
<para>JRE</para>
</entry>
</row>
<row>
<entry>
<para>The Blackdown Java Kit</para>
</entry>
<entry>
<para>dev-java/blackdown-jdk</para>
</entry>
<entry>
<para>dev-java/blackdown-jre</para>
</entry>
</row>
<row>
<entry>
<para>Sun's Java Kit</para>
</entry>
<entry>
<para>dev-java/sun-jdk</para>
</entry>
<entry>
<para>dev-java/sun-jre-bin</para>
</entry>
</row>
<row>
<entry>
<para>The IBM Java Kit</para>
</entry>
<entry>
<para>dev-java/ibm-jdk-bin</para>
</entry>
<entry>
<para>dev-java/ibm-jre-bin</para>
</entry>
</row>
<row>
<entry>
<para>BEA WebLogic's J2SE Development Kit</para>
</entry>
<entry>
<para>dev-java/jrockit-jdk-bin</para>
</entry>
<entry>
<para>----------------------------</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Таблица 3.1: Выбор JDKs/JREs в Gentoo Linux</para>
<para/>
<para>Пара Blackdown JRE/JDK  используется по умолчанию для версии 1.4., т.к. Она свободна доступна без дополнительных регистраций. JREs и JDKs от <ulink url="http://java.sun.com/javase/downloads/index.jsp">Sun</ulink>, <ulink url="http://www.ibm.com/developerworks/java/jdk/">IBM</ulink>, и <ulink url="http://www.bea.com/framework.jsp?CNT=index.htm&amp;FP=/content/products/jrockit/">BEA</ulink> конечно быстрее, но их получение требует немного больше усилий, таких как чтение и подтверждение лицензии перед загрузкой (IBM дополнительно требует Вашей регистрации).</para></sect4><sect4><title>Установка JRE/JDKs</title>
<para>Для установки JDK, принятой по умолчанию для Вашего профиля запустите:</para>
<para> emerge  virtual/jdk.</para>
<para>Или для установки JRE, принятой по умолчанию для Вашего профиля, запустите: </para>
<para> emerge virtual/jre.</para>
<para>Недавно Sun провел повторное лицензирование своих JDK и JRE под более дружественной к Linux лицензией. В результате этого, Sun выпустил версию Java 1.5 и выше как свободно загружаемые, без дополнительных трудностей.</para>
<para>Примечание: JDK также включает и JRE, поэтому установив JDK, Вам не нужно устанавливать JRE</para></sect4><sect4><title>Установка других, немного ограничивающих их получение, виртуальных машин</title>
<para>Как уже упоминалось, некоторые из JDKs и JREs требуют, чтобы Вы совершили несколько дополнительных действий перед установкой. Просто запустите emerge для этих пакетов как Вы обычно это делаете. Ebuilds (сборочные файлы) в последствии сообщат Вам, куда идти и что скачать. Затем Вам следует загрузить указанные файлы в каталог: /usr/portage/distfiles. После этого, Вы можете повторно запустить команду emerge, которая на этот раз установит данную JRE/JDK.</para></sect4></sect3><sect3><title>4. Настройка Вашей виртуальной машины</title><sect4><title>Введение</title>
<para>Gentoo способен иметь множество  установленных JDKs и JREs  без появления каких-либо конфликтов.</para>
<para>Используя средство  java-config, Вы можете установить умолчания для всей системы (удостоверьтесь, что Вы имеете доступ под root). Пользователи могут также использовать java-config, для установки их персональных настроек по умолчанию.</para>
<para>Примечание: Вы также можете использовать eselect  для изменения системной и пользовательской  виртуальной машины. Смотрите eselect java-vm help.</para>
<para/></sect4><sect4><title>Установка виртуальной машины по умолчанию</title>
<para>Запущенная команда java-config --list-available-vms даст Вам список всех JREs и JDKs, установленных на Вашей системе. Здесь приведен пример вывода этой команды:</para>
<para/>
<para>Листинг 4.1 Список доступных виртуальных машин.</para>
<para># java-config --list-available-vms</para>
<para>The following VMs are available for generation-2:</para>
<para>1)      Blackdown JDK 1.4.2.03 [blackdown-jdk-1.4.2]</para>
<para>2)      Blackdown JRE 1.4.2.03 [blackdown-jre-1.4.2]</para>
<para>3)      Blackdown 32bit JRE 1.4.2.03 [emul-linux-x86-java-1.4.2]</para>
<para>4)      Sun 32bit JRE 1.5.0.08 [emul-linux-x86-java-1.5]</para>
<para>5)      Kaffe 1.1.7 [kaffe]</para>
<para>*)      Sun JDK 1.5.0.08 [sun-jdk-1.5]</para>
<para/>
<para>Символ * показывает текущую активную виртуальную машину (system-vm или user-vm). Имя в скобках ([]) это описатель или номер для конкретной VM. Вы можете использовать описатель или номер для команды: java-config —set-system-vm. Здесь приведён пример по установке системной VM:</para>
<para/>
<para>Листинг 4.2 Установка системной виртуальной машины (system-vm)</para>
<para>(По описателю (предпочтительней))</para>
<para># java-config --set-system-vm blackdown-jdk-1.4</para>
<para>Now using blackdown-jdk-1.4 as your generation-2 system JVM</para>
<para>(По номеру)</para>
<para># java-config --set-system-vm 6</para>
<para>Now using sun-jdk-1.5 as your generation-2 system JVM</para>
<para/>
<para>Как обычный пользователь, Вы можете использовать: java-config --set-user-vm</para>
<para>Примечание: Вам нет необходимости изменять профиль для смены user/system VM.</para></sect4><sect4><title>Установка предпочтительной виртуальной машины</title>
<para>Во время установки различных Java пакетов, виртуальная машина может и будет переключена так, как требуется.</para>
<para>Из-за того, что доступно большое множество виртуальных машин, мы не имеем ресурсов для тестирования и проверки работы каждого пакета их всех.  Таким образом, для гарантии того, что все пакеты установятся гладко и правильно, мы определили список по умолчанию/поддерживаемых виртуальных машин на каждую архитектуру. Вы можете найти этот список в файле: /usr/share/java-config-2/config/jdk-defaults.conf. Когда Вы устанавливаете Java пакеты (через portage), то он обнаруживает одну из этих виртуальных машин в том файле и будет автоматически использовать ту VM, вместо системной VM. Во время установки VM переключается если это необходимо когда, например, ваша системная VM установлена на версию 1.4, но пакет, который Вы устанавливаете, требует как минимум VM версии 1.5. Во время установки он будет использовать предпочтительную версию 1.5 VM, оставляя вашу системную VM не тронутой.</para>
<para>Конечно, Gentoo всегда предлагает выбор, поэтому Вы можете переопределить эти установки по умолчанию в файле: /etc/java-config-2/build/jdk.conf и будете иметь полный контроль тем, какая VM будет использована. Несколько примеров:</para>
<para/>
<para>Листинг 4.3 Пример файла: /etc/java-config-2/build/jdk.conf</para>
<para>(Я хочу всегда использовать sun-jdk, т.е sun-jdk-1.4 для 1.4, sun-jdk-1.5 для 1.5, и так далее)</para>
<para>*=sun-jdk</para>
<para/>
<para>Листинг 4.4 Пример файла: /etc/java-config-2/build/jdk.conf</para>
<para>(Я хочу всегда использовать sun-jdk-1.5 когда возможно, за исключением случаев, когда 1.3 или 1.4 VM явно необходимы)</para>
<para>*=sun-jdk-1.5</para>
<para/>
<para>Листинг 4.5 Пример файла: /etc/java-config-2/build/jdk.conf</para>
<para># Для 1.3  я предпочитаю  sun-jdk 1.4, но когда она недоступна необходимо использовать ibm-jdk-bin,</para>
<para># Для 1.4, использовать blackdown-jdk, а для 1.5, использовать sun-jdk </para>
<para>1.3=sun-jdk-1.4 ibm-jdk-bin</para>
<para>1.4=blackdown-jdk</para>
<para>1.5=sun-jdk</para>
<para/>
<para>Предупреждение: Вам нет необходимости изменять этот файл. Если вы измените эти параметры на не поддерживаемую VM, может случиться непредсказуемое. Сведения об ошибках в таком случае будут иметь гораздо меньший приоритет, чем сведения об ошибках с поддерживаемыми Vms.</para>
<para/></sect4></sect3><sect3><title>5. Компиляторы</title>
<para>Стандартным Java-компилятором, используемым для сборки, является: javac. Он поставляется с каждым JDK. В добавление к настройке виртуальной машины, используемой на этапе сборки, также возможно настроить какой компилятор использовать. Вы определяете список предпочтительных компиляторов в файле: in /etc/java-config-2/build/compilers.conf.</para>
<para/>
<para>Листинг 5.1 файл /etc/java-config-2/build/compilers.conf</para>
<para># If the ebuild supports it</para>
<para># it will check the COMPILERS var front to back and</para>
<para># use the first compiler that is installed</para>
<para/>
<para>COMPILERS="ecj-3.1 jikes javac"</para>
<para/>
<para>Некоторый компиляторы не поддерживают все возможные параметры -target и -source.  Как бы то ни было, каждый компилятор в этом списке проверяется, может ли он поддерживать желаемые -source/-target. javac будет работать во всех случаях, когда ни одного подходящего компилятора не найдено. Более детально о каждом компиляторе показано в таблице ниже:</para>
<para/>
<informaltable frame="all">
<tgroup cols="4"><tbody>
<row>
<entry>
<para>Наименование</para>
</entry>
<entry>
<para>Описатель</para>
</entry>
<entry>
<para>Пакет </para>
</entry>
<entry>
<para>Подробности</para>
</entry>
</row>
<row>
<entry>
<para>javac</para>
</entry>
<entry>
<para>javac</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Это компилятор по умолчанию, поставляется с каждой JDK</para>
</entry>
</row>
<row>
<entry>
<para>jikes</para>
</entry>
<entry>
<para>jikes</para>
</entry>
<entry>
<para>dev-java/jikes</para>
</entry>
<entry>
<para>Jikes был изначально разработан IBM. Это анекдот, но он обычно быстрее чем javac. Тем не менее он более педантичный и падает в тех случаях, в которых javac не имеет проблем. Jikes пока не поддерживает синтаксис Java 1.5 </para>
</entry>
</row>
<row>
<entry>
<para>Eclipse Compiler for Java</para>
</entry>
<entry>
<para>ecj-3.1</para>
</entry>
<entry>
<para>=dev-java/eclipse-ecj-3.1*</para>
</entry>
<entry>
<para>Этот компилятор используется в Eclipse SDK. Он является достаточно функциональным и быстрым. Также поддерживает синтаксис Java 1.5</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/></sect3><sect3><title>6. Установка переменной CLASSPATH по умолчанию</title>
<para>Предупреждение:  Опции, рассмотренные в этом разделе являются устаревшими, и будут удалены в будущем. Мы очень рекомендуем не использовать их, так как Ваши Java проекты или приложения могут идеально управлять своими classpaths. Если Вы определили специфичный CLASSPATH по умолчанию, то некоторые приложения могут повести себя неожиданно, так как классы могут вдруг появиться в classpath.</para>
<para/>
<para>java-config может использоваться для установки системного CLASSPATH, так же как и пользовательского CLASSPATH.  Во-первых Вам необходимо получить список доступных java библиотек, установленных в Вашей системе, которые Вы желаете поместить в CLASSPATH.  Далее приведен пример:</para>
<para>Листинг 6.1: Список классов</para>
<para># java-config --list-available-packages</para>
<para>[xerces-2] The next generation of high performance, fully compliant XML parsers in the Apache Xerces family (/usr/share/xerces-2/package.env)</para>
<para>[junit] Simple framework to write repeatable tests (/usr/share/junit/package.env)</para>
<para>[bsh] BeanShell: A small embeddable Java source interpreter (/usr/share/bsh/package.env)</para>
<para>[bcel] The Byte Code Engineering Library: analyze, create, manipulate Java class files (/usr/share/bcel/package.env)</para>
<para>[log4j] A low-overhead robust logging package for Java (/usr/share/log4j/package.env)</para>
<para>...</para>
<para>И вновь, имена в скобках ([]) являются ID для передачи в  java-config —set-system-classpath. Здесь  пример:</para>
<para/>
<para>Листинг 6.2 Установка CLASSPATHs.</para>
<para># java-config --set-system-classpath log4j,xerces-2</para>
<para/>
<para>Примечание: заметьте, что текущая директория (.) не является частью системного CLASSPATH, и должна быть добавлена  в пользовательский профиль</para>
<para/>
<para>Для обновления Вашего окружения, выйдите их системы, и зайдите вновь. Можно еще сделать </para>
<para>source /etc/profile</para>
<para>Для пользователей,java-config —set-user-classpath создаст ~/.gentoo/java-env-classpath,  который будет затем использоваться в вашем консольном профиле.</para>
<para>Листинг 6.3 Установка пользовательского classpath.</para>
<para>if [[ -f "${HOME}/.gentoo/java-env-classpath" ]]; then</para>
<para>       source ${HOME}/.gentoo/java-env-classpath</para>
<para>fi</para>
<para/>
<para>Если Вы действительно хотите иметь системный или пользовательский classpath, Вы можете добавить следующее в Ваш консольный профиль. Но мы советует избегать этого</para>
<para/>
<para>Листинг 6.4 Установка CLASSPATH</para>
<para>export CLASSPATH="${CLASSPATH}:$(java-config --classpath log4j,xerces-2)" </para>
<para/></sect3><sect3><title>7. Java-плагины для  браузера</title><sect4><title>Установка плагина</title>
<para>Вы можете установить Java плагин для Вашего Web браузера путем запуска emerge для Java VM  c включенным флагом nsplugin.</para>
<para>Примечание: nsplugin недоступен для всех архитектур. Для проверки доступности плагинов для вашей архитектуры, перед установкой Java VM выполните:</para>
<para>emerge -pv &lt;java-vm&gt;</para>
<para>Portage позволяет установить Вам множество версий плагинов, но только один будет использоваться браузером. Вы можете проверить список доступных плагинов, запустив:</para>
<para/>
<para>Листинг 7.1: Просмотр доступных плагинов</para>
<para># eselect java-nsplugin list</para>
<para>   [1]   sun-jre-bin-1.5</para>
<para>   [2]   blackdown-jre-1.4.2</para>
<para/>
<para>В примере ниже, sun-jre-bin устанавливается в качестве плагина для браузера:</para>
<para/>
<para/>
<para>Листинг 7.2:  Выбор плагина</para>
<para># eselect java-nsplugin set sun-jre-bin-1.5</para>
<para/>
<para>Проверка, что правильный плагин был выбран:</para>
<para/>
<para>Листинг 7.3 Проверка правильности выбора плагина</para>
<para># eselect java-nsplugin list</para>
<para>   [1]   sun-jre-bin-1.5  current</para>
<para>   [2]   blackdown-jre-1.4.2</para>
<para/>
<para>Ресурс <ulink url="http://java.com/">http://java.com</ulink> также предоставляет ссылку для <ulink url="http://java.com/en/download/installed.jsp">проверки правильности установки плагина</ulink>
<ulink url="http://java.com/en/download/installed.jsp">. </ulink> Дополнительно, если Вы используете браузер, основанный на Mozilla (например Firefox), тогда Вы можете проверить Ваш Java плагин, просто введя: about:plugins в адресной строке.</para>
<para/></sect4><sect4><title>Плагины на системах с множеством библиотек.</title>
<para>Если Вы работаете на смешанной 64-битной и 32-битной системе (например: на AMD64), то можете использовать только 32-битные плагины.</para>
<para>Для использования 32-битного плагина, Вам необходимо выполнить:</para>
<para>emerge emul-linux-x86-java</para>
<para>с включенным USE-флагом nsplugin.</para>
<para>Листинг 7.4 Установка 32-битного плагина.</para>
<para># echo "app-emulation/emul-linux-x86-java nsplugin" &gt;&gt; /etc/portage/package.use</para>
<para># emerge emul-linux-x86-java</para>
<para/>
<para>Далее проверьте, какие плагины вообще доступны:</para>
<para/>
<para>Листинг 7.5 Просмотр доступных плагинов.</para>
<para># eselect java-nsplugin list</para>
<para>Available 32-bit Java browser plugins</para>
<para>  [1]   emul-linux-x86-java-1.4.2</para>
<para>  [2]   emul-linux-x86-java-1.5</para>
<para/>
<para>Хотя, Вы должны выбрать 32-битный браузер (такой как mozilla-firefox-bin) для использования с Вашим 32-битным плагином, 64-битная версия  konqueror использует Вашу Java VM напрямую. Таким образом, возможно использовать 64-битную версию  blackdown с этим браузером без дополнительных настроек.</para>
<para>Теперь выберите правильный плагин для Вашего 32-битного браузера:</para>
<para>Листинг 7.6 Выбор плагинов</para>
<para># eselect java-nsplugin set 32bit emul-linux-x86-java-1.5</para>
<para/>
<para>Проверка, что правильные плагины были выбраны.</para>
<para/>
<para>Листинг 7.7 Проверка правильного плагина</para>
<para># eselect java-nsplugin list</para>
<para>Available 32-bit Java browser plugins</para>
<para>  [1]   emul-linux-x86-java-1.4.2</para>
<para>  [2]   emul-linux-x86-java-1.5  current</para>
<para/></sect4></sect3><sect3><title>8.  USE флаги, используемые с  Java</title>
<para>Установка USE флагов.</para>
<para>Для получения дополнительной информации относительно USE флагов, смотрите главу <link linkend="">USE флаги</link> в настольной книге Gentoo</para>
<para>Флаги<footnote>
<para>Для более удобной установки USE-флагов, используйте ufed (Use Flag Editor) (emerge ufed)</para>
</footnote>:</para>
<orderedlist>
<listitem>
<para>Флаг java добавляет поддержку Java  во множество программ.</para>
</listitem>
<listitem>
<para>Флаг nsplugin добавляет поддержку для браузеров, основанных на Mozilla (включая Firefox). Это необходимо для просмотра апплетов в этих браузерах.</para>
</listitem>
<listitem>
<para>Флаг source включает установку zip архива исходных кодов пакета. Это обычно используется в IDE для присоединения исходников.</para>
</listitem>
<listitem>
<para>Флаг jce добавляет поддержку криптографического расширения Java.</para>
</listitem>
<listitem>
<para>Для Java пакетов, флаг doc включает сборку документации по API, используя javadoc.</para>
</listitem>
</orderedlist>
<para/></sect3><sect3><title>9.  Дополнительные ресурсы</title>
<para>Off-line ресурсы:</para>
<orderedlist>
<listitem>
<para>java-config man page </para>
</listitem>
<listitem>
<para>java-config --help </para>
</listitem>
</orderedlist>
<para>Online ресурсы</para>
<orderedlist>
<listitem>
<para>
<ulink url="http://www.gentoo.org/proj/en/java/">Java Project Page</ulink> </para>
</listitem>
<listitem>
<para> <ulink url="http://news.gmane.org/gmane.linux.gentoo.java">gentoo-java</ulink>, <ulink url="http://news.gmane.org/gmane.linux.gentoo.user">gentoo-user</ulink>, и <ulink url="http://news.gmane.org/gmane.linux.gentoo.devel">gentoo-dev</ulink> списки рассылки</para>
</listitem>
<listitem>
<para>#gentoo и #gentoo-java на irc.freenode.net </para>
</listitem>
<listitem>
<para>
<ulink url="http://en.wikipedia.org/wiki/Java_programming_language">Wikipedia's entry for Java</ulink> </para>
</listitem>
<listitem>
<para>If you have suggestions or questions regarding this document, please email the Gentoo Java team: <ulink url="mailto:java@gentoo.org">java@gentoo.org</ulink> </para>
</listitem>
</orderedlist>
<para/></sect3></sect2><sect2><title>Руководство по обновлению Java в Gentoo</title>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/proj/en/java/java-upgrade.xml">http://www.gentoo.org/proj/en/java/java-upgrade.xml</ulink>
<ulink url="http://www.gentoo.org/doc/en/java.xml"> </ulink>
</para>
<para>Перевод: <ulink url="mailto:JohnBat26@gmail.com?subject=По%20поводу%20вашего%20перевода%20статьи:%20Руководство%20по%20обновлению%20Java%20в%20Gentoo">Батогов Е.В a.k.a. JohnBat26 </ulink>
</para>
<para>С версии: 1.4.</para>
<para>Дата оригинала:  19.10.2006</para>
<para>Дата перевода: 29.01.2008</para><sect3><title>1. Введение</title>
<para>Привет и добро пожаловать. Теперь Вы можете спросить: "почему я могу захотеть обновлять  Java?". Или, вероятно, вы начали процесс и получили ссылку на эту страницу после ошибки в течение выполнения emerge?  Несмотря ни на что, целью этого документа является помощь Вам в процессе обновления на новую Java систему. Но чем же является эта новая Java система.</para>
<para/><sect4><title>Новая Java система</title>
<para>Для тех, кто не знаком с новой Java системой, здесь приведен список новых возможностей:</para>
<orderedlist>
<listitem>
<para>Способность переключать текущую VM на лету.</para>
</listitem>
<listitem>
<para>Непосредственно изменять пользовательскую и системную VM, без необходимости трогать окружение шелла (т.е. не надо больше запускать env-update &amp;&amp; source /etc/profile после переключения системной VM) .</para>
</listitem>
<listitem>
<para>Теперь появилось понятие "сборочной VM", используемой для установки (через emerge) пакетов, и настраиваемой независимо от системной VM.</para>
</listitem>
<listitem>
<para>Для каждой версии Java, т.е. 1.3, 1.4, 1.5, 1.6 и т.д., сборочная VM может быть настроена  и по поставщику и по версии.</para>
</listitem>
<listitem>
<para>Во время выполнения emerge, VM может переключаться на лету в соответствии с её настройками, а также из-за зависимостей пакетов. Например, некоторые пакеты не собираются с версией 1.5. В таких случаях  версия 1.4 будет использована во время сборки.</para>
</listitem>
<listitem>
<para>У Java пакетов, которые собираются с ant, во время компиляции будет перезаписан файл build.xml, для гарантии, что правильная версия байт-кода будет получена.</para>
</listitem>
</orderedlist>
<para/></sect4><sect4><title>Терминология/ основные понятия</title>
<para>Теперь, когда Вы знаете идею того, что получаете... далее приводится несколько терминов и понятий, которые Вы можете найти полезными перед началом.</para>
<para/>
<para>Поколение (Generation)</para>
<para>Это новое понятие. Смысл состоит в том, что поколение это множество средств и eclasses для сборки Java пакетов. В некоторое время мы начнем переходить с существующего поколения на новое. В течение этого времени, оба поколения существуют вместе в Вашей системе и в дереве портежей. Так например, Вы можете иметь системную VM для поколения 1 и системную VM для поколения 2. Для достижения этого, пакеты которые используют поколение 1 и поколение 2 могут сосуществовать, пока происходит миграция на новое поколение.</para>
<para/>
<para>Поколение 1 (Generation 1)</para>
<para>       Это поколение состоит из существующих eclasses (java-pkg, java-utils, и java)         и</para>
<para>       java-config-1. Поколение 1 это устаревшая, постепенно уходящая, система. </para>
<para>Поколение 2 (Generation 2)</para>
<para>Это поколение состоит из новых eclasses (java-pkg-2, java-pkg-opt-2, java-ant-2, и java-utils-2) и новой версии java-config. Это поколение, куда мы постепенно мигрируем.</para>
<para>Поколение 1 Системная VM</para>
<para>     Эта VM используется для установки Java пакетов, используя eclasses из         Поколения 1. Она устанавливается следующим образом:</para>
<para>          java-config-1 --set-system-vm &lt;choice of vm&gt;. </para>
<para>Поколение 2 Системная VM </para>
<para>C Поколением 1, системная VM используется только для  root и для пользователей, которые не имеют установленной пользовательской VM</para>
<para>Поколение 2 Сборочная VM</para>
<para>        Поколение 2 вводит новый класс VM. Сборочная VM используется во время         установки для сборки Java пакетов. Она изменяется, как того требует         зависимости от пакетов. Например, если пакет собирается только с версией         1.4, то VM версии 1.4 и будет использоваться. Умолчания определены в         файле: /usr/share/java-config-2/config/jdk-defaults.conf.  Дополнительно         сборочная VM может быть настроена в файле:/etc/java-config-2/build/jdk.conf. </para>
<para/></sect4></sect3><sect3><title>2.  Обновление java-config</title>
<para>Новый пакет java-config-wrapper, блокируется старыми версиями java-confg, так что нам следует удалить его сначала: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.1: Удаление старого java-config</para>
</entry>
</row>
<row>
<entry>
<para># emerge -C java-config</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь нам необходимо установить новую версию java-config:</para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.2: Установка нового java-config</para>
</entry>
</row>
<row>
<entry>
<para># emerge -1 "=java-config-1*" "=java-config-2*"</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3><sect3><title>3. Проверка вашего окружения</title>
<para>У нас теперь есть новый скрипт: java-check-environment. Как можно догадаться из его названия, он проверяет правильность Вашего окружения Java. Потом он советует, какие действия Вы можете предпринять для исправления найденных проблем. Таким образом, теперь запустите:</para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.1: Проверка Вашего окружения </para>
</entry>
</row>
<row>
<entry>
<para># java-check-environment</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Если java-check-environment обнаружит проблему, остановится и скажет Вам о том как её исправить. Следуйте этим советам, и повторно запускайте java-check-environment,  пока он не найдет никаких проблем.</para></sect3><sect3><title>4. Обновление ... завершено!</title>
<para>Если Вы дошли до этого места, значит Вы успешно перешли на новую Java систему. Поздравляем !</para>
<para>Теперь, когда Вы обновились, Вы можете захотеть взглянуть на нашу обновленную документацию:</para>
<orderedlist>
<listitem>
<para>
<link linkend="">Руководство пользователя (Рус.)</link>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://www.gentoo.org/proj/en/java/java-devel.xml">Руководство разработчика (Англ.)</ulink>
</para>
</listitem>
</orderedlist>
<para/></sect3><sect3><title>5. Общие проблемы и вопросы</title>
<para>Для решения общих проблем, Java team имеет свою wiki страницу <ulink url="http://overlays.gentoo.org/proj/java/wiki/Common_Problems">здесь</ulink>. Перед поиском помощи, или отправкой отчета о проблеме, пожалуйста, ознакомьтесь с этой страницей.</para></sect3></sect2></sect1><sect1><title>Gentoo и GPRS</title><sect2><title>GPRS через USB (Руководство)</title>
<para>Ссылка на оригинал: <ulink url="http://linuxforum.ru/index.php?s=79d5938b878e18abfae087fa54a21809&amp;showtopic=52062">http://linuxforum.ru/</ulink>
</para>
<para>Автор: Nikoli (Linuxforum.ru)</para>
<para>С версии: 1.3</para>
<para/>
<para>Появилась необходимость в GPRS соединение в качестве страховочного. Телефоны подключал по USB. Потратил пару часов на настройку, но в итоге получилось довольно простое решение. Здесь для Gentoo такого руководства не выкладывали, надеюсь моё будет полезно. Если считаете необходимым, добавьте его в FAQ.</para>
<para/>
<para>1) Ядро должно быть собрано с:</para>
<para/>
<para>Device Drivers  ---&gt;        USB support  ---&gt;          &lt;M&gt;   USB Modem (CDC ACM) support</para>
<para/>
<para>2) Должен быть установлен ppp3) В /etc/conf.d/net нужно добавить:</para>
<para/>
<para>#**********/-------Nokia with Megafonconfig_ppp1=( "ppp" )link_ppp1="ttyACM0"pppd_ppp1=("debug" # Comment this off, if you don't need more info#460800 # Serial port line speed"crtscts" # hardware flow control for cable"local" # Ignore carrier detect signal from the modem:"lcp-echo-failure 0""lcp-echo-interval 0"# IP addresses:":0.0.0.0"# - accept peers idea of our local address and set address peer as 10.6.6.6# (any address would do, since IPCP gives 0.0.0.0 to it)# - if you use the 10. network at home or something and pppd rejects it,# change the address "noipdefault" # pppd must not propose any IP address to the peer!"ipcp-accept-local" # Accept peers idea of our local address"defaultroute" # Add the ppp interface as default route to the IP routing table#replacedefaultroute # New route should be our default route to Internet"usepeerdns" # User DNS returned by server"noauth" # The phone is not required to authenticate# Most phone do not support compression, so turn it off.#noipv6#novj#nobsdcomp#novjccomp#nopcomp#noaccomp# Username and password:# If username and password are required by the APN, put here the username# and put the username-password combination to the secrets file:# /etc/ppp/pap-secrets for PAP and /etc/ppp/chap-secrets for CHAP# authentication. See pppd man pages for details.'user "internet"' # Change this"persist" # Persistent connection"maxfail 99999" # Retry and retry and retry if failed...)chat_ppp1=('TIMEOUT' '45''ABORT' 'BUSY''ABORT' 'NO CARRIER''ABORT' 'ERROR''' 'ATE1''OK' 'AT+CGDCONT=1,"IP","internet"''OK' 'ATD*99***1#''CONNECT' 'c')#**********/-------Motorola with Beelineconfig_ppp2=( "ppp" )link_ppp2="ttyACM0"pppd_ppp2=("debug" # Comment this off, if you don't need more info#460800 # Serial port line speed"crtscts" # hardware flow control for cable"local" # Ignore carrier detect signal from the modem:"lcp-echo-failure 0""lcp-echo-interval 0"# IP addresses:":0.0.0.0"# - accept peers idea of our local address and set address peer as 10.6.6.6# (any address would do, since IPCP gives 0.0.0.0 to it)# - if you use the 10. network at home or something and pppd rejects it,# change the address "noipdefault" # pppd must not propose any IP address to the peer!"ipcp-accept-local" # Accept peers idea of our local address"defaultroute" # Add the ppp interface as default route to the IP routing table#replacedefaultroute # New route should be our default route to Internet"usepeerdns" # User DNS returned by server"noauth" # The phone is not required to authenticate# Most phone do not support compression, so turn it off.#noipv6#novj#nobsdcomp#novjccomp#nopcomp#noaccomp# Username and password:# If username and password are required by the APN, put here the username# and put the username-password combination to the secrets file:# /etc/ppp/pap-secrets for PAP and /etc/ppp/chap-secrets for CHAP# authentication. See pppd man pages for details.'user "internet.beeline.ru"' # Change this"persist" # Persistent connection"maxfail 99999" # Retry and retry and retry if failed...)chat_ppp2=('TIMEOUT' '45''ABORT' 'BUSY''ABORT' 'NO CARRIER''ABORT' 'ERROR''' 'ATE1''OK' 'AT+CGDCONT=1,"IP","INTERNET.MSK"''OK' 'ATD*99***1#''CONNECT' 'c')</para>
<para/>
<para/>
<para>4) Сделайте ссылки на net.lo</para>
<para/>
<para>ln -s /etc/init.d/net.lo /etc/init.d/net.ppp1ln -s /etc/init.d/net.lo /etc/init.d/net.ppp2</para>
<para/>
<para/>
<para>5) Подключите телефон с помощью USB, появится /dev/ttyACM0</para>
<para>6) Выполните</para>
<para/>
<para>/etc/init.d/net.ppp1 start</para>
<para/>
<para>Возможно у вас появится соединение с интернетом.Полезно почитать вывод tail -f /var/log/messages :</para>
<para/>
<para>Oct 27 01:18:03 kompyc pppd[9874]: pppd 2.4.4 started by root, uid 0Oct 27 01:18:03 kompyc chat[9877]: timeout set to 45 secondsOct 27 01:18:03 kompyc chat[9877]: abort on (BUSY)Oct 27 01:18:03 kompyc chat[9877]: abort on (NO CARRIER)Oct 27 01:18:03 kompyc chat[9877]: abort on (ERROR)Oct 27 01:18:03 kompyc chat[9877]: send (ATE1^M)Oct 27 01:18:03 kompyc chat[9877]: expect (OK)Oct 27 01:18:03 kompyc chat[9877]: ATE1^M^MOct 27 01:18:03 kompyc chat[9877]: OKOct 27 01:18:03 kompyc chat[9877]: -- got itOct 27 01:18:03 kompyc chat[9877]: send (AT+CGDCONT=1,"IP","internet"^M)Oct 27 01:18:04 kompyc chat[9877]: expect (OK)Oct 27 01:18:04 kompyc chat[9877]: ^MOct 27 01:18:04 kompyc chat[9877]: AT+CGDCONT=1,"IP","internet"^M^MOct 27 01:18:04 kompyc chat[9877]: OKOct 27 01:18:04 kompyc chat[9877]: -- got itOct 27 01:18:04 kompyc chat[9877]: send (ATD*99***1#^M)Oct 27 01:18:04 kompyc chat[9877]: expect (CONNECT)Oct 27 01:18:04 kompyc chat[9877]: ^MOct 27 01:18:05 kompyc chat[9877]: ATD*99***1#^M^MOct 27 01:18:05 kompyc chat[9877]: CONNECTOct 27 01:18:05 kompyc chat[9877]: -- got itOct 27 01:18:05 kompyc chat[9877]: send (c^M)Oct 27 01:18:05 kompyc pppd[9874]: Serial connection established.Oct 27 01:18:05 kompyc pppd[9874]: Using interface ppp1Oct 27 01:18:05 kompyc pppd[9874]: Connect: ppp1 &lt;--&gt; /dev/ttyACM0Oct 27 01:18:06 kompyc pppd[9874]: local IP address 10.205.145.43Oct 27 01:18:06 kompyc pppd[9874]: remote IP address 10.6.6.6Oct 27 01:18:06 kompyc pppd[9874]: primary DNS address 10.77.48.2Oct 27 01:18:06 kompyc pppd[9874]: secondary DNS address 10.77.48.3</para>
<para/>
<para/>
<para>Проверял на том, что было. С отключённым сжатием у меня заработало, у вас его возможно нужно выключить. Если у вас есть замечания по улучшению, буду рад.По мотивам:</para>
<para>
<ulink url="http://gentoo-wiki.com/Nokia_S60_and_N_series">http://gentoo-wiki.com/Nokia_S60_and_N_series</ulink>
<ulink url="http://gentoo-wiki.com/HOWTO_Phone_sync">http://gentoo-wiki.com/HOWTO_Phone_sync</ulink>
<ulink url="http://www.opennet.ru/base/modem/gprs_linux.txt.html">http://www.opennet.ru/base/modem/gprs_linux.txt.html</ulink>
</para>
<para/><sect3><title>Настройка GPRS в Linux</title>
<para>Ссылка на оригинал: <ulink url="http://ru.gentoo-wiki.com/Настройка_GPRS_в_Linux">http://ru.gentoo-wiki.com</ulink>
</para>
<para>С версии: 1.3</para>
<para/></sect3><sect3><title>Введение</title>
<para/>
<para>Это руководство поможет настроить мобильный телефон для связи с провайдером через GPRS (на примере beeline). Для того, чтобы настроить мобильный телефон для связи через GPRS, вам понадобится подключить на вашем телефоне услугу GPRS. Обзавестись Mini-USB кабелем. Поправить ручками кое-что в ядре и собрать дополнительные пакеты из набора portage. </para></sect3><sect3><title>Подготовка</title>
<para/>
<para>Для наших задач нам понадобится изменить несколько файлов настроек.</para>
<para>Я использовал ядро gentoo-sources-2.4.28-gentoo-r5 из portage, </para>
<para>дозвонщик wvdial оттуда же</para>
<para>и ppp-2.4.3-r1 тоже соответсвенно из portage. </para>
<para/>
<para>Изменяем файлы: </para>
<para>Открываем /etc/make.conf для редактирования nano -w /etc/make.conf </para>
<para/>
<para>Добавляем mppe-mppc (Нужно для подключения с шифрованием Microsoft MS-CHAPv2)к вашим USE Файл: /etc/make.conf </para>
<para/>
<para>USE="mppe-mppc" </para>
<para/></sect3><sect3><title>Сборка пакетов</title>
<para/>
<para>Собираем pppd: </para>
<para>emerge /usr/portage/net-dialup/ppp/ppp-2.4.3-r1.ebuild </para>
<para/>
<para>собираем wvdial: </para>
<para>emerge wvdial </para>
<para/>
<para>редактируем ядро </para>
<para/>
<para>cd /usr/src/linux &amp;&amp; make menuconfig </para>
<para/>
<para>(подразумевается что linux это символичесская ссылка на исходники ядра) </para>
<para/>
<para>изменяем: </para>
<para/>
<para>Network Device Support ---&gt; </para>
<para>&lt;M&gt;   (PPP point-to-point protocol) support</para>
<para>[ ]   PPP multilink support (EXPEREMRNTAL) (Вы же не хотите объеденять несколько телефонов в один канал)</para>
<para>[M]   PPP filtering</para>
<para>&lt;M&gt;   PPP support for async serial ports</para>
<para>&lt;M&gt;   PPP support for sync tty ports</para>
<para>&lt;M&gt;   PPP Deflate compression</para>
<para>&lt;M&gt;   PPP BSD-Compress compression</para>
<para>&lt;M&gt;   PPP over Ethernet (EXPEREMENTAL)</para>
<para/>
<para>Примечание - т.к. у меня ядро 2.6.12-gentoo-r6, то выше названные модули я просто включил в ядро, и не возился в дальнейшем с их загрузкой. Пока проблем не было. </para>
<para/>
<para>ISDN Subsystem ---&gt; </para>
<para>&lt;*&gt;   ISDN Support</para>
<para>[*]   Support asynchronus PPP</para>
<para>[*]   PPP filtering for ISDN</para>
<para>[*]   Use VJ-compression with asynchronus PPP</para>
<para/>
<para>USB supprot ---&gt; </para>
<para>[*]   Support for USB</para>
<para>--- USB Host Controller Driver</para>
<para>&lt;*&gt;   ECHI HCD (USB2.0) support (EXPEREMENTAL)</para>
<para/>
<para>(так как у меня чип материнской платы Intel то) </para>
<para>&lt;*&gt;   UHCI (Intel PIIX4, VIA, ...) support</para>
<para>--- USB Device Class drivers</para>
<para>&lt;M&gt;   USB Modem (CDC ACM) support</para>
<para/>
<para>Примечание - для ядра 2.6.12-gentoo-r6 нужно установить: </para>
<para/>
<para>Device Drivers ---&gt; ISDN subsystem ---&gt; </para>
<para>ISDN subsystem  ---&gt;</para>
<para>[*]     CAPI2.0 Middleware support (Может и не нужно, но с ним работает)</para>
<para/>
<para>Для C380 в данном разделе остальное у меня отключено. </para>
<para>И по меньшей мере для C380 дополнительно требуется установить: </para>
<para>Device Drivers ---&gt; USB support ---&gt; USB Serial Converter support ---&gt; </para>
<para>&lt;*&gt; USB Serial Converter support</para>
<para>[*]   USB Serial Console device support</para>
<para/>
<para/>
<para/>
<para>Сохраняем конфигурацию ядра и выполняем сборку. После сборки устанавливаем новое ядро</para>
<para>(Процесс установки ядра описан во многих источниках так что не буду повторяться) </para>
<para>и перезагружаем машину. </para></sect3><sect3><title>Настройка</title>
<para/>
<para>После перезагрузки пытаемся загрузить модули </para>
<para>перед всеми манипуляциями проверить есть ли в /dev устройство ttyACM0, иначе скрипт и терминалка не увидят модема (телефона) по крайней мере в Fedore Core 2.0 если с ttyUSB0(1,2,3,4,5) ничего не вышло наберите находясь в /dev "mknod ttyACM0 c 160 0" (спасибо Pooh) и все должно заработать, естественно что модемом после этого будет устройство ttyACM0 (Yuri г. Barnaul) </para>
<orderedlist>
<listitem>
<para>стандартный модуль PPP modprobe ppp_generic </para>
</listitem>
<listitem>
<para>Модуль для асинхронной передачи modprobe ppp_async </para>
</listitem>
<listitem>
<para>Модуль для нашего телефона modprobe acm </para>
</listitem>
</orderedlist>
<para/>
<para>Проверяем загрузились модули lsmod </para>
<para/>
<para>Вывод должен выглядеть примерно так ---&gt; </para>
<para>ppp_async               6848   0  (unused)</para>
<para>ppp_generic            22628   0  [ppp_async]</para>
<para>slhc                    4624   0  [ppp_generic]</para>
<para>acm                    45353   0  [xxxxxxxxxxx] (не помню точно что должно быть)</para>
<para/>
<para>Производим первичную конфигурацию wvdial </para>
<para>cd /etc &amp;&amp; wvdialconf wvdial.conf </para>
<para/>
<para>открываем для редактирования /etc/wvdial.conf </para>
<para>nano -w wvdial.conf Файл: /etc/wvdial.conf </para>
<para>и изменяем сделующие строки </para>
<para/>
<para>Init2 = AT+CGDCONT=1,"IP","internet.beeline.ru"</para>
<para>Phone = *99***1#</para>
<para>Username = beeline</para>
<para>Password = beeline</para>
<para/>
<para/>
<para>сохраняем полученный файл. Если значение Init2 уже занато (для C380 в нем дополнительные комманды инициализации), то используйте значение Init3 (Init3 = AT+CGDCONT=1,"IP","internet.beeline.ru"). </para>
<para/>
<para>На некоторых тарифах имя пользователя и пароль пустые, тогда файл для C380 и ядра 2.6.12-r6 будет выглядеть примерно так: Файл: /etc/wvdial.conf </para>
<para/>
<para>Modem = /dev/ttyACM0</para>
<para>Baud = 460800</para>
<para>Init1 = ATZ</para>
<para>Init2 = ATQ0 V1 E1 S0=0 &amp;C1 &amp;D2 +FCLASS=0</para>
<para>Init3 = AT+CGDCONT=1,"IP","internet.usi.ru"</para>
<para>ISDN = 0</para>
<para>Modem Type = Analog Modem</para>
<para>Phone = *99***1#</para>
<para>Username = ""</para>
<para>Password = ""</para></sect3><sect3><title>Установка соединения</title>
<para/>
<para>запускаем wvdial </para>
<para/>
<para>wvdial </para>
<para/>
<para>Потираем ручки и юзаем GPRS на Linux </para>
<para/></sect3><sect3><title>Автоматическая установка соединения</title>
<para/>
<para>Если вы используете udev, можно настроить автоматическое подключение GPRS при подключении телефона к USB. </para>
<para>Для этого создайте такой вот файл: Файл: /etc/udev/rules.d/90-gprs-autodial.rules </para>
<para/>
<para>KERNEL=="ttyACM0", RUN="/usr/bin/wvdial" </para>
<para/>
<para>(немного некрасиво, но работает на ура) </para>
<para>..а при отключении телефона соединение оборвётся и без наших скриптов.. </para>
<para/>
<para/>
<para>Примечание: А вообще, на домашних компьютерах можно использовать и графическую звонилку kppp, там и в командной строке набирать ничего не надо, да и удобнее она чем wvdial. </para>
<para/></sect3><sect3><title>Заключение</title>
<para/>
<para>Данная статья ни в коем случае не претендует на то что это является правильным и единственным способом подключения GPRS. Вся ответсвенность за действия ложится на ваши плечи. Я описал то что у меня работает. Допускаю что мог в чем то ошибиться так как писал это все на память так что милости прошу ваши коментарии и исправления можно отправлять по email <ulink url="mailto:darkman@rusgate.org">darkman@rusgate.org</ulink>
</para>
<para/></sect3></sect2><sect2><title>Экономим трафик, с помощью Toonel. (Linux)</title>
<para/>
<para>Ссылка на оригинал:<ulink url="http://doc.3dn.ru/publ/9-1-0-12"> </ulink>
<ulink url="http://doc.3dn.ru/publ/9-1-0-12">http://doc.3dn.ru/publ/9-1-0-12</ulink>
</para>
<para>Автор: Дмитрий a.k.a. doc (<ulink url="http://doc.3dn.ru/">http://doc.3dn.ru</ulink>)</para>
<para>С версии: 1.3</para>
<para/>
<para>Бесплатный сервис toonel.net. Клиент написан на java, поэтому необходима виртуальная машина java.</para>
<para>Оф.сайт: <ulink url="http://www.toonel.net/">www.toonel.net</ulink>
</para>
<para/>
<para>Убедитесь, что у вас установлена виртуальная машина JAVA. Посмотрите в /usr/lib/jre-ххххх (х – номер версии), если нестоит то установите с диска дистрибутива (практический во всех дистрибутивах JAVA клиент есть), обычно называется j2re-xxxxx (х – номер версии), если Java стоит, то можно приступать к установке toonel.</para>
<para>Прежде чем запускать файл toonel, поменяйте у него права на чтение и запись.</para>
<para>Теперь выполняем простую команду:</para>
<para/>
<para>$ java -jar /указываем путь/toonel.jar</para>
<para>Появляется окно программы.</para>
<para>
<!--<inlinegraphic fileref="embedded:Графический объект5" width="2.317cm" depth="3.301cm"/>
<inlinegraphic fileref="embedded:Графический объект4" width="2.306cm" depth="3.303cm"/>
<inlinegraphic fileref="embedded:Графический объект1" width="2.255cm" depth="3.299cm"/>--> </para>
<para>Вкладка Stats – показывает статистику, </para>
<para>вкладка Mapping – настройка программы, </para>
<para>вкладка About – о программе.</para>
<para>Теперь переходим к настройки, вкладка Mapping.</para>
<para>Чтобы настроить сжатие в браузере жмем на 127.0.0.1</para>
<para>Здесь стоит hostname: 127.0.0.1</para>
<para>localport: 8080</para>
<para>web interface port: 7999</para>
<para>Устанавливаем нужный процент сжатия JPEG.</para>
<para>Теперь переходим в браузер, входим в Настройки, Параметры соединения.</para>
<para>Выбираем: Настройка прокси в ручную:</para>
<para>HTPP-прокси: 127.0.0.1 Порт:8080</para>
<para>SSL-прокси: 127.0.0.1 Порт:8080</para>
<para>FTP-прокси: 127.0.0.1 Порт:8080</para>
<para>
<!--<inlinegraphic fileref="embedded:Графический объект6" width="10.29cm" depth="6.476cm"/>Gopher-прокси:127.0.0.1 Порт:8080 --></para>
<para/>
<para>Все теперь сжатие трафика с проводника установлено.</para><sect3><title>Сжимаем трафик электронной почты.</title>Сжимаем трафик электронной почты.<para/>
<para>В Toonel на вкладке Mapping жмем на – new port mapping – в hostname пишем pop3 вашего почтового сервера, например pop3.yandex.ru , в local port указываем порт для прокси сервера, например 8111 и в remote port указываем порт для входящей почты обычно 110, и жмем кнопку Apply.</para>
<para>Для исходящей почты тоже самое только меняем порты, ну и конечножи сервер на smtp.</para>

<!--<inlinegraphic fileref="embedded:Графический объект8" width="2.599cm" depth="3.908cm"/>
<inlinegraphic fileref="embedded:Графический объект7" width="2.744cm" depth="3.919cm"/> </para>-->
<para/>
<para>Все toonel для сжатия почты готов, теперь переходим в почтовый клиент.</para>
<para>Входим в Настройки, Параметры соединения, выбираем Настройка прокси вручную:</para>
<para>HTTP-прокси: 127.0.0.1 Порт:8080</para>
<para>SSL-прокси: 127.0.0.1 Порт:8080</para>
<para> </para>
<para>После настройки прокси, входим в Параметры учетной записи и меняем Имя сервера: на 127.0.0.1 а порт 110, на порт который указали в toonel 8111.</para>
<para> </para>
<para>Теперь и сжатие трафика входящей почты установлено.</para>
<para>Для исходящей почты Имя сервера: на 127.0.0.1 а порт 25, на порт который указали в toonel 8026.</para>
<para>
<!--<inlinegraphic fileref="embedded:Графический объект9" width="9.791cm" depth="7.111cm"/> --></para>
<para> </para>
<para>Таким образом можно настроить сжатие любой программы которой вы пользуетесь выходя во всемирную паутину.</para>
<para/>
<para/></sect3></sect2><sect2><title>GPRS через KPPP</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.linuxcenter.ru/lib/articles/networking/kppp_gprs_hints.phtml">http://www.linuxcenter.ru/lib/articles/networking/kppp_gprs_hints.phtml</ulink>
</para>
<para>Автор: Валентин Синицин</para>
<para>С версии: 1.3</para>
<para/>
<para>Телефон с поддержкой GPRS сегодня есть практически у каждого. Руководств по настройке GPRS-соединения в Linux тоже предостаточно, но большая часть из них ориентирована на конкретных операторов сотовой связи или не выходит за рамки mini-HOWTO. В этой статье мы постарались дать общее представление о том, что представляет собой "GPRS в Linux" и привели примерную схему действий для настройки подключения "стандартными средствами" — через KPPP</para>
<para>С точки зрения повседневного использования сотовый телефон с поддержкой GPRS не слишком отличается от старого доброго модема на 14400 (да, и по скорости временами тоже). Значит, для подключения к "мобильному Интернету" можно использовать все привычные PPP-утилиты — ничего нового не потребуется. Впрочем, необходимо учесть кое-какие тонкости — о них мы и собираемся поговорить.</para>
<para>Как и всякое приличное "железо", GPRS-модем идентифицируется в системе файлом устройства в /dev. Его конкретное имя может отличаться в зависимости от дистрибутива и способа подключения: для дата-кабеля оно может называться /dev/ttyUSB0 (необходимо подгрузить драйвер используемого конвертера USB-to-Serial, чем, по сути, и является дата-кабель. Весьма распространенный вариант — pl2303, если в вашем дата-кабеле используется другая микросхема — ознакомьтесь с соответствующей секцией конфигуратора ядра Linux или поищите на форумах. В современных дистрибутивах с udev, как правило, необходим только скомпилированный модуль — все остальное, в том числе, создание файла устройства происходит автоматически), для IrDA — /dev/ircomm0, для Bluetooth — /dev/rfcomm0. В двух последних случаях потребуется некоторая предварительная настройка, выходящая за рамки данной статьи — все подробности можно найти в соответствующих HOWTO.</para>
<para>Настройку GPRS-подключения, как уже упоминалось выше, можно произвести стандартными утилитами. Конкретные параметры можно найти на сайте вашего оператора сотовой связи, здесь же мы опишем стандартную схему действий на примере KPPP. </para>
<orderedlist>
<listitem>
<para>Запустите KPPP и создайте новый модем (Confugure-&gt;Modems-&gt;New). Укажите используемое имя устройства (если нужного вам имени в списке нет, создайте соответствующую символическую ссылку. Лучше делать это прямо из правил udev) </para>
</listitem>
<listitem>
<para>Перейдите на вкладку "Modem" и нажмите кнопку "Modem commands". Введите дополнительную строку инициализации вида AT+CGDCONT=1,"IP","APN_NAME". Точный вид этой строки должен быть приведен на сайте вашего оператора. </para>
</listitem>
<listitem>
<para>Проверьте модем, нажав на кнопку Query Modem. Если вы не увидите сообщения об ошибке, значит, все прошло, как надо. </para>
</listitem>
<listitem>
<para>Создайте новое подключение. В качестве телефона введите *99***1# — точный вариант, опять же, ищите на сайте оператора. </para>
</listitem>
<listitem>
<para>Теперь можно задать дополнительные аргументы pppd. Рекомендуем добавить "debug" — будете хорошо видеть, если что-то пойдет не так. Если оператор требует отключить сжатие данных — введите "связку" nodeflate + nobsdcomp; если необходимо избавиться от сжатия заголовков TCP/IP — добавьте nojv + novjccomp. </para>
</listitem>
<listitem>
<para>Отдельного упоминания заслуживает фраза: "имя пользователи и пароль не используются". Дело в том, что KPPP не позволяет оставить имя пользователя и пароль пустыми, если используется PAP-авторизация, а некоторые операторы не принимают никакие реквизиты, кроме пустой строки. Проблема решается следующим образом: откройте файл /etc/ppp/options (от имени root) и добавьте в него опцию privgroup &lt;ваша_группа&gt;. Это позволит вам передавать в командной строке привилегированные опции pppd, в частности, noauth. Ею и следует воспользоваться. </para>
</listitem>
<listitem>
<para>Закройте окно настроек. Введите имя пользователя и пароль (в случае, если они "не используются", ими может быть любой набор символов) и нажмите кнопку "Connect". Если все пройдет гладко, то через некоторое время KPPP свернется в трей — это значит, что подключение удалось. В противном случае проверьте файл журнала на предмет сообщений об ошибках. </para>
</listitem>
</orderedlist>
<para/></sect2><sect2><title>GPRS  через Bluetooth</title>GPRS  через Bluetooth<para/>
<para>Смотрите "<link linkend="">HOWTO Соединение с Internet !</link>"</para></sect2></sect1><sect1><title>HOWTO Соединение с Internet</title>HOWTO Соединение с Internet<para/>
<para>    Ссылка на оригинал: <ulink url="http://ru.gentoo-wiki.com/HOWTO_Соединение_с_Internet">http://ru.gentoo-wiki.com/</ulink>
</para>
<para>C версии: 1.0</para>
<para>Изменено: 1.3</para>
<para/><sect2><title>Настройка VPN</title>Настройка VPN<para>Это работает для ядер &gt;=2.6.15 </para><sect3><title>Проверка параметров ядра </title>
<para>Если ваш провайдер использует mppe-mppc проверьте следующее: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Linux Kernel Configuration: Параметры ядра </para>
</entry>
</row>
<row>
<entry>
<para>  Device Drivers ---&gt;</para>
<para>    Network support ---&gt;</para>
<para>      &lt;M&gt;   PPP (point-to-point protocol) support</para>
<para>        &lt;M&gt;   PPP MPPE compression (encryption) (EXPERIMENTAL)  </para>
<para> Cryptographic options ---&gt; </para>
<para>&lt;M&gt;   SHA1 and RC4 algorithms</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь необходимо собрать наше ядро. Без разницы, как вы скомпилировали эти части. Вы можете вкомпилировать все в ядро или собрать модулями. В конце вы должны подгрузить модули: </para>
<orderedlist>
<listitem>
<para>libcrc32c </para>
</listitem>
<listitem>
<para>ip_gre </para>
</listitem>
<listitem>
<para>crc_ccitt </para>
</listitem>
<listitem>
<para>ppp_async </para>
</listitem>
<listitem>
<para>и конечно ppp_mppe_mppc. </para>
</listitem>
</orderedlist>
<para>А затем запустите modules-config. </para></sect3><sect3><title>Установка пакетов </title>
<para>Это работает для ядер &gt;=2.6.15 </para>
<para>Установка очень проста: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Установка </para>
</entry>
</row>
<row>
<entry>
<para>emerge sys-kernel/gentoo-dev-sourcesemerge ppp для ppp должны быть включены флаги pam,atp,dhcp (не достоверно, у меня работает без atp и dhcp)emerge pptpclient </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3><sect3><title>Настройка клиента</title>
<para>Если все удалось, то теперь вам необходимо сконфигурировать клиента. Вот пример конфигурации /etc/ppp/peers/myvpn: </para>
<para>pty            "/usr/sbin/pptp xxx.xxx.xxx.xxx --nolaunchpppd" #xxx...это адрес сервера</para>
<para>name           myname</para>
<para>remotename     myvpn</para>
<para>lock</para>
<para>dump</para>
<para>noipx</para>
<para>#debug  #включите эту опцию,если хотите видеть отладочные сообщения(пригодиться если ничего не работает)</para>
<para>ipcp-accept-local</para>
<para>ipcp-accept-remote</para>
<para>lcp-echo-failure 4</para>
<para>lcp-echo-interval 30</para>
<para>asyncmap 0</para>
<para>crtscts</para>
<para>require-mppe</para>
<para>refuse-eap</para>
<para>nobsdcomp</para>
<para>nodeflate</para>
<para>proxyarp</para>
<para>ipparam myvpn</para>
<para>Осталось только дозвониться до провайдера: pon myvpn Для вывода отладочных сообщений на этой же консоли введите: pon myvpn debug dump logfd 2 </para>
<para>Теперь необходимо настроить таблицы маршрутизации. Обычно это делается так: route add default dev ppp0 </para></sect3><sect3><title>Настройка с помощью pptpconfig</title>
<para>Для графической (GTK+) настройки PPTP используйте </para>
<orderedlist>
<listitem>
<para>net-dialup/pptpconfig </para>
</listitem>
</orderedlist>
<para>он пока под маской "~x86" </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: установка pptpconfig </para>
</entry>
</row>
<row>
<entry>
<para>ACCEPT_KEYWORDS="~x86" emerge pptpconfig </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Или более правильно в файл /etc/portage/package.keywords добавить следующие строки: </para>
<para>net-dialup/pptpconfig ~x86 </para>
<para/>
<para>dev-php4/php-gtk ~x86 </para>
<para/>
<para>А затем </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: установка pptpconfig </para>
</entry>
</row>
<row>
<entry>
<para>emerge pptpconfig </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Для нормальной сборки необходимы флаги USE=cli pcntl pcre posix session </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Наберите от рута, например в xterm: pptpconfig &amp; </para>
<para>Создайте новое соединение и настройте в соответствии с параметрами указаннымы выше, плюс поправка на рекомендации провайдера. </para>
<para>Для настройки маршрутизации по умолчанию используется вкладка Routing , на ней используйте значение All to tunnel.Выберите созданное соединение и нажмите Start. Все :) </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: если возникнут проблемы с соединением на вкладке "Miscellanyous" в опциях для pppd напишите </para>
<para>noipdefault 50 </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3><sect3><title>Проверяем соединение </title>
<para/>
<para>Теперь все готово. Можно навестить <ulink url="http://ru.gentoo-wiki.com/">Gentoo-Wiki</ulink> ;) </para>
<para>Проверить соединение можно командой: </para>
<para># ifconfig ppp0</para>
<para>ppp0  Link encap:Point-to-Point Protocol</para>
<para>      inet addr:xxx.xxx.xxx.xxx  P-t-P:xxx.xxx.xxx.xxx  Mask:xxx.xxx.xxx.xxx.xxx</para>
<para>      UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1</para>
<para>      RX packets:6 errors:0 dropped:0 overruns:0 frame:0</para>
<para>      TX packets:6 errors:0 dropped:0 overruns:0 carrier:0</para>
<para>      collisions:0 txqueuelen:3</para>
<para>      RX bytes:72 (72.0 b)  TX bytes:78 (78.0 b)</para>
<para>
<ulink url="http://pptpclient.sourceforge.net/howto-gentoo.phtml">Настройка VPN-соединения</ulink> для Gentoo </para>
<para>
<ulink url="http://pptpclient.sourceforge.net/routing.phtml">Настройка маршрутизации</ulink> для VPN-соединений</para>
<para/>
<para>Примечание (JohnBat26): Я использую perl скрипт: pptp-command для работы с VPN. Также можно воспользоваться Webmin. Взято с сайта провайдера <ulink url="http://2com.net/">2Com:</ulink>
</para>
<para>/usr/sbin/pptp-command (появится после установки pptp-client) </para>
<para/>
<para>Надо запустить этот скрипт из под пользователя root.</para>
<para>Затем выбрать:</para>
<para>Setup -&gt; Manage CHAP secrets -&gt; Add a New CHAP secret</para>
<para>Local Name:         ВАШ_ЛОГИН</para>
<para>Remote Name [PPTP]: 2Com</para>
<para>Password:           ВАШ_ПАРОЛЬ</para>
<para/>
<para>Затем выбрать Quit</para>
<para/>
<para>Затем выбрать:</para>
<para>Add a NEW PPTP Tunnel -&gt; Other </para>
<para>Tunnel Name:         2Com</para>
<para>Server IP:           192.168.X.2        (здесь Х - номер вашей сети)</para>
<para>route:               add default ppp0</para>
<para>route:          </para>
<para>Local Name:          ВАШ_ЛОГИН</para>
<para>Remote Name [PPTP]:  2Com</para>
<para>        </para>
<para>Затем выбрать Quit</para>
<para/>
<para>ВНИМАНИЕ!!!!</para>
<para>проверьте наличие файла /etc/ppp/options.pptp </para>
<para>Файл /etc/ppp/options.pptp должен выглядеть след. образом:</para>
<para>lock</para>
<para>noauth</para>
<para>nobsdcomp</para>
<para>nodeflate</para>
<para>novj</para>
<para>novjccomp</para>
<para>nopcomp</para>
<para>noaccomp</para>
<para/>
<para>Для установки VPN соединения надо запустить скрипт /usr/sbin/pptp-command</para>
<para>Затем выбрать:</para>
<para> start -&gt; 2Com</para>
<para/>
<para>Для разрыва VPN соединения надо запустить скрипт /usr/sbin/pptp-command</para>
<para>Затем выбрать:</para>
<para> stop </para>
<para/></sect3></sect2><sect2><title>Через pppoe</title>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Устанавливаем pppoe </para>
</entry>
</row>
<row>
<entry>
<para>emerge pppoe </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>В /etc/conf.d/net прописываем</para>
<para/>
<para>modules=( "ifconfig" )</para>
<para>config_eth0=( "null" )</para>
<para>config_ppp0=( "ppp" )</para>
<para>link_ppp0="eth0"</para>
<para>plugins_ppp0=("pppoe")</para>
<para>username_ppp0='login'</para>
<para>password_ppp0='passwd'</para>
<para>pppd_ppp0=(</para>
<para>       "defaultroute"  # Make this PPP interface the default route</para>
<para>       "usepeerdns"    # Use the DNS settings provided by PPP</para>
<para>       "lcp-echo-interval 15"  # Send a LCP echo every 15 seconds</para>
<para>       "lcp-echo-failure 3"    # Make peer dead after 3 consective</para>
<para>       )</para>
<para>#Если собираемся раздавать интернет в локалку с помощью маскарадинга то нужно добавить такую строчку в IPTABLES:</para>
<para>#iptables -I FORWARD 1 -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu</para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Делаем симлинк </para>
</entry>
</row>
<row>
<entry>
<para>ln -s /etc/init.d/net.lo /etc/init.d/net.ppp0 </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Запускаем </para>
</entry>
</row>
<row>
<entry>
<para>/etc/inet.d/net.ppp0 start </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>Настройка выхода через DIAL-UP</title>
<para/><sect3><title>Подключение модема</title><sect4><title>Последовательный порт</title>
<para>Подключение данного типа модема заключается в физическом "втыкании" в один из COM портов дата кабеля модема, включении модема в розетку и подсоединения к нему телефонной лини. Все это можно прочитать в руководстве к модему. Как извесно последовательные порты в Линукс именуются /dev/ttySx (где x - номер порта, /dev/ttyS0 = COM1 и т.д.) Вам нужно будет знать имя порта на который Вы "повесили свой модем"...скорее всего у вас их два или даже один, поэтому ошибиться здесь довольно сложно. Либо /dev/ttyS0, либо /dev/ttyS1.На этом подключение модема к последовательному порту можно считаль законченым. </para></sect4><sect4><title>Подключение через USB</title>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Linux Kernel Configuration: Установка пакетов </para>
</entry>
</row>
<row>
<entry>
<para>   "USB support" &gt;&gt;</para>
<para>     &lt;*&gt;"USB Modem (CDC ADCM)support" </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>устройство будет называться /dev/ttyACM0 </para></sect4><sect4><title>Win модемы</title>
<para>Для работы Win-модема нужно установить драйвер. Не все win-модемы поддерживаються поэтому Вам остается надеяться на лучшее. За драйверами идем на <ulink url="http://www.linmodems.org/">http://www.linmodems.org/</ulink> Там можно взять отличную софтину под названием scanModem которая опросит Ваш модем и выдаст (или не выдаст) URL откуда взять драйвер. Тянем. Распаковываем. Читаем INSTALL. Ставим. Еще можно почитать эту статью: <ulink url="http://ru.gentoo-wiki.com/Linmodems">linmodems</ulink> </para></sect4><sect4><title>Для всех типов модемов</title>
<para>Для удобства можно создать симлинк вида /dev/modem на соответствующее модему устройство: </para>
<para>ln -s /dev/ttyS0 /dev/modem</para>
<para>и в дальшейшем в настройках использовать устройство ( /dev/modem )...хотя никто и не запрещает использовать устройство модема без симлинка /dev/tyySx </para></sect4><sect4><title>Проверка работоспособности, возможные грабли</title>
<para>После подключения модема и установки всех необходимых драйверов необходимо проверить его работоспособность. Я делаю это так: запускаю утилиту minicom и даю команду AT. Если все в порядке, я в ответ получаю ОК, и не получаю если что-то не так. Если ОК не получен, то самое первое, что нужно сделать - это проверить настройки minicom. Если модем ответил "ОК", можно попробовать позвонить провайдеру:</para>
<para>ATDP 554554 - для пульсового набораилиATDT 554554 - для тонового набора</para>
<para>если модемы соединились и на экране появилось приглашение ввести логин или посыпался мусор в виде фигурных скобок ({{{{{{), можете себя поздравить и переходить к настройке програмного обеспечения, модем у вас работает. </para></sect4></sect3><sect3><title>Настройка программного обеспечения</title><sect4><title>Включение поддержки PPP в ядре</title>
<para>в ядре должны быть включены опции отвечающие за ppp: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Linux Kernel Configuration: Установка пакетов </para>
</entry>
</row>
<row>
<entry>
<para>Device Drivers---------&gt;</para>
<para>  Networking support---------&gt;</para>
<para>     &lt;*&gt;PPP (point-to-point protocol) support</para>
<para>     &lt;*&gt;PPP support for async serial ports</para>
<para>     &lt;*&gt;PPP Deflate compression</para>
<para>     &lt;*&gt;PPP BSD compression</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>Установка необходимых пакетов</title>
<para>во-первых нужно установить пакет который реализует поддержку протокола точка-точка (point-to-point protocol) </para>
<para>emerge ppp</para>
<para>во-вторых нужна звонилка или скрипт для автоматизирования процеса установления соединения. </para>
<para>Обзор звонилок и примеры скриптов смотри ниже...</para></sect4><sect4><title>Настройка соединения с помощью chat-script</title>
<para>Прежде чем писать скрипт, необходимо настроить pppd:в /etc/ppp/pap-secrets пропишем свои Логин/Пароль </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: /etc/ppp/pap-secrets </para>
</entry>
</row>
<row>
<entry>
<para>login * password * </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>где login и password выданые Вашим провайдером Вам логин и пароль соответственно... </para>
<para>в /etc/ppp/options пропишем: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: /etc/ppp/options </para>
</entry>
</row>
<row>
<entry>
<para>nodetachdefaultroutelockcrtscts </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>в /etc/resolv.conf прописываем один или несколько ip-адресов DNS серверов (спросить у провайдера адрес его сервера) </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: /etc/resolv.conf </para>
</entry>
</row>
<row>
<entry>
<para>nameserver xx.xx.xx.xx</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>xx.xx.xx.xx - заменить на ip-адресс DNS сервера </para>
<para>В каталоге /usr/share/doc/ppp-*/scripts лежат примеры скриптов, нам нужны:</para>
<para>ppp-on</para>
<para>ppp-off</para>
<para>ppp-on-dialer</para>
<para>подправляем в них логин, номер телефона, пароль...и вуаля...ppp-on поднимает соединение, ppp-off разрывает его, а ppp-on-dialer -воспомогательный скрипт для осуществления дозвона. </para>
<para>замечу только что для тонового набора используется AT-команда ATDT, а для пульсового - ATDP. </para></sect4><sect4><title>Обзор звонилок</title>
<para>Хорошая звонилка избавит Вас от процеса написания скриптов, вникания в опции pppd, и сделает настройку соединения довольно тривиальной</para>
<para/></sect4><sect4><title>chestnut-dialer</title>
<para>Замечательная звонилка которая к сожалению не поставляется в стандартных портах gentoo. ebuild можна взять <ulink url="http://bugs.gentoo.org/show_bug.cgi?id=123820">здесь</ulink> </para>
<para>Из плюсов </para>
<orderedlist>
<listitem>
<para>Настройка тривиальна </para>
</listitem>
<listitem>
<para>Умеет работать в консоли </para>
</listitem>
<listitem>
<para>Умеет работать в GUI (имеет GTK+ и Qt интерфейсы) </para>
</listitem>
<listitem>
<para>Умеет call back </para>
</listitem>
<listitem>
<para>Нетребовательна к ресурсам </para>
</listitem>
<listitem>
<para>"Местного разлива" - можно пообщаться с автором на родном языке, что для многих немаловажно. </para>
</listitem>
</orderedlist>
<para>Из минусов </para>
<orderedlist>
<listitem>
<para>Не входит в официальное дерево портов </para>
</listitem>
</orderedlist></sect4></sect3><sect3><title>Настройка Call back</title>
<para>pppd должен быть собран с поддержкой CALLBACK. В gentoo это делается по умолчанию, так что вам нужно просто собрать pppd штатными средствами. </para>
<para>Самый простой скрипт для CALLBACK был обнаружен в /usr/doc/ppp-2.4.2/README.cbcp: </para>
<para>#!/bin/sh</para>
<para>pppd debug nodetach /dev/modem 115200 crtscts modem \</para>
<para>callback СВОЙ_НОМЕР name ЛОГИН \</para>
<para>connect 'chat -v "" atz OK atdtНОМЕР_ПРОВАЙДЕРА CONNECT "~--"'</para>
<para>sleep 1</para>
<para>pppd debug nodetach /dev/modem 115200 crtscts modem \</para>
<para>name ЛОГИН defaultroute \</para>
<para>connect 'chat -v RING ATA CONNECT "\c"'</para>
<para>ЛОГИН должен соответствовать записи в /etc/ppp/chap-secrets (/etc/ppp/pap-secrets). В /etc/resolv.conf нужно прописать адрес DNS-сервера (можно добавить опцию usepeerdns в /etc/ppp/options для получения списка DNS серверов от провайдера). </para>
<para>Также можно использовать kppp или chestnut-dialer для установки callback соединения. Настройки их достаточно тривиальны. </para>
<para>Самым сложным может оказаться правильно подобрать строку инициализации для модема. Рекомендуют отключить CallerID. Приведу несколько строк инициализации для примера, но лучше берите документацию от модема (часто идет только на сидироме хотя иногда бывает и в бумажном виде), смотрите что каждая из AT комманд означает и экспериментируйте. </para>
<orderedlist>
<listitem>
<para>Для модемов Lucent: </para>
</listitem>
</orderedlist>
<para>ats0=1s38=0s37=17-v90=0</para>
<para>ats0=1s38=0s37=17-v90=0+vcid=0</para>
<para>значение регистра s37 можна понижать до 14 </para>
<orderedlist>
<listitem>
<para>Для модемов GVC Vector K2D: </para>
</listitem>
</orderedlist>
<para>ATS0=1+VCID=0&amp;U1</para>
<para>Я лично подобрав подходящую строку инициализации, сохранил ее прямо в профиле модема... </para></sect3></sect2><sect2><title>Настройка выхода через GPRS</title>
<para>Если вы подключаетесь через GPRS с помощью звонилки (kppp, chestnut-dialer), может быть важным использование опции pppd - noipdefault !!! </para><sect3><title>Требуемая аппаратура</title>
<para>Для соединения по GPRS потребуется следующее: </para>
<orderedlist>
<listitem>
<para>Мобильный телефон, поддерживающий технологию GPRS </para>
</listitem>
<listitem>
<para>Кабель COM или USB для подключения к компьютеру ("data-кабель") либо IrDA-интерфейс. </para>
</listitem>
</orderedlist></sect3><sect3><title>Подключение с помощью USB-кабеля</title>
<para>Убедитесь, что в конфигурационном файле Вашего ядра присутствуют следующие опции: </para>
<para>"Device Drivers" &gt;&gt;</para>
<para>  [*]"Networking support" &gt;&gt;</para>
<para>    [*] "Network device support"</para>
<para>    &lt;M&gt; "PPP (point-to-point protocol) support"</para>
<para>    &lt;M&gt; "PPP support for async serial ports"</para>
<para>    &lt;M&gt; "PPP support for sync tty ports"</para>
<para>    &lt;M&gt; "PPP Deflate compression"</para>
<para>    &lt;M&gt; "PPP BSD-Compress compression"</para>
<para>Для data-кабелей на основе микросхем Profilic 2303 (используются для подключения большинства телефонов, в том числе Siemens, Motorola, Nokia и др.) проверьте наличие: </para>
<para>  "USB support" &gt;&gt;</para>
<para>    "USB Serial Converter support" &gt;&gt;</para>
<para>      &lt;M&gt; "USB Prolific 2303 Single Port Serial Driver"</para>
<para>После компиляции ядра проверьте модуль: </para>
<para>modprobe pl2303</para>
<para>Теперь кабель представлен в системе как устройство /dev/usb/tts/0 (возможно /dev/ttyUSB0), которое может быть использовано в качестве обычного модема. </para>
<para>Для телефонов Motorola, которые подключаются кабелем mini-USB (например С380,С390) достаточно включить </para>
<para>   "USB support" &gt;&gt;</para>
<para>     &lt;*&gt;"USB Modem (CDC ADCM)support" </para>
<para>устройство будет называться /dev/ttyACM0 </para></sect3><sect3><title>Подключение с помощью COM-кабеля</title>
<para>Тут все просто, "втыкаем" и используем...как любой модем на последовательном порту. </para></sect3><sect3><title>Подключение через Bluetooth</title>
<para>Предполагается что вы уже настроили соединение телефона с компьютером через bluetooth, например по этой статье :<ulink url="http://ru.gentoo-wiki.com/Работа_с_мобильными_телефонами_через_bluetooth">Работа с мобильными телефонами через bluetooth</ulink>. Итак устройства сопряжены. Теперь нам необходимо подключить телефон как модем. Для этого мы выполним привязку bluetooth-сервиса 1(то есть Dial-Up) к устройству /dev/rfcomm0.Начнем по порядку. </para>
<orderedlist>
<listitem>
<para>Поищем телефон </para>
</listitem>
</orderedlist>
<para>#hcitool scan</para>
<para>Scanning ...</para>
<para>       00:60:57:D5:3B:BE       Gtbear</para>
<orderedlist>
<listitem>
<para>Подключим его к rfcomm0 </para>
</listitem>
</orderedlist>
<para>#rfcomm bind 0 00:60:57:D5:3B:BE 1</para>
<para>Этой командой мы подключили в rfcomm0 канал 1. Теперь телефон готов к работе. Осталось настроить соединения в конфигах pppd. </para>
<orderedlist>
<listitem>
<para>Создадим файл /etc/ppp/peers/gprs.В него запишем следующее: </para>
</listitem>
</orderedlist>
<para>lcp-echo-failure 0</para>
<para>lcp-echo-interval 0</para>
<para>/dev/rfcomm0</para>
<para>connect /etc/ppp/peers/suct-connect # Это скрипт соединения,такое имя выбрано в честь моего оператора:</para>
<para>115200                              #Южно-Уральский Сотовый Телефон :)</para>
<para>crtscts</para>
<para>local</para>
<para>ipcp-accept-local</para>
<para>noauth</para>
<para>usepeerdns</para>
<para>user suct</para>
<para>defaultroute</para>
<para>noipdefault</para>
<orderedlist>
<listitem>
<para>Теперь сделаем скрипт соединения: </para>
</listitem>
</orderedlist>
<para>#!/bin/bash</para>
<para>exec chat -vS  \</para>
<para>'' \rAT \</para>
<para>TIMEOUT 12 \</para>
<para>OK ATH \</para>
<para>OK ATE1 \</para>
<para>OK 'AT+CGDCONT=1,"IP","internet.usi.ru"' \</para>
<para>OK ATD*99***1# \</para>
<para>TIMEOUT 22 \</para>
<para>SAY "\nWaiting for connect...\n" \</para>
<para>CONNECT "" \</para>
<para>SAY "\nGPRS connected.Enjoy.."</para>
<orderedlist>
<listitem>
<para>В принципе все готово. Для запуска соединения можно использовать команду pppd call gprs nodetach </para>
</listitem>
</orderedlist></sect3><sect3><title>Подключение через IrDA</title>
<para>Пакеты: </para>
<para>emerge irda-utils</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Linux Kernel Configuration: Ядро 2.6 </para>
</entry>
</row>
<row>
<entry>
<para>Device Drivers ---&gt;</para>
<para>[*] Networking support</para>
<para>  &lt;*&gt; IrDA (infrared) subsystem support ---&gt;</para>
<para>  &lt;*&gt; IrCOMM protocol</para>
<para>  Infrared-port device drivers ---&gt;</para>
<para>    &lt;*&gt; IrDA USB dongles</para>
<para>    &lt;*&gt; SigmaTel STIr4200 bridge (EXPERIMENTAL)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Когда ядро будет готово можно запускать команду: </para>
<para>irattach irda0 -s</para>
<para>Теперь если поднести телефон к инфракрасному порту он должен определиться... Дальше можно поднимать ppp как для обычного модема</para></sect3></sect2><sect2><title>Настройка выхода через CDMA (SKYLINK)</title><sect3><title>Подключение аппаратуры</title>
<orderedlist>
<listitem>
<para>
<ulink url="http://ru.gentoo-wiki.com/Работа_с_модемом_AnyDATA_ADU-E100A_%28SKYLINK%29">Модем AnyDATA ADU-E100A</ulink> </para>
</listitem>
</orderedlist></sect3><sect3><title>Настройка программного обеспечения</title>
<orderedlist>
<listitem>
<para>Устанавливаем пакет который реализует поддержку протокола точка-точка (point-to-point protocol) </para>
</listitem>
</orderedlist>
<para># emerge ppp </para>
<orderedlist>
<listitem>
<para>Редактируем файл /etc/ppp/chap-secrets </para>
</listitem>
</orderedlist>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: /etc/ppp/chap-secrets </para>
</entry>
</row>
<row>
<entry>
<para># Secrets for authentication using CHAP# client server secret IPaddresses"mobile" * "internet" * </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<orderedlist>
<listitem>
<para>Создаем файл /etc/ppp/peers/cdma </para>
</listitem>
</orderedlist>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: /etc/ppp/peers/cdma </para>
</entry>
</row>
<row>
<entry>
<para>debug/dev/ttyUSB0921600noipdefaultdefaultrouteipcp-accept-locallcp-echo-interval 60lcp-echo-failure 5usepeerdnsnopcompnoauthnoaccompnodetachuser "mobile"connect "/usr/sbin/chat -s -S -V -t 5 -f /etc/ppp/cdma.chat" </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<orderedlist>
<listitem>
<para>Создаем файл /etc/ppp/cdma.chat </para>
</listitem>
</orderedlist>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: /etc/ppp/cdma.chat </para>
</entry>
</row>
<row>
<entry>
<para>'' '' # "Это не кавычки, а два знака, который на клавиатуре слева от единички'' 'ATZ' # "Это не кавычки, а два знака, который на клавиатуре слева от единички'OK' 'ATI''OK' 'ATDT#777''CONNECT' 'ATO' </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<orderedlist>
<listitem>
<para>Пробуем </para>
</listitem>
</orderedlist>
<para># pon cdma </para>
<para/></sect3></sect2></sect1><sect1><title>Настройка спутникового интернета в Gentoo</title>Настройка спутникового интернета в Gentoo<para>   Автор: <ulink url="mailto:tuxmaster@list.ru?subject=По%20поводу%20Вашей%20статьи%20о%20настройке%20спутникового%20интернета">tuxmaster</ulink>
</para>
<para>   С версии: 1.5</para>
<para/><sect2><title>Введение</title>
<para>Спутниковый Интернет - это экономичный способ высокоскоростного подключения к интернету. Спутниковое соединение обеспечивает столь же быструю скорость, как и выделенная линия или DSL - до нескольких мегабит в секунду (это примерно в 100 раз быстрее обычного модема). Спутниковая связь очень надежна, и вопреки расхожему мнению, отлично работает при любой погоде - нужно просто использовать антенну достаточного диаметра.</para>
<para/>
<para>Услугами спутникового Интернет можно пользоваться в любой географической точке, расположенной в обширной зоне обслуживания спутника. Если изменится место Вашего проживания, Вы всегда сможете перенести свой "спутниковый канал". Вам не придется снова тратить деньги на высокоскоростное подключение к интернету. </para><sect3><title>Как работает спутниковый Интернет? </title>Как работает спутниковый Интернет? <para>Передача данных через спутник носит односторонний характер (асимметричный доступ): Вы можете только получать данные. Для передачи Ваших запросов на какую-либо информацию в Сети, а также исходящих от Вас данных (например, Ваших электронных писем) нужно использовать любой вид наземного соединения. Вся входящая к Вам информация будет поступать через высокоскоростной спутниковый канал.</para></sect3><sect3><title>Оборудование</title>
<para>Для приема информации со спутника используется комплект оборудования, состоящий из спутниковой антенны, конвертера и dvb-платы. Никаких разрешительных документов на установку принимающей антенны не требуется. В дальнейшем мы предполагаем, что Ваша спутниковая антенна уже установлена и настроена.</para>
<para/></sect3></sect2><sect2><title>Подготовка Gentoo к использованию спутникового Интернета</title><sect3><title>Настройка ядра</title>
<para>Перейдите в каталог с исходными кодами ядра и введите команду make menuconfig. Этой командой Вы вызовете конфигурационное меню, использующее ncurses.</para>
<para/>
<para>Листинг 1: Вызов конфигурационного меню</para>
<para># cd /usr/src/linux</para>
<para># make menuconfig</para>
<para/>
<para>Перед Вами появятся несколько секций настроек. Прежде всего необходимо включить поддержку загружаемых модулей (если Вы использовали genkernel этот шаг можно пропустить).</para>
<para/>
<para>Листинг 2: Включение поддержки модулей</para>
<para>Loadable module support ---&gt;</para>
<para>        [*] Enable loadable module support</para>
<para>        [*] Automatic kernel module loading</para>
<para/>
<para>Включите поддержку Вашей DVB-платы.</para>
<para/>
<para>Листинг 3: Включение поддержки DVB:</para>
<para>Device Drivers ---&gt;</para>
<para>        Multimedia devices ---&gt;</para>
<para>                &lt;M&gt; DVB for Linux</para>
<para>                [*] Load and attach frontends modules as needed </para>
<para>                [*] DVB/ATSC adapters  ---&gt; </para>
<para>                        &lt;M&gt; Ваша_DVB-плата</para>
<para/>
<para>Теперь Вы можете приступить к компиляции ядра. Если Вы неуверенны в своих силах обратитесь к соответствующим разделам руководства.</para></sect3><sect3><title>Установка пакета утилит</title>
<para>Для проверки работоспособности оборудования, настройки, создания сетевого интерфейса, и т.п. Вам потребуются определенные утилиты, входящие в состав linuxtv-dvb-apps</para>
<para/>
<para>Листинг 4: Установка пакета утилит</para>
<para># emerge linuxtv-dvb-apps</para></sect3><sect3><title>Настройка параметров системы</title></sect3><sect3><title>dvb_core</title>
<para>По умолчанию после 5 секунд простоя  DVB-плата отключается, при использовании ядер 2.6.23 и старше эта проблема решается загрузкой модуля dvb_core с параметром dvb_shutdown_timeout=0 </para>
<para/>
<para>Листинг 5: Установка параметров модуля</para>
<para># echo 'alias dvb_core dvb_shutdown_timeout=0' &gt;&gt; /etc/modules.d/aliases</para>
<para/>
<para>К сожалению, в ядрах 2.6.24 такой способ не работает.</para></sect3><sect3><title>/etc/channels.conf</title>/etc/channels.conf<para>В файле channels.conf хранятся параметры настройки dvb-карты на спутник. Для дальнейшей работы нам нужны значения частоты, скорости потока и поляризации, узнать их можно на сайте провайдера.</para>
<para/>
<para>Листинг 6: Создаем /etc/channels.conf</para>
<para># nano -w /etc/channels.conf</para>
<para/>
<para>Теперь заполним channels.conf  параметрами транспондеров. Ниже приведен пример channels.conf для провайдера Raduga с подробными комментариями.</para>
<para/>
<para>Листинг 7: channels.conf для абонетов Raduga</para>
<para># Каждая строка описывает параметры отдельного транспондера в формате:</para>
<para># Name:Frequency:Polarisation:diseqc:Symbolrate:VPID:APID:SID</para>
<para># где</para>
<para># Name — Желаемое название транспондера</para>
<para># Frequency — Частота транспондера в мегагерцах (МГц, MHz)</para>
<para># Polarisation — Поляризация, возможные значения  </para>
<para>#    v-вертикальная (левая круговая), h-горизонтальная (правая круговая)</para>
<para># diseqc — Номер входа diseqc. Если у Вас один конвертер выберите 0.</para>
<para># Symbolrate — Символьная скорость в килосимволов/сек (Ksps)</para>
<para/>
<para>#  Express AM22 (53 East)</para>
<para>1:11096:v:0:6164:0:0:0</para>
<para/>
<para>#  Express AM1 (40 East)</para>
<para>2:11082:v:0:5064:0:0:0</para>
<para/>
<para>#  Intelsat 904 (60 East)</para>
<para>3:11595:v:0:29270:0:0:0</para>
<para>4:10983:v:0:3819:0:0:0</para>
<para/>
<para>#  Yamal 201 Ku (90 East)</para>
<para>5:11672:v:0:18200:0:0:0</para>
<para/>
<para>#  Yamal 201 C (90 East)</para>
<para>6:3980:h:0:38000:0:0:0</para>
<para/>
<para>#  ABS 1 (75 East)</para>
<para>7:12609:v:0:22000:0:0:0</para>
<para/>
<para>#  Sirius 4 (5 East)</para>
<para>8:12680:v:0:9404:0:0:0</para>
<para/></sect3><sect3><title>Сетевой интерфейс</title>Сетевой интерфейс<para>Так как при каждом включении или перезагрузке необходимо создавать dvb-сетевой интерфейс, рекомендуем создать скрипт, выполняющий эти действия автоматически.</para>
<para/>
<para> Листинг 8: Создаем /bin/satup</para>
<para># nano -w /bin/satup</para>
<para/>
<para/>
<para> Листинг 9: Вариант /bin/satup</para>
<para>#!/bin/bash</para>
<para/>
<para># Параметры подписки </para>
<para># Ваш PID</para>
<para>PID=0x1234 </para>
<para/>
<para># IP адрес подписки</para>
<para>IP_ADDR=000.111.222.333</para>
<para/>
<para># MAC адрес платы, на которую оформлена подписка</para>
<para>MAC_ADDR=00:11:22:33:44:55 </para>
<para/>
<para># Поднимаем сетевой интерфейс </para>
<para>dvbnet -p $PID </para>
<para>/sbin/ifconfig dvb0_0 $IP_ADDR </para>
<para>/sbin/ifconfig dvb0_0 hw ether $MAC_ADDR </para>
<para/>
<para># Отключаем spoof-фильтрацию</para>
<para>echo 0 &gt; /proc/sys/net/ipv4/conf/dvb0_0/rp_filter</para>
<para/>
<para/>
<para> Листинг 10: Добавление /bin/satup в автозапуск</para>
<para># echo '/bin/satup' &gt;&gt; /etc/conf.d/local.start</para>
<para/></sect3><sect3><title>Сетевой фильтр</title>Сетевой фильтр<para>Общий принцип, не зависящий от провайдера: необходимо разрешить входящий трафика с DVB-платы на порты ускорителя и исходящий на сервер провайдера.</para>
<para/>
<para> Листинг 11: Пример настройки iptables для ускорителя Sprint (спутник Yamal-90 Ku)</para>
<para># iptables -A INPUT -p udp -m udp -i dvb0_0 --dport 8093 --sport 1024:65535 -j ACCEPT</para>
<para># iptables -A OUTPUT -p udp -m udp -m multiport -d 80.81.208.66 --dports 8093,8095 --sport 1024:65535 -j ACCEPT</para>
<para># /etc/init.d/iptables save</para></sect3></sect2><sect2><title>Проверка работоспособности</title>Проверка работоспособности<para>Запустите в терминале szap с параметрами 'n номер_транспондера_в_файле_channels.conf', 'x' — прекратить работу после настройки и 'c путь_к_файлу_channels.conf'</para>
<para/>
<para> Листинг 12: Проверка параметров трансподера Ku-диапазон</para>
<para>~ szap -n 5 -x -c /etc/channels.conf</para>
<para>reading channels from file '/etc/channels.conf' </para>
<para>zapping to 5 '5': </para>
<para>sat 0, frequency = 11671 MHz V, symbolrate 18200000, vpid = 0x0000, apid = 0x0000 </para>
<para>using '/dev/dvb/adapter0/frontend0' and '/dev/dvb/adapter0/demux0' </para>
<para>status 00 | signal d689 | snr 9a83 | ber 00000117 | unc 00000000 | </para>
<para>status 1f | signal e625 | snr d587 | ber 00000088 | unc 00000000 | FE_HAS_LOCK </para>
<para/>
<para> Листинг 13: Проверка параметров трансподера C-диапазон</para>
<para>~ szap -n 6 -x -l C-BAND -c /etc/channels.conf</para>
<para>reading channels from file '/etc/channels.conf' </para>
<para>zapping to 6 '6': </para>
<para>sat 0, frequency = 3980 MHz H, symbolrate 38000000, vpid = 0x0000, apid = 0x0000 </para>
<para>using '/dev/dvb/adapter0/frontend0' and '/dev/dvb/adapter0/demux0' </para>
<para>status 00 | signal a367 | snr 7543 | ber 00000129 | unc 00000000 | </para>
<para>status 1f | signal ea32 | snr e259 | ber 00000052 | unc 00000000 | FE_HAS_LOCK </para>
<para/>
<para>Ключевые слова: status 1f и  FE_HAS_LOCK говорят о том, что настройка завершилась успешно. Теперь проверим, поддерживает ли Ваше ядро параметр  dvb_shutdown_timeout=0</para>
<para/>
<para> Листинг 14: Ядро поддерживает  dvb_shutdown_timeout=0</para>
<para>~ femon</para>
<para>using '/dev/dvb/adapter0/frontend0' </para>
<para>FE: ST STV0299 DVB-S (SAT) </para>
<para>status 1f | signal e5df | snr d500 | ber 00000000 | unc 00000000 | FE_HAS_LOCK </para>
<para>status 1f | signal e879 | snr d518 | ber 00000000 | unc 00000000 | FE_HAS_LOCK </para>
<para>status 1f | signal e8a0 | snr d527 | ber 00000000 | unc 00000000 | FE_HAS_LOCK </para>
<para/>
<para> Листинг 15: Ядро не поддерживает  dvb_shutdown_timeout=0</para>
<para>~ femon</para>
<para>using '/dev/dvb/adapter0/frontend0' </para>
<para>FE: ST STV0299 DVB-S (SAT) </para>
<para>status 03 | signal 9f5e | snr 0000 | ber 00008080 | unc 00000000 | </para>
<para>status 03 | signal 9f5e | snr 0000 | ber 00008080 | unc 00000000 | </para>
<para>status 03 | signal 9f5e | snr 0000 | ber 00008080 | unc 00000000 | </para>
<para/>
<para>Во втором случае перед подключением к Интернету необходимо запустить szap без параметра 'х' (при этом окно терминала закрывать нельзя). Добавьте эту команду в скрипт запуска ускорителя спутникового интернета.</para>
<para/>
<para> Листинг 16: Запуск szap в фоновом режиме (пример для Ku-диапазона спутника Yamal-90)</para>
<para>~ szap -n 5 -c /etc/channels.conf &gt;&gt; null &amp;</para>
<para/>
<para>Теперь, когда dvb-плата настроена, проверим принимает ли dvb-плата поток</para>
<para/>
<para> Листинг 17: Проверка обработки dvb-платой транспортного потока</para>
<para>~ dvbtraffic</para>
<para>1039    53 p/s     9 kb/s    80 kbit </para>
<para>103a     7 p/s     1 kb/s    11 kbit </para>
<para>103b   271 p/s    49 kb/s   408 kbit </para>
<para>103c   102 p/s    18 kb/s   154 kbit </para>
<para>103d   713 p/s   130 kb/s  1073 kbit </para>
<para>104a  1190 p/s   218 kb/s  1790 kbit </para>
<para>104b   835 p/s   153 kb/s  1256 kbit </para>
<para>104c   635 p/s   116 kb/s   955 kbit </para>
<para>104d   843 p/s   154 kb/s  1267 kbit </para>
<para>104e  1187 p/s   217 kb/s  1786 kbit </para>
<para>104f   962 p/s   176 kb/s  1447 kbit </para>
<para>1051   167 p/s    30 kb/s   252 kbit </para>
<para>1057    91 p/s    16 kb/s   137 kbit </para>
<para>1101  4485 p/s   823 kb/s  6746 kbit </para>
<para>1105   195 p/s    35 kb/s   293 kbit </para>
<para>2000 14404 p/s  2644 kb/s 21664 kbit </para>
<para>-PID—FREQ-----BANDWIDTH-BANDWIDTH- </para>
<para/>
<para/>
<para>и функционирование сетевого интерфейса</para>
<para/>
<para> Листинг 18: Проверка сетевого интерфейса</para>
<para># tcpdump -c 3 -qn -i dvb0_0 </para>
<para>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode </para>
<para>listening on dvb0_0, link-type EN10MB (Ethernet), capture size 96 bytes </para>
<para>16:55:06.196218 IP 10.10.10.1 &gt; 10.252.43.127: udp </para>
<para>16:55:06.196802 IP 10.10.10.1.52632 &gt; 10.252.43.246.8093: UDP, length 884 </para>
<para>16:55:06.196871 IP 10.10.10.1.52632 &gt; 10.252.43.246.8093: UDP, length 884 </para>
<para>3 packets captured </para>
<para>3 packets received by filter </para>
<para>0 packets dropped by kernel </para>
<para/>
<para/>
<para/></sect2><sect2><title>Использование спутникового канала</title>Использование спутникового канала<para>Установите соединение с наземным провайдером, запустите ускоритель и пользуйтесь недорогим и качественным интернетом со спутника :)</para>
<para/>
<para/>
<para> Листинг 19: Пример скрипта для запуска ускорителя Sprint</para>
<para>#!/bin/bash</para>
<para>szap -n 5 -c /etc/channels.conf &gt;&gt; null &amp;</para>
<para>cd /home/sprint</para>
<para>/home/sprint/sprint</para>
<para/></sect2></sect1><sect1><title>Соединение нескольких офисов в одну сеть с помощью OpenVPN</title>Соединение нескольких офисов в одну сеть с помощью OpenVPN<para/>
<para>   Ссылка на оригинал: <ulink url="http://ylsoftware.com/?action=news&amp;na=viewfull&amp;news=393">http://ylsoftware.com/</ulink>
</para>
<para>   Автор: MooSE (<ulink url="mailto:moose@home.ylsoftware.com?subject=По%20поводу%20вашей%20статьи%20о%20OpenVPN">moose@home.ylsoftware.com</ulink>)</para>
<para>   С версии: 1.4</para>
<para>   Дата: 19.01.2008</para>
<para/>
<para>Итак. Допустим что у некоторой фирмы есть несколько офисов в различных точках города (возможно даже земного шара - не суть важно) и нам нужно обеспечить максимально простой способ взаимодействия локальных сетей различных офисов между собой. Неплохим решением этой задачи будет объединение этих сетей посредством OpenVPN.</para>
<para>Итак. Уточним начальные условия:</para>
<para/>
<para>Центральный офис (office-0):</para>
<para>Сервер под управлением Ubuntu Linux. Три сетевых интерфейса: eth0, eth1, eth2. Конфигурация следующая:</para>
<orderedlist>
<listitem>
<para>eth0: внешний интерфейс, имеющий реальный ip-адрес a.b.c.d. </para>
</listitem>
<listitem>
<para>eth1: первая локальная сеть: 192.168.1.1/24. </para>
</listitem>
<listitem>
<para>eth2: вторая локальная сеть: 192.168.2.1/24. </para>
</listitem>
</orderedlist>
<para>Офис 1 (office-1):</para>
<para>Под управлением Mandriva Linux. Два интерфейса:</para>
<orderedlist>
<listitem>
<para>eth0: внешний интерфейс, имеющий доступ к адресу a.b.c.d (каким либо образом). </para>
</listitem>
<listitem>
<para>eth1: локальная сеть: 192.168.3.1/24. </para>
</listitem>
</orderedlist>
<para>Офис 2 (office-2)</para>
<para>Сервер полностью аналогичен серверу в первом офисе, за исключением eth1: там адрес 192.168.4.1/24.</para>
<para/>
<para>Объединять мы будем сервера в виртуальную сеть 192.168.10.0/24. Поэтому на всех серверах должен быть настроен NAT не только для "своих" сетей, но и для сети 192.168.10.0/24.</para>
<para>Будем считать что всё это уже сделано. Приступаем к установке и настройке OpenVPN-сервера:</para>
<para>apt-get install openvpn</para>
<para>Создаём файл конфигурации /etc/openvpn/server.conf следующего содержания:</para>
<para>mode server</para>
<para>tls-server</para>
<para>daemon</para>
<para/>
<para>ifconfig 192.168.10.1 255.255.255.0</para>
<para/>
<para>port 1194</para>
<para>proto tcp-server</para>
<para>dev tap</para>
<para>ca /etc/openvpn/keys/ca.crt</para>
<para>cert /etc/openvpn/keys/office-0.crt</para>
<para>key /etc/openvpn/keys/office-0.key</para>
<para>dh /etc/openvpn/keys/dh1024.pem</para>
<para>client-config-dir /etc/openvpn/ccd</para>
<para>push "route 192.168.10.0 255.255.255.0 192.168.10.1"</para>
<para>keepalive 10 120</para>
<para>comp-lzo</para>
<para>persist-key</para>
<para>persist-tun</para>
<para>verb 3</para>
<para>log-append /var/log/openvpn.log</para>
<para>Создаём каталог, в котором будут хранится индивидуальные настройки клиентов:</para>
<para>mkdir /etc/openvpn/ccd</para>
<para>Копируем скрипты для генерации ключей и создаём ключи:</para>
<para>cp -vR /usr/share/doc/openvpn/examples/easy-rsa/2.0 /etc/openvpn/</para>
<para>mkdir /etc/openvpn/2.0/keys</para>
<para>ln -s /etc/openvpn/2.0/keys /etc/openvpn/keys</para>
<para>cd /etc/openvpn/2.0/keys</para>
<para>source ./vars</para>
<para>./clean-all</para>
<para>./build-ca</para>
<para>./build-dh</para>
<para/>
<para># Ключ для центрального офиса</para>
<para>./build-key office-0</para>
<para/>
<para># Ключ для первого офиса</para>
<para>./build-key office-1</para>
<para/>
<para># Ключ для второго офиса</para>
<para>./build-key office-2</para>
<para>В ходе выполнения этих команд будет задан ряд вопрос. Ответы на них вобщем-то очевидны, поэтому заострять на них внимание не будем.</para>
<para>Далее создаём файлы /etc/openvpn/ccd/office-1 и /etc/openvpn/ccd/office-2. Содержание первого:</para>
<para># приcваиваем ip-адрес</para>
<para>ifconfig-push 192.168.10.101 255.255.255.0</para>
<para/>
<para># роутинг на сети центрального офиса</para>
<para>push "route 192.168.1.0 255.255.255.0 192.168.10.1"</para>
<para>push "route 192.168.2.0 255.255.255.0 192.168.10.1"</para>
<para/>
<para># роутинг на сеть второго офиса</para>
<para>push "route 192.168.4.0 255.255.255.0 192.168.10.102"</para>
<para>Содержание второго:</para>
<para># присваиваем ip-адрес</para>
<para>ifconfig-push 192.168.10.102 255.255.255.0</para>
<para/>
<para># роутинг на сети центрального офиса</para>
<para>push "route 192.168.1.0 255.255.255.0 192.168.10.1"</para>
<para>push "route 192.168.2.0 255.255.255.0 192.168.10.1"</para>
<para/>
<para># роутинг на сеть первого офиса</para>
<para>push "route 192.168.3.0 255.255.255.0 192.168.10.101"</para>
<para>На этом настрока сервера завершена. Перезапускаем его:</para>
<para>/etc/init.d/openvpn restart</para>
<para>Убеждаемся что поднялся интерфейс tap0:</para>
<para>ifconfig tap0</para>
<para>Переходим к настройке офисов. Рассмотрим только один. Второй будет сделан аналогично, за исключением имён сертификатов.</para>
<para>Устанавливаем openvpn:</para>
<para>urpmi openvpn</para>
<para>mkdir /etc/openvpn/keys</para>
<para>Создаём файл конфигурации /etc/openvpn/client.conf:</para>
<para>client</para>
<para>dev tap</para>
<para>proto tcp</para>
<para/>
<para># адрес сервера в центрально офисе</para>
<para>remote a.b.c.d 1194</para>
<para>resolv-retry infinite</para>
<para>nobind</para>
<para>persist-key</para>
<para>persist-tun</para>
<para>comp-lzo</para>
<para>ns-cert-type server</para>
<para>ca ca.crt</para>
<para>cert /etc/openvpn/keys/office-1.crt</para>
<para>key /etc/openvpn/keys/office-1.key</para>
<para>log-append /var/log/openvpn.log</para>
<para>Далее нам нужно поместить файлы office-1.* и ca.crt из каталога /etc/openvpn/keys сервера в каталог /etc/openvpn/keys клиента.</para>
<para>После этого запускаем сервис:</para>
<para>chkconfig openvpn on</para>
<para>service openvpn start</para>
<para>Убеждаемся что поднялся интерфейс:</para>
<para>ifconfig tap0</para>
<para>После настройки обоих офисов можно убедиться в работе сети попробовав пинговать из одного офиса какой-нибудь компьютер, расположенный в другом офисе.</para>
<para>На этом всё. Более подробную информацию можно найти в документации по openvpn.</para></sect1><sect1><title>Управление питанием компьютера</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/en/power-management-guide.xml">http://www.gentoo.org/doc/en/power-management-guide.xml</ulink>
</para>
<para>Автор: <ulink url="mailto:earthwings@gentoo.org">Dennis Nienhüser</ulink>
</para>
<para>Перевод: <ulink url="http://iandmyfriendgentoo.blogspot.com/2007/12/blog-post_12.html">Управление питанием компьютера</ulink>
</para>
<para>Перевод: vah.</para>
<para>С версии: 1.5.</para>
<para>Дата оригинала:  21.01.2008</para>
<para>Дата перевода: 08.02.2008</para>
<para/>
<para>Перевод статьи <ulink url="http://www.gentoo.org/doc/en/power-management-guide.xml">Power Management Guide</ulink>. В статье рассматриваются способы увеличения жизни ноутбука от батареи. Статья ориентирована на Gentoo, но думаю, сделав замену emerge на apt-get install/rpm -Uvh/.. и обладая общими знаниями о runlevels в вашей системе, можно всё написанное перенести и на другие дистрибутивы.</para><sect2><title>1. Введение</title>
<para>Ёмкость и время жизни батареи ноутбуков были значительно увеличены в последние годы. Тем не менее, современные процессоры потребляют намного больше энергии, чем более старые, и каждое новое поколение ноутбуков комплектуется всё более и более жадными до энергии устройствами. Поэтому Управление Питанием становится даже более важным, чем прежде. Увеличение времени автономной жизни совсем не обязательно влечёт покупку ещё одной батареи - многое можно выжать, применяя грамотные установки Управления Питанием.</para><sect3><title>Краткий обзор</title>
<para>Пожалуйста, учтите, что данное руководство описывает настройку Управления Питанием только для ноутбуков. Хотя некоторые разделы и могут быть также применимы к серверам, другие - не только не применимы, но могут даже нанести урон. Не стоит делать что-либо без понимания того, что вы делаете.</para>
<para>Так как это руководство стало достаточно длинным, ниже приведён краткий обзор, который поможет вам не запутаться среди стольких букв. </para>
<para>В главе <link linkend="">Подготовка</link> говорится о некоторых общих действиях, которые необходимо выполнить перед настройкой отдельных устройств. Это включает настройку BIOS, конфигурацию ядра и некоторые изменения пользовательских настроек. Следующие три главы сфокусированы на устройствах, обычно потребляющих больше всего энергии - процессоре, дисплее и жёстком диске. Каждое из них может быть настроены независимо. Глава <link linkend="">Управление питанием ЦПУ</link> показывает, как изменять частоту процессора для сохранения максимального количества энергии, не теряя слишком много в производительности. Несколько способов отучить ваш жёсткий диск работать напрасно (тем самым заодно уменьшив шум) можно найти в <link linkend="">Управление питанием диска</link>. Некоторые заметки о графических картах, беспроводных сетях и USB завершают раздел об устройствах главой <link linkend="">Управление питанием других устройств</link>. Отдельная глава отведена (довольно не стабильным) <link linkend="">Состояния спячки</link> (sleep states). Последний раздел, <link linkend="">Устранение неполадок</link>, содержит список самых распространённых проблем.</para></sect3><sect3><title>Покомпонентное распределение энергии</title>
<para>
<!--<inlinegraphic fileref="embedded:Графический объект14" width="6.411cm" depth="4.077cm"/>
--><anchor id="energy-budget"/> </para>
<para>Почти каждый элемент может находиться в различных положениях - выключен, спит, ждёт, активен - потребляя различное количество энергии. Наибольшие части отъедаются экраном, процессором, чипсетом и жёсткими дисками. Часто устройство может быть переведено в ОС-независимый режим управления питанием через BIOS, но интеллектуальные средства операционной системы, реагирующие на ситуацию, могут принести намного больше. </para></sect3></sect2><sect2><title>
<anchor id="prerequisite"/>2. Подготовка</title>
<para>Перед детальным обсуждением настройки Управления Питанием для отдельных устройств, стоит убедиться, что следующие требования выполнены. После проверки установок BIOS, стоит включить некоторые опции в ядре (если коротко, то это - ACPI, режимы спячки и регулирование частоты ЦП). Так как сохранение энергии в большинстве случаев влечёт потери производительности, то его стоит применять только при работе от батарей. Для этого разграничения очень полезен отдельный уровень запуска (runlevel) battery. </para><sect3><title>BIOS</title>
<para>Для начала стоит взглянуть на настройки управления питанием в BIOS. Наилучшее решение - совмещать возможности BIOS и операционной системы. Но чтобы быть уверенными, что BIOS не будет конфликтовать с операционной системой, лучше пока отключить бОльшую часть его настроек по управлению питанием. Не забудьте перепроверить настройки BIOS после конфигурации чего-либо ещё. </para></sect3><sect3><title>Настройка USE-флагов</title>
<para>Убедитесь, что acpi USE-флаг установлен в вашем /etc/make.conf. Так же в вашей системе могут быть уместны флаги apm, lm_sensors, nforce2, nvidia, pmu. Подробно об этих флагах смотрите в /usr/portage/profiles/use*.desc. Если вы забыли выставить один из этих флагов, вы можете перекомпилировать необходимые пакеты командой emerge --deep --update --newuse world, подробности в man emerge. </para></sect3><sect3><title>Конфигурация ядра</title>
<para>Работа над поддержкой ACPI (Advanced Configuration and Power Interface) в ядре всё ещё не закончена. Используя последнее ядро, вы получаете самую свежую её версию. </para>
<para>В портэжах (portage) содержится несколько версий ядра. Я бы рекомендовал использовать gentoo-sources или suspend2-sources. Последнее содержит патчи для программной остановки 2 (Software Suspend 2), смотрите главу о <link linkend="">режимах спячки</link> для более подробной информации. Во время конфигурации ядра включите хотя бы эти опции: </para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 2.1: Минимальные настройки ядра для Управления Питанием (приведено для ядра 2.6.23)</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>Power Management Options ---&gt;</para>
<para>  [*] Power Management Support</para>
<para>  [ ] Software Suspend</para>
<para/>
<para>  ACPI( Advanced Configuration and Power Interface ) Support ---&gt;</para>
<para>--- ACPI Support (Advanced Configuration and Power Interface) Support</para>
<para>    [*] Deprecated /proc/acpi files </para>
<para>    [*] Deprecated /proc/acpi/event support </para>
<para>    [ ]   Sleep States</para>
<para>    [ ]     /proc/acpi/sleep (deprecated)</para>
<para>    [*]   AC Adapter</para>
<para>    [*]   Battery</para>
<para>    &lt;M&gt;   Button</para>
<para>    &lt;M&gt;   Video</para>
<para>    &lt;M&gt;   Fan</para>
<para>    &lt; &gt;   Dock</para>
<para>    &lt;M&gt;   Processor</para>
<para>    &lt;M&gt;     Thermal Zone</para>
<para>    &lt; &gt;   ASUS/Medion Laptop Extras</para>
<para>    &lt; &gt;   IBM ThinkPad Laptop Extras</para>
<para>    &lt; &gt;   Toshiba Laptop Extras</para>
<para>    (0)   Disable ACPI for systems before Jan 1st this year</para>
<para>    [ ]   Debug Statements</para>
<para>    [*]   Power Management Timer Support</para>
<para>    &lt; &gt;   ACPI0004,PNP0A05 and PNP0A06 Container Driver (EXPERIMENTAL)</para>
<para>    &lt; &gt;   Smart Battery System (EXPERIMENTAL)</para>
<para/>
<para>  CPU Frequency Scaling ---&gt;</para>
<para>    [*] CPU Frequency scaling</para>
<para>    [ ]   Enable CPUfreq debugging</para>
<para>    &lt; &gt;   CPU frequency translation statistics</para>
<para>    [ ]     CPU frequency translation statistics details</para>
<para>          Default CPUFreq governor (userspace)</para>
<para>    &lt;*&gt;   'performance' governor</para>
<para>    &lt;*&gt;   'powersave' governor</para>
<para>    &lt;*&gt;   'ondemand' cpufreq policy governor</para>
<para>    &lt;*&gt;   'conservative' cpufreq governor</para>
<para>    &lt;*&gt;   CPU frequency table helpers</para>
<para>    &lt;M&gt; ACPI Processor P-States driver</para>
<para>    &lt;*&gt; CPUFreq driver for your processor</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para/>
<para/>
<para>Примечание переводчика: поддержка '/proc/acpi' и '/proc/acpi/event' в ядре 2.6.23 была помечена не рекомендуемой (deprecated), в связи с изменением acpi-интерфейса (подробнее см. на <ulink url="http://www.kernel.org/doc/menuconfig/drivers-acpi-Kconfig.html">kernel.org</ulink>), но она необходима для acpid, который пока "не приспособился" к /sys интерфейсу. </para>
<para>Решите для себя, хотите ли вы включать программную остановку и состояния спячки (см. ниже). Если у вас ноутбук ASUS, Medion, IBM Thinkpad или Toshiba, но активируйте соответствующий пункт.</para>
<para>Ядро должно знать, как включить изменение частоты процессора. Так как разные типы ЦП имеют разные интерфейсы, стоит выбрать правильный драйвер для процессора. Будьте осторожны - включение, например, Intel Pentium 4 clock modulation на Pentium M приведёт странному поведению системы. Обратитесь к документации по ядру, если вы не знаете, что выбрать. </para>
<para>Скомпилируйте полученное поддерживающее ACPI ядро; убедитесь, что необходимые модули подгружаются при старте системы. Далее запустите emerge sys-power/acpid, чтобы получить acpi-демона. Он сообщает вам о событиях (event) таких, как переключение с питания от сети на батарею или закрытие крышки ноутбука. Убедившись, что модули запущены (если вы не скомпилировали их как часть ядра), запустите acpid командой /etc/init.d/acpid start. Выполните rc-update add acpid default, чтобы демон автоматически запускался при старте системы. Вы скоро узнаете, как использовать его. </para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 2.2: Установка acpid</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># emerge sys-power/acpid # /etc/init.d/acpid start # rc-update add acpid default </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3><sect3><title>Создание уровня запуска (runlevel) "battery"</title>
<para>Политики (policy) по умолчанию будут включать Управление Питанием, только когда это необходимо, т.е. при работе от батареи. Чтобы сделать переключение между питанием от сети и питанием от батарей более удобным, создайте уровень запуска battery, который будет содержать все скрипты запускающие и останавливающие управление питанием.</para>
<para>Примечание: Вы можете пропустить эту секцию, если вы не хотите создавать ещё один уровень запуска. В последующих секции предполагается, что уровень запуска battery существует.</para>
<para> </para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 2.3: Создание уровня запуска battery</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># cd /etc/runlevels # cp -a default battery </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Вот и всё! Новоиспечённый уровень запуска battery содержит всё, что есть в defaults, но автоматического переключения между ними нет. Пора изменить это.</para></sect3><sect3><title>Реагирование на ACPI-события</title>
<para>Типичные ACPI-события - это закрытие крышки, изменение источника питания и нажатие клавиши засыпания. Для нас важно события изменения источника питания - именно из-за него будут переключаться уровни запуска. Маленький скрипт позаботится об этом. </para>
<para>Для начала, вам нужен скрипт, который меняет уровень запуска на defaults или battery в зависимости от источника энергии. Скрипт использует команду on_ac_power из sys-power/powermgmt-base - убедитесь, что он установлен на вашей системе. </para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 2.4: Установка sys-power/powermgmt-base</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># emerge powermgmt-base </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Теперь вы может определить источник питания, запустив on_ac_power &amp;&amp; echo AC available || echo Running on batteries в консоли. Скрипт ниже отвечает за переключение уровней. Сохраните его как /etc/acpi/actions/pmg_switch_runlevel.sh. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 2.5: /etc/acpi/actions/pmg_switch_runlevel.sh</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>#!/bin/bash</para>
<para/>
<para># BEGIN configuration</para>
<para>RUNLEVEL_AC="default"</para>
<para>RUNLEVEL_BATTERY="battery"</para>
<para># END configuration</para>
<para/>
<para/>
<para>if [ ! -d "/etc/runlevels/${RUNLEVEL_AC}" ]</para>
<para>then</para>
<para>    logger "${0}: Runlevel ${RUNLEVEL_AC} does not exist. Aborting."</para>
<para>    exit 1</para>
<para>fi</para>
<para/>
<para>if [ ! -d "/etc/runlevels/${RUNLEVEL_BATTERY}" ]</para>
<para>then</para>
<para>    logger "${0}: Runlevel ${RUNLEVEL_BATTERY} does not exist. Aborting."</para>
<para>    exit 1</para>
<para>fi</para>
<para/>
<para>if on_ac_power</para>
<para>then</para>
<para>    if [[ "$(&lt;/var/lib/init.d/softlevel)" != "${RUNLEVEL_AC}" ]]</para>
<para>    then</para>
<para>        logger "Switching to ${RUNLEVEL_AC} runlevel"</para>
<para>         /sbin/rc ${RUNLEVEL_AC}</para>
<para>    fi</para>
<para>elif [[ "$(&lt;/var/lib/init.d/softlevel)" != "${RUNLEVEL_BATTERY}" ]]</para>
<para>then</para>
<para>    logger "Switching to ${RUNLEVEL_BATTERY} runlevel"</para>
<para>    /sbin/rc ${RUNLEVEL_BATTERY}</para>
<para>fi</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Не забудьте сделать скрипт исполняемым, запустив chmod +x /etc/acpi/actions/pmg_switch_runlevel.sh. Последнее, что осталось сделать, - это вызов скрипта всякий раз, когда изменяется источник питания. Это можно сделать, перехватывая ACPI-события посредством acpid. Главное - знать, какое событие генерируется при изменении источника питания. События называются ac_adapter и battery на большинстве ноутбуков, но могут быть другими на вашем. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 2.6: Определение ACPI-событий для изменение источника питания</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># tail -f /var/log/messages | grep "received event" </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Запустите команду выше и отключите ноутбук от питания. Затем снова подключите его. Вы должны увидеть что-то такое:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 2.7: Определение ACPI-событий для изменение источника питания</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>[Tue Sep 20 17:39:06 2015] received event "ac_adapter AC 00000080 00000000" [Tue Sep 20 17:39:06 2015] received event "battery BAT0 00000080 00000001" </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Интересующая часть - строки, заключенные в кавычки, после received event. Они должны совпадать с теми, что используются в файле ниже. Не беспокойтесь, если ваша система выдает много событий или всегда одни и те же. Пока хоть какое-нибудь событие генерируется, переключение уровней будет работать. </para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 2.8: /etc/acpi/events/pmg_ac_adapter</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># Замените "ac_adapter" ниже на реальное событие вашем ноутбуке </para>
<para># Например, ac_adapter.* будет соответствовать ac_adapter AC 00000080 00000000 event=ac_adapter.* action=/etc/acpi/actions/pmg_switch_runlevel.sh %e </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 2.9: /etc/acpi/events/pmg_battery</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># Замените "battery" ниже на реальное событие вашем ноутбуке </para>
<para># Например, battery.* будет соотвествовать battery AC 00000080 00000001 event=battery.* action=/etc/acpi/actions/pmg_switch_runlevel.sh %e </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Наконец, acpid должен быть перезапущен, чтобы изменения вступили в силу. </para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 2.10: Последний штрих</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># /etc/init.d/acpid restart </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Вы можете проверить работоспособность скриптов, отсоединив кабель питания и вставив его вновь, - в syslog должны появляться сообщения "Switching to AC mode" или "Switching to battery mode". Обратитесь к <link linkend="">устранению неполадок</link>, если скрипт некорректно распознаёт источник питания. </para>
<para>Из-за природы механизма событий, ваш ноутбук будет загружаться в уровень запуска default не зависимо от источника питания. Это просто замечательно, если мы подключены к сети, но если нет, то нам хотелось бы загружаться в уровень запуска battery. Одно из решений - это добавить ещё один пункт в менеджер загрузки, с параметром softlevel=battery, но не сложно просто забыть его выбрать. Лучший путь - поставить ACPI-событие в конец процесса загрузки и позволить скрипту pmg_switch_runlevel.sh решать, какое изменение уровня необходимо. Откройте /etc/conf.d/local.start в вашем любимом редакторе и добавьте следующие строки: </para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 2.11: Изменение уровня запуска во время загрузки</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># Эмулируем acpi событие, чтобы переключить уровень запуска, если работаем от батареи /etc/acpi/actions/pmg_switch_runlevel.sh "battery/battery" </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Подготовив систему таким образом, вы можете активировать политики управления питанием для отдельных устройств. </para></sect3></sect2><sect2><title>
<anchor id="cpu"/>3. Управление питанием ЦПУ</title>
<para>Мобильные процессоры могут работать на нескольких частотах, а некоторые позволяют даже менять напряжение. Максимальная производительность нужна далеко не всегда, и меняя её можно сохранить немало энергии, причём зачастую без какого-либо понижения производительности</para><sect3><title>Техническая часть</title>
<para>Частота процессора связана с некоторыми техническими терминами, который могут быть вам незнакомы, поэтому ниже будет дано краткое введение.</para>
<para>Для начала, ядро должно "уметь" менять частоту процессора. <emphasis>Драйвер процессора CPUfreq</emphasis> (CPUfreq processor driver) знает как сделать это на вашем ЦП, поэтому важно указать его правильно в вашем ядре. Скорее всего, вы это уже сделали выше. Также ядро должно знать, какую частоту устанавливать. Это достигается посредством <emphasis>политик</emphasis> (policy), которые состоят из <emphasis>политики CPUfreq</emphasis> (CPUfreq policy) и <emphasis>властелина</emphasis> (governor). Первое - это пара из двух чисел, обозначающих максимальную и минимальную допустимую частоту ЦП, а второе отвечает за то, какую конкретно частоту выбрать. Так, властелин сохранения энергии (powersave governor) всегда выбирает минимальную допустимую частоту, а властелин максимальной производительностью (performance governor), наоборот, максимальную; властелин пользователя (userspace governor) использует необходимую пользователю (или его приложениям) частоту, читая её из /sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed.</para>
<para>Всё это не очень похоже на динамическое изменение частоты (и действительно не является таковым). Однако динамика может быть получена несколькими способами. Например, "требовательный" властелин (ondemand governor) принимает решение, основываясь на текущей загрузке ЦП. Это же может быть реализовано посредством различных пользовательских инструментов таких, как cpudn, cpufreqd, powernowd и многих других. События ACPI можно использовать для включения или выключения динамического изменения частоты в зависимости от источника питания. </para></sect3><sect3><title>Установка частоты вручную</title>
<para>Уменьшение скорости и напряжение на ЦП даёт двойной выигрыш: с одной стороны, потребляется меньше энергии, а с другой - ваша система греется не так сильно, как на полной мощности. Главный недостаток - очевидная потеря производительности. Уменьшение скорости процессора - обмен производительности на сохранение энергии.</para>
<para>Примечание: Не все ноутбуки поддерживают изменение частоты. Если вы не уверены, посмотрите список поддерживаемых процессоров в секции <ulink url="http://iandmyfriendgentoo.blogspot.com/2007/12/blog-post_12.html#troubleshooting">Устранение неполадок</ulink>. </para>
<para>Самое время проверить, работает ли изменение частоты процессора. Давайте установим ещё один очень полезный при отладке инструмент: sys-power/cpufrequtils</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 3.1: Проверка частоты ЦП</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># emerge cpufrequtils # cpufreq-info </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Вывод будет примерно таким: </para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 3.2: Пример вывода cpufreq-info</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>cpufrequtils 0.3: cpufreq-info (C) Dominik Brodowski 2004</para>
<para>Report errors and bugs to linux@brodo.de, please.</para>
<para>analyzing CPU 0:</para>
<para>  driver: centrino</para>
<para>  CPUs which need to switch frequency at the same time: 0</para>
<para>  hardware limits: 600 MHz - 1.40 GHz</para>
<para>  available frequency steps: 600 MHz, 800 MHz, 1000 MHz, 1.20 GHz, 1.40 GHz</para>
<para>  available cpufreq governors: conservative, ondemand, powersave, userspace, performance</para>
<para>  current policy: frequency should be within 924 MHz and 1.40 GHz.</para>
<para>    The governor "performance" may decide which speed to use</para>
<para>    within this range.</para>
<para>  current CPU frequency is 1.40 GHz. governor "conservative" may decide which  speed to use within this range. </para>
<para> current CPU frequency is 1.60 GHz. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь, поиграйтесь с cpufreq-set, чтобы убедиться в работоспособности переключение частоты. Например, выполните cpufreq-set -g ondemand, чтобы активировать "требовательного" властелина, и проверьте изменение с помощью cpufreq-info. Если не работает как надо, вы можете попробовать найти причину в <ulink url="http://iandmyfriendgentoo.blogspot.com/2007/12/blog-post_12.html#troubleshooting">Устранении неполадок</ulink> в конце этого руководства.</para></sect3><sect3><title>Автоматическая настройка частоты</title>
<para>Сказанное, конечно, прекрасно, но не очень применимо в реальной жизни. Лучше поручить вашей системе автоматически подбирать подходящую частоту. Есть много способов сделать это. Следующая таблица даёт общее представление о них и поможет вам выбрать необходимый. Их можно не совсем точно разделить на три типа: ядро - для методов нуждающихся только в поддержке ядра, демон - для запускающихся в фоне программ и графический - для программ, которые предоставляют графический интерфейс для простой настройки.</para>
<para/>
<informaltable frame="all">
<tgroup cols="6">
<thead>
<row>
<entry>
<para>Имя</para>
</entry>
<entry>
<para>Тип</para>
</entry>
<entry>
<para>Причины для переключения (Switch decision)</para>
</entry>
<entry>
<para>Используемые властелины ядра(Kernel governors)</para>
</entry>
<entry>
<para>Предоставляемые режимы (Further governors)</para>
</entry>
<entry>
<para>Комментарии</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>требовательный властелин ('ondemand' governor)</para>
</entry>
<entry>
<para>Ядро</para>
</entry>
<entry>
<para>Загрузка ЦП</para>
</entry>
<entry>
<para>-</para>
</entry>
<entry>
<para>-</para>
</entry>
<entry>
<para>Выставляет максимальную частоту при загрузке ЦП и медленно шагает вниз во время простоя ЦП. Дальнейшая настройка через /sys/devices/system/cpu/cpu0/cpufreq/ondemand/. По-прежнему требует пользовательских программ (скриптов), если переключение властелинов или подобное необходимо. </para>
</entry>
</row>
<row>
<entry>
<para>консервативный властелин ('conservative' governor)</para>
</entry>
<entry>
<para>Ядро</para>
</entry>
<entry>
<para>Загрузка ЦП</para>
</entry>
<entry>
<para>-</para>
</entry>
<entry>
<para>-</para>
</entry>
<entry>
<para>В отличие от требовательного властелина, консервативный не прыгает до максимальной частоты во время высокой загрузки ЦП, а увеличивает частоту постепенно. Дальнейшая настройка через /sys/devices/system/cpu/cpu0/cpufreq/conservative/. По-прежнему требует пользовательских программ (скриптов), если переключение властелинов или подобное необходимо. </para>
</entry>
</row>
<row>
<entry>
<para>
<ulink url="http://mnm.uib.es/%7Egallir/cpudyn/">cpudyn</ulink>
</para>
</entry>
<entry>
<para>Демон</para>
</entry>
<entry>
<para>Загрузка ЦП</para>
</entry>
<entry>
<para>Производительность, сохранение энергии</para>
</entry>
<entry>
<para>Динамические</para>
</entry>
<entry>
<para>Также поддерживает disk standby. Однако стоит заметить, что laptop-mode в большинстве случаев работает лучше. </para>
</entry>
</row>
<row>
<entry>
<para>
<ulink url="http://sourceforge.net/projects/cpufreqd/">cpufreqd</ulink>
</para>
</entry>
<entry>
<para>Демон</para>
</entry>
<entry>
<para>Состояние батареи, загрузка ЦП, температура, запущенные программы и др.</para>
</entry>
<entry>
<para>Все возможные</para>
</entry>
<entry>
<para>Нет</para>
</entry>
<entry>
<para>Тонкая (и местами сложная) установка. Расширяем посредством плагинов, таких как отслеживание показаний сенсоров (sensor monitoring) (lm_sensors). Может управлять памятью и ядром некоторых построенных на NVidia графических карт. Cpufreqd не поддерживает SMP, и при желании им можно управлять вручную во время выполнения. </para>
</entry>
</row>
<row>
<entry>
<para>
<ulink url="http://www.deater.net/john/powernowd.html">powernowd</ulink> </para>
</entry>
<entry>
<para>Демон</para>
</entry>
<entry>
<para>Загрузка процессора</para>
</entry>
<entry>
<para>Нет</para>
</entry>
<entry>
<para>Пассивный, синусоидальный (sine), агрессивный</para>
</entry>
<entry>
<para>Поддерживает SMP. </para>
</entry>
</row>
<row>
<entry>
<para>
<ulink url="http://projects.simpledesigns.com.pl/project/ncpufreqd/">ncpufreqd</ulink> </para>
</entry>
<entry>
<para>Демон</para>
</entry>
<entry>
<para>Температура</para>
</entry>
<entry>
<para>Нет</para>
</entry>
<entry>
<para>Производительность, сохранение энергии</para>
</entry>
<entry>
<para>Переключает властителинов производительности и сохранения энергии. Очень полезен на ноутбуках, страдающих перегревом. </para>
</entry>
</row>
<row>
<entry>
<para>
<ulink url="http://www.goop.org/%7Ejeremy/speedfreq/">speedfreq</ulink>
</para>
</entry>
<entry>
<para>Демон</para>
</entry>
<entry>
<para>Загрузка ЦП</para>
</entry>
<entry>
<para>Нет</para>
</entry>
<entry>
<para>Динамический, сохранения энергия, производительность, фиксированной скорости</para>
</entry>
<entry>
<para>Легко настраивается с помощью приятного клиент-серверного интерфейса. Требуется ядро 2.6. Не поддерживается, сломан и поэтому удален из портежей. Пожалуйста, перейдите на cpufreqd, если вы всё ещё используете эту программу. </para>
</entry>
</row>
<row>
<entry>
<para>
<ulink url="http://cpuspeedy.sourceforge.net/">gtk-cpuspeedy</ulink>
</para>
</entry>
<entry>
<para>Графический</para>
</entry>
<entry>
<para>Нет</para>
</entry>
<entry>
<para>Нет</para>
</entry>
<entry>
<para>Нет</para>
</entry>
<entry>
<para>Gnome-приложение, графический инструмент для ручной установки частоты процессора. Не предоставляет никакой автоматизации. </para>
</entry>
</row>
<row>
<entry>
<para>klaptopdaemon</para>
</entry>
<entry>
<para>Графический</para>
</entry>
<entry>
<para>Состояние батареи</para>
</entry>
<entry>
<para>Все возможные</para>
</entry>
<entry>
<para>Нет</para>
</entry>
<entry>
<para>Только для КДЕ, властелин требований для динамического изменения частоты. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Хотя изменение частоты в зависимости от нагрузки выглядит просто на первый взгляд, это не такая уж и тривиальная задача. Плохой алгоритм может привести к постоянному переключению между двумя частотами или бессмысленному перерасходу энергии из-за неоправданно большой частоты.</para>
<para>Что выбрать? Если вы не можете решить, попробуйте cpufreqd.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 3.3: Установка cpufreqd</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># emerge cpufreqd </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>cpufreqd настраивается редактированием /etc/cpufreqd.conf. Конфиг, предоставляемый по умолчанию, может вас несколько смутить. Рекомендуется заменить его на конфигурационный файл, который создал бывший разработчик Gentoo - Henrik Brix Andersen. Учтите, что вам необходим cpufreqd-2.0.0 или более новая версия. Ранние версии используют другой синтаксис конфигурационного файла.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 3.4: /etc/cpufreqd.conf (cpufreqd-2.0.0 или более новый)</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>[General]</para>
<para>pidfile=/var/run/cpufreqd.pid</para>
<para>poll_interval=3</para>
<para>enable_plugins=acpi_ac, acpi_battery</para>
<para>enable_remote=1</para>
<para>remote_group=wheel</para>
<para>verbosity=5</para>
<para>[/General]</para>
<para/>
<para>[Profile]</para>
<para>name=ondemand</para>
<para>minfreq=0%</para>
<para>maxfreq=100%</para>
<para>policy=ondemand</para>
<para>[/Profile]</para>
<para/>
<para>[Profile]</para>
<para>name=conservative</para>
<para>minfreq=0%</para>
<para>maxfreq=100%</para>
<para>policy=conservative</para>
<para>[/Profile]</para>
<para/>
<para>[Profile]</para>
<para>name=powersave</para>
<para>minfreq=0%</para>
<para>maxfreq=100%</para>
<para>policy=powersave</para>
<para>[/Profile]</para>
<para/>
<para>[Profile]</para>
<para>name=performance</para>
<para>minfreq=0%</para>
<para>maxfreq=100%</para>
<para>policy=performance</para>
<para>[/Profile]</para>
<para/>
<para>[Rule]</para>
<para>name=battery</para>
<para>ac=off</para>
<para>profile=conservative</para>
<para>[/Rule]</para>
<para/>
<para>[Rule]</para>
<para>name=battery_low</para>
<para>ac=off</para>
<para>battery_interval=0-10</para>
<para>profile=powersave</para>
<para>[/Rule]</para>
<para/>
<para>[Rule]</para>
<para>name=ac</para>
<para>ac=on</para>
<para>profile=ondemand</para>
<para>[/Rule]</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь вы можете запустить демон cpufreqd. Добавьте его в уровни запуска default и battery.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 3.5: Запуск cpufreqd</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># rc-update add cpufreqd default battery # rc </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Иногда желательно установить политику отличную от той, что выбрал демон. Например, если заряд батареи низок, но вы знаете, что скоро появится питание от сети. В этом случае вы можете перевести cpufreqd в ручной режим с помощью команды cpufreqd-set manual и далее выбрать одну из сконфигурированных политик (они перечислены в cpufreqd-get). Выйти из ручного режима вы можете командой cpufreqd-set dynamic</para>
<para>Предупреждение: Не запускайте одновременно более одной программы, перечисленной выше. Это может привести к конфликтах таких, как постоянное переключение между двумя частотами. </para></sect3><sect3><title>Проверка результата</title>
<para>Осталось только проверить, что ваши новые политики работают правильно. Простой способ сделать это - следить за скоростью ЦП во время работы:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 3.6: Отслеживание скорости ЦП</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># watch grep \"cpu MHz\" /proc/cpuinfo </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Если /proc/cpuinfo не обновляется (см. <ulink url="http://iandmyfriendgentoo.blogspot.com/2007/12/blog-post_12.html#troubleshooting">Устранение неполадок</ulink>), попробуйте sys-apps/x86info:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 3.7: Альтернативное отслеживание скорочти ЦП</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># watch x86info -mhz </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>В зависимости от ваших настроек, частота должна возрастать при нагрузке, падать в спокойном состоянии, или оставаться на том же уровне. Если вы используете cpufreqd и уровень подробности (verbosity) равен 5 или больше в cpufreqd.conf, то вы можете найти дополнительную информацию о происходящем в syslog.</para></sect3></sect2><sect2><title>4. LCD Power Management</title>
<para>Как вы видели в графике <ulink url="http://iandmyfriendgentoo.blogspot.com/2007/12/blog-post_12.html#energy-budget">распределения энергии</ulink>, LCD экран потребляет наибольшую часть энергии (по крайней мере для мобильных ПК). Таким образом, важно не только выключать экран, когда он не нужен, но и уменьшать его яркость, если это возможно. Большинство ноутбуков предоставляют возможность контролировать яркость экрана</para><sect3><title>Настройки засыпания (standby)</title>
<para>В первую очередь необходимо проверить настройки засыпания(standby), остановки(suspend), выключения дисплея. Так как это сильно зависит от вашего оконного менеджера, то вам предстоит делать это самим. Только два замечания: погасить терминал можно командой setterm -blank &lt;количество минут&gt;, setterm -powersave on и setterm -powerdown &lt;количество минут&gt;. Для X.org, необходимо исправить в /etc/X11/xorg.conf следующее (или в /etc/X11/XF86Config для XFree86):</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 4.1: Настройка засыпания дисплея в X.org и XFree86</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>Section "ServerLayout"</para>
<para>  Identifier  [...]</para>
<para>  [...]</para>
<para>  Option  "BlankTime"  "5"  # Blank the screen after 5 minutes (Fake)</para>
<para>  Option  "StandbyTime"  "10"  # Turn off screen after 10 minutes (DPMS)</para>
<para>  Option  "SuspendTime"  "20"  # Full suspend after 20 minutes</para>
<para>  Option  "OffTime"  "30"  # Turn off after half an hour</para>
<para>  [...]</para>
<para>EndSection</para>
<para/>
<para>[...]</para>
<para/>
<para>Section "Monitor"</para>
<para>  Identifier  [...]</para>
<para>  Option  "DPMS"  "true"</para>
<para>  [...]</para>
<para>EndSection</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3><sect3><title>Уменьшение подсветки</title>
<para>Если вы можете управлять яркостью с помощью программы, напишите маленький скрипт, который уменьшает подсветку и поместите его в ваш уровень запуска batery. Следующий скрипт должен работать на большинстве ноутбуков IBM Thinkpad и Toshiba. Для ноутбуков IBM необходимо включить соответствующий пункт в ядре, а владельцы Toshiba могут поставить sys-power/acpitool и пропустить настройку ibm_acpi, описанную ниже.</para>
<para>Предупреждение: Поддержка изменения яркости является экспериментальной для ibm-acpi, так как работает с оборудованием напрямую и может серьёзно поредить его. Обратитесь к <ulink url="http://ibm-acpi.sourceforge.net/">сайту ibm-acpi</ulink> за подробностями. </para>
<para>Для поддержки изменения уровня яркости, модуль ibm_acpi должен быть запущен с параметром experimental.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 4.2: Настройка засыпания дисплея в X.org и XFree86</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>(Прочтите предупреждение выше, прежде чем делать это)</para>
<para># echo "options ibm_acpi experimental=1" &gt;&gt; /etc/modules.d/ibm_acpi</para>
<para># /sbin/update-modules </para>
<para># echo ibm_acpi &gt;&gt; /etc/modules.autoload.d/kernel-2.6 </para>
<para># modprobe ibm_acpi </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Это должно выполниться без ошибок, а также должен появится файл /proc/acpi/ibm/brightness. Скрипт инициализации будет принимать решение об уровне подсветки в зависимости от источника питания.</para>
<para/>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 4.3: /etc/conf.d/lcd-brightness</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># См. допустимые значения в /proc/acpi/ibm/brightness </para>
<para># Пожалуйста, прочтите /usr/src/linux/Documentation/ibm-acpi.txt</para>
<para># Уровень яркости при питании от сети. По умолчанию - 7. BRIGHTNESS_AC=7</para>
<para># Уровень яркости при питании от батареи. По умолчанию - 4. BRIGHTNESS_BATTERY=4 </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 4.4: /etc/init.d/lcd-brightness</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>#!/sbin/runscript</para>
<para/>
<para>set_brightness() {</para>
<para>    if on_ac_power</para>
<para>    then</para>
<para>        LEVEL=${BRIGHTNESS_AC:-7}</para>
<para>    else</para>
<para>        LEVEL=${BRIGHTNESS_BATTERY:-4}</para>
<para>    fi</para>
<para/>
<para>    if [ -f /proc/acpi/ibm/brightness ]</para>
<para>    then</para>
<para>        ebegin "Setting LCD brightness"</para>
<para>        echo "level ${LEVEL}" &gt; /proc/acpi/ibm/brightness</para>
<para>        eend $?</para>
<para>    elif [[ -e /usr/bin/acpitool &amp;&amp; -n $(acpitool -T | grep "LCD brightness") ]]</para>
<para>    then</para>
<para>        ebegin "Setting LCD brightness"</para>
<para>        acpitool -l $LEVEL &gt;/dev/null || ewarn "Unable to set lcd brightness"</para>
<para>        eend $?</para>
<para>    else</para>
<para>        ewarn "Setting LCD brightness is not supported."</para>
<para>        ewarn "For IBM Thinkpads, check that ibm_acpi is loaded into the kernel"</para>
<para>        ewarn "For Toshiba laptops, you've got to install sys-power/acpitool"</para>
<para>    fi</para>
<para>}</para>
<para/>
<para>start() {</para>
<para>    set_brightness</para>
<para>}</para>
<para/>
<para>stop () {</para>
<para>    set_brightness</para>
<para>}</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Далее, убедитесь, что уровень яркости меняется автоматически, добавив скрипт в уровень запуска battery.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 4.5: Включаем автоматическое изменение яркости</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># chmod +x /etc/init.d/lcd-brightness </para>
<para># rc-update add lcd-brightness battery </para>
<para># rc </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3><sect3><title>
<anchor id="harddrive"/>Управление питанием диска</title>
<para>Жёсткий диск потребляет меньше энергии во время спящего режима (sleep mode). Поэтому разумно активировать возможности сохранения энергии, когда жёсткий диск не используется некоторое время. Есть два различных способа сделать это. Первый, (laptop-mode) будет сберегать больше всего энергии за счёт предотвращения или, по крайней мере, задержки записи на диск. Обратной стороной медали является повышенный риск потери данных при сбое питания или аварии ядра; чтобы уменьшить масштабы возможной аварии, убедитесь, что не запущенно часто пишущих на диск процессов. В качестве альтернативного, второго способа вы можете включить сохранение энергии на диске с помощью hdparm.</para></sect3><sect3><title>Увеличение времени покоя (idle time) - laptop-mode</title>
<para>Последние 2.6-ядра включают одноимённый laptop-mode. Когда он активирован, "грязные" буферы (dirty buffers) пишутся на диск при вызовах чтения (read calls) или после 10 минут (вместо 30 секунд). Это минимизирует время, которое тратится на раскручивание диска.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 5.1: Автоматический старт laptop-mode</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># emerge laptop-mode-tools </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Настройки пакета laptop-mode-tools хранятся в файле /etc/laptop-mode/laptop-mode.conf. Отредактируйте его на свой вкус - он отлично документирован. Выполните rc-update add laptop_mode battery, чтобы он запускался автоматически.</para>
<para>Последние версии (1.11 и позже) этого пакета включают полезный инструмент lm-profiler. Он следит за использованием диска и запущенными сетевыми сервисами и предлагает отключить ненужные. Вы можете отключить их как используя встроенную в laptop-mode-tools поддержку уровней запуска (которая будет переопределена /sbin/rc), так и через созданные вами уровни запуска default/battery (рекомендуется).</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 5.2: Пример вывода lm-profiler</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># lm-profiler</para>
<para>Profiling session started.</para>
<para>Time remaining: 600 seconds</para>
<para>[4296896.602000] amarokapp</para>
<para>Time remaining: 599 seconds</para>
<para>[4296897.714000] sort</para>
<para>[4296897.970000] mv</para>
<para>Time remaining: 598 seconds</para>
<para>Time remaining: 597 seconds</para>
<para>[4296900.482000] reiserfs/0</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>После наблюдения за вашей системой в течении 10 минут, lm-profiler выведет список сервисов, которые могли вызвать обращения к диску за этот промежуток времени.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 5.3: lm-profiler предлагает отключить некоторые сервисы</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>Program:     "atd"</para>
<para>Reason:      standard recommendation (program may not be running)</para>
<para>Init script: /etc/init.d/atd (GUESSED)</para>
<para/>
<para>Do you want to disable this service in battery mode? [y/N]: n</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Чтобы отключить atd, как предлагается в примере выше, выполните rc-update del atd battery. Будьте осторожны, не отключите жизенноважные сервисы - lm-profiler частенько выдает не совсем правильные данные. Не отключайте что-либо, если вы полностью не уверены в ненужности сервиса.</para></sect3><sect3><title>Ограничение доступа на запись</title>
<para>Если вы не хотите использовать laptop-mode, вы должны отключить часто пишущие на диск сервисы вручную - syslogd кандидат на выбывание, например. Возможно, вы не хотите выключать его полностью, тогда можно подправить конфиг так, чтобы писались только "необходимые вещи". Cups пишет на диск лишь время о времени, поэтому можно выключить его и включать вручную, когда необходимо.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 5.4: Выключение cups из уровня запуска battery</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># rc-update del cupsd battery </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Вы также может использовать lm-profiler из laptop-mode-tools (см. выше), чтобы найти неугодные сервисы. Если вы истребили их всех, то можно переходить к настройке hdparm.</para></sect3><sect3><title>hdparm</title>
<para>Вторая возможность - использование hdparm. Пропустите этот шаг, если вы используете laptop-mode. Иначе, откройте /etc/conf.d/hdparm и добавьте следующие строки для ваших жёстких дисков. Этот пример предполагает, что ваш диск именуется hda:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 5.5: Использование /etc/conf.d/hdparm для засыпания диска</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>hda_args="-q -S12" </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Это включит управление питанием для вашего жесткого диска. Если вы когда-нибудь решите отключить управление питанием, то просто измените значение в /etc/conf.d/hdparm на -q -S0 или выполните hdparm -q -S0 /dev/hda.</para>
<para>Обратитесь к man hdparm за другими опциями. Хотя вы всегда можете запускать hdparm вручную командой /etc/init.d/hdparm start, намного проще автоматизировать её запуск и остановку. Чтобы сделать это, добавить hdparm в уровень запуска battery.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 5.6: Автоматизация засыпания диска</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>#rc-update add hdparm battery </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Внимание: Будьте осторожны с настройками засыпания/остановки (sleep/spin down) вашего жёсткого диска. Установление слишком низких значений может быстро "износить" ваш диск, что приведёт к потере гарантии. (Прим. пер.: вспомните <ulink url="http://www.opennet.ru/cgi-bin/openforum/vsluhboard.cgi?az=show_thread&amp;omm=0&amp;om=38837&amp;forum=vsluhforumID3">историю про Ubuntu</ulink>) </para></sect3><sect3><title>Другие "типы и трюки"</title>
<para>Ещё один способ достижения светлой цели снижения энергопотребления состоит в отключении свопа (swap) в режиме питания от батареи. Перед тем, как писать переключатель swapon/swapoff, убедитесь, что у вас достаточно оперативной памяти и своп существенно не используется, иначе вы рискуете приобрести большие проблемы. </para>
<para>Если вы не хотите использовать laptop-mode, то можно уменьшить обращение к диску, монтируя некоторые директории как tmpfs - запись на такие разделы хранится не на диске, а в ОЗУ, и поэтому пропадает после отмонтирования. Зачастую удобно примонтировать /tmp таким образом, так как она в любом случае очищается при каждой перезагрузке. Правда, стоит убедиться, что у вас достаточно памяти и что нет программ (таких, как менеджеры закачек и архиваторы), которым требуется экстремально много места в /tmp. Чтобы сделать это, включите поддержку tmpfs в ядре и добавьте подобную следующей строку в /etc/fstab: </para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 5.7: Редактирование /etc/fstab, чтобы сделать /tmp более отрешённым от диска (volatile)</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>none /tmp tmpfs size=32m 0 0 </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Предупреждение: Обратите внимание на параметр (32 m), и подстройте его под вашу систему. Если вы не уверены, не пробуйте это вообще - это может сильно уменьшить производительность. Если вы хотите подмонтировать /var/log таким же образом, убедитесь, что файлы сохраняются на диск перед размонтированием. Они необходимы. Не пытайтесь примонтировать /var/tmp таким образом - он используется Portage при сборке пакетов.</para></sect3></sect2><sect2><title>
<anchor id="other"/>6. Управление питанием других устройств</title><sect3><title>Графические карты</title>
<para>Если у вас стоит карточка ATI с поддержкой PowerPlay (динамическое изменение частоты графического процессора), вы можете активировать эту возможность в X.org. Откройте /etc/X11/xorg.conf и добавьте (или включите) опцию DynamicClocks в секции Устройство (device). Учтите, что это может привести к падению на некоторых системах.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 6.1: Включение поддержки ATI PowerPlay в X.org</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>Section "Device" [...] Option "DynamicClocks" "on" EndSection </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3><sect3><title>Управление питанием беспроводных соединений</title>
<para>Карточка беспроводного соединения потребляет немалую часть энергии. Переведите их в режим сохранения энергии так, как вы сделали это с жёсткими дисками.</para>
<para>Примечание: В скрипте предполагается, что ваш беспроводной интерфейс - wlan0. Если в вашей системе это не так, что просто замените его на своё. </para>
<para>Добавьте следующую строку в /etc/conf.d/net для автоматического включения управления питанием беспроводной карты: </para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 6.2: Автоматизированное управления питанием WLAN</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>iwconfig_wlan0="power on" </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Обратитесь к man iwconfig за деталями и другими опциями такими, как интервалы между пробуждениями или настройки тайм аута. Если ваш драйвер и точка доступа поддерживает изменение частоты сигналов, то из этого можно извлечь ещё больше сохранённой энергии.</para></sect3><sect3><title>Управление питанием USB</title>
<para>Есть две проблемы с потреблением энергии USB-устройствами. Во-первых, устройства такие, как USB мыши, цифровые камеры или флэшки потребляют энергию всё время, пока подключены, вы не можете избежать этого (кроме как отключая их, когда в них нет необходимости). Во-вторых, когда USD устройство подключено, контроллер USB хоста время от времени опрашивает шину, что не даёт CPU уйти в спящий режим. Ядро предоставляет экспериментальную опцию для включение приостановления (suspend) для USB устройств посредством вызова драйвера или одного из файлов power/state в /sys.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 6.3: Включение поддержки приостановления (suspend) USB в ядре</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>Device Drivers</para>
<para>  USB support</para>
<para>    [*]   Support for Host-side USB</para>
<para>      [*]   USB suspend/resume (EXPERIMENTAL)</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect3></sect2><sect2><title>
<anchor id="sleepstates"/>7. Состояния спячки: sleep, standby, suspend to disk</title>
<para>Примечание переводчика: данный раздел существенно устарел. Более свежую информацию можно найти на <ulink url="http://gentoo-wiki.com/HOWTO_Software_Suspend_v2">gentoo-wiki.com (EN)</ulink>. Также в русской есть короткий пересказ: <ulink url="http://ru.gentoo-wiki.com/Suspend2">gentoo-wiki.com</ulink>. </para>
<para>ACPI определяет несколько состояний спячки. Основные три из них:</para>
<orderedlist>
<listitem>
<para>S1 aka Standby </para>
</listitem>
<listitem>
<para>S3 aka Suspend to RAM aka Sleep </para>
</listitem>
<listitem>
<para>S4 aka Suspend to Disk aka Hibernate </para>
</listitem>
</orderedlist>
<para>Они могут вызываться в моменты, когда компьютер не используется, но выключение не желательно из-за долгой загрузки</para><sect3><title>Sleep (S3)</title>
<para>Поддержка ACPI для этих состояний спячки помечена экспериментальной, и для этого есть достаточно оснований. Возможно, состояния спячки в APM (Advanced Power Management) несколько более стабильны, но использовать APM и ACPI одновременно нельзя.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 7.1: Конфигурация ядра для включений состояний спички</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>  Power Management Options ---&gt;</para>
<para>    [*]  Power Management support</para>
<para>      ACPI (Advanced Configuration and Power Interface) Support ---&gt;</para>
<para>        [*]  ACPI Support</para>
<para>          [*]   Sleep States</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Когда ядро настроено, вы можете воспользоваться скриптом hibernate-script, чтобы активировать suspend или sleep. Для начала его надо установить.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 7.2: Установка hibernate-script</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># emerge hibernate-script </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Необходимо некоторые настройки в /etc/hibernate. По умолчанию пакет предоставляет несколько конфигурационных файлов для каждого состояния спячки. Общие настройки помещены в common.conf; убедитесь, что этот файл правильно сконфигурирован для вашей системы.</para>
<para>Чтобы настроить sleep, отредактируйте sysfs-ram.conf в /etc/hibernate. Опция UseSysfsPowerState mem уже выставлена правильно, но если вы хотите произвести дальнейшие настройки в этом или любом другом состоянии спячки, то не забудьте добавить их в /etc/hibernate/hibernate.conf. Комментарии и названия опций помогут вам разобраться. Если вы используете nfs или сетевые ресурсы самбы (samba shares over the network), то необходимо завершать соответствующие скрипты инициализации, чтобы избежать тайм аутов (timeouts).</para>
<para/>
<para>Примечание: Дополнительную информацию о состояниях спячки см. в man hibernate.conf </para>
<para>Готовы? У вас остался последний шанс сделать backup данных прежде, чем запустить следующую команду. Обратите внимание, что вам возможно потребуется нажать специальную клавишу такую, как Fn, чтобы вернутся из спячки.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 7.3: Засыпание</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># hibernate-ram </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Если вы всё ещё читаете, то, видимо, всё работает. Вы можете таким же образом настроить standby (S1), подредактировав sysfs-ram.conf и изменив UseSysfsPowerState mem на UseSysfsPowerState standby. Режимы S3 и S4 более интересны, поскольку сохраняют больше энергии. </para></sect3><sect3><title>Hibernate (S4)</title>
<para>Эта секция посвящена hibernation. В этом режиме снимок (snapshot) работающей системы записывается на диск, перед выключением. При включении, снимок загружается и вы можете продолжать работы с момент выключения.</para>
<para>Предупреждение: Не заменяйте устройства не поддерживающие горячую замены во время остановки. Не пытайтесь загрузить снимок на другой машине. Отключите все сетевые ФС и клиенты/серверы самбы перед засыпанием. </para>
<para>Существуют две различных реализации S4. Оригинальная - swsusp, и более новая tuxonice с более приятным интерфейсом (с поддержкой fbsplash). <ulink url="http://tuxonice.net/features.html#compare">Сравнение их возможностей</ulink> вы можете найти на <ulink url="http://www.tuxonice.net/">домашней странице tuxonice</ulink>. There used to be Suspend-to-Disk (pmdisk), a fork of swsusp, but it has been merged back.</para>
<para>TuxOnIce пока не включен в основную ветку ядра (mainline kernel), поэтому вам либо надо пропатчить ядро (патчи можно найти на <ulink url="http://www.tuxonice.net/">tuxonice.net</ulink>), либо использовать sys-kernel/tuxonice-sources.</para>
<para>Настройки ядра и для swsusp и для TuxOnIce следующие:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 7.4: Настройки ядра для hibernate</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>Power Management Options ---&gt;</para>
<para>  (hibernate with swsusp)</para>
<para>  [*] Software Suspend</para>
<para>      (replace /dev/SWAP with your swap partition)</para>
<para>      (/dev/SWAP)      Default resume partition</para>
<para/>
<para>  (hibernate with TuxOnIce)</para>
<para>  Enhanced Hibernation (TuxOnIce)</para>
<para>    --- Image Storage (you need at least one writer)</para>
<para>    [*]     File Writer</para>
<para>    [*]    Swap Writer</para>
<para>    ---   General Options</para>
<para>    [*]    LZF image compression</para>
<para>    (replace /dev/SWAP with your swap partition)</para>
<para>    (swap:/dev/SWAP)   Default resume device name</para>
<para>    [ ]     Allow Keep Image Mode</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Настройка swsusp много проще. Если вы не вписали имя своп-раздела в настройках ядра, вы должны передать его как параметр в директиве resume=/dev/SWAP. Если загрузка невозможна из-за сломанного образа, воспользуйтесь параметром noresume. Скрипт инициализации hibernate-cleanup чистит (invalidates) образы swsusp во время загрузки.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 7.5: Чистка образов swsusp во время загрузки</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># rc-update add hibernate-cleanup boot </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Для активации swsusp, используйте hibernate script, установив UseSysfsPowerState disk в /etc/hibernate/sysfs-disk.</para>
<para>Предупреждение: Сделайте резервную копию данных перед остановкой. Запустите sync, чтобы записать на диск всю кэшированную информацию. Вначале, попробуйте сделать это без иксов, потом в иксах, но не логинясь. </para>
<para>Если вы наталкиваетесь на панику ядра (kernel panic) из-за uhci или подобного, попробуйте скомпилировать поддержку usb модулем и выгрузить модули из памяти перед остановкой. Соответствующая опция есть в common.conf.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 7.6: Засыпание посредством swsusp</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># nano -w /etc/hibernate/common.conf (Час X - вы сделали резерную копию?) </para>
<para># hibernate </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>В следующей секции обсуждается установка TunOnIce, включая поддержку fbsplash для симпатичного графического индикатора прогресса во время засыпания и просыпания.</para>
<para>Первая часть конфигурации похожа на настройку swsusp. Если вы не вписали имя своп-раздела в настройках ядра, вы должны передать его как параметр в директиве resume=swap:/dev/SWAP. Если загрузка невозможна из-за сломанного образа, воспользуйтесь параметром noresume. Скрипт инициализации hibernate-cleanup чистит (invalidates) образы TuxOnIce во время загрузки.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 7.7: Чистка образов TuxOnIce во время загрузки</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># rc-update add hibernate-cleanup boot </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь, отредактируйте /etc/hibernate/suspend2.conf, включите опцию TuxOnIce. Не включайте fbsplash в common.conf пока.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 7.8: Засыпание посредством TuxOnIce</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># nano -w /etc/hibernate/suspend2.conf (Час X - вы сделали резерную копию?) </para>
<para># hibernate </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Настройте fbsplash, если вы не сделали этого ранее. Чтобы задействовать поддержку fbsplash во время засыпания, необходимо поставить пакет sys-apps/tuxonice-userui. Также, вам необхожимо утсановить USE-флаг fbsplash.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 7.9: Установка tuxonice-userui</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># echo "sys-apps/tuxonice-userui fbsplash" &gt;&gt; /etc/portage/package.use</para>
<para>(It may be marked ~arch, so first it must be keyworded)</para>
<para># echo "sys-apps/tuxonice-userui" &gt;&gt; /etc/portage/package.keywords</para>
<para># emerge tuxonice-userui</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Ебилд попросит вас создать символическую ссылку на тему, которю вы хотите использовать. Например, чтобы использовать тему livecd-2005.1, выполните следующую команду:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 7.10: Использование темы livecd-2005.1 во время засыпания</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># ln -sfn /etc/splash/livecd-2005.1 /etc/splash/suspend2 </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Если вы не хотите видеть чёрный экран в первой части процесса пробуждения, добавьте tuxoniceui_fbsplash в ваш образ initrd. Если ваш образ initrd называется splash_geninitramfs и он сохранён в /boot/fbsplash-emergence-1024x768, то вам необходимо сделать буквально следующее:</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 7.11: Добавление tuxoniceui_fbsplash в образ initrd.</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># mount /boot</para>
<para># mkdir ~/initrd.d</para>
<para># cp /boot/fbsplash-emergence-1024x768 ~/initrd.d/</para>
<para># cd ~/initrd.d</para>
<para># gunzip -c fbsplash-emergence-1024x768 | cpio -idm --quiet -H newc</para>
<para># rm fbsplash-emergence-1024x768</para>
<para># cp /usr/sbin/tuxoniceui_fbsplash sbin/</para>
<para># find . | cpio --quiet --dereference -o -H newc | gzip -9 &gt; /boot/fbsplash-tuxonice-emergence-1024x768</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Далее, отрихтуйте ваш grub.conf (или lilo.conf), чтоб при загрузке вашего ядра грузился обрах /boot/fbsplash-tuxonice-emergence-1024x768. Вы теперь можете попробовать холостой прогон, чтоб убедиться, что всё работает правильно.</para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 7.12: Тестовый запус fbsplash hibernation</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para># tuxoniceui_fbsplash -t </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Наконец, откройте /etc/hibernate/common.conf и включите поддержку fbsplash. Запустите hibernate и наслаждайтесь!</para></sect3></sect2><sect2><title>
<anchor id="troubleshooting"/>8. Устранение неполадок</title>
<para>В: Я пытаюсь изменить частоту ЦПУ, но /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor не существует.</para>
<para>О: Убедитесь, что ваш процессор поддерживает изменение частоты и выберите правильный CPUFreq драйвер для вашего процессора. Список процессоров, поддерживающих изменение частоты (ядро 2.6.7): ARM Integrator, ARM-SA1100, ARM-SA1110, AMD Elan - SC400, SC410, AMD mobile K6-2+, AMD mobile K6-3+, AMD mobile Duron, AMD mobile Athlon, AMD Opteron, AMD Athlon 64, Cyrix Media GXm, Intel mobile PIII и Intel mobile PIII-M на определённых чипсетах, Intel Pentium 4, Intel Xeon, Intel Pentium M (Centrino), National Semiconductors Geode GX, Transmeta Crusoe, VIA Cyrix 3 / C3, UltraSPARC-III, SuperH SH-3, SH-4, некоторые "PowerBook" и "iBook2" и различные процессоры на совместимых с ACPI 2.0 системах (только если "ACPI Processor Performance States" доступно через интерфейс ACPI/BIOS).</para>
<para/>
<para>В: Мой ноутбук поддерживает изменение частоты, но директория /sys/devices/system/cpu/cpu0/cpufreq/ пуста.</para>
<para>О: Поищите связанные с ACPI ошибки в dmesg | grep ACPI. Попробуйте обновить BIOS, особенно, если обнаружены проблемы в DSDT. Вы также можете попробовать исправить это самостоятельно (что выходит за рамки этого руководства).</para>
<para/>
<para>В: Мой ноутбук поддерживает изменение частоты, но согласно /proc/cpuinfo частота никогда не изменяется.</para>
<para>О: Возможно, вы включили поддержку симметричной мультипроцессорной обработки (symmetric multiprocessing support) (CONFIG_SMP) в вашем ядре. Попробуйте отключить её, всё должно заработать. Также это может быть багом старых ядер. В таком случае выполните emerge x86info, обновите ваше ядро как требуется и проверьте текущую частоту через x86info -mhz.</para>
<para/>
<para>В: Я могу изменять частоты, но выбор не так широк, как на другой ОС.</para>
<para>О: Вы можете совместить изменение частоты с "торможением" через ACPI (ACPI throttling), чтобы добиться более низких частот. Но стоит понимать, что это не даст большого прироста в сохранении энергии и создана, по большой части, для температурного регулирования (чтобы ноутбук был холодным и тихим). Вы можете просмотреть текущее состояние "торможения" командой cat /proc/acpi/processor/CPU/throttling и изменить его, выполнив echo -n "0:x" &gt; /proc/acpi/processor/CPU/limit, где x - одно из возможных состояний, перечислены в /proc/acpi/processor/CPU/throttling.</para>
<para/>
<para>В: При конфигурировании ядра пункты powersave governor, performance governor и userspace governor есть, а ondemand governor отсутствует. В чём проблема? </para>
<para>О: Пункт ondemand governor появился только в последних версиях ядра. Попробуйте обновить его.</para>
<para/>
<para>В: Время жизни от батареи стало меньше, чем было.</para>
<para>О: Проверьте настройки BIOS. Возможно, вы забыли заново включить какие-то опции.</para>
<para/>
<para>В: Моя батарея заряжена, но КДЕ сообщает, что осталось 0%, и тут же выключается.</para>
<para>О: Убедитесь, что поддержка батареи выключена в вашем ядре. Если она скомпилирована модулем, то не забудьте загрузить его.</para>
<para/>
<para>В: Моя система журналирования (system logger) пишет что-то, типа "logger: ACPI group battery / action battery is not defined".</para>
<para>О: Это сообщение генерирует скрипт /etc/acpi/default.sh, которые прилагается к acpid. Вы можете просто игнорировать его. Если же вы всё-таки хотите его унять, закомментируйте соответствующую строку в /etc/acpi/default.sh как показано ниже: </para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 8.1: Отключение предупреждения о событиях ACPI</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>*) # logger "ACPI action $action is not defined" </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>В: У меня Dell Inspiron 51XX, и я не получаю никаких ACPI-событий</para>
<para>О: Скорее всего, это баг ядра. Прочтите <ulink url="http://bugme.osdl.org/show_bug.cgi?id=1752">это</ulink>.</para>
<para/>
<para>В: Я включил DynamicClocks в xorg.conf и теперь X.org рушится / экран остаётся чёрным / мой ноутбук не выключается корректно.</para>
<para>О: Такое бывает на некоторых системах. Вам придётся отключить DynamicClocks.</para>
<para/>
<para>В: Я хочу использовать TuxOnIce, но он говорит, что моя своп - партиция слишком маленькая. Изменение её размеров - не вариант.</para>
<para>О: Если в вашей системе достаточно свободного места, то вы можете использовать запись в файл, вместо запись в своп. Такой вариант поддерживается hibernate-script. Дополнительную информацию вы можете найти в /usr/src/linux/Documentation/power/tuxonice.txt.</para>
<para/>
<para>В: Я только купил новую фирмешную батарею, но она кончается за несколько минут. Что я делаю не так?</para>
<para>О: Для начала, следуйте инструкция производителя, как зарядить батарею правильно. </para>
<para>В: Выше написанное не помогло, что делать теперь?</para>
<para>О: Некоторые батареи продаются как "новые", но на самом деле уже не новы. Попробуйте следующее: </para>
<informaltable frame="all">
<tgroup cols="1">
<thead>
<row>
<entry>
<para>Листинг 8.2: Запрос состояния батареи</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>$ grep capacity /proc/acpi/battery/BAT0/info</para>
<para>design capacity:     47520 mWh</para>
<para>last full capacity:  41830 mWh</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Если "last full capacity" кардинально отличается от design capacity, ваше батарея, скорее всего, неисправна. Попробуйте потребовать гарантию. </para>
<para/>
<para>В: Моя проблема не перечислена выше. Что мне делать теперь?</para>
<para>О: Не бойтесь связаться со мной, <ulink url="mailto:earthwings@gentoo.org">Dennis Nienhüser</ulink>, напрямую. Также вам, наверняка, помогут на <ulink url="http://forums.gentoo.org/">Форумах Gentoo</ulink>. Если вы предпочитается IRC, заходите в канал #gentoo-laptop на <ulink url="irc://irc.freenode.net">irc.freenode.net</ulink>
</para>
<para/>
<para>Замечания к переводуНе удалось найти хороший перевод слову governor. Хороший означает, что оно не слишком общо (как, например, драйвер), ну и подходит по смыслу ;) . Поэтому в тексте используется слово властелин, формально подходящее под условия, но слишком уж не формальное. </para>
<para/></sect2></sect1><sect1><title>Gentoo и СУБД</title><sect2><title>Руководство по MySQL для начинающих</title>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/udev-guide.xml">http://www.gentoo.org/doc/ru/mysql-howto.xml</ulink>
</para>
<para>C версии: 1.5</para><sect3><title>1. Начало работы с MySQL</title><sect4><title>
<anchor id="doc_chap1_sect1"/>Введение</title>
<para>MySQL — это популярный сервер баз данных, используемый в различных областях. Аббревиатура SQL означает Structured Query Language (язык структурированных запросов), именно его использует MySQL для общения с другими программами. Более того, в MySQL есть собственные расширенные функции SQL, дающие дополнительные возможности пользователям. В этом руководстве рассматривается процесс начальной установки MySQL, настройка баз данных и таблиц, заведение новых пользователей. Итак, начнем с установки. </para></sect4><sect4><title>
<anchor id="doc_chap1_sect2"/>Установка MySQL</title>
<para>Сначала нужно установить MySQL. Если вам нужны определенные возможности MySQL, установите соответствующие флаги USE, которые позволяют точнее регулировать процесс установки. </para>
<para>
<anchor id="doc_chap1_pre1"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1.1: Установка MySQL</para>
</entry>
</row>
<row>
<entry>
<para>(просмотр имеющихся флагов USE)</para>
<para># emerge --pretend --verbose mysql</para>
<para>(установка MySQL)</para>
<para># emerge mysql</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>По завершении установки вы увидите такое сообщение: </para>
<para>
<anchor id="doc_chap1_pre2"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1.2: Сообщение программы MySQL einfo</para>
</entry>
</row>
<row>
<entry>
<para>You might want to run:</para>
<para>"emerge --config =dev-db/mysql-[version]"</para>
<para>if this is a new install.</para>
<para/>
<para>Рекомендуется запустить команду</para>
<para>"emerge --config =dev-db/mysql-[версия]"</para>
<para>после первоначальной установки MySQL.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Поскольку у нас первоначальная установка, запустим команду. Во время настройки базы данных MySQL вам потребуется по запросу нажать клавишу ENTER. В процессе настройки устанавливается главная база данных MySQL, содержащая служебные сведения о базах данных, таблицах, пользователях, правах доступа и т.д. При настройке будет рекомендовано как можно раньше изменить корневой пароль. Мы определенно это сделаем, чтобы кто-нибудь не смог улучшить момент и взломать наш сервер MySQL, настроенный по умолчанию. </para>
<para>
<anchor id="doc_chap1_pre3"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1.3: Настройка MySQL</para>
</entry>
</row>
<row>
<entry>
<para># ebuild /var/db/pkg/dev-db/mysql-[version]/mysql-[version].ebuild config</para>
<para> * MySQL DATADIR is /var/lib/mysql</para>
<para> * Press ENTER to create the mysql database and set proper</para>
<para> * permissions on it, or Control-C to abort now...</para>
<para/>
<para>   Preparing db table</para>
<para>   Preparing host table</para>
<para>   Preparing user table</para>
<para>   Preparing func table</para>
<para>   Preparing tables_priv table</para>
<para>   Preparing columns_priv table</para>
<para>   Installing all prepared tables</para>
<para/>
<para>   To start mysqld at boot time you have to copy support-files/mysql.server</para>
<para>   to the right place for your system</para>
<para/>
<para>   PLEASE REMEMBER TO SET A PASSWORD FOR THE MySQL root USER !</para>
<para>   To do so, issue the following commands to start the server</para>
<para>   and change the applicable passwords:</para>
<para>(обратите внимание на следующие 3 строки)</para>
<para>   /etc/init.d/mysql start</para>
<para>   /usr/bin/mysqladmin -u root -h pegasos password 'new-password'</para>
<para>   /usr/bin/mysqladmin -u root password 'new-password'</para>
<para>   Depending on your configuration, a -p option may be needed</para>
<para>   in the last command. See the manual for more details.</para>
<para/>
<para>(различные сообщения, не относящиеся к установке, опущены для краткости)</para>
<para/>
<para>   * For security reasons you should set your MySQL root</para>
<para>   * password as soon as possible.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Важно: Начиная с mysql-4.0.24-r2, пароли вводятся на этапе настройки, что повышает надежность ввода корневого пароля. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Сценарий установки уже отобразил команды, нужные для установки пароля. Теперь запустим их. </para>
<para>
<anchor id="doc_chap1_pre4"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1.4: Установка корневого пароля MySQL</para>
</entry>
</row>
<row>
<entry>
<para># /etc/init.d/mysql start</para>
<para> * Re-caching dependency info (mtimes differ)...</para>
<para> * Starting mysqld (/etc/mysql/my.cnf) ...        [ ok ]</para>
<para>(вместо 'новый-пароль' укажите ваш пароль)</para>
<para># /usr/bin/mysqladmin -u root -h localhost password 'новый-пароль'</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь вы можете убедиться в работоспособности нового пароля, попытавшись войти на свой сервер MySQL: </para>
<para>
<anchor id="doc_chap1_pre5"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 1.5: Вход на сервер MySQL программой mysql</para>
</entry>
</row>
<row>
<entry>
<para>$ mysql -u root -h localhost -p</para>
<para>Enter password:</para>
<para>Welcome to the MySQL monitor. Commands end with ; or \g.</para>
<para>Your MySQL connection id is 4 to server version: 4.0.25</para>
<para/>
<para>Type 'help;' or '\h' for help. Type '\c' to clear the buffer.</para>
<para/>
<para>mysql&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Параметр -u указывает пользователя, который будет входить в систему. Параметр -h указывает узел сети. Обычно это localhost, если вы настраиваете не удаленный сервер. Наконец, -p сообщает программе-клиенту mysql, что для доступа к базе данных будет вводится пароль. Обратите внимание на приглашение mysql&gt;. Именно здесь вы будете вводить все свои команды. Теперь, находясь в среде mysql в качестве корневого пользователя, мы можем начать настройку базы данных. </para></sect4></sect3><sect3><title>
<anchor id="doc_chap2"/>2.  Настройка базы данных</title><sect4><title>
<anchor id="doc_chap2_sect1"/>Создание базы данных</title>
<para>Мы вошли, и на экране — приглашение mysql. Сначала взглянем на список уже имеющихся баз данных. Для этого введем команду SHOW DATABASES. </para>
<para>
<anchor id="doc_chap2_pre1"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.1: Вывод списка баз данных MySQL</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SHOW DATABASES;</para>
<para>+----------+</para>
<para>| Database |</para>
<para>+----------+</para>
<para>| mysql    |</para>
<para>| test     |</para>
<para>+----------+</para>
<para>2 rows in set (0.09 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Важно: Запомните, что команды MySQL следует заканчивать точкой с запятой — ; </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Несмотря на то, что база данных test уже создана, создадим свою собственную. Базы данных создаются командой CREATE DATABASE. Мы назовем свою gentoo. </para>
<para>
<anchor id="doc_chap2_pre2"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.2: Создание базы данных gentoo</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; CREATE DATABASE gentoo;</para>
<para>Query OK, 1 row affected (0.08 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Ответ дает понять, что команда выполнена без каких-либо ошибок. В данном случае, изменилась одна строка. Это относится к главной базе данных mysql, в которой содержится список всех баз данных. Но вам не нужно слишком беспокоиться о второстепенных подробностях. Последнее число означает время выполнения запроса. Убедиться, что база данных создана, мы можем, снова запустив команду SHOW DATABASES. </para>
<para>
<anchor id="doc_chap2_pre3"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.3: Проверка наличия базы данных</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SHOW DATABASES;</para>
<para>+----------+</para>
<para>| Database |</para>
<para>+----------+</para>
<para>| gentoo   |</para>
<para>| mysql    |</para>
<para>| test     |</para>
<para>+----------+</para>
<para>3 rows in set (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Разумеется, наша база данных создана. Чтобы заняться созданием таблиц в новой базе данных gentoo, нам потребуется установить ее как текущую. Для этого используем команду USE. Параметром этой команды указывается название базы данных, которую нужно сделать текущей. Еще текущую базу можно устанавливать в командной строке, указывая ее название после параметра -D. Давайте продолжим и переключимся на базу данных gentoo. </para>
<para>
<anchor id="doc_chap2_pre4"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 2.4: Переключение базы данных</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; USE gentoo;</para>
<para>Database changed</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь текущей является только что созданная база данных gentoo. Теперь, используя ее, мы можем заняться созданием таблиц и наполнением их информацией. </para></sect4></sect3><sect3><title>
<anchor id="doc_chap3"/>3.  Работа с таблицами в MySQL</title><sect4><title>
<anchor id="doc_chap3_sect1"/>Создание таблицы</title>
<para>В структуру MySQL входят базы данных, таблицы, записи и поля. В базах данных собраны таблицы, в таблицах собраны записи, в записях — поля, в которых, в свою очередь, хранится собственно информация. Такая структура позволяет пользователям выбирать, каким образом обращаться к своей информации. Только что мы работали с базами данных, теперь давайте поработаем с таблицами. Для начала, список таблиц можно вывести так же, как и список баз данных, используя команду SHOW TABLES. Сейчас в нашей базе данных gentoo еще нет таблиц, как показывает эта команда: </para>
<para>
<anchor id="doc_chap3_pre1"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.1: Пустая база данных gentoo</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SHOW TABLES;</para>
<para>Empty set (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Значит, нужно создать несколько таблиц. Чтобы это сделать, используем команду CREATE TABLE. Однако, эта команда довольно сильно отличается от простой команды CREATE DATABASE. Ей передается список аргументов следующего вида: </para>
<para>
<anchor id="doc_chap3_pre2"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.2: Синтаксис CREATE TABLE</para>
</entry>
</row>
<row>
<entry>
<para>CREATE TABLE [имя_таблицы] ([имя_поля] [тип_данных_поля]([размер]));</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>имя_таблицы — имя создаваемой таблицы. В данном случае, давайте создадим таблицу с названием developers (разработчики). В таблице будут находится имена разработчиков, адреса электронной почты и род занятий. имя_поля будет содержать имена полей. Нам нужны три имени: name (имя), email (почта) и job (род занятий). В параметре тип_данных_поля укажем тип заносимой информации. Перечень возможных форматов находится на <ulink url="http://dev.mysql.com/doc/mysql/en/column-types.html">странице описания типов столбцов MySQL (англ.)</ulink>. Здесь мы для всех полей укажем тип VARCHAR. VARCHAR — один из простейших типов данных, предназначенный для работы со строками. размер указывает, сколько данных можно сохранить в одном поле. Укажем 128. Это значит, что поле сможет содержать 128 байт данных типа VARCHAR. Cейчас можно упрощенно считать, что это 128 знаков текста, хотя на вышеупомянутом сайте представлено более точное описание. Теперь, зная, какую мы собираемся создать таблицу, сделаем это. </para>
<para>
<anchor id="doc_chap3_pre3"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.3: Создание таблицы</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; CREATE TABLE developers ( name VARCHAR(128), email VARCHAR(128), job VARCHAR(128));</para>
<para>Query OK, 0 rows affected (0.11 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Похоже, таблица создалась нормально. Давайте проверим это командой SHOW TABLES: </para>
<para>
<anchor id="doc_chap3_pre4"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.4: Проверка таблицы</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SHOW TABLES;</para>
<para>+------------------+</para>
<para>| Tables_in_gentoo |</para>
<para>+------------------+</para>
<para>| developers       |</para>
<para>+------------------+</para>
<para>1 row in set (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Да, это она! Но не показано никакой информации о введенных типах полей. Для этого используем команду DESCRIBE (или ее краткий вариант, DESC), параметром которой указывается имя таблицы. Посмотрим, что она выдаст для таблицы developers. </para>
<para>
<anchor id="doc_chap3_pre5"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.5: Описание таблицы developers</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; DESCRIBE developers;</para>
<para>+-------+--------------+------+-----+---------+-------+</para>
<para>| Field | Type         | Null | Key | Default | Extra |</para>
<para>+-------+--------------+------+-----+---------+-------+</para>
<para>| name  | varchar(128) | YES  |     | NULL    |       |</para>
<para>| email | varchar(128) | YES  |     | NULL    |       |</para>
<para>| job   | varchar(128) | YES  |     | NULL    |       |</para>
<para>+-------+--------------+------+-----+---------+-------+</para>
<para>3 rows in set (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Показаны различные поля и их типы. Видно также несколько дополнительных атрибутов, выходящих за рамки этого руководства. За дополнительными сведениями можно обратиться к <ulink url="http://dev.mysql.com/doc/mysql/en/">Руководству по MySQL (англ.)</ulink>. Теперь у нас есть рабочая таблица. Давайте двинемся дальше и наполним ее. </para>
<para>
<anchor id="doc_chap3_sect2"/>Заполнение базы данных MySQL</para>
<para>Таблица заполняется (данные добавляются) командой INSERT. Как и у команды CREATE TABLE, у нее есть определенный формат: </para>
<para>
<anchor id="doc_chap3_pre6"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.6: Синтаксис INSERT</para>
</entry>
</row>
<row>
<entry>
<para>INSERT INTO имя_таблицы (столбец1, столбец2, ...) VALUES('знач1','знач2',...); </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Эту команду используют для вставки записей в таблицу. Сначала указывается имя таблицы, в которую нужно добавить информацию. Затем может идти список столбцов, в которые добавляются данные, а в VALUES указываются значения, которые добавляются в таблицу. Можно опустить список полей, если значения добавляются в каждое в том же порядке, в каком определены поля в таблице. Сейчас мы добавим данные в теблицу developers. Вставьте записи как в примере: </para>
<para>
<anchor id="doc_chap3_pre7"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.7: Добавление информации в таблицу developers</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; INSERT INTO developers VALUES('Joe Smith', 'joesmith@gentoo.org', 'toolchain');</para>
<para>Query OK, 1 row affected (0.06 sec)</para>
<para>(Если вы не знаете порядок полей в таблице или хотите добавить</para>
<para>неполную запись)</para>
<para>mysql&gt; INSERT INTO developers (job, name) VALUES('outsourced', 'Jane</para>
<para>Doe');</para>
<para>Query OK, 1 row affected (0.01 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Согласно полученному ответу, запись, похоже, добавилась правильно. Но что если требуется ввести более одной записи? Именно здесь пригодиться команда LOAD DATA. Она загружает записи из файла, разделенного знаками табуляции. Попробуем создать файл с записями в своем домашнем каталоге. Назовем его records.txt. Вот пример: </para>
<para>
<anchor id="doc_chap3_pre8"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.8: ~/records.txt</para>
</entry>
</row>
<row>
<entry>
<para>John Doe        johndoe@gentoo.org      portage</para>
<para>Chris White     chriswhite@gentoo.org   documentation</para>
<para>Sam Smith       samsmith@gentoo.org     amd64</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Важно: Всегда уточняйте, с какими данными работаете. Чрезвычайно небезопасно использовать LOAD DATA, если вы не знаете, что находится внутри файла! </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Вообще, у команды LOAD DATA весьма пространное определение, но сейчас мы используем простейшую форму. </para>
<para>
<anchor id="doc_chap3_pre9"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.9: Синтаксис LOAD DATA</para>
</entry>
</row>
<row>
<entry>
<para>LOAD DATA LOCAL INFILE '/путь/к/файлу' INTO TABLE имя_таблицы;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Здесь тоже все просто. Укажите путь к файлу и имя таблицы. В нашем случае — это файл ~/records.txt и таблица developers. </para>
<para>
<anchor id="doc_chap3_pre10"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.10: Загрузка данных</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; LOAD DATA LOCAL INFILE '~/records.txt' INTO TABLE developers;</para>
<para>Query OK, 3 rows affected (0.00 sec)</para>
<para>Records: 3  Deleted: 0  Skipped: 0  Warnings: 0</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Важно: Если вы столкнетесь со странностями, убедитесь, что поля разделены табуляторами. Если вы вставляете информацию в файл из другого источника, табуляторы могут преобразоваться в пробелы. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Сработало. Но эта команда просто добавляет записи и не дает проконтролировать работу MySQL. Множество веб-приложений используют сценарии sql для быстрой и легкой настройки базы данных MySQL. Если вы хотите использовать сценарий sql, вам понадобится запустить mysql в пакетном режиме (в качестве ввода используется файл со сценарием). Вот пример запуска mysql в пакетном режиме: </para>
<para>
<anchor id="doc_chap3_pre11"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.11: MySQL в пакетном режиме</para>
</entry>
</row>
<row>
<entry>
<para>$ mysql -u root -h localhost -p &lt; sqlfile</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Как и в случае с LOAD DATA, убедитесь, что знаете, что именно выполняет файл sqlfile. Не делая этого, вы можете подвергнуть вашу базу данных серьезному риску утечки! Другой путь заключается в использовании команды source. Эта команда запускает команды mysql из файла, когда mysql находится в интерактивном режиме. Вот как взять команды sql из файла: </para>
<para>
<anchor id="doc_chap3_pre12"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.12: Исполнение команд sql из файла</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; source sqlfile;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Если вы столкнетесь с веб-приложением, которому нужно, чтобы вы запустили файл с командами sql, можно использовать одну из двух команд, показанных выше. Итак, наша таблица сформирована, но как же работать с полями? Это делается поиском в таблице при помощи запросов. </para></sect4><sect4><title>
<anchor id="doc_chap3_sect3"/>Запросы к таблицам в MySQL</title>
<para>Одна из главных функций любой базы данных SQL — запросы. Они помогают обратить данные из таблиц во что-то полезное. Большинство запросов выполняется командой SELECT. Эта команда довольно сложна, поэтому в этом документе мы рассмотрим лишь три основных ее формы. </para>
<para>
<anchor id="doc_chap3_pre13"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.13: Формы SELECT</para>
</entry>
</row>
<row>
<entry>
<para>(Выборка всех записей в таблице)</para>
<para>SELECT * FROM имя_таблицы;</para>
<para>(Выборка конкретных записей в таблице)</para>
<para>SELECT * FROM имя_таблицы WHERE поле=значение;</para>
<para>(Выборка конкретных полей)</para>
<para>SELECT поле1,поле2,поле3 FROM имя_таблицы [WHERE поле=значение];</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Посмотрим на первую форму. Она относительно проста и позволяет взглянуть на всю таблицу. Попробуем: запустим эту команду, чтобы увидеть, что находится в нашей таблице. </para>
<para>
<anchor id="doc_chap3_pre14"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.14: Содержимое таблицы developers</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SELECT * FROM developers;</para>
<para>+-------------+-----------------------+----------------+</para>
<para>| name        | email                 | job            |</para>
<para>+-------------+-----------------------+----------------+</para>
<para>| Joe Smith   | joesmith@gentoo.org   | toolchain      |</para>
<para>| John Doe    | johndoe@gentoo.org    | portage        |</para>
<para>| Chris White | chriswhite@gentoo.org | documentation  |</para>
<para>| Sam Smith   | samsmith@gentoo.org   | amd64          |</para>
<para>| Jane Doe    | NULL                  | Outsourced job |</para>
<para>+-------------+-----------------------+----------------+</para>
<para>5 rows in set (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Видно данные, не только вставленные путем INSERT, но и вставленные командой LOAD DATA. Теперь, к примеру, нужно посмотреть запись для Chris White. Это можно сделать, используя вторую форму выборки. </para>
<para>
<anchor id="doc_chap3_pre15"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.15: Выборка конкретной записи, используя SELECT</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SELECT * FROM developers WHERE name = 'Chris White';</para>
<para>+-------------+-----------------------+---------------+</para>
<para>| name        | email                 | job           |</para>
<para>+-------------+-----------------------+---------------+</para>
<para>| Chris White | chriswhite@gentoo.org | documentation |</para>
<para>+-------------+-----------------------+---------------+</para>
<para>1 row in set (0.08 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Как и ожидалось, отобрана нужная искомая запись. Теперь, допустим, что нужно знать только род занятий и адрес электронной почты, но не имя. Это делается при помощи третьей формы SELECT, как показано ниже. </para>
<para>
<anchor id="doc_chap3_pre16"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 3.16: Выборка нужной записи и полей с помощью SELECT</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SELECT email,job FROM developers WHERE name = 'Chris White';</para>
<para>+-----------------------+---------------+</para>
<para>| email                 | job           |</para>
<para>+-----------------------+---------------+</para>
<para>| chriswhite@gentoo.org | documentation |</para>
<para>+-----------------------+---------------+</para>
<para>1 row in set (0.04 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Этот способ выборки легче в управлении, особенно при больших объемах информации, как показано далее. Сейчас, войдя как суперпользователь, вы обладаете неограниченными правами на любые действия в MySQL. Пользователь с такими привилегиями в серверной среде может быть достаточно трудноуправляемым. Чтобы управлять тем, кто и что может делать с базами данных, надо устанавливать привилегии. </para></sect4></sect3><sect3><title>
<anchor id="doc_chap4"/>4.  Привилегии в MySQL</title><sect4><title>
<anchor id="doc_chap4_sect1"/>Предоставление привилегий командой GRANT</title>
<para>Привилегиями определяются возможности доступа пользователей к базам данных, таблицам... почти ко всему. Сейчас только суперпользователь root из MySQL может обращаться к базе данных gentoo, согласно данным разрешениям. Давайте создадим двух самых обычных пользователей, например, guest (гостя) и admin (администратора), которые будут обращаться к базе данных gentoo и работать с информацией из нее. Пусть пользователь guest будет ограничен в правах, и все, что он сможет — это получать информацию из базы данных. admin получит те же права доступа, что и root, но только к базе данных gentoo (не к основным базам mysql). Но прежде, чем начать, давайте взглянем на несколько упрощенный формат команды GRANT. </para>
<para>
<anchor id="doc_chap4_pre1"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.1: Синтаксис GRANT</para>
</entry>
</row>
<row>
<entry>
<para>GRANT [привилегии] ON база_данных.* TO '[пользователь]'@'[узел]'</para>
<para>IDENTIFIED BY '[пароль]';</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Команда GRANT считается способом создания пользователя. Поздние версии MySQL, однако, также содержат функцию CREATE_USER, хотя GRANT до сих пор предпочительнее. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь нужны привилегии, которые можно присваивать. Используя все вышесказанное, можно устанавливать следующие привилегии: </para>
<orderedlist>
<listitem>
<para>ALL - дается полный доступ ко всей базе данных </para>
</listitem>
<listitem>
<para>CREATE - пользователям позволяется создавать таблицы </para>
</listitem>
<listitem>
<para>SELECT - пользователям позволяется делать запросы к таблицам </para>
</listitem>
<listitem>
<para>INSERT - пользователям позволяется вставлять данные в таблицу </para>
</listitem>
<listitem>
<para>SHOW DATABASES - разрешается выводить список баз данных </para>
</listitem>
<listitem>
<para>USAGE - у пользователя нет привилегий </para>
</listitem>
<listitem>
<para>GRANT OPTION - пользователям разрешается давать привилегии </para>
</listitem>
</orderedlist>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Если вы используете MySQL для обмена данными с веб-приложением, то разъясняемые здесь привилегии CREATE, SELECT, INSERT, а также привилегии DELETE и UPDATE (описанные в <ulink url="http://dev.mysql.com/doc/mysql/en/grant.html">руководстве по MySQL, раздел GRANT and REVOKE Syntax (англ.)</ulink>) — единственные, которые, вероятно, потребуются. Многие совершают ошибку, раздавая все привилегии, когда это, в действительности, не нужно. Сверьтесь с разработчиками приложений, действительно ли такие разрешения создадут проблемы в работе. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Для нашего пользователя admin подойдет ALL. А для пользователя guest привилегии SELECT будет достаточно для доступа на чтение. В качестве базы данных укажем gentoo, на нее будут установлены разрешения. .* означает «все таблицы». Если потребуется, можно установить права доступа к отдельным таблицам. Дальше идет имя пользователя и имя узла, с которого будет работать пользователь. В большинстве случаев это будет узел localhost. Наконец, задается пароль пользователя. Исходя из этого, давайте создадим пользователей. </para>
<para>
<anchor id="doc_chap4_pre2"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.2: Создание пользователей admin и guest</para>
</entry>
</row>
<row>
<entry>
<para>(admin)</para>
<para>mysql&gt; GRANT ALL ON gentoo.* TO 'admin'@'localhost' IDENTIFIED BY 'пароль';</para>
<para>(guest)</para>
<para>mysql&gt; GRANT SELECT ON gentoo.* TO 'guest'@'localhost' IDENTIFIED BY 'пароль';</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Итак, пользователи созданы; теперь протестируем их. Сначала выйдем из mysql, написав quit в строке приглашения: </para>
<para>
<anchor id="doc_chap4_pre3"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.3: Выход из MySQL</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; quit</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь мы снова в консоли. Пользователи настроены, давайте посмотрим, что они могут делать. </para></sect4><sect4><title>
<anchor id="doc_chap4_sect2"/>Проверка прав пользователей</title>
<para>Попробуем зайти как пользователь guest. В данный момент у пользователя guest есть только право выборки (SELECT). В основном, это сводится к возможности поиска и ничему другому. Зайдем как пользователь guest. </para>
<para>
<anchor id="doc_chap4_pre4"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.4: Вход опользователя guest</para>
</entry>
</row>
<row>
<entry>
<para>$ mysql -u guest -h localhost -p</para>
<para>Enter password:</para>
<para>Welcome to the MySQL monitor. Commands end with ; or \g.</para>
<para>Your MySQL connection id is 6 to server version: 4.0.25</para>
<para/>
<para>Type 'help;' or '\h' for help. Type '\c' to clear the buffer.</para>
<para/>
<para>mysql&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь нам нужно проверить его ограничения. Переключимся на базу данных gentoo: </para>
<para>
<anchor id="doc_chap4_pre5"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.5: Переключение на базу gentoo</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; USE gentoo;</para>
<para>Reading table information for completion of table and column names</para>
<para>You can turn off this feature to get a quicker startup with -A</para>
<para/>
<para>Database changed</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь попытаемся сделать что-нибудь недозволенное. Попробуем создать таблицу. </para>
<para>
<anchor id="doc_chap4_pre6"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.6: Попытка создать таблицу пользователем guest</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; CREATE TABLE test (test VARCHAR(20), foobar VARCHAR(2));</para>
<para>ERROR 1044: Access denied for user: 'guest@localhost' to database 'gentoo'</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Как видно, это не удалось, из-за того, что у пользователя недостаточно прав. Но ему дано право на использование SELECT. Давайте проверим: </para>
<para>
<anchor id="doc_chap4_pre7"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.7: Попытка выборки командой SELECT</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SELECT * FROM developers;</para>
<para>+-------------+-----------------------+----------------+</para>
<para>| name        | email                 | job            |</para>
<para>+-------------+-----------------------+----------------+</para>
<para>| Joe Smith   | joesmith@gentoo.org   | toolchain      |</para>
<para>| John Doe    | johndoe@gentoo.org    | portage        |</para>
<para>| Chris White | chriswhite@gentoo.org | documentation  |</para>
<para>| Sam Smith   | samsmith@gentoo.org   | amd64          |</para>
<para>| Jane Doe    | NULL                  | Outsourced job |</para>
<para>+-------------+-----------------------+----------------+</para>
<para>5 rows in set (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Команда успешно отработала, а получили представление о том, на что способны права пользователей. Но мы ведь еще создали пользователя admin. Он создавался для демонстрации того, что даже у пользователей, которым даны все права, могут быть ограничения. Выйдите из MySQL и зайдите как пользователь admin. </para>
<para>
<anchor id="doc_chap4_pre8"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.8: Вход пользователя admin</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; quit</para>
<para>Bye</para>
<para>$ mysql -u admin -h localhost -p</para>
<para>Enter password:</para>
<para>Welcome to the MySQL monitor. Commands end with ; or \g.</para>
<para>Your MySQL connection id is 7 to server version: 4.0.25</para>
<para/>
<para>Type 'help;' or '\h' for help. Type '\c' to clear the buffer.</para>
<para/>
<para>mysql&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Для начала, попробуем создать новую базу данных как пользователь admin. У пользователя admin схожие права с учетной записью root в MySQL, и он может вносить любые изменения, выбрав базу данных gentoo. Мы проверим права его доступа к главной базе данных MySQL. Вспомним, что ранее мы дали ему права только для доступа к конкретной базе данных. </para>
<para>
<anchor id="doc_chap4_pre9"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.9: Попытка создания новой базы данных</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; CREATE DATABASE gentoo2;</para>
<para>ERROR 1044: Access denied for user: 'admin@localhost' to database 'gentoo2'</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Разумеется, пользователь admin не может создавать базы данных в основной базе MySQL, несмотря на все права на базу данных gentoo. Но admin все еще может изменять базу данных gentoo, как показывает вставка данных в следующем примере. </para>
<para>
<anchor id="doc_chap4_pre10"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.10: Права admin в базе данных gentoo</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; USE gentoo;</para>
<para>Reading table information for completion of table and column names</para>
<para>You can turn off this feature to get a quicker startup with -A</para>
<para/>
<para>Database changed</para>
<para>mysql&gt; INSERT INTO developers VALUES('Bob Simmons', 'bobsimmons@gentoo.org', 'python');</para>
<para>Query OK, 1 row affected (0.08 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Пользователь admin может обращаться к базе gentoo, как захочет. Но иногда требуется лишить пользователя прав. Это может быть что угодно, начиная с проблематичного пользоватля, и заканчивая ушедшим сотрудником. Давайте разберемся, как отзывать разрешения с помощью команды REVOKE. </para></sect4><sect4><title>
<anchor id="doc_chap4_sect3"/>Удаление прав пользователя командой REVOKE</title>
<para>Команда REVOKE позволяет запретить доступ пользователю. Можно либо запретить любой доступ, либо только определенный. В самом деле, формат очень похож на GRANT. </para>
<para>
<anchor id="doc_chap4_pre11"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.11: Синтаксис REVOKE</para>
</entry>
</row>
<row>
<entry>
<para>REVOKE [привилегии] ON база_данных.* FROM '[пользователь]'@'[узел]';</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Параметры объясняются в разделе команды GRANT. А сейчас мы запретим пользователю любой вид доступа. Скажем, мы выяснили, что учетная запись guest вызывает проблемы с безопасностью. Мы решаем отозвать все права. Заходим как root делаем необходимое. </para>
<para>
<anchor id="doc_chap4_pre12"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.12: Отзыв разрешений для пользователя user</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; REVOKE ALL ON gentoo.* FROM 'guest'@'localhost';</para>
<para>Query OK, 0 rows affected (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: В данном случае, доступ пользователя прост, поэтому отмена прав на одну базу данных — не проблема. Но обычно вам, скорее всего, потребуется использовать *.* вместо gentoo.*, чтобы заодно отменить доступ пользователя ко всем остальным базам данных.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Давайте выйдем и попробуем зайти как пользователь guest. </para>
<para>
<anchor id="doc_chap4_pre13"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.13: Попытка зайти как пользователь guest</para>
</entry>
</row>
<row>
<entry>
<para>$ mysql -u guest -h localhost -p</para>
<para>Enter password:</para>
<para>Welcome to the MySQL monitor. Commands end with ; or \g.</para>
<para>Your MySQL connection id is 9 to server version: 4.0.25</para>
<para/>
<para>Type 'help;' or '\h' for help. Type '\c' to clear the buffer.</para>
<para/>
<para>mysql&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Хотя нам удалось войти, доступ к базе gentoo уже пропал. </para>
<para>
<anchor id="doc_chap4_pre14"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.14: Пользователю guest запрещен доступ </para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; USE gentoo;</para>
<para>ERROR 1044: Access denied for user: 'guest@localhost' to database 'gentoo'</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>И наш проблематичный пользователь больше не может обращаться к базе gentoo. Заметьте, что пользователь сохранил возможность входа. Это потому, что он остается в основной базе данных MySQL. Теперь взглянем, как полностью удалить учетную запись командой DELETE, и посмотрим на таблицу пользователей MySQL. </para></sect4><sect4><title>
<anchor id="doc_chap4_sect4"/>Удаление учетных записей командой DELETE</title>
<para>Таблица пользователей MySQL — это список пользователей и информации о них. Убедитесь, что вы зашли как root. Используйте основную базу данных MySQL. </para>
<para>
<anchor id="doc_chap4_pre15"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.15: Использование основной базы mysql</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; USE mysql;</para>
<para>Reading table information for completion of table and column names</para>
<para>You can turn off this feature to get a quicker startup with -A</para>
<para/>
<para>Database changed</para>
<para>mysql&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Посмотрим, какие в базе mysql существуют таблицы: </para>
<para>
<anchor id="doc_chap4_pre16"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.16: Список таблиц БД mysql</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SHOW TABLES;</para>
<para>+-----------------+</para>
<para>| Tables_in_mysql |</para>
<para>+-----------------+</para>
<para>| columns_priv    |</para>
<para>| db              |</para>
<para>| func            |</para>
<para>| host            |</para>
<para>| tables_priv     |</para>
<para>| user            |</para>
<para>+-----------------+</para>
<para>6 rows in set (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Таблица user — та, что нужна. В ней 30 различных полей, и ее сложно читать. Для облегчения чтения используем третью форму команды SELECT. Искомые поля — Host (узел) и User (пользователь). </para>
<para>
<anchor id="doc_chap4_pre17"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.17: Нахождение пользователя guest в таблице user</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; SELECT Host,User FROM user WHERE User = 'guest';</para>
<para>+-----------+-------+</para>
<para>| Host      | User  |</para>
<para>+-----------+-------+</para>
<para>| localhost | guest |</para>
<para>+-----------+-------+</para>
<para>1 row in set (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь, получив информацию, мы можем избавиться от пользователя guest. Это делается командой DELETE; вот ее синтаксис: </para>
<para>
<anchor id="doc_chap4_pre18"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.18: Синтаксис DELETE</para>
</entry>
</row>
<row>
<entry>
<para>DELETE FROM имя_таблицы WHERE поле='значение';</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Вы могли заметить, что формат DELETE чем-то схож с форматом SELECT. Укажем поле User и значение guest. Это удалит запись из таблицы user, где пользователь — guest, удаляя нашу гостевую учетную запись. Сделаем так: </para>
<para>
<anchor id="doc_chap4_pre19"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.19: Удаление пользователя guest</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; DELETE FROM user WHERE User='guest';</para>
<para>Query OK, 1 row affected (0.07 sec)</para>
<para>(Команда FLUSH PRIVILEGES нужна, чтобы обновить разрешения)</para>
<para>mysql&gt; FLUSH PRIVILEGES;</para>
<para>Query OK, 0 rows affected (0.00 sec)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Похоже, сработало. Проверим: выйдите и попробуйте зайти как пользователь guest. </para>
<para>
<anchor id="doc_chap4_pre20"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Листинг 4.20: Попытка входа пользователя guest</para>
</entry>
</row>
<row>
<entry>
<para>mysql&gt; quit</para>
<para>Bye</para>
<para>$ mysql -u guest -h localhost -p</para>
<para>Enter password:</para>
<para>ERROR 1045: Access denied for user: 'guest@localhost' (Using password: YES)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Все, пользователь успешно удален! </para>
<para>
<anchor id="doc_chap4_sect5"/>Заключение</para>
<para>В этом руководстве в основном рассматривалась настройка MySQL из командной строки. Существует несколько альтернатив с графическим интерфейсом: </para>
<orderedlist>
<listitem>
<para>
<ulink url="http://www.phpmyadmin.net/home_page/">phpMyAdmin </ulink> — популярное средство администрирования MySQL, написанное на php. </para>
</listitem>
<listitem>
<para>
<ulink url="http://sourceforge.net/projects/mysqlnavigator/">mysqlnavigator </ulink> — оболочка MySQL для Qt. </para>
</listitem>
<listitem>
<para>
<ulink url="http://gmyclient.sourceforge.net/">gmyclient</ulink> — клиент MySQL для GNOME. </para>
</listitem>
<listitem>
<para>
<ulink url="http://www.knoda.org/">knoda</ulink> — клиент MySQL для KDE. </para>
</listitem>
</orderedlist>
<para>На этом заканчивается введение в MySQL. Надеюсь, что оно помогло вам лучше разобраться в основах MySQL и настройке базы данных. Пожалуйста, присылайте свои соображения мне по адресу Chris White. </para>
<para/>
<para/></sect4></sect3></sect2><sect2><title>PostgreSQL Guide</title>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/udev-guide.xml">http://www.gentoo.org/doc/en/postgres-howto.xml</ulink>
</para>
<para>C версии: 1.5</para><sect3><title>1.  Introduction</title><sect4><title>
<anchor id="doc_chap1_sect11"/>PostgreSQL introduction</title>
<para>When talking to most developers about the different database solutions to use, two major databases will usually form the answer. One would be MySQL, and the other is what this document will refer to, PostgreSQL. The advantages of one over the other is a somewhat long winded debate, however it is just to say that PostgreSQL has had a more firm grasp on true relational database structure than MySQL. Most of the standard features such as FOREIGN KEY was only just added in MySQL 5. However, whatever the case may be, this document assumes that you have selected PostgreSQL as the database to use. The first place to start is the emerge process. In the next section, the installation process through emerge will be described, as well as the basic configuration. </para></sect4><sect4><title>
<anchor id="doc_chap1_sect21"/>PostgreSQL installation</title>
<para>To begin, we must first emerge the PostgreSQL package. To do so, run the following code to first ensure that the options for it are properly set: </para>
<para>
<anchor id="doc_chap1_pre11"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 1.1: Checking the PostgreSQL build options</para>
</entry>
</row>
<row>
<entry>
<para># emerge -pv postgresql</para>
<para/>
<para>These are the packages that I would merge, in order:</para>
<para/>
<para>Calculating dependencies ...done!</para>
<para>[ebuild  N    ] dev-db/postgresql-8.0.4  -doc -kerberos +nls +pam +perl -pg-intdatetime +python +readline (-selinux) +ssl -tcl +xml +zlib 0 kB</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Here's a list of what the different build options indicate: </para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>USE Flag</para>
</entry>
<entry>
<para>Meaning</para>
</entry>
</row>
<row>
<entry>
<para>doc</para>
</entry>
<entry>
<para>This USE flag enables or disables the installation of documentation outside of the standard man pages. The one good time to disable this option is if you are low on space, or you have alternate methods of getting a hold of the documentation (online, etc.) </para>
</entry>
</row>
<row>
<entry>
<para>kerberos</para>
</entry>
<entry>
<para>When connecting to the database, with this option enabled, the admin has the option of using kerberos to authenticate their users/services to the database. </para>
</entry>
</row>
<row>
<entry>
<para>nls</para>
</entry>
<entry>
<para>If this option is enabled, PostgreSQL can utilize translated strings for non-English speaking users. </para>
</entry>
</row>
<row>
<entry>
<para>pam</para>
</entry>
<entry>
<para>If this option is enabled, and the admin configures the PostgreSQL configuration file properly, users/services will be able to login to a PostgreSQL database using PAM (Pluggable Authentication Module). </para>
</entry>
</row>
<row>
<entry>
<para>perl</para>
</entry>
<entry>
<para>If this option is enabled, perl bindings for PostgreSQL will be built. </para>
</entry>
</row>
<row>
<entry>
<para>pg-intdatetime</para>
</entry>
<entry>
<para>If this option is enabled, PostgreSQL will support 64 bit integer date types. </para>
</entry>
</row>
<row>
<entry>
<para>python</para>
</entry>
<entry>
<para>If this option is enabled, PostgreSQL will be built with python bindings. </para>
</entry>
</row>
<row>
<entry>
<para>readline</para>
</entry>
<entry>
<para>If this option is enabled, PostgreSQL will support readline style command line editing. This includes command history and isearch. </para>
</entry>
</row>
<row>
<entry>
<para>selinux</para>
</entry>
<entry>
<para>If this option is enabled, an selinux policy for PostgreSQL will be installed. </para>
</entry>
</row>
<row>
<entry>
<para>ssl</para>
</entry>
<entry>
<para>If this option is enabled, PostgreSQL will utilize the OpenSSL library to encrypt traffic between PostgreSQL clients and servers. </para>
</entry>
</row>
<row>
<entry>
<para>tcl</para>
</entry>
<entry>
<para>If this option is enabled, PostgreSQL will build tcl bindings. </para>
</entry>
</row>
<row>
<entry>
<para>xml</para>
</entry>
<entry>
<para>If this option is enabled, XPATH style xml support will be built. More information on using xml support with PostgreSQL can be found on: <ulink url="http://www.throwingbeans.org/postgresql_and_xml.html">PostgreSQL and XML</ulink>. </para>
</entry>
</row>
<row>
<entry>
<para>zlib</para>
</entry>
<entry>
<para>This isn't really used by PostgreSQL itself, but by pg_dump to compress the dumps it produces. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Once you've customized PostgreSQL to meet your specific needs, go ahead and start the emerge: </para>
<para>
<anchor id="doc_chap1_pre21"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 1.2: Emerge-ing PostgreSQL</para>
</entry>
</row>
<row>
<entry>
<para># emerge postgresql</para>
<para>(Output shortened)</para>
<para>&gt;&gt;&gt; /usr/lib/libecpg.so.5 -&gt; libecpg.so.5.0</para>
<para>&gt;&gt;&gt; /usr/bin/postmaster -&gt; postgres</para>
<para> * Make sure the postgres user in /etc/passwd has an account setup with /bin/bash as the shell</para>
<para> *</para>
<para> * Execute the following command</para>
<para> * emerge --config =postgresql-8.0.4</para>
<para> * to setup the initial database environment.</para>
<para> *</para>
<para>&gt;&gt;&gt; Regenerating /etc/ld.so.cache...</para>
<para>&gt;&gt;&gt; dev-db/postgresql-8.0.4 merged.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>As shown by the einfo output, there is some post setup that must be done. The next chapter will look at the actual configuration of PostgreSQL. </para></sect4></sect3><sect3><title>
<anchor id="doc_chap21"/>2.  PostgreSQL configuration</title><sect4><title>
<anchor id="doc_chap2_sect11"/>Setting up the initial database environment</title>
<para>As noted in the earlier emerge output, the initial database environment must be setup. However, before this is done, one thing needs to be considered. Unlike, say MySQL, PostgreSQL's "root" password is the password of the actual user. However, only the user is created by the ebuild not the password. So before we can begin, the password must be set for the postgres user: </para>
<para>
<anchor id="doc_chap2_pre11"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.1: Setting the password</para>
</entry>
</row>
<row>
<entry>
<para># passwd postgres</para>
<para>New UNIX password:</para>
<para>Retype new UNIX password:</para>
<para>passwd: password updated successfully</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Now that this is setup, the creation of the initial database environment can occur: </para>
<para>
<anchor id="doc_chap2_pre21"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.2: Configuring the database environment with emerge --config</para>
</entry>
</row>
<row>
<entry>
<para># emerge --config =postgresql-8.0.4</para>
<para/>
<para/>
<para>Configuring pkg...</para>
<para/>
<para> * Creating the data directory ...</para>
<para> * Initializing the database ...</para>
<para>The files belonging to this database system will be owned by user "postgres".</para>
<para>This user must also own the server process.</para>
<para/>
<para>The database cluster will be initialized with locale C.</para>
<para/>
<para>fixing permissions on existing directory /var/lib/postgresql/data ... ok</para>
<para>creating directory /var/lib/postgresql/data/global ... ok</para>
<para>creating directory /var/lib/postgresql/data/pg_xlog ... ok</para>
<para>creating directory /var/lib/postgresql/data/pg_xlog/archive_status ... ok</para>
<para>creating directory /var/lib/postgresql/data/pg_clog ... ok</para>
<para>creating directory /var/lib/postgresql/data/pg_subtrans ... ok</para>
<para>creating directory /var/lib/postgresql/data/base ... ok</para>
<para>creating directory /var/lib/postgresql/data/base/1 ... ok</para>
<para>creating directory /var/lib/postgresql/data/pg_tblspc ... ok</para>
<para>selecting default max_connections ... 100</para>
<para>selecting default shared_buffers ... 1000</para>
<para>creating configuration files ... ok</para>
<para>creating template1 database in /var/lib/postgresql/data/base/1 ... ok</para>
<para>initializing pg_shadow ... ok</para>
<para>enabling unlimited row size for system tables ... ok</para>
<para>initializing pg_depend ... ok</para>
<para>creating system views ... ok</para>
<para>loading pg_description ... ok</para>
<para>creating conversions ... ok</para>
<para>setting privileges on built-in objects ... ok</para>
<para>creating information schema ... ok</para>
<para>vacuuming database template1 ... ok</para>
<para>copying template1 to template0 ... ok</para>
<para/>
<para>WARNING: enabling "trust" authentication for local connections</para>
<para>You can change this by editing pg_hba.conf or using the -A option the</para>
<para>next time you run initdb.</para>
<para/>
<para>Success. You can now start the database server using:</para>
<para/>
<para>    /usr/bin/postmaster -D /var/lib/postgresql/data</para>
<para>or</para>
<para>    /usr/bin/pg_ctl -D /var/lib/postgresql/data -l logfile start</para>
<para/>
<para> *</para>
<para> * You can use /etc/init.d/postgresql script to run PostgreSQL instead of pg_ctl.</para>
<para> *</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Now the initial database environment is setup. The next section will look at verifying the install and setting up users to access the database. </para></sect4><sect4><title>
<anchor id="doc_chap2_sect2"/>PostgreSQL database setup</title>
<para>Now that PostgreSQL is setup, it's a good idea at this point to verify the installation. First, make sure the service starts up ok: </para>
<para>
<anchor id="doc_chap2_pre31"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.3: Starting up the PostgreSQL service</para>
</entry>
</row>
<row>
<entry>
<para># /etc/init.d/postgresql start</para>
<para>* Starting PostgreSQL ...                                          [ ok ]</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Once this is verified working, it's also a good idea to add it to the default runlevel so it starts at boot: </para>
<para>
<anchor id="doc_chap2_pre41"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.4: Adding to the default runlevel</para>
</entry>
</row>
<row>
<entry>
<para># rc-update add postgresql default</para>
<para>* postgresql added to runlevel default</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Now that the service has started, it's time to try setting up a test database. To start out, let's create a test database by using the createdb command. We'll also pass along the -U option to set the user (it defaults to the current user name if you don't), and the -W option to request the password we created earlier. Finally we give it the name of the database we want to create: </para>
<para>
<anchor id="doc_chap2_pre5"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.5: Creating a database with createdb</para>
</entry>
</row>
<row>
<entry>
<para>$ createdb -U postgres -W test</para>
<para>Password:</para>
<para>CREATE DATABASE</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>The database was successfully created, and we can confirm that the database can run basic tasks. We'll go ahead and drop this database (remove it) with the dropdb command: </para>
<para>
<anchor id="doc_chap2_pre6"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.6: Dropping a database with dropdb</para>
</entry>
</row>
<row>
<entry>
<para>$ dropdb -U postgres -W test</para>
<para>Password:</para>
<para>DROP DATABASE</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Right now, only the postgres user can run commands. Obviously this is not the sort of setup one would like in a multi-user environment. The next section will look at working with user accounts. </para></sect4><sect4><title>
<anchor id="doc_chap2_sect3"/>Setting up database user accounts</title>
<para>As mentioned earlier, having to login as the postgres user is somewhat undesirable in a mult-user environment. In most cases there will be various users and services accessing the server, and each have different permission requirements. So, to handle this, the createuser command can be used. This command is an alternative to running a few SQL queries, and is a lot more flexible from an admin standpoint. We'll go ahead and create two users, a 'superuser' that can add other users and administer the db, and a standard user: </para>
<para>
<anchor id="doc_chap2_pre7"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.7: Setting up the superuser</para>
</entry>
</row>
<row>
<entry>
<para>(replace chris with the username you'd like to use)</para>
<para>$ createuser -a -d -P -E -U postgres -W chris</para>
<para>Enter password for new user:</para>
<para>Enter it again:</para>
<para>Password:</para>
<para>CREATE USER</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>There, we've created the superuser. The command line option -a specifies that this user can add other users. -d means that this user can create databases. -P let's you enter a password for the user and -E will encrypt it for security purposes. Now then, we'll test this new user's permissions out by setting up our standard user: </para>
<para>
<anchor id="doc_chap2_pre8"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.8: Setting up the standard user</para>
</entry>
</row>
<row>
<entry>
<para>(replace chris with the username you've just created)</para>
<para>$ createuser -A -D -P -E -U chris -W testuser</para>
<para>Enter password for new user:</para>
<para>Enter it again:</para>
<para>Password:</para>
<para>CREATE USER</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Success! Our new user was created using the previously created superuser. The -A and -D options do the opposite of -a and -d, and instead deny the user the ability to create other users and databases. Now that there are users to work with, the next chapter will look at using the new database. </para></sect4></sect3><sect3><title>
<anchor id="doc_chap31"/>3.  Using PostgreSQL</title><sect4><title>
<anchor id="doc_chap3_sect11"/>Setting up permissions</title>
<para>Now there is a user that can create databases and add other users, and the main postgres user that can do anything. The user created earlier can currently login to the server, and that's about it. In general, users need to be able to insert data and retrieve data, and sometimes any other number of tasks. So, for this new user to be able to do anything, they must be setup with the proper permissions. This can easily be done by passing the -O parameter to createdb. We'll start by making a new database, MyDB with our superuser that will be owned by the previous testuser: </para>
<para>
<anchor id="doc_chap3_pre17"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.1: Creating the MyDB database</para>
</entry>
</row>
<row>
<entry>
<para>$ createdb -O testuser -U chris -W MyDB</para>
<para>Password:</para>
<para>CREATE DATABASE</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Alright, now we have a new MyDB database, and a testuser that can access it. To test this out, we'll login as the testuser to the new MyDB database. We'll do this with the psql program. This program is what's used to connect to the PostgreSQL database from command line. So connect to the new database like so: </para>
<para>
<anchor id="doc_chap3_pre21"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.2: Logging into the MyDB database as the testuser</para>
</entry>
</row>
<row>
<entry>
<para>$ psql -U testuser -W MyDB</para>
<para>Password:</para>
<para>Welcome to psql 8.0.4, the PostgreSQL interactive terminal.</para>
<para/>
<para>Type:  \copyright for distribution terms</para>
<para>       \h for help with SQL commands</para>
<para>       \? for help with psql commands</para>
<para>       \g or terminate with semicolon to execute query</para>
<para>       \q to quit</para>
<para/>
<para>MyDB=&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>So, the testuser is now logged into the database, and can begin to initiate some commands. To get a feel for using PostgreSQL, the next section will take a look at some of the basic commands in navigating the psql client. </para>
<para>
<anchor id="doc_chap3_sect21"/>Basic PostgreSQL commands and creating a table</para>
<para>For those who are used to MySQL, this is somewhat of a definite read. This is where PostgreSQL may get somewhat unique with regards to running commands. To start, here is a list of some commands that will be discussed: </para>
<informaltable frame="all">
<tgroup cols="3"><tbody>
<row>
<entry>
<para>Command</para>
</entry>
<entry>
<para>Usage</para>
</entry>
<entry>
<para>MySQL Equivalent</para>
</entry>
</row>
<row>
<entry>
<para>\c[onnect] [DBNAME|- [USER]]</para>
</entry>
<entry>
<para>Connects to another database</para>
</entry>
<entry>
<para>USE DATABASE</para>
</entry>
</row>
<row>
<entry>
<para>\q</para>
</entry>
<entry>
<para>Quit the psql client</para>
</entry>
<entry>
<para>quit</para>
</entry>
</row>
<row>
<entry>
<para>\i FILE</para>
</entry>
<entry>
<para>Run commands from FILE </para>
</entry>
<entry>
<para>source FILE</para>
</entry>
</row>
<row>
<entry>
<para>\o [FILE]</para>
</entry>
<entry>
<para>Send query results to FILE </para>
</entry>
<entry>
<para>INTO OUTFILE, but outputs everything (not just SELECTS)</para>
</entry>
</row>
<row>
<entry>
<para>\d [NAME]</para>
</entry>
<entry>
<para>Describe a database or table (as well as other items)</para>
</entry>
<entry>
<para>DESC(RIBE)</para>
</entry>
</row>
<row>
<entry>
<para>\db [PATTERN]</para>
</entry>
<entry>
<para>List available tables that match PATTERN (all if no pattern is given) </para>
</entry>
<entry>
<para>SHOW TABLES</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>With the exception of \c[onnect], all the commands shown will be used later on in the section. So right now the database is empty. That said, we need to insert some data. The first step to inserting data, however, is to put it in a table. Right now there are no tables in the database, so we need to create one. This is done with the CREATE TABLE command. We'll make a table of items. They will contain a Product ID, Description, and price: </para>
<para>
<anchor id="doc_chap3_pre31"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.3: Creating the products table</para>
</entry>
</row>
<row>
<entry>
<para>MyDB=&gt; CREATE TABLE products (</para>
<para>MyDB(&gt;   product_id SERIAL,</para>
<para>MyDB(&gt;   description TEXT,</para>
<para>MyDB(&gt;   price DECIMAL</para>
<para>MyDB(&gt; );</para>
<para>NOTICE:  CREATE TABLE will create implicit sequence "products_product_id_seq"</para>
<para>for serial column "products.product_id"</para>
<para>CREATE TABLE</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>You can ignore the NOTICE, it's perfectly harmless. Looking at the last line of the function, CREATE TABLE seems to indicate that the command has succeeded. However, let's go ahead and verify that the table was indeed successfully created with the \d command: </para>
<para>
<anchor id="doc_chap3_pre41"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.4: Looking at the newly created table</para>
</entry>
</row>
<row>
<entry>
<para>MyDB=&gt; \d products</para>
<para>                                 Table "public.products"</para>
<para>   Column    |  Type   |                            Modifiers</para>
<para>-------------+---------+------------------------------------------------------------------</para>
<para> product_id  | integer | not null default nextval('public.products_product_id_seq'::text)</para>
<para> description | text    |</para>
<para> price       | numeric |</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Indeed the table was successfully created. Now that the table is created, it needs to be populated with data. The next section will look at populating the database with data. </para></sect4><sect4><title>
<anchor id="doc_chap3_sect31"/>Inserting data into the database</title>
<para>This section will look at the two ways of populating the newly created table with data. First let's look at the most basic command, INSERT: </para>
<para>
<anchor id="doc_chap3_pre51"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.5: INSERT syntax</para>
</entry>
</row>
<row>
<entry>
<para>INSERT INTO [tablename] (column1,column2,column3) VALUES(value1,value2,value3)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>tablename contains the name of the table to insert the data into. (column1,column2,column3) lets you specify the specific columns to insert the values into. VALUES(value1,value2,value3) is the listing of values. The values are inserted into the same order as the columns (column1 gets value1, column2 gets value2, column3 gets value3). These counts must be the same. So let's go ahead and insert an item into the table: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Important: From working with databases for a long time, I personally recommend specifying INSERT statements exactly as above. Developers often make the mistake of using INSERT INTO without specifying columns. This is unproductive, as if a new column gets added to the database, it will cause in error if the value to column count is not the same. You should always specify the columns unless you're 300% sure you'll never add a column. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>
<anchor id="doc_chap3_pre61"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.6: Inserting data into the table</para>
</entry>
</row>
<row>
<entry>
<para>MyDB=&gt; INSERT INTO products (description,price) VALUES('A test product', 12.00);</para>
<para>INSERT 17273 1</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>The last line needs a bit of explaining. The return of an insert command is an OID (Object Identifier) and the number of rows inserted. OID's are a bit beyond the scope of this guide, and the <ulink url="http://www.postgresql.org/docs/8.1/static/datatype-oid.html">PostgreSQL manual</ulink> has some good information on it. Now, for a situation where you have 20,000 products, these insert statements can be a little tedious. However, not all is lost. The COPY command can be used to insert data into a table from a file or stdin. In this example, let's assume that you have a csv (comma separated values) file, which contains the product id, description, and price. The file looks like this: </para>
<para>
<anchor id="doc_chap3_pre71"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.7: products.csv</para>
</entry>
</row>
<row>
<entry>
<para>2,meat,6.79</para>
<para>3,soup,0.69</para>
<para>4,soda,1.79</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Now we'll use the COPY command to populate our data: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Important: The COPY FROM STDIN command is used because only the postgres user can insert data from a file (for obvious security reasons). </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>
<anchor id="doc_chap3_pre81"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.8: Using COPY to populate the products table</para>
</entry>
</row>
<row>
<entry>
<para>MyDB=&gt; COPY products FROM STDIN WITH DELIMITER AS ',';</para>
<para>Enter data to be copied followed by a newline.</para>
<para>End with a backslash and a period on a line by itself.</para>
<para>&gt;&gt; 2,meat,6.79</para>
<para>&gt;&gt; 3,soup,0.69</para>
<para>&gt;&gt; 4,soda,1.79</para>
<para>&gt;&gt; \.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Unfortunately, this line doesn't return the same status information as the INSERT INTO statement. How do we know the data was inserted? The next section will look at running queries to check our data. </para></sect4><sect4><title>
<anchor id="doc_chap3_sect4"/>Using PostgreSQL queries</title>
<para>This section will look at using the SELECT statement to view data in our tables. The basic SELECT format looks like this: </para>
<para>
<anchor id="doc_chap3_pre91"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.9: SELECT syntax</para>
</entry>
</row>
<row>
<entry>
<para>SELECT (column1,column2|*) FROM (table) [WHERE (conditionals)]</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>There are two ways to select columns. The first is using * to select all columns, and the second is to specify a list of specific columns you wish to see. The second is quite handy when you want to find a specific column in a rather large list of them. Let's start out with using SELECT with * to specify all columns: </para>
<para>
<anchor id="doc_chap3_pre101"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.10: Viewing the products table</para>
</entry>
</row>
<row>
<entry>
<para>MyDB=&gt; SELECT * FROM products;</para>
<para> product_id |  description   | price</para>
<para>------------+----------------+-------</para>
<para>          1 | A test product | 12.00</para>
<para>          2 | meat           |  6.79</para>
<para>          3 | soup           |  0.69</para>
<para>          4 | soda           |  1.79</para>
<para>(4 rows)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>As shown here, all the data we inserted earlier is indeed in the table. Now let's say we only want to see the description and the price, and don't care about the product id. In this case we'll use the column specific SELECT form: </para>
<para>
<anchor id="doc_chap3_pre111"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.11: Viewing specific columns from the products table</para>
</entry>
</row>
<row>
<entry>
<para>MyDB=&gt; SELECT description,price FROM products;</para>
<para>  description   | price</para>
<para>----------------+-------</para>
<para> A test product | 12.00</para>
<para> meat           |  6.79</para>
<para> soup           |  0.69</para>
<para> soda           |  1.79</para>
<para>(4 rows)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Now only the product and price is shown, letting us focus on only the important data. Now let's say that we want to see only the items that are greater than $2.00. Here's where the WHERE clause comes in handy: </para>
<para>
<anchor id="doc_chap3_pre121"/>
</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 3.12: Viewing specific rows from the products table</para>
</entry>
</row>
<row>
<entry>
<para>MyDB=&gt; SELECT description,price FROM products WHERE price &gt; 2.00;</para>
<para>  description   | price</para>
<para>----------------+-------</para>
<para> A test product | 12.00</para>
<para> meat           |  6.79</para>
<para>(2 rows)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Now a listing of products over $2.00 is displayed, focusing the data even more. These forms of querying for information are very powerful, and can help create extremely useful reports. </para></sect4><sect4><title>
<anchor id="doc_chap3_sect5"/>Conclusion</title>
<para>This concludes the PostgreSQL Guide. A big thanks goes to Masatomo Nakano, the previous Gentoo PostgreSQL maintainer for his help in answering my questions. Any suggestions on this guide should be sent to Chris White. For more extensive documentation, see the <ulink url="http://www.postgresql.org/">PostgreSQL website</ulink>. </para>
<para/></sect4></sect3></sect2></sect1><sect1><title>Gentoo и системы контроля версий.</title><sect2><title>Gentoo и Subversion.</title><sect3><title>HOWTO Subversion сервер при помощи Apache2 и WebDav</title>
<para>Ссылка на оригинал: <ulink url="http://ru.gentoo-wiki.com/HOWTO_Subversion_сервер_при_помощи_Apache2_и_WebDav">http://ru.gentoo-wiki.com/HOWTO Subversion сервер при помощи Apache2 и WebDav</ulink>
</para>
<para>C версии: 1.5</para><sect4><title>О чем эта статья </title>
<para>Данное HOWTO является вольным переводом оригинальной английской статьи. Также в статью добавленно некоторое количество отсебятины по поводу и без (надеюсь автор оригинала не знает русского и не увидит как я испохабил его несчастную статью). </para>
<para>Данная статья посвещена настройке сервера Subversion под Apache с применением WebDav и только ей. Информацию по клиенту и настройке автономного сервера можно найти по ссылке <ulink url="http://gentoo-wiki.com/HOWTO_Subversion">en:HOWTO Subversion</ulink> </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: Данная статья предусматривает, что читатель - разумный человек и не будет вешать репозиторий не на ssl хост, и вообще заботится о безопасности. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>FIXME: Хорошо бы описать в чем плюсы WebDav подхода и в чем минусы </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title> Настройка WebDav глобально, безотносительно в virtual-хостам </title></sect4><sect4><title>Apache. Компиляция без Worker MPM </title>
<para>
<ulink url="http://svn.haxx.se/users/archive-2006-02/1317.shtml">Существует известная проблема</ulink> при больших коммитах (commit, оффициальный перевод - "фиксация изменений", на мой взгляд длинновато) связанная с использованием апачевого (от Apache) "worker" MPM. Рекомендуется просто отключить этот MPM и скомпилировать Apache с "prefork" MPM. Для этого просто добавьте новую (или поменяйте существующую, если таковая уже есть) строчку в package.use (в случае использования Gentoo, естественно): </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/portage/package.use </para>
</entry>
</row>
<row>
<entry>
<para>www-servers/apache -mpm-worker mpm-prefork</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>После чего перекомпилируйте Апач: emerge -aDNtuv apache </para>
<para>Более того, пожалуйста убедитесь, что subversion скомпилированна с (use flag) apache2 и без nowebdav юзами (от use flags). </para></sect4><sect4><title>Включение SVN и WebDav модулей в Apache </title>
<para>Для использования WebDav и Subversion модулей их, как ни странно, необходимо включить. Делается это при помощи передачи соответсвующих опций (далее - дефайнов, от Define) Апачу при загрузке. Также, для аутентификации, вам возможно понадобится SSL (если вам так не кажется, советую подумать еще раз). Добавте следующую строчку после уже существующей APACHE2_OPTS строчки. (-D SVN_AUTHZ необходимо для использования авторизации, см. ниже) </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/conf.d/apache2 </para>
</entry>
</row>
<row>
<entry>
<para>        APACHE2_OPTS="$APACHE2_OPTS -D SVN -D SVN_AUTHZ -D DAV -D SSL"</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>Создание репозиториев применительно к данной конфигурации </title>
<para>Необходимо, чтобы Апач имел права на запись на папку репозитория(иев), с которым(и) он должен работать. Это можно сделать двумя способами: </para>
<orderedlist>
<listitem>
<para>Сменой пользователя/группы папки репозитория: </para>
</listitem>
<listitem>
<para>Добавлением пользователя apache (или того, под которым ваш Апач бегает) в группу svnusers: </para>
</listitem>
</orderedlist>
<para>Лично я, переводчик, рекомендую воспользоваться комбинацией этих способов, из соображений, что права на запись могут понадобится не только Апачу, а включать страждущего пользователя в группу apache тоже как-то нехорошо, т.к. это даст доступ не только к репозиториям. Для упрощения этой задачи мною был написан следующий скрипт: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: create_repository.sh </para>
</entry>
</row>
<row>
<entry>
<para>#!/bin/sh</para>
<para/>
<para>DIR_MODE=770</para>
<para>FILE_MODE=660</para>
<para>SVN_ROOT="/var/svn"</para>
<para/>
<para>SVN_USER="apache"</para>
<para>SVN_GROUP="svn"</para>
<para/>
<para>NAME=${1:?"Usage: create_repository.sh &lt;repository name&gt;"}</para>
<para/>
<para>REPO_DIR="${SVN_ROOT}/${NAME}"</para>
<para/>
<para>svnadmin create "${REPO_DIR}"</para>
<para>chown "${SVN_USER}:${SVN_GROUP}" -R "${REPO_DIR}"</para>
<para>find "${REPO_DIR}" -type d -exec chmod ${DIR_MODE} {} +</para>
<para>find "${REPO_DIR}" -type f -exec chmod ${FILE_MODE} {} +</para>
<para/>
<para># vim: nobackup</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>Базовая настройка </title>
<para>Вместе с subversion устанавливается файл /etc/apache2/modules.d/47_mod_dav_svn.conf (в случае включенного юза apache2), в котором и содержится практически работающий конфиг (от config - настройка). </para>
<para>Инструкция </para>
<para>&lt;Location /svn&gt;</para>
<para>        DAV svn</para>
<para>сообщает Апачу о том, что все запросы, чей путь начинается с /svn необходимо обрабатывать при помощи WebDav модуля (Dav svn директива). </para>
<orderedlist>
<listitem>
<para>Если вам достаточно только одного репозитория то используйте директиву </para>
</listitem>
</orderedlist>
<para>        SVNPath /путь/к/репозиторию</para>
<orderedlist>
<listitem>
<para>В противном случе, для многочисленных репозиториев, необходимо использовать следующую директиву: </para>
</listitem>
</orderedlist>
<para>        SVNParentPath /путь/к/папке/с/репозиториями</para>
<para>В этом случае все подпапки папки, указанной в SVNParentPath директиве, будут рассматриватся как репозитории Subversion (Даже если они таковыми не являются). </para>
<para>Также существует возможность заставить Апач формировать список репозиториев/содержимого в них, в случае захода с обычного брузера. Для этого существует магическая опция SVNListParentPath (Правда данная опция доступна только с subversion версии 1.3, но для настоящего гентушника это все равно уже антиквариат), которую необходимо установить в on: </para>
<para>        SVNListParentPath on</para>
<para>ВАЖНО: При использовании SVNListParentPath может так случится, что вы получите 403 Forbidden, а не список репозиториев (Более подробно данный природный феномен описан <ulink url="http://www.nabble.com/SVNListParentPath-t839339.html">здесь</ulink>). Как вариант избавления, вы можете добавить в описание блока Location заключительный слэш. </para>
<para>        &lt;Location /svn/&gt;</para>
<para>В таком случае, вам наверняка также захочется, чтобы Апач также отлавливал и просто путь /svn . Для этого можно воспользоватся магической опцией RedirectMatch (добавив ее куда-нибудь вовне блока Location), как показанно в нижеприведенном заклинании. </para>
<para>        RedirectMatch ^(/svn)$ $1/</para>
<para>Дабы избежать ппроблем, вроде описанной тут: <ulink url="http://www.kde-forum.org/artikel/14030/Intermediate-Collectionsfolders.html">Resource cannot be created at the destination...</ulink>, будет полезно добавить в конфиг директиву: </para>
<para>        SVNAutoVersioning On</para></sect4><sect4><title>Аутентификация </title></sect4><sect4><title>Стандартная </title>
<para>На данный момент мы, чисто теоретически, имеем работающий Апач с подключенным Сабвершеном (от Subversion). Однако любая подозрительная личность может сделать с нашим репозиторием что захочет, что естественно не входит в наши планы. </para>
<para>Добавление следующих строчек в /etc/apache2/modules.d/47_mod_dav_svn.conf включит базовую аутентификацию Апача </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/apache2/modules.d/47_mod_dav_svn.conf </para>
</entry>
</row>
<row>
<entry>
<para>        AuthType Basic</para>
<para>        AuthName "Subversion repository"</para>
<para>        AuthUserFile /var/svn/conf/svnusers</para>
<para>        Require valid-user</para>
<para>        # Тип встроенной аутентификации "Basic" посылает пароли открытым текстом, что есть небезопасно. Чтобы избежать  ситуации кражи пароля необходимо добавить следующую директиву, которая будет требовать подключения с ssl</para>
<para>        SSLRequireSSL</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Как несложно догадатся, для того чтобы можно было требовать ssl, его неплохо было бы включить. Как это сделать было описано выше. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Дополнение: Однако намного более завлекательным вариантом является принудительный редирект на ssl хост, т.к. не вводит среднестатистического пользователя в ступор при виде непонятной ошибки на иноземном языке </para>
<para>Начало общефилософского лирического отступления </para>
<para>Также положительным побочным действием предложенного решения является то, что если у вас стандартный ssl порт уже занят, то таким образом можно ликвидировать проблему с запоминанием номера порта, просто заходя на http, а Апач вас уже перешлет на правильный порт (при условии, что вы ему скажите это делать, естественно - болезненной самостоятельностью юниксовые сервера, по счастью, не обладают (хотя периодически и кажется, что они проявляют признаки очень вредного интеллекта, подкидывая все новые и новые гадости))) </para>
<para>Конец лирическому отступлению </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/apache2/modules.d/47_mod_dav_svn.conf </para>
</entry>
</row>
<row>
<entry>
<para>&lt;Location /svn&gt;</para>
<para>        [...]</para>
<para> </para>
<para>        RewriteEngine On</para>
<para>        RewriteCond %{HTTPS} !on</para>
<para>        RewriteRule ^/(.*) https://%{SERVER_NAME}%{REQUEST_URI} [R]</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Возможность: Чтобы ограничить доступ только по ssl, недостаточно директивы SSLRequireSSL в 47_mod_dav_svn.conf. Для этого необходимо перенести все директивы из 47_mod_dav_svn.conf в файл с дефолтным (от default - по умолчанию) виртуальным хостом для ssl - XX_mod_ssl_default-vhost.conf. Также необходимо так поменять номер этого виртуального хоста так чтобы он грузился после mod_dav (все файлы в папке /etc/apache2/conf/modules.d загружаются в алфавитном порядке). Впрочем это необходимо только тем у кого настолько древний Апач (или настолько новый, кто знает - постоянно туда-сюда эти хосты путешествуют. По моему мнению, их вообще выкинуть можно), что дефолтный хост лежит все еще в modules.d - их уже месяцов пять как переместили в vhosts.d. Остальным беспокоится не зачем - vhosts.d загружаются после modules.d </para>
<para>Небольшая оптимизация: Однако вместо того чтобы перемещать директивы из файла 47_mod_dav_svn.conf внутрь виртуального ssl-хоста, можно попросту проинклюдить (от include - включать (в себя)) туда целиком файл, предварительно поменяв ему расширение на что-нибуть отличное от .conf, либо вынеся вовне {{filename|modules.d}, дабы самостоятельно Апач его не разыскал. Делается это при помощи магической директивы Include с указанием абсолютного пути до желаемого файла </para>
<para>Начало лирического отступления о культурных особенностях индейцев Вообще-то можно указать и относительный, но стоит учитывать, что Апач - индеец и имеет несколько свои представления о том что такое "относительный путь". Для него это путь относительно истинного пути - путь ServerRoot'а - т.е. по умолчанию откуда-то от /usr/lib/apache2 </para>
<para>Конец лирическому отступлению </para>
<para>Оптимизация побольше и по-глобальнее: По-умолчанию Апач грузит все конфиги в папке {{filename|modules.d} по маске {{filename|modules.d/*.conf}, так что можно немного переписать систему инклюдов, дабы разделить конфиги на обычные и продвинутые-ssl-ные. Для этого достаточно переименовать полюбившийся конфиг, в нашем случае - 47_mod_dav_svn.conf, в что-нибудь с расширением отличным от .conf (либо, как уже было предложено выше, создав отдельную папку для подобных продвинутых конфигов), к примеру в 47_mod_dav_svn.ssl-conf. Тогда достаточно будет указать в httpd.conf (или любом другом глобальном конфиге - к примеру в modules.d/40_mod_ssl.conf), внутри соответствующего блока &lt;IfModule ssl_module&gt;/&lt;IfDefine SSL&gt; следующие строчки: </para>
<para>        # Загрузить модули зависщие от ssl</para>
<para>        Include /etc/apache2/modules.d/*.ssl-conf # либо /etc/apache2/modules.ssl.d/*.conf</para>
<para>Анонимный доступ: Хорошо, мы добились того, что теперь при каждом запросе к subversion будет спрашиваться пароль, однако вам может захотеться, чтобы анонимные пользователи могли читать ваш труд, а то зачем все это надо? В таком случае директиву Require valid-user стоит поместить в блок &lt;LimitExcept ...&gt; указав в качестве параметра список операций, которые, по вашему мнению, всякие подозрительные личности без особой опасности могут производить на вашем репозитории: </para>
<para>        [...]</para>
<para>        AuthType Basic</para>
<para>        [...]</para>
<para>        # Для любых операций, кроме нижеперечисленных, спрашивать пароль.</para>
<para>        &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;</para>
<para>                Require valid-user</para>
<para>        &lt;/LimitExcept&gt;</para>
<para>В любом случае, для правильной работы subversion клиента с ssl в дефолтный ssl-хост XX_mod_ssl_default-vhost.conf, либо в 40_mod_ssl.conf, необходимо добавить следующую строчку ( подробности - <ulink url="http://www.mail-archive.com/dev@httpd.apache.org/msg14702.html">тут</ulink> ) </para>
<para>        BrowserMatch "SVN" redirect-carefully</para>
<para>Упомянутый выше файл /var/svn/conf/svnusers и содержит имена и зашифрованные пароли пользователей. </para>
<para>Чтобы создать этот файл/добавить в него новую запись воспользуйтесь коммандой htpasswd2. </para>
<para>Для создания файла с первым пользователем: </para>
<para>htpasswd2 -c /var/svn/conf/svnusers &lt;имя первого пользователя&gt; </para>
<para>и для добавления последующих: </para>
<para>htpasswd2 /var/svn/conf/svnusers &lt;имя последующего пользователя&gt; </para>
<para/></sect4><sect4><title>Основанная на PAM </title>
<para>Если управление аж двумя различными файлами с паролями (системного и Апачевого) для вас слишком утомительно, то специально для вас был придуман модуль mod_auth_pam, который использует PAM для аутентификации пользователей. Если у вас нет еще этого модуля - emerge mod_auth_pam </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: Да будет вам известно, что mod_auth_pam представляет из себя потенциальную уязвимость: системный пользователь 'apache' (или тот под которым запущен ваш сервер) получит доступ на чтение к /etc/shadow. Это означает, что в случае взлома Апача, злоумышленник получит доступ к файлу /etc/shadow, и сможет натравить на него программу по взлому паролей (дальнейшая судьба системы будет зависить от того, заметите ли вы взлом и примите меры раньше, чем злоумышленник получит пароль рута). </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>После сборки mod_auth_pam необходимо внести несколько изменений (суперпользователем) в ваши конфигурационные файлы. Для начала надо выдать пользователю 'apache' доступ на чтение /etc/shadow: </para>
<orderedlist>
<listitem>
<para>groupadd shadow </para>
</listitem>
<listitem>
<para>gpasswd -a apache shadow </para>
</listitem>
<listitem>
<para>chgrp shadow /etc/shadow </para>
</listitem>
<listitem>
<para>chmod g+r /etc/shadow </para>
</listitem>
</orderedlist>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: Если у вас есть веб-сервер на котором работают посторонние люди, и он работает под тем же пользователем 'apache', то эти самые посторонние люди без всякого взлома смогут прочесть ваш /etc/shadow, и это уже действительно опасно!. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>После чего внесите следующие изменения в /etc/apache2/modules.d/47_mod_dav_svn.conf: Вовнутрь блока &lt;Location /svn&gt; впишите: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/apache2/modules.d/47_mod_dav_svn.conf </para>
</entry>
</row>
<row>
<entry>
<para>&lt;IfModule mod_auth_sys_group.c&gt;</para>
<para>        AuthPAM_Enabled on</para>
<para>        AuthType Basic</para>
<para>        AuthName "Subversion Repository"</para>
<para>        SSLRequireSSL</para>
<para>        Require group subversion</para>
<para>&lt;/IfModule&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>ВАЖНО: В отличие от стандартной ('basic') аутентификации, описанной выше, убедитесь что вы не указали директивы </para>
<para>AuthUserFile /var/svn/conf/svnusers</para>
<para>Впрочем существует возможность оставить стандартную аутентификацию как запасную на случай если PAM модуль по каким-то причинам не сработает. Для этого обратите внимание на файл /etc/apache2/modules.d/10_mod_auth_pam.conf </para>
<para>ВАЖНО: Как уже упоминалось выше базовый тип встроенной аутентификации (AuthType Basic) передает пароли открытым текстом и для обеспечения минимальной безопасности необходимо ограничить аутентификацию только по ссл, при помощи директивы SSLRequireSSL </para>
<para>Ну а для того, чтобы все, в пределах этого параграфа, проделанное имело смысл, необходимо включить mod_auth_pam, добавив -D AUTH_PAM в APACHE2_OPTS в /etc/conf.d/apache2 </para></sect4><sect4><title>Active Directory/LDAP </title>
<para>Для того, чтобы настроить авторизацию в SVN через LDAP или Active Directory, следуйте следующим инструкциям. </para>
<para>В /etc/conf.d/apache2 добавляем -D LDAP и -D AUTH_LDAP </para>
<para>APACHE2_OPTS="-D SSL -D PHP4 -D DAV -D DAV_FS -D SVN -D DAV_SVN -D LDAP -D AUTH_LDAP"</para>
<para>вот пример моей рабочей конфигурации Apache для авторизации через Active Directory: (нужно изменить путь к ldap на тот, что вы хотите использовать) </para>
<para>&lt;IfDefine SVN&gt;</para>
<para>&lt;Location /svn/repo&gt;</para>
<para>DAV svn</para>
<para>SVNPath /var/svn/repo</para>
<para>AuthType Basic</para>
<para>Options Indexes FollowSymLinks</para>
<para>AllowOverride None</para>
<para>order allow,deny</para>
<para>allow from all</para>
<para>AuthName "Authorize Me"</para>
<para>AuthLDAPURL</para>
<para>ldap://domain.com:389/OU=IT,OU=MainOffice,OU=Locations,OU=Corporate,DC=domainname,DC=com?samAccountName?sub?(objectCategory=person)</para>
<para>AuthLDAPBindDN "CN=webuser,OU=Resources,OU=Corporate,OU=AOM,DC=domain,DC=com"</para>
<para>AuthLDAPBindPassword xxxxxxxxxxx</para>
<para>Require valid-user</para>
<para>&lt;/Location&gt;</para>
<para>&lt;/IfDefine&gt;</para>
<para>Для того, чтобы разрешить доступ только ограниченному списку пользователей: </para>
<para>&lt;Location "/useraccess"&gt;</para>
<para>AuthName "user permissions"</para>
<para>require user larry bill sam</para>
<para>&lt;/Location&gt;</para>
<para>Для того, чтобы разрешить доступ только ограниченному списку групп: </para>
<para>&lt;Location "/group"&gt;</para>
<para>AuthName "group permissions"</para>
<para>require group cn=Group,cn=Users,dc=domainname,dc=com</para>
<para>&lt;/Location&gt;</para>
<para>В случае возникновения проблем с запросами к LDAP, запустите следующую команду на вашем Windows-сервере: </para>
<para>ldifde -f mydomain.ldif -s 127.0.0.1</para>
<para>Она сбросит все содержимое LDAP в указанный файл. </para></sect4><sect4><title>Авторизация </title>
<para>Если обычной авторизации недостаточно, можно расширить ее списками доступа. Имеется в виду что базовая аутентификация уже настроена и мы будем раздавать или запрещать доступ отдельным пользователям. Управлять списком можно через специальный файл, SVNAccessFile: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: SVNAccessFile </para>
</entry>
</row>
<row>
<entry>
<para>AuthzSVNAccessFile /var/svn/conf/svnpolicy</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Директива, указанная выше включает возможность создания списков доступа (ACL) для работы с репозиториями subversion через apache. </para>
<para>Правила авторизации для определенного репозитория задаются примерно так: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: SVNAccessFile </para>
</entry>
</row>
<row>
<entry>
<para>[test:/trunk]</para>
<para>testuser1 = rw</para>
<para>testuser2 = </para>
<para>* = r</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Описанное выше правило разрешает производить пользователю testuser1 запись (commit, copy и т.д.) в репозиторий test (папка /trunk). Пользователь же testuser2 не имеет доступа к репозиторию. Остальные пользователи (маска *) имеют доступ только для чтения (могут производить checkout). </para>
<para>Для того, чтобы apache был в курсе наших опытов, нам нужно подредактировать /etc/conf.d/apache2: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/conf.d/apache2 </para>
</entry>
</row>
<row>
<entry>
<para>APACHE2_OPTS="... -D SVN_AUTHZ"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>И напоследок, несколько замечаний по работе с правилами доступа: будьте осторожны с пробелами - внутри скобок не должно быть ни одного; при использовании только одного репозитория, его название можно не указывать, достаточно указать только папку. </para></sect4><sect4><title>Наводим марафет </title>
<para>В последней ревизии репозитория можно полазать в любимом браузере. Удовольствия это много недоставит - выглядит все это дело не очень красиво. Чтобы это исправить, добавьте директиву </para>
<para>SVNIndexXSLT /svnindex.xsl</para>
<para>внутри тега &lt;Location /svn&gt; и укажите свой xsl-файл. Если же с xml вы знакомы недостаточно хорошо, попробуйте xsl и css -файлы, входящие в стандартный пакет subversion в папке /usr/share/doc/subversion-&lt;версия_пакета&gt;. </para>
<para>Некоторые браузеры (например, Opera), вместо нормального отображения XSL-файла, могут показывать пустую страницу. Чтобы этого избежать, можно пропустить XSL через xsltproc, чтобы он преобразовал это дело в обычный html. Для этого необходимо установить пакет xsltproc: </para>
<para>emerge libxslt</para>
<para>И добавить следующее в файл настроек apache: </para>
<para>BrowserMatch "Opera" xsltfilter </para>
<para/>
<para>ExtFilterDefine xslt mode=output enableenv=xsltfilter \ </para>
<para>        intype=text/xml outtype=text/html \ </para>
<para>        cmd="/usr/bin/xsltproc /var/www/svnindex.xsl -" </para>
<para>И добавить следующее внутрь тега &lt;Location /svn&gt;: </para>
<para>SetOutputFilter xslt </para>
<para>AddDefaultCharset utf-8</para></sect4><sect4><title>Полезные ссылки </title>
<orderedlist>
<listitem>
<para>
<ulink url="http://svnbook.red-bean.com/">Книга по Subversion</ulink> </para>
</listitem>
<listitem>
<para>
<ulink url="http://httpd.apache.org/docs/2.0/mod/mod_auth_ldap.html">Документация по mod_auth_ldap</ulink> </para>
</listitem>
</orderedlist>
<para/></sect4></sect3></sect2></sect1><sect1><title>Руководство по udev в Gentoo</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/udev-guide.xml">http://www.gentoo.org/doc/ru/udev-guide.xml</ulink>
</para>
<para>C версии: 1.0</para><sect2><title>1. Что такое udev?</title>
<para>Каталог /dev</para>
<para/>
<para>Когда пользователи Linux разговаривают о начинке своих систем среди людей, полагающих, что Linux — это какой-то вид вируса или марка кофе, пользуясь оборотами вроде «слэш дев слэш что—нибудь» (/dev/foo), на них наверняка смотрят косо. Но для счастливчиков (естественно, включая вас), /dev/hda1 — просто быстрый способ упоминания первого раздела ведущего диска IDE на первичном канале. Разве нет? </para>
<para/>
<para>Все мы знаем, что такое файл устройства. Некоторые даже знают, почему рядом с ними видны специальные числа, если посмотреть на результат ls -l, запущенной в каталоге /dev. Но мы принимаем за данность, что первичный ведущий диск IDE называется /dev/hda. У вас может быть и не так, но это всего лишь пример. </para>
<para/>
<para>Представим себе устройства «горячей замены» вроде USB, IEEE1394, заменяемой PCI и т.д. Какое из них является первым по счету? Надолго ли? Как изменятся названия других устройств, если первое отключить? Как это повлияет на текущие операции? Было бы забавно, если бы задание печати вдруг переключалось с вашего супер навороченного лазерного принтера на старый полудохлый матричный из-за того, что ваша мама решила выдернуть разъем лазерного принтера, а тот оказался первым в списке, не так ли? </para>
<para/>
<para>Перейдем к udev. Цели проекта udev как занимательны, так и актуальны: </para>
<para>запуск драйверов в режиме пользователя</para>
<para>динамическое создание и удаление файлов устройств</para>
<para>согласованное назначение имен устройств</para>
<para>предоставление интерфейса программирования (API) для режима пользователя </para>
<para/>
<para>Разработка udev состоит из трех отдельных проектов: namedev, libsysfs и, конечно, udev. </para>
<para/>
<para>namedev</para>
<para/>
<para>Namedev позволяет отделить именование устройств от программы udev. Это дает возможность гибкого использования правил и схем именования, разработанныых отдельно. Подсистема именования предоставляет стандартный интерфейс, который может использоваться udev. </para>
<para/>
<para>Сейчас, через namedev представлена только одна схема именования, предоставляемая LANANA. Она используется на большинстве Linux—систем, и поэтому хорошо подходит основной массе пользователей Linux. </para>
<para/>
<para>В namedev для определения имени конкретного устройства используется последовательность из пяти шагов. Если на одном из шагов имя установлено, оно и используется. Вот эти шаги: </para>
<orderedlist>
<listitem>
<para>по метке или серийному номеру</para>
</listitem>
<listitem>
<para>по номеру устройства шины</para>
</listitem>
<listitem>
<para>по топологии шины</para>
</listitem>
<listitem>
<para>статическое имя</para>
</listitem>
<listitem>
<para>имя, назначенное в ядре</para>
</listitem>
</orderedlist>
<para/>
<para>По метке или серийному номеру — проверяется, есть ли у устройства уникальный идентификатор. Например, у устройств USB есть уникальный серийный номер USB, а у устройств SCSI — уникальный UUID. Если namedev находит соответствие уникального номера и определенного конфигурационного файла, используется имя, указанное в конфигурационном файле. </para>
<para/>
<para>По номеру устройства шины — проверяется номер устройства, подключаемого к шине. В среде, где нет возможности «горячей замены», этого шага достаточно для идентификации устройства (например, номер на шине PCI редко меняется за время существования системы). Опять же, если namedev находит соответствие номера устройства шины и определенного конфигурационного файла, используется имя, указанное в конфигурационном файле. </para>
<para/>
<para>Подобным образом, по топологии шины — это, скорее, статический способ идентификации устройств, подходящий до тех пор, пока пользователь не начинает их переключать. Когда позиция устройства совпадает со значением, заданным пользователем, используется указанное имя. </para>
<para/>
<para>Четвёртый шаг, статическое имя — это простая подстановка строки. Замененное имя присваивается, когда имя, назначенное в ядре (по умолчанию) совпадает с заданной строкой замены. </para>
<para/>
<para>Последний шаг (имя, назначенное в ядре) покрывает все остальные случаи: при этом берётся имя по умолчанию, присвоенное в ядре. В большинстве случаев этого достаточно, поскольку имя соответствует принятому в современных Linux-системах. </para>
<para/>
<para>libsysfs</para>
<para/>
<para>udev взаимодействует с ядром через псевдофайловую систему sysfs. Проект libsysfs предлагает обобщенный интерфейс программирования для доступа к сведениям, предоставляемым файловой системой sysfs. Это даёт возможность опроса разнородных устройств без необходимости знания их типа. </para>
<para/>
<para>udev</para>
<para/>
<para>Каждый раз, когда ядро обнаруживает обновление структуры устройств, оно вызывает программу /sbin/hotplug. Hotplug, в свою очередь, запускает приложения, указанные в каталоге /etc/hotplug.d/default, где также находится символическая ссылка на приложение udev. Hotplug направляет сведения, данные ядром, в программу udev, которая производит необходимые действия над структурой /dev (создавая или удаляя файлы устройств). </para>
<para/></sect2><sect2><title>2. Как использовать udev в Gentoo</title>
<para/>
<para>Требования к системе</para>
<para/>
<para>Файловая система udev должна использоваться вместе с ядром версии 2.6 (пакеты vanilla-sources или gentoo-sources, и профилем 2005.0). Если вы используете такое ядро, убедитесь, что у вас есть самая последняя версия sys-apps/baselayout. Вот и всё, что потребуется. </para>
<para/>
<para>Листинг 2.1: Установка udev</para>
<para># emerge udev</para>
<para/>
<para/>
<para>udev установит пакет hotplug-base, как одну из зависимостей. Не нужно устанавливать пакет hotplug до тех пор, пока вы хотите, чтобы модули автоматически загружались при подключении устройств. hotplug также управляет автоматическим включением сетевых устройств и загрузкой встроенного ПО. </para>
<para/>
<para>Листинг 2.2: Установка дополнительных сценариев hotplug</para>
<para># emerge hotplug</para>
<para/>
<para/>
<para>Если хотите, чтобы загружались модули для устройств, подключаемых до загрузки, используйте пакет coldplug: </para>
<para/>
<para>Листинг 2.3: Установка пакета coldplug</para>
<para># emerge coldplug</para>
<para/>
<para/>
<para>И не забудьте добавить coldplug на загрузочный уровень запуска (boot): </para>
<para/>
<para>Листинг 2.4: Добавление coldplug на загрузочный уровень запуска</para>
<para># rc-update add coldplug boot</para>
<para/>
<para/>
<para>Что же касается ядра, не забудьте выбрать следующие параметры: </para>
<para/>
<para>Листинг 2.5: Требуемые параметры ядра</para>
<para>General setup ---&gt;</para>
<para>  [*] Support for hot-pluggable devices</para>
<para/>
<para>File systems ---&gt;</para>
<para>  Pseudo filesystems ---&gt;</para>
<para>    [*] /proc file system support</para>
<para>    [*] Virtual memory file system support (former shm fs)</para>
<para/>
<para/>
<para>По вашему усмотрению, можете оставить поддержку файловой системы /dev file system support (OBSOLETE) активной, но обязательно убедитесь в том, что параметр «Automatically mount at boot» выключен: </para>
<para/>
<para>Листинг 2.6: Автоматически не монтировать devfsd</para>
<para>File systems ---&gt;</para>
<para>  Pseudo Filesystems ---&gt;</para>
<para>    [*] /dev file system support (OBSOLETE)</para>
<para>      [ ]   Automatically mount at boot</para>
<para/>
<para/>
<para>Если вы используете genkernel, не забудьте запустить её с параметром --udev, для включения всех необходимых параметров конфигурации ядра. Конфигурация по умолчанию, даваемая этим обращением к genkernel, достаточна. </para>
<para/>
<para>Конфигурация</para>
<para/>
<para>Если вы хотите использовать улучшения udev, добавленные Gentoo для более удобного использования, не читайте дальше. Gentoo будет использовать udev, сохраняя неизменной структуру /dev, так что вы никогда не потеряете специальные файлы устройств. Сценарии инициализации Gentoo не будут запускать демон devfsd и деактивируют devfs при загрузке. </para>
<para/>
<para>Но если вы «крепкий орешек» и хотите запустить любыми средствами систему только с udev и без улучшений, к чему и стремится разработка udev (включая сложности в отсутствии узлов устройств, потому, что udev их ещё не поддерживает), тогда читайте дальше :) </para>
<para/>
<para>Мы деактивируем правила, которые сохраняют специальные файлы устройств: отредактируйте переменную RC_DEVICE_TARBALL в /etc/conf.d/rc и устанавите её значение на no: </para>
<para/>
<para>Листинг 2.7: /etc/conf.d/rc</para>
<para>RC_DEVICE_TARBALL="no"</para>
<para/>
<para/>
<para>Если вы включили поддержку devfs в вашем ядре, вы можете деактивировать её в конфигурации загрузчика: добавьте gentoo=nodevfs как параметр ядра. Если вы хотите использовать devfs и деактивировать udev, добавьте gentoo=noudev. </para>
<para/></sect2><sect2><title>3. Известные проблемы</title>
<para/>
<para>Отсутствие специальных файлов устройств при загрузке</para>
<para/>
<para>Если ваша машина не может успешно загрузится и выдаётся ошибка о том, что путь /dev/null не найден или отсутствует первоначальная консоль, то проблема в том, что отсутствуют некоторые файлы устройств, которые должны быть доступны до того, как /dev смонтирован и обработан udev. Это часто встречается на машинах, где Gentoo установлен со старых носителей. </para>
<para/>
<para>Если вы используете sys-apps/baselayout-1.8.12 или более позднюю версию, эта проблема облегчается, так как процесс загрузки должен управлять до полного завершения. Однако, чтобы избавится от этих раздражающих предупреждений, вам следует создать отсутствующие специальные файлы, как описано далее. </para>
<para/>
<para>Выполните следующие команды для того, чтобы увидеть, какие специальные файлы присутствуют до обработки udev в /dev: </para>
<para/>
<para>Листинг 3.1: Вывод списка специальных файлов устройств, доступных при загрузке</para>
<para># mkdir test</para>
<para># mount --bind / test</para>
<para># cd test/dev</para>
<para># ls</para>
<para/>
<para/>
<para>Устройства /dev/null и /dev/console необходимымы для успешной загрузки. Если они не были показаны в предыдущем тесте, вы должны создать их самостоятельно. Выполните следующие команды в каталоге test/dev/: </para>
<para/>
<para>Листинг 3.2: Создание необходимых специальных файлов устройств</para>
<para># mknod -m 660 console c 5 1</para>
<para># mknod -m 660 null c 1 3</para>
<para/>
<para/>
<para>Когда закончите, не забудьте отмонтировать каталог test/: </para>
<para/>
<para>Листинг 3.3: Отмонтирование каталога test/</para>
<para># cd ../..</para>
<para># umount test</para>
<para># rmdir test</para>
<para/>
<para/>
<para>udev и nvidia</para>
<para/>
<para>Если вы используете коммерческий драйвер от nVidia и сервер X не запускается только в системе с udev, убедитесь что у вас: </para>
<para>название модуля nvidia указано в файле /etc/modules.autoload.d/kernel-2.6 </para>
<para>версия nvidia-kernel больше или равна media-video/nvidia-kernel-1.0.5336-r2 </para>
<para>версия baselayout как минимум sys-apps/baselayout-1.8.12 </para>
<para/>
<para>Если xorg-x11 отказывается запускаться, возможно, отсутствует файл устройства /dev/nvidia. В этом случае запустите /sbin/NVmakedevices.sh, чтобы его создать или пересоздать. </para>
<para/>
<para>Не появляются имена LVM2</para>
<para/>
<para>Если вы используете вместе udev и Logical Volume Manager 2 (LVM—менеджер логических разделов), вы можете заметить, что созданные вами группы разделов и логические разделы исчезли. Что ж, на самом деле нет, но они, к несчастью, названы /dev/dm-#, где #—это 0,1, ... и т.д. </para>
<para/>
<para>Чтобы это исправить, отредактируйте файл /etc/udev/rules.d/50-udev.rules и уберите комментарий со следующей строки: </para>
<para/>
<para>Листинг 3.4: Как убрать комментарий со строки из файла /etc/udev/rules.d/50-udev.rules</para>
<para>KERNEL="dm-[0-9]*",     PROGRAM="/sbin/devmap_name %M %m", NAME="%k",</para>
<para>SYMLINK="%c"</para>
<para/>
<para/>
<para>Далее, установите пакет sys-fs/multipath-tools, который содержит программу devmap_name. </para>
<para/>
<para>Листинг 3.5: Установка пакета multipath-tools</para>
<para>(На момент написания, пакет multipath-tools был доступен только в</para>
<para>тестовой ветке дерева Portage)</para>
<para># echo "=sys-fs/multipath-tools-0.4.2 ~x86" &gt;&gt;</para>
<para>/etc/portage/package.keywords</para>
<para># emerge multipath-tools</para>
<para/>
<para/>
<para>Отличающиеся названия в DevFS и udev</para>
<para/>
<para>Даже если наша цель—иметь совместимую схему именований между этими динамическими системами управления устройствами, иногда случаются различия в именовании. </para>
<para/>
<para>Сообщалось о коллизии в работе контроллера HP Smart Array 5i (более точно - модуль ядра cciss). При использовании udev, устройства именовались как /dev/cciss/cXdYpZ, где X, Y и Z - числа. При использовании devfs, устройства именовались /dev/hostX/targetY/partZ или являлись символическими ссылками на /dev/ccisss/cXdY. </para>
<para/>
<para>В этом случае, не забудьте обновить файл /etc/fstab и конфигурационные файлы загрузчика соответственно. </para>
<para/>
<para>То же самое происходит со всеми символическими ссылками, которые существуют в каталоге /dev, такими как /dev/mouse, которые udev больше не создаёт. Обязательно проверьте настройку графического сервера X и посмотрите секцию Device, указывает ли там строка настройки на существующий файл устройства. </para>
<para/>
<para>Другая проблема заключается в различном именовании терминалов между devfs и udev. Если в devfs терминалы называются tty, то в udev они называются vc. Это может привести к проблемам если возможность входа root с консоли ограничивается с помощью /etc/securetty. Чтобы обеспечить возможность входа root с консоли, нужно обязательно изменить tty1 на vc/1 в /etc/securetty. </para>
<para/>
<para>Другие проблемы</para>
<para/>
<para>Если файлы устройств не создаются, когда соответствующий модуль загружается из /etc/modules.autoload.d/kernel-2.6, но появляются когда вы загружаете этот модуль вручную при помощи modprobe, тогда вам стоит произвести обновление до sys-apps/baselayout-1.8.12 или более поздней версии. </para>
<para/>
<para>Поддержка устройств кадрового буфера (/dev/fb/*) включена в ядро с версии 2.6.6-rc2. </para>
<para/>
<para>В ядрах старше, чем 2.6.4, вам следует явно включить поддержку для файловой системы /dev/pts. </para>
<para/>
<para>Листинг 3.6: Включение поддержки файловой системы /dev/pts</para>
<para>File systems ---&gt;</para>
<para>  Pseudo filesystems ---&gt;</para>
<para>    [*] /dev/pts file system for Unix98 PTYs</para>
<para/>
<para/></sect2><sect2><title>4. Ссылки на ресурсы и благодарности</title>
<para/>
<para>Разговор об udev начался на симпозиуме по Linux в Оттаве в 2003 году (Linux Symposium, Ottawa, Ontario Canada - 2003) Грегом Кроа-Хартманом (Greg Kroah-Hartman) из корпорации IBM, который дал ясное понимание для применения udev. </para>
<para/>
<para>Decibel's UDEV Primer - документ о udev и Gentoo. </para>
<para/>
<para>Написание правил для udev члена сообщества разработки Gentoo Дэниела Дрэйка (Daniel Drake) - отличный документ для того, чтобы научится управлять установкой udev.</para></sect2></sect1><sect1><title>Gentoo LDAP-DNS Guide  (Англ.)</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/en/ldapdns-guide.xml">http://www.gentoo.org/doc/en/ldapdns-guide.xml</ulink>
</para>
<para>C версии: 1.0</para>
<para/><sect2><title>1. Introduction</title>
<para/>
<para>LDAPDNS is a small server that provides DNS services to your network. With DNS services, you can manage your hostnames in a central manner deprecating the tedious /etc/hosts updates every time a system is added/removed or has changed its host name. </para>
<para/>
<para>The LDAPDNS package uses an LDAP service to store all DNS records (which is, simply explained, a line that contains the mapping between a hostname and an IP address). LDAP is a standard protocol to obtain information from a hierarchically represented knowledge base (directories). The most well-known LDAP service for Linux is OpenLDAP, a free LDAP implementation. </para>
<para/>
<para>With this small guide at hand, you should be able to set up DNS services on your network with as little effort as possible. </para>
<para/></sect2><sect2><title>2. Configuring LDAP-DNS</title>
<para>First, install net-dns/ldapdns. </para>
<para/>
<para>Code Listing 2.1: Installing ldapdns</para>
<para># emerge net-dns/ldapdns</para>
<para/>
<para/>
<para>Next, configure ldapdns to host the DNS records for your network. We use ldapdns-conf which uses the following syntax: </para>
<para/>
<para>Code Listing 2.2: Syntax for ldapdns-conf</para>
<para>ldapdns-conf acct logacct /path yourip ldaphost dn [suffix]</para>
<para>Keyword        Explanation        Example</para>
<para>acct        Username as which ldapdns will run        ldapdns</para>
<para>logacct        Username as which the ldapdns logging will run        dnslog</para>
<para>/path        Chrooted home directory for ldapdns        /var/lib/ldapdns</para>
<para>yourip        IP address to listen to        127.0.0.1</para>
<para>ldaphost        Address of the LDAP service        ldapi://%2fvar%2frun%2fopenldap%2fslapd.sock</para>
<para>dn        LDAP login credentials        cn=Manager,dc=yourdomain </para>
<para>suffix        Optional default ldap path to add on all queries        ou=Machines,dc=yourdomain </para>
<para/>
<para/>
<para>You should substitute the 127.0.0.1 IP address with an IP address that all hosts can reach and don't forget to use the domain name you want instead of yourdomain. </para>
<para/>
<para>Code Listing 2.3: Example ldapdns-conf run</para>
<para># ldapdns-conf ldapdns dnslog /var/lib/ldapdns 127.0.0.1 ldapi://%2fvar%2frun%2fopenldap%2fsldapd.sock cn=Manager,dc=yourdomain ou=Machines,dc=yourdomain</para>
<para/>
<para/>
<para>Now set the LDAP login password: </para>
<para/>
<para>Code Listing 2.4: Setting the LDAP login password</para>
<para># echo YourSecretPassword &gt; /var/lib/ldapdns/root/password</para>
<para># chmod 0400 /var/lib/ldapdns/root/password</para>
<para/>
<para/>
<para>Now configure ldapdns to use the simple authentication method and the cosine LDAP schemas: </para>
<para/>
<para>Code Listing 2.5: Configuring ldapdns</para>
<para># echo simple &gt; /var/lib/ldapdns/env/LDAP_AUTH</para>
<para># echo cosine &gt; /var/lib/ldapdns/env/SCHEMA</para>
<para/>
<para/>
<para>You can optionally set an e-mail address for the service: </para>
<para/>
<para>Code Listing 2.6: Setting a host master e-mail address</para>
<para># echo YourMail@address &gt; /var/lib/ldapdns/env/HOSTMASTER</para>
<para/>
<para/>
<para>Add the service to the supervise scan and run the service supervisor if you haven't started it already: </para>
<para/>
<para>Code Listing 2.7: Managing supervise services</para>
<para># ln -s /var/lib/ldapdns /service</para>
<para># /etc/init.d/svscan start</para>
<para># rc-update add svscan default</para>
<para/>
<para/></sect2><sect2><title>3. Configuring OpenLDAP</title>
<para/>
<para>Now we need to configure OpenLDAP with the DNS schema. Open up /etc/openldap/sldap.conf with your favorite editor and make sure the following three lines are listed: </para>
<para/>
<para>Code Listing 3.1: Editing /etc/openldap/sldap.conf</para>
<para>include         /etc/openldap/schema/cosine.schema</para>
<para>include         /etc/openldap/schema/inetorgperson.schema</para>
<para>include         /etc/openldap/schema/nis.schema</para>
<para/>
<para/>
<para>Bootstrap LDAP with the base dn you defined previously with ldapdns-conf. To accomplish this, we first create a file called bootstrap.ldif (it is just a name) which we fill up with DNS information. </para>
<para/>
<para>As an example, we provide a bootstrap.ldif file for the fictitious domain cherchetoujours.org. </para>
<para/>
<para>Now bootstrap your LDAP with this information: </para>
<para/>
<para>Code Listing 3.2: Bootstrapping LDAP</para>
<para># ldapadd -x -D "cn=Manager,dc=yourdomain" -W -f bootstrap.ldif</para>
<para/>
<para/></sect2><sect2><title>4. Testing the Installation</title>
<para/>
<para>Now you are all set. Test your setup using nslookup (part of net-dns/bind-tools): </para>
<para/>
<para>Code Listing 4.1: Testing the ldapdns configuration</para>
<para># nslookup ns1.yourdomain</para>
<para> Note:  nslookup is deprecated and may be removed from future releases.</para>
<para> Consider using the `dig' or `host' programs instead.  Run nslookup with</para>
<para> the `-sil[ent]' option to prevent this message from appearing.</para>
<para> Server:         127.0.0.1</para>
<para> Address:        127.0.0.1#53</para>
<para/>
<para> Name:   ns1.example.com</para>
<para> Address: (Your server IP address)</para>
<para/></sect2></sect1><sect1><title>Руководство по настройке Samba в режиме PDC с использованием LDAP</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/handbook/handbook-x86.xml">http://ru.gentoo-wiki.com/Samba_PDC_LDAP</ulink>
</para>
<para>С версии: 1.2</para>
<para/>
<para>смотрите также:</para>
<para>
<ulink url="http://www.netup.ru/articles.php?n=11">Настройка и использование централизованного управления сервисами с использованием сервера LDAP</ulink>.</para>
<para/>
<para/><sect2><title>Устанавливаемые пакеты </title>
<para>Установим нужные пакеты: </para>
<para># USE="ldap acl ldapsam pam gdbm samba ssl tcpd winbind" emerge samba openldap acl nss_ldap pam_ldap </para>
<para/>
<para>ВАЖНО: Версия nss_ldap должна быть не ниже 250-r1 (&gt;=sys-auth/nss_ldap-250-r1) </para></sect2><sect2><title>OpenLDAP</title><sect3><title>Конфигурирование OpenLDAP</title>
<para>Для примера используется домен amber.global.com который является дочерним доменом домена global.com, который работает под управлением Win2003 Server. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Не решенной задачей осталось создание доверительных отношений между доменами и включение домена amber в лес global.com </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/openldap/slapd.conf </para>
</entry>
</row>
<row>
<entry>
<para>include /etc/openldap/schema/core.schema</para>
<para> include /etc/openldap/schema/cosine.schema</para>
<para> include /etc/openldap/schema/inetorgperson.schema</para>
<para> include /etc/openldap/schema/misc.schema</para>
<para> include /etc/openldap/schema/nis.schema</para>
<para> include /etc/openldap/schema/openldap.schema</para>
<para> include /etc/openldap/schema/samba.schema</para>
<para> pidfile                        /var/run/openldap/slapd.pid</para>
<para> argsfile               /var/run/openldap/slapd.args</para>
<para/>
<para> access to dn.base=""</para>
<para>                by self write</para>
<para>                by * auth</para>
<para> access to attr=userPassword</para>
<para>                by self write</para>
<para>                by * auth</para>
<para> access to attr=shadowLastChange</para>
<para>                by self write</para>
<para>                by * read</para>
<para> access to *</para>
<para>                by * read</para>
<para>                by anonymous auth</para>
<para> #loglevel 1</para>
<para> database        ldbm</para>
<para> suffix          "dc=amber,dc=global,dc=com"</para>
<para> rootdn          "cn=Manager,dc=amber,dc=global,dc=com"</para>
<para> # Пароль rootpw лучше всего указывать в зашифрованном виде.</para>
<para> # Для генерации шифрованного пароля используйте утилиту slappasswd</para>
<para> # Например: slappasswd -h {MD5}</para>
<para> # rootpw = secret</para>
<para> rootpw         {MD5}Xr4ilOzQ4PCOq3aQ0qbuaQ==</para>
<para> directory      /var/lib/openldap-ldbm</para>
<para/>
<para> index objectClass           eq</para>
<para> index cn                    eq,subinitial</para>
<para> index sn                    eq,subinitial</para>
<para> index uid                   eq,subinitial</para>
<para> index displayName           eq,subinitial</para>
<para> index uidNumber             eq</para>
<para> index gidNumber             eq</para>
<para> index memberUID             eq</para>
<para> index sambaSID              eq</para>
<para> index sambaPrimaryGroupSID  eq</para>
<para> index sambaDomainName       eq</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/openldap/ldap.conf </para>
</entry>
</row>
<row>
<entry>
<para>HOST 127.0.0.1</para>
<para>BASE dc=sanaa,dc=global,dc=com</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Проверяем разрешения на каталоги /var/lib/openldap-*ls -la /var/lib/ </para>
<para>ВАЖНО: </para>
<para>drwx------   2 ldap     ldap      104 Июн  8 18:31 openldap-data</para>
<para>drwx------   2 ldap     ldap       72 Июн  8 18:31 openldap-ldbm</para>
<para>drwx------   2 ldap     ldap       72 Июн  8 18:31 openldap-slurp</para></sect3><sect3><title> Запуск сервера OpenLDAP</title>
<para>Пока работаем без шифрования трафика, так как сервер LDAP и SAMBA работают на одном сервере, подправляем конфиг чтобы LDAP слушал 389 порт только на localhost. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/conf.d/slapd </para>
</entry>
</row>
<row>
<entry>
<para># conf.d file for the openldap-2.1 series</para>
<para>#</para>
<para># To enable both the standard unciphered server and the ssl encrypted</para>
<para># one uncomment this line or set any other server starting options</para>
<para># you may desire.</para>
<para>#</para>
<para># OPTS="-h 'ldaps:// ldap:// ldapi://%2fvar%2frun%2fopenldap%2fslapd.sock'"</para>
<para>OPTS="-h 'ldap://127.0.0.1'"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>и запускаем OpenLDAP </para>
<para>/etc/init.d/slapd start </para></sect3></sect2><sect2><title>SAMBA</title><sect3><title>Миграция OpenLDAP</title>
<para>Существует 2 пути создания учетных записей пользователей: домен уже существует и создание нового домена. В первом случае самбу нужно настроить в режиме BDC, перенести все учетные записи, и потом изолировав PDC, перезапустить самбу в режиме PDC. Во втором случае все еще проще, самбу сразу запускаем в режиме PDC и создаем стандарные учетные записи при помощи замечательного пакета smbldap-tools. </para>
<para/>
<para>emerge smbldap-tools/etc/init.d/samba start</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: configure.pl </para>
</entry>
</row>
<row>
<entry>
<para>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-</para>
<para>       smbldap-tools script configuration</para>
<para>       -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</para>
<para>Before starting, check</para>
<para> . if your samba controller is up and running.</para>
<para> . if the domain SID is defined (you can get it with the 'net getlocalsid')</para>
<para/>
<para> . you can leave the configuration using the Crtl-c key combination</para>
<para> . empty value can be set with the "." character</para>
<para>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-</para>
<para>Looking for configuration files...</para>
<para/>
<para>Samba Configuration File Path [/etc/samba/smb.conf] &gt; </para>
<para>The default directory in which the smbldap configuration files are stored is shown.</para>
<para>If you need to change this, enter the full directory path, then press enter to continue.</para>
<para>Smbldap-tools Configuration Directory Path [/etc/smbldap-tools/] &gt; </para>
<para>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</para>
<para>Let's start configuring the smbldap-tools scripts ...</para>
<para/>
<para>. workgroup name: name of the domain Samba act as a PDC</para>
<para>  workgroup name [amber] &gt; </para>
<para>. netbios name: netbios name of the samba controler</para>
<para>  netbios name [neptun] &gt; </para>
<para>. logon drive: local path to which the home directory will be connected </para>
<para> (for NT Workstations). Ex: 'H:'</para>
<para>  logon drive [U:] &gt; </para>
<para>. logon home: home directory location (for Win95/98 or NT Workstation).</para>
<para>  (use %U as username) Ex:'\\neptun\%U'</para>
<para>  logon home (press the "." character if you don't want homeDirectory) [\\%L\users\%U] &gt; </para>
<para>. logon path: directory where roaming profiles are stored. Ex:'\\neptun\profiles\%U'</para>
<para>  logon path (press the "." character if you don't </para>
<para>  want roaming profile) [\\%L\Profiles\%a\%U] &gt; </para>
<para>. home directory prefix (use %U as username) [/home/%U] &gt; </para>
<para>. default users' homeDirectory mode [700] &gt; </para>
<para>. default user netlogon script (use %U as username) [] &gt;</para>
<para>   default password validation time (time in days) [45] &gt; 900</para>
<para>. ldap suffix [dc=amber,dc=global,dc=com] &gt; </para>
<para>. ldap group suffix [ou=Groups] &gt; </para>
<para>. ldap user suffix [ou=Users] &gt; </para>
<para>. ldap machine suffix [ou=Users] &gt; </para>
<para>. Idmap suffix [ou=Idmap] &gt; </para>
<para>. sambaUnixIdPooldn: object where you want to store the next uidNumber</para>
<para>  and gidNumber available for new users and groups</para>
<para>  sambaUnixIdPooldn object (relative to ${suffix}) [sambaDomainName=amber] &gt; </para>
<para>. ldap master server: IP adress or DNS name of the master (writable) ldap server</para>
<para>  ldap master server [127.0.0.1] &gt; </para>
<para>. ldap master port [389] &gt; </para>
<para>. ldap master bind dn [cn=Manager,dc=amber,dc=global,dc=com] &gt; </para>
<para>. ldap master bind password [] &gt;  </para>
<para>. ldap slave server: IP adress or DNS name of the slave ldap server: can also </para>
<para>  be the master one</para>
<para>  ldap slave server [127.0.0.1] &gt; </para>
<para>. ldap slave port [389] &gt; </para>
<para>. ldap slave bind dn [cn=Manager,dc=amber,dc=global,dc=com] &gt; </para>
<para>. ldap slave bind password [] &gt;  </para>
<para>. ldap tls support (1/0) [0] &gt; </para>
<para>. SID for domain amber: SID of the domain (can be obtained with 'net getlocalsid neptun')</para>
<para>  SID for domain amber [S-1-5-21-1918777035-593721947-2697221154] &gt; </para>
<para>. unix password encryption: encryption used for unix passwords</para>
<para>  unix password encryption (CRYPT, MD5, SMD5, SSHA, SHA) [SSHA] &gt; MD5</para>
<para>. default user gidNumber [513] &gt; </para>
<para>. default computer gidNumber [515] &gt; </para>
<para>. default login shell [/bin/bash] &gt; </para>
<para>. default skeleton directory [/etc/skel] &gt; </para>
<para>. default domain name to append to mail adress [] &gt; </para>
<para>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</para>
<para>backup old configuration files:</para>
<para>  /etc/smbldap-tools/smbldap.conf-&gt;/etc/smbldap-tools/smbldap.conf.old</para>
<para>  /etc/smbldap-tools/smbldap_bind.conf-&gt;/etc/smbldap-tools/smbldap_bind.conf.old</para>
<para>writing new configuration file:</para>
<para>  /etc/smbldap-tools/smbldap.conf done.</para>
<para>  /etc/smbldap-tools/smbldap_bind.conf done.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Если мы не хотим, что бы у всех пользователей профили были перемещаемыми, то в файле /etc/smbldap-tools/smbldap.conf установим следующее значение: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/smbldap-tools/smbldap.conf </para>
</entry>
</row>
<row>
<entry>
<para> ...</para>
<para> userProfile=""</para>
<para> ...</para>
<para> </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Инициализируем каталоги самбы в LDAP: </para>
<para>smbldap-populate -a Administrator -k 0 -m 0</para></sect3><sect3><title>Конфигурация SAMBA</title>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/samba/smb.conf </para>
</entry>
</row>
<row>
<entry>
<para>[global]</para>
<para>        workgroup = amber</para>
<para>        netbios name = neptun</para>
<para>        realm = amber.global.com</para>
<para>        nt acl support = yes</para>
<para>        acl compatibility = win2k</para>
<para>        map acl inherit = yes</para>
<para>        server string = Samba Server %v</para>
<para>        interfaces = eth0</para>
<para>        bind interfaces only = yes</para>
<para>        hosts allow = 192.168.7. 127.</para>
<para>        log file = /var/log/samba/log.%m</para>
<para>        debug level = 9</para>
<para>        max log size = 500</para>
<para>        socket options = TCP_NODELAY SO_SNDBUF=8192 SO_RCVBUF=8192</para>
<para>        security = user</para>
<para>        os level = 250</para>
<para>        passdb backend = ldapsam:"ldap://127.0.0.1/"</para>
<para>        enable privileges = yes</para>
<para>        </para>
<para>        passwd program = /usr/sbin/smbldap-passwd "%u"</para>
<para>        passwd chat = *new*password* %n\n *new*password* %n\n *successfully*</para>
<para>        passdb expand explicit = no</para>
<para>        unix password sync = no</para>
<para>        ldap passwd sync = no</para>
<para>        </para>
<para>        ldap suffix = dc=amber,dc=global,dc=com</para>
<para>        ldap admin dn = cn=Manager,dc=amber,dc=global,dc=com</para>
<para>        ldap user suffix = ou=Users</para>
<para>        ldap group suffix = ou=Groups</para>
<para># Т.к. для самбы компьютеры и пользователи - одно и то же,</para>
<para># и искать она в дальнейшем записи компьютеров будет в пользователях,</para>
<para># то для избежания дальнейших проблем при добавлении рабочих станций</para>
<para># к домену мы вместо следующей строки</para>
<para>#</para>
<para>#       ldap machine suffix = ou=Computers</para>
<para>#</para>
<para># напишем другую:</para>
<para>        ldap machine suffix = ou=Users</para>
<para>        ldap idmap suffix = ou=Idmap</para>
<para>        idmap backend = ldapsam:ldap://127.0.0.1/</para>
<para>        idmap uid = 10000-20000</para>
<para>        idmap gid = 10000-20000</para>
<para>        </para>
<para>        ldap delete dn = Yes</para>
<para>        ldap ssl = no</para>
<para>        </para>
<para>        </para>
<para>        add user script = /usr/sbin/smbldap-useradd -n -a "%u"</para>
<para>        delete user script = /usr/sbin/smbldap-userdel "%u"</para>
<para>        </para>
<para>        add group script = /usr/sbin/smbldap-groupadd -p "%g"</para>
<para>        delete group script = /usr/sbin/smbldap-userdel "%g"</para>
<para>        </para>
<para>        add user to group script = /usr/sbin/smbldap-groupmod -m "%u" "%g"</para>
<para>        delete user from group script = /usr/sbin/smbldap-groupmod -x "%u" "%g"</para>
<para>        set primary group script = /usr/sbin/smbldap-usermod -g "%g" "%u"</para>
<para>        </para>
<para>        </para>
<para>        add machine script = /usr/sbin/smbldap-useradd -w "%u"</para>
<para>        </para>
<para>        #PDC</para>
<para>        domain master = yes</para>
<para>        preferred master = yes</para>
<para>        #BDC</para>
<para>#       domain master = no</para>
<para>#       preferred master = no</para>
<para>        domain logons = Yes</para>
<para>        </para>
<para/>
<para>        logon script = </para>
<para># Если хотите, что бы профили всех пользователей были перемещаемыми</para>
<para># и хранились на сервере (со всеми гигабайтами фильмов и личных фотографий)</para>
<para># то укажите такое значение следующего параметра:</para>
<para>#</para>
<para>#       logon path = \\%L\Profiles\%a\%U</para>
<para>#</para>
<para># Если вы не хотите гонять профили по сети, оставьте значение пустым, </para>
<para># (но ни в коем случае не комментируйте эту строку, она просто получит </para>
<para># значение по умолчанию), вот так:</para>
<para>        logon path =</para>
<para>        logon drive = U: </para>
<para>        logon home = \\%L\users\%U</para>
<para>        </para>
<para>        </para>
<para>#============================ Share Definitions ==============================</para>
<para>[netlogon]</para>
<para>    comment = Network Logon Service</para>
<para>    path = /var/lib/samba/netlogon</para>
<para>    browseable = yes</para>
<para>    guest ok = yes</para>
<para>    writable = no</para>
<para>    share modes = no</para>
<para/>
<para>[Profiles]</para>
<para>    admin users = admin</para>
<para>    create mode = 600</para>
<para>    directory mode = 700</para>
<para>    path = /var/lib/samba/profiles</para>
<para>    browseable = yes</para>
<para>    guest ok = yes</para>
<para>    writable = yes</para>
<para/>
<para>[homes]</para>
<para>  comment = Home Directories</para>
<para>  browseable = no</para>
<para>  read only = no</para>
<para/>
<para>[public]</para>
<para>  path = /pub</para>
<para>  guest ok = yes</para>
<para>  read only = no</para>
<para/>
<para>[users]</para>
<para>  path = /home/users</para>
<para>  writable = yes</para>
<para>  printable = no</para>
<para> </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Добавим запуск winbind с самбой (если нужно): </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/conf.d/samba </para>
</entry>
</row>
<row>
<entry>
<para> ...</para>
<para> daemon_list="smbd nmbd winbind"</para>
<para> ...</para>
<para> </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Введём пароль рабочей станции: </para>
<para>smbpasswd -w secret </para>
<para>Введём контроллёр домена, собственно в домен </para>
<para>net rpc join -S neptun -U Administrator </para></sect3></sect2><sect2><title>Настройка системы на авторизацию в LDAP</title>
<para>--ladserg 14:05, 28 июля 2006 (UTC) У меня честно говоря не получилось сделать авторизацию пользователей samba через LDAP без настройки поддержки авторизации системных пользователей в LDAP, пришлось настраивать и это. </para>
<para>Сначала поправим файл /etc/ldap.conf, приведя его примерно к следующему виду: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/ldap.conf </para>
</entry>
</row>
<row>
<entry>
<para> host 127.0.0.1</para>
<para> base dc=amber,dc=global,dc=com</para>
<para> ldap_version 3</para>
<para> rootbinddn cn=Manager,dc=amber,dc=global,dc=com</para>
<para> bind_timelimit 10</para>
<para> bind_policy soft</para>
<para> pam_filter objectClass=posixAccount</para>
<para> pam_password exop</para>
<para> nss_base_passwd         ou=Users,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_shadow         ou=Users,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_group          ou=Groups,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_hosts          ou=Hosts,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_services       ou=Services,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_networks       ou=Networks,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_protocols      ou=Protocols,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_rpc            ou=Rpc,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_ethers         ou=Ethers,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_netmasks       ou=Networks,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_bootparams     ou=Ethers,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_aliases        ou=Aliases,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_netgroup       ou=Netgroup,dc=tty,dc=perm,dc=ru?one</para>
<para> ssl off</para>
<para> nss_reconnect_tries 4</para>
<para> nss_reconnect_sleeptime 1</para>
<para> nss_reconnect_maxsleeptime 16</para>
<para> nss_reconnect_maxconntries 2</para>
<para> </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Сим мы скажем nss_ldap где и как искать записи пользователей и групп. </para>
<para>Теперь создадим файл /etc/ldap.secret и при помощи любого текстого редактора в plain/text виде занесём туда пароль пользователя, который выше у нас указан в опции rootbinddn, например пароль secret: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/ldap.secret </para>
</entry>
</row>
<row>
<entry>
<para>secret </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Затем непременно установим на него нужные права: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Установка прав на файл /etc/ldap.secret </para>
</entry>
</row>
<row>
<entry>
<para> #chmod 600 /etc/ldap.secret</para>
<para> #chown root:wheel /etc/ldap.secret</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Далее приведём файл /etc/pam.d/system-auth к следующему виду: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/pam.d/system-auth </para>
</entry>
</row>
<row>
<entry>
<para> auth       required     pam_env.so</para>
<para> auth       sufficient   pam_unix.so likeauth nullok</para>
<para> auth       sufficient   pam_ldap.so use_first_pass</para>
<para> auth       required     pam_deny.so</para>
<para/>
<para> account    sufficient   pam_ldap.so</para>
<para> account    required     pam_unix.so</para>
<para/>
<para> password   required     pam_cracklib.so difok=2 minlen=8 dcredit=2 ocredit=2 retry=3</para>
<para> password   sufficient   pam_unix.so nullok md5 shadow use_authtok</para>
<para> password   sufficient   pam_ldap.so use_authtok</para>
<para> password   required     pam_deny.so</para>
<para/>
<para> session    required     pam_limits.so</para>
<para> session    required     pam_unix.so</para>
<para> session    required     pam_mkhomedir.so skel=/etc/skel/ umask=077</para>
<para> session    optional     pam_ldap.so</para>
<para> </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Обратите внимание на строку: </para>
<para>session required pam_mkhomedir.so skel=/etc/skel/ umask=077 </para>
<para>Она заставляет систему создавать домашние каталоги для тех пользоватей у которых они ещё не созданы, при этом в новый каталог помещается содержимое директории /etc/skel/ и задаётся маска каталога 0x700 </para>
<para>После чего правим файл /etc/nsswitch.conf, приводя его к следующему виду: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/nsswitch.conf </para>
</entry>
</row>
<row>
<entry>
<para> passwd:      files ldap</para>
<para> shadow:      files ldap</para>
<para> group:       files ldap</para>
<para/>
<para> hosts:       files dns</para>
<para> networks:    files dns</para>
<para/>
<para> services:    db files</para>
<para> protocols:   db files</para>
<para> rpc:         ldap [NOTFOUND=return] db files</para>
<para> ethers:      ldap [NOTFOUND=return] db files</para>
<para> netmasks:    files</para>
<para> netgroup:    ldap [NOTFOUND=return] files</para>
<para> bootparams:  files</para>
<para/>
<para> automount:   files</para>
<para> aliases:     files </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: Ни в коем случае не добавляйте значение ldap к следующим базам: hosts, networks, protocols, services. Иначе вы рискуете не дождаться следующей загрузки системы. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Всё, теперь мы указали системе брать пользователей как из системных файлов, так и из LDAP. </para>
<para>Перезагрузим наш компьютер, дабы убедиться что система грузится нормально. Если система останавливается на загрузке udev, то смотрите ошибки в файле /etc/nsswitch.conf, может вы указали использовать ldap не в той базе. </para></sect2><sect2><title>Управление пользователями</title>
<para>Ранее мы установили пакет smbldap-tools, теперь рассмотрим возможность управления пользователями с его помощью. </para><sect3><title>Создание пользователя</title>
<para>smbldap-useradd [-o] [-a] [-b] [-w] [-i] [-u uid] [-g gid ] [-G groups,,,] </para>
<para> [-n] [-d home] [-s shell] [-c gecos] [-m [-k]] [-t] [-P] [-A 0|1] [-B 0|1] </para>
<para> [-C sambaHomePath] [-D sambaHomeDrive] [-E sambaLogonScript] [-F sambaProfilePath] </para>
<para> [-H sambaAcctFlags] [-N surname] [-S family name] [-M local mailAddress,,,] </para>
<para> [-T mailToAddress] [-?] user</para>
<para>Где: </para>
<para> user - системное имя создаваемого пользователя</para>
<para> -o   - add the user in the organizational unit (relative to the user suffix)</para>
<para> -a   - is a Windows User (otherwise, Posix stuff only)</para>
<para> -b   - is a AIX User</para>
<para> -w   - is a Windows Workstation (otherwise, Posix stuff only)</para>
<para> -i   - is a trust account (Windows Workstation)</para>
<para> -u   - uid</para>
<para> -g   - gid</para>
<para> -G   - список групп пользователя, разделённых запятой.</para>
<para> -n   - do not create a group</para>
<para> -d   - домашний каталог пользователя (по умолчанию /home/имя_пользователя)</para>
<para> -s   - оболочка пользователя (по умолчанию /bin/false)</para>
<para> -c   - отображаемое в Windows имя пользователя</para>
<para> -m   - создать домашний каталог и скопировать в него файлы из /etc/skel</para>
<para> -k   - указать иной каталог, из которого будут копироваться файлы при </para>
<para>        создании домашнего каталога пользователя (используется с ключём -m)</para>
<para> -t   - time. Wait 'time' seconds before exiting (when adding Windows Workstation)</para>
<para> -P   - ends by invoking smbldap-passwd</para>
<para> -A   - возможность менять пароль пользователем, значение 0 если нет, 1 если да</para>
<para> -B   - пользователь должен поменять пароль, значение 0 если нет, 1 если да</para>
<para> -C   - домашний каталог samba (например '\\PDC-SRV\homes')</para>
<para> -D   - буква диска для монтирования домашнего каталога samba (например 'H:')</para>
<para> -E   - скрипт, выполняемый при входе в систему</para>
<para> -F   - каталог профиля пользователя (например '\\PDC-SRV\profiles\foo')</para>
<para> -H   - sambaAcctFlags (samba account control bits like '[NDHTUMWSLKI]')</para>
<para> -N   - настоящее имя пользователя (для русских ещё и отчество)</para>
<para> -S   - фамилия пользователя</para>
<para> -M   - local mailAddress (comma seperated)</para>
<para> -T   - mailToAddress (forward address) (comma seperated)</para>
<para> -?   - отобразить помощь</para>
<para>Например создание пользователя ladserg: </para>
<para>smbldap-useradd -a -c 'Serg Alex Lad' -N 'Serg Alex' -S 'Lad' -s /bin/bash ladserg </para>
<para>К сожалению подружить smbldap-tools с русским мне не удалось, даже при использовании кодировки UTF-8. </para>
<para>Итак, в приведённом выше примере будет создан пользователь с системным именем ladserg, фамилией Lad, именем Serg Alex, оболочкой /bin/bash, домашним каталогом /home/ladserg. Флаг -a укажет, что пользователь также будет являться пользователем домена. </para></sect3><sect3><title> Изменение пароля</title>
<para>smbldap-passwd [-s] [-u] [-h] username</para>
<para>Где: </para>
<para> username       - имя пользователя</para>
<para> -h, -?, --help - показать помощь</para>
<para> -s             - обновить только samba пароль</para>
<para> -u             - обновить только UNIX пароль</para>
<para>Например: </para>
<para>smbldap-passwd ladserg </para>
<para>После чего дважды будет запрошен пароль. </para>
<para>Теперь можно попробовать зайти в систему под учётной записью только что созданного пользователя. </para></sect3><sect3><title>Модификация пользователя</title>
<para>smbldap-usermod [-a] [-c comment] [-d home_dir] [-e expiration_date] </para>
<para> [-g initial_group] [-r new_login_name] [-p passwd] [-s shell] [-u uid [ -o]] [-x] </para>
<para> [-A canchange] [-B mustchange] [-C smbhome] [-D homedrive] [-E scriptpath] </para>
<para> [-F profilepath] [-G group[,...]] [-H acct‐flags] [-N canonical_name] </para>
<para> [-S surname] [-P] login</para>
<para>Где: </para>
<para> -c    - Полное имя</para>
<para> -d    - Домашний каталог</para>
<para> -r    - новое имя пользователя (cn, sn и dn будут обновлены)</para>
<para> -u    - uid</para>
<para> -o    - uid может быть не уникальным</para>
<para> -g    - gid</para>
<para> -G    - список групп пользователя, разделённых запятой.</para>
<para> -s    - оболочка</para>
<para> -N    - настоящее имя пользователя (для русских ещё и отчество)</para>
<para> -S    - фамилия пользователя</para>
<para> -P    - ends by invoking smbldap-passwd</para>
<para>For samba users:</para>
<para> -a    - add sambaSAMAccount objectclass</para>
<para> -e    - expire date ("YYYY-MM-DD HH:MM:SS")</para>
<para> -A    - возможность менять пароль пользователем, значение 0 если нет, 1 если да</para>
<para> -B    - пользователь должен поменять пароль, значение 0 если нет, 1 если да</para>
<para> -C    - домашний каталог samba (например '\\PDC-SRV\homes')</para>
<para> -D    - буква диска для монтирования домашнего каталога samba (например 'H:')</para>
<para> -E    - скрипт, выполняемый при входе в систему</para>
<para> -F    - каталог профиля пользователя (например '\\PDC-SRV\profiles\foo')</para>
<para> -H    - sambaAcctFlags (samba account control bits like '[NDHTUMWSLKI]')</para>
<para> -I    - disable an user. Can't be used with -H or -J</para>
<para> -J    - enable an user. Can't be used with -H or -I</para>
<para> -M    - mailAddresses (comma seperated)</para>
<para> -T    - mailToAddress (forward address) (comma seperated)</para>
<para> -?|-h - отобразить помощь</para>
<para>Например комманда: </para>
<para>smbldap-usermod -A 1 ladserg</para>
<para>Позволит пользователю ladserg менять пароль. А комманда: </para>
<para>smbldap-usermod -a slad-adm</para>
<para>Добавит к учётной записи пользователя slad-adm класс sambaSAMAccount, что сделает его пользователем samba. </para></sect3><sect3><title>Удаление пользователя</title>
<para>smbldap-userdel [-r|-R|-?] username</para>
<para>Где: </para>
<para> -r    удалить домашний каталог</para>
<para> -R    удалить домашний каталог с запросом на удаление каждого файла</para>
<para> -?    отобразить помощь</para>
<para>Например команда: </para>
<para>smbldap-userdel -r slad-adm </para>
<para>удалит пользователя slad-adm, и его домашний каталог. </para></sect3></sect2><sect2><title>Управление пользователями в оффтопике</title>
<para>Если вы вводите в домен компьютеры под управлением Windows, то вам пригодятся пара утилит, архив которых можно скачать отсюда: </para>
<para>
<ulink url="ftp://ftp.microsoft.com/Softlib/MSLFILES/SRVTOOLS.EXE">ftp://ftp.microsoft.com/Softlib/MSLFILES/SRVTOOLS.EXE</ulink> </para></sect2><sect2><title>Источники</title>
<orderedlist>
<listitem>
<para>
<ulink url="http://us4.samba.org/samba/docs/man/Samba-Guide/happy.html">http://us4.samba.org/samba/docs/man/Samba-Guide/happy.html</ulink> </para>
</listitem>
<listitem>
<para>
<ulink url="http://www.opennet.ru/base/net/ldap_spama_pdc.txt.html">http://www.opennet.ru/base/net/ldap_spama_pdc.txt.html</ulink> </para>
</listitem>
</orderedlist>
<para/></sect2></sect1><sect1><title>Создание виртуальной почтовой системы</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/virt-mail-howto.xml">http://www.gentoo.org/doc/ru/virt-mail-howto.xml</ulink>
</para>
<para>C версии: 1.0</para><sect2><title>1. Введение</title>
<para/>
<para>Для большинства пользователей gentoo простого почтового клиента и fetchmail (для сбора почты) достаточно. Однако, если вы размещаете на своей системе домен, вам необходим полноценный MTA (Mail Transfer Agent). И если вы размещаете на своей системе несколько доменов, тогда вам точно необходимо что-то мощное для обработки всей почты ваших пользователей. Эта система была разработана для элегантного решения этой проблемы. </para>
<para/>
<para>Виртуальная почтовая система должна быть способна обработать почту от многочисленных доменов с множеством пользователей через разнообразные интерфейсы. С этим связано несколько проблем, которые надо решить. Для примера, что если вы имеете двух пользователей в разных доменах, которые хотят иметь одинаковые имена? Если вы предоставляете сервисы imap и smtp-авторизации, как вы комбинируете различные демоны авторизации в одной системе? Как обеспечиваете безопасность многочисленных компонентов которая содержит система? Как вы управляете этим всем? </para>
<para/>
<para>Это howto покажет вам, как настроить гибкую систему обработки почты из стольких доменов, сколько ваша поддерживает система, как создавать виртуальных пользователей не требующих наличия аккаунта в системе, иметь доменные имена пользователей, как авторизовать пользователей через веб, imap, smtp и pop3 снова таки из одной базы данных, использовать ssl-транспорт для безопасности, как обрабатывать списки рассылки для любого домена на машине, и контролировать все хорошей и простой базой данных mysql. </para>
<para/>
<para>Конечно существует множество путей настройки виртуальной почтовой системы. Другой способ возможно окажется более подходящим вашим нуждам. Дополнительную информацию вы можете найти на http://www.qmail.org/ и http://www.exim.org/ </para>
<para/>
<para>Мы будем использовать следующие программы: apache, courier-imap, pam_mysql, postfix, mod_php, phpmyadmin, squirrelmail, cyrus-sasl, mysql, php, и mailman. </para>
<para/>
<para>Убедитесь что вы добавили в файле /etc/make.conf в переменную USE следующие пакеты: USE="mysql imap libwww maildir sasl ssl". Иначе, возможно, вам придeтся перекомпилировать пакеты, для поддержки всех необходимых протоколов. Затем, хорошей идеей будет отключить любые другие почтовые и сетевые программы которые вам не нужны, вроде IPv6. </para>
<para>Важно: Это howto написано для postfix-2.0.x. Если вы используете postfix версии &lt; 2 некоторые переменные используемые в этом документе могут отличается. В таком случае рекомендуется обновить postfix. Некоторые пакеты используемые в этом документе зависят от версии. Вы поступите мудро, если прочтете документацию поставляемую с пакетами, при возникновении вопросов. </para>
<para/>
<para>Важно: В нашем документе мы будем использовать apache-1.3.x. В портежах Apache-2 был помечен stable, но как бы то ни было существуют еще некоторые проблемы интеграции с php. Пока php-поддержка в apache-2.0.x не будет отмечена stable, в этом документе будем продолжать использовать apache-1.3.x. </para>
<para/>
<para>Важно: Вам необходимо доменное имя для работы общедоступного почтового сервера, или по крайней мере иметь МХ-записи для домена. В идеале вы должны иметь контроль над двумя доменами, для извлечения пользы из функциональности новой виртуальной системы. </para>
<para/>
<para>Важно: Убедитесь что в /etc/hostname указано правильное имя сервера, также убедитесь что в /etc/hosts нет конфликтных значений. </para>
<para/>
<para>Примечание: Рекомендуется прочесть документ полностью и ознакомится со всеми шагами настройки, перед тем как начинать инсталляцию. Если вы столкнетесь с проблемами при любом из шагов, проверьте troubleshooting guide в конце этого документа. Также не все упомянутые пакеты необходимы, просто настройка, описанная здесь, достаточна гибка. Для примера, если вам не требуется веб-интерфейса, вы свободны пропустить соответствующий раздел squirrelmail. </para>
<para/>
<para/></sect2><sect2><title>2. Начальная настройка postfix</title>
<para/>
<para>Листинг 2.1: Инсталляция postfix</para>
<para># emerge postfix</para>
<para/>
<para>Предупреждение: Проверьте чтобы у вас не были проинсталлированы любые другие MTA, например ssmtp, exim или qmail, иначе у вас могут быть БОЛЬШИЕ проблемы. </para>
<para/>
<para/>
<para>После инсталляции postfix, время его настроить. Измените следующие настройки в /etc/postfix/main.cf: </para>
<para/>
<para>Листинг 2.2: /etc/postfix/main.cf</para>
<para/>
<para>myhostname = $host.domain.name</para>
<para>mydomain = $domain.name</para>
<para>inet_interfaces = all</para>
<para>mydestination = $myhostname, localhost.$mydomain $mydomain</para>
<para>mynetworks = my.ip.net.work/24, 127.0.0.0/8</para>
<para>home_mailbox = .maildir/</para>
<para>local_destination_concurrency_limit = 2</para>
<para>default_destination_concurrency_limit = 10 </para>
<para/>
<para/>
<para>Следующие изменения следуют для /etc/postfix/master.cf. Они включат режим подробного протоколирования для отладки: </para>
<para/>
<para>Листинг 2.3: /etc/postfix/master.cf</para>
<para/>
<para># service type  private unpriv  chroot  wakeup  maxproc command + args</para>
<para>#               (yes)   (yes)   (yes)   (never) (50)</para>
<para>#</para>
<para>==========================================================================</para>
<para>smtp      inet  n       -       n       -       -       smtpd -v</para>
<para/>
<para>(просто добавьте -v после smtpd)</para>
<para/>
<para/>
<para>Дальше правим /etc/mail/aliases для добавления локальных псевдонимов. По крайне туда должен быть включен псевдоним для root типа: root: your@email.address. </para>
<para/>
<para>Листинг 2.4: Запуск postfix'а в первый раз</para>
<para># /usr/bin/newaliases</para>
<para>(это создаст новые псевдонимы. Это требуется делать)</para>
<para>(когда вы создаете или обновляете файл псевдонимов.)</para>
<para># /etc/init.d/postfix start</para>
<para/>
<para/>
<para>Теперь postfix запущен, запустите вашего любимого консольного почтового клиента и пошлите самому себе письмо. Я использую mutt для всей переписки из консоли. </para>
<para>Примечание: Настоятельно рекомендуется проверить, чтобы postfix доставлял почту локальным пользователям, перед тем как перейти к следующему шагу. </para>
<para/>
<para/></sect2><sect2><title>3. Courier-imap</title>
<para/>
<para>Листинг 3.1: Инсталляция courier-imap</para>
<para># emerge courier-imap</para>
<para/>
<para/>
<para>Листинг 3.2: Настройка courier-imap</para>
<para># cd /etc/courier-imap</para>
<para>(если вы хотите использовать возможности ssl в courier-imap или pop3, )</para>
<para>(вам необходимо создать сертификаты)</para>
<para>(если вы не хотите использовать ssl, просто пропустите следующий шаг )</para>
<para/>
<para># nano -w pop3d.cnf</para>
<para># nano -w imapd.cnf</para>
<para>(измените значения C, ST, L, CN и адреса e-mail)</para>
<para/>
<para># mkpop3dcert</para>
<para># mkimapdcert</para>
<para/>
<para/>
<para>Листинг 3.3: Запуск нужных вам сервисов courier</para>
<para># /etc/init.d/courier-imapd start</para>
<para># /etc/init.d/courier-imapd-ssl start</para>
<para># /etc/init.d/courier-pop3d start</para>
<para># /etc/init.d/courier-pop3d-ssl start</para>
<para/>
<para/>
<para>Снова запустите ваш любимый почтовый клиент и проверьте что сервисы начали принимать и посылать почту. Теперь когда основная часть заработала, перейдем к связыванию всех компонентов, для получения спокойно работающей системы. Снова, проверьте, что все что мы сделали работает, перед тем как переходить к следующему шагу. </para>
<para/></sect2><sect2><title>4. Cyrus-sasl</title>
<para/>
<para>Следующим шагом будет инсталляция cyrus-sasl. Sasl на самом деле играет роль передатчика авторизационных переменных к pam (Pluggable Authentication Modules), который передаст эту информацию mysql, для авторизации smtp пользователей. Мы не будем проверять работоспособность sasl, пока не настроим mysql, и не создадим тестовых пользователей. В конечном результате, он будет авторизовать пользователей в mysql. </para>
<para>Примечание: По некоторым причинам, sasl плохо работает с pam используя shadow. Для меня долгое время это была большая проблема. Если кто-нибудь знает почему sasl не авторизирует пользователей из /etc/shadow в текущем релизе gentoo, пожалуйста напишите мне об этом, я буду очень рад услышать решение этой проблемы. E-mail. </para>
<para/>
<para/>
<para>Листинг 4.1: Инсталляция и настройка cyrus-sasl</para>
<para># USE='-ldap -mysql' emerge cyrus-sasl</para>
<para>(мы не используем ldap и мы не используем возможности sasl-mysql,</para>
<para>поэтому мы отключаем их )</para>
<para/>
<para/>
<para>Дальше правим /usr/lib/sasl2/smtp.conf. </para>
<para/>
<para>Листинг 4.2: Запуск sasl</para>
<para># nano -w /usr/lib/sasl2/smtp.conf</para>
<para>pwcheck_method: saslauthd</para>
<para>mech_list: LOGIN PLAIN</para>
<para>(важно выключить метод авторизации который мы не используем.</para>
<para>Они могут привести к граблям на некоторых почтовых клиентах)</para>
<para># /etc/init.d/saslauthd start</para>
<para/>
<para/></sect2><sect2><title>5. SSL-сертификаты для Postfix и Apache</title>
<para/>
<para>Дальше делаем ssl-сертификаты для posfix и apache. </para>
<para/>
<para>Листинг 5.1: </para>
<para># cd /etc/ssl/</para>
<para># nano -w openssl.cnf</para>
<para>(измените следующие значения для вашего домена:)</para>
<para>countryName_default</para>
<para>stateOrProvinceName_default</para>
<para>localityName_default</para>
<para>0.organizationName_default</para>
<para>commonName_default</para>
<para>emailAddress_default.</para>
<para/>
<para>(если каких-то переменных нет, просто добавьте их в любое удобное место)</para>
<para/>
<para># cd misc</para>
<para># nano -w CA.pl</para>
<para>(нам необходимо добавить -nodes в код строк "# create a certificate" и</para>
<para>"# create a certificate request" таким образом чтобы наши новые ssl-сертификаты</para>
<para>загрузились без пароля. Иначе после перезагрузки системы ssl-сертификаты будут </para>
<para>не доступны )</para>
<para>(найдите эти строки в файле и измените их:)</para>
<para/>
<para># create a certificate</para>
<para>system ("$REQ -new -nodes -x509 -keyout newreq.pem -out newreq.pem $DAYS");</para>
<para/>
<para># create a certificate request</para>
<para>system ("$REQ -new -nodes -keyout newreq.pem -out newreq.pem $DAYS");</para>
<para/>
<para>(далее создаем сертификат для postfix)</para>
<para/>
<para># ./CA.pl -newca</para>
<para># ./CA.pl -newreq</para>
<para># ./CA.pl -sign</para>
<para># cp newcert.pem /etc/postfix</para>
<para># cp newreq.pem /etc/postfix</para>
<para># cp demoCA/cacert.pem /etc/postfix</para>
<para>(а теперь такой же для apache)</para>
<para/>
<para># openssl req -new &gt; new.cert.csr</para>
<para># openssl rsa -in privkey.pem -out new.cert.key</para>
<para># openssl x509 -in new.cert.csr -out new.cert.cert -req -signkey new.cert.key -days 365</para>
<para>(оставьте получившиеся сертификаты, мы их проинсталлируем когда будем настраивать apache )</para>
<para/>
<para/></sect2><sect2><title>6. Добавим SSL и SASL поддержку в Postfix</title>
<para/>
<para>Теперь поправим конфигурацию postfix чтобы включить совместимость с sasl и ssl. Добавьте следующие параметры в конец файла, где их легко потом можно будет найти. </para>
<para/>
<para>Листинг 6.1: /etc/postfix/main.cf</para>
<para># nano -w /etc/postfix/main.cf</para>
<para/>
<para>smtpd_sasl_auth_enable = yes</para>
<para>smtpd_sasl2_auth_enable = yes</para>
<para>smtpd_sasl_security_options = noanonymous</para>
<para>broken_sasl_auth_clients = yes</para>
<para>smtpd_sasl_local_domain =</para>
<para/>
<para>(опция broken_sasl_auth_clients и метод авторизации используется только</para>
<para>для outlook и outlook express, они не документированы. Опция smtpd_sasl_local_domain </para>
<para>добавляет имя домена для клиентов использующих smtp-авторизацию. Убедитесь что </para>
<para>postfix отвергает пустое или просто имя пользователя, и они не могут авторизоваться )</para>
<para/>
<para>smtpd_recipient_restrictions =</para>
<para>        permit_sasl_authenticated,</para>
<para>        permit_mynetworks,</para>
<para>        reject_unauth_destination</para>
<para/>
<para/>
<para>smtpd_use_tls = yes</para>
<para>#smtpd_tls_auth_only = yes</para>
<para>smtpd_tls_key_file = /etc/postfix/newreq.pem</para>
<para>smtpd_tls_cert_file = /etc/postfix/newcert.pem</para>
<para>smtpd_tls_CAfile = /etc/postfix/cacert.pem</para>
<para>smtpd_tls_loglevel = 3</para>
<para>smtpd_tls_received_header = yes</para>
<para>smtpd_tls_session_cache_timeout = 3600s</para>
<para>tls_random_source = dev:/dev/urandom</para>
<para/>
<para>(опция smtpd_tls_auth_only закомментирована для простоты тестирования,</para>
<para>вы можете включить ее позже, если захотите)</para>
<para/>
<para># postfix reload</para>
<para/>
<para/>
<para>Теперь мы попробуем проверить работоспособность postfix'а, и то что он прочел файлы конфигурации. </para>
<para/>
<para>Листинг 6.2: Проверка поддержки sasl и tls</para>
<para># telnet localhost 25</para>
<para/>
<para>Trying 127.0.0.1...</para>
<para>Connected to localhost.</para>
<para>Escape character is '^]'.</para>
<para>220 mail.domain.com ESMTP Postfix</para>
<para>EHLO domain.com</para>
<para>250-mail.domain.com</para>
<para>250-PIPELINING</para>
<para>250-SIZE 10240000</para>
<para>250-VRFY</para>
<para>250-ETRN</para>
<para>250-STARTTLS</para>
<para>250-AUTH LOGIN PLAIN</para>
<para>250-AUTH=LOGIN PLAIN</para>
<para>250-XVERP</para>
<para>250 8BITMIME</para>
<para>^]</para>
<para>telnet&gt; quit</para>
<para/>
<para/>
<para>Проверьте, что ответ postfix'а содержит линии AUTH и STARTTLS. Как уже замечалось выше, AUTH пока не будет работать, потому что sasl пытается авторизовать из sasldb, вместо shadow по неизвестным причинам. Итак мы просто пропускаем это и дальше настраиваем mysql для принятия нашей авторизации и информации о виртуальных доменах. </para>
<para/></sect2><sect2><title>7. MySQL</title>
<para/>
<para>Для инсталляции mysql нам необходим dump-файл genericmailsql.sql genericmailsql.sql </para>
<para/>
<para>Листинг 7.1: Инсталляция и настройка MySQL</para>
<para># emerge mysql</para>
<para># /usr/bin/mysql_install_db</para>
<para>(далее следуйте указаниям на экране, для добавления пароля root в </para>
<para>mysql, не mysqladmin, иначе ваша база будет открыта всем ветрам )</para>
<para/>
<para># /etc/init.d/mysql start</para>
<para># mysqladmin -u root -p create mailsql</para>
<para># mysql -u root -p mailsql &lt; genericmailsql.sql</para>
<para/>
<para># mysql -u root -p mysql</para>
<para>mysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE</para>
<para>        -&gt;     ON mailsql.*</para>
<para>        -&gt;     TO mailsql@localhost</para>
<para>        -&gt;     IDENTIFIED BY '$password';</para>
<para/>
<para>        -&gt;     quit</para>
<para>(проверьте, что новый mailsql пользователь, может подключатся к mysql серверу )</para>
<para/>
<para># mysql -u mailsql -p mailsql</para>
<para/>
<para/>
<para>Ваша новая база имеет значения по умолчанию и таблицы для двух доменов. Вложены следующие таблицы: </para>
<para/>
<orderedlist>
<listitem>
<para>alias — локальные e-mail и информация о псевдонимах для mailman</para>
</listitem>
<listitem>
<para>relocated — информация о адресах перемещенных пользователях</para>
</listitem>
<listitem>
<para>transport — информация о почтовых транспортах для всех доменов размещающихся у вас </para>
</listitem>
<listitem>
<para>users — информация о всех пользователях</para>
</listitem>
<listitem>
<para>virtual — информация о псевдонимах для виртуальных доменов</para>
</listitem>
</orderedlist>
<para/>
<para>Листинг 7.2: пример таблицы псевдонимов</para>
<para>id   alias    destination</para>
<para>1    root     foo@bar.com</para>
<para>2  postmaster foo@bar.com</para>
<para/>
<para/>
<para>Листинг 7.3: пример таблицы пользователей</para>
<para>(приведем для ясности строку)</para>
<para>id email            clear     name     uid     gid     homedir     \</para>
<para>        maildir                                quota  postfix</para>
<para>10 foo@virt-bar.org $password realname virtid  virtid  /home/vmail \</para>
<para>        /home/vmail/virt-bar.org/foo/.maildir/        y</para>
<para>13 foo@bar.com      $password realname localid localid /home/foo   \</para>
<para>        /home/foo/.maildir/                           y</para>
<para/>
<para/>
<para>Листинг 7.4: пример таблицы транспортов</para>
<para>id   domain       destination</para>
<para>1    bar.com      local:</para>
<para>2    virt-bar.org virtual:</para>
<para/>
<para/>
<para>Листинг 7.5: пример таблицы псевдонимов для виртуальных доменов</para>
<para>id   email            destination</para>
<para>3   root@virt-bar.org other@email.address</para>
<para/>
<para/></sect2><sect2><title>8. Apache и phpMyAdmin</title>
<para/>
<para>Итак, следующим шагом мы настроим apache и создадим интерфейс для еще более простого взаимодействия с базой данных. </para>
<para/>
<para>Листинг 8.1: Настройка apache и phpmyadmin</para>
<para># emerge apache mod_php phpmyadmin</para>
<para/>
<para/>
<para>Существует множество руководств по настройке apache с поддержкой php. Например, http://www.linuxguruz.org/z.php?id=31. Также многочисленные сообщения на http://forums.gentoo.org где рассматриваются решения проблем возникших в ходе инсталляции (поиск по "apache php"). Итак, я не стараюсь раскрыть эту тему здесь. Настройте apache и php, затем продолжим вместе настройку. Теперь слово для умных: .htaccess положите в директорию к phpmyadmin. Если вы не сделаете этого, поисковые системы проиндексируют страницы phpmyadmin и каждый сможет получить к нему доступ с помощью google, и изменить ваши базы, что не есть хорошо. Существует много howto как это сделать. http://docs.csoft.net/micro/black-htaccess.html. </para>
<para/>
<para>Теперь мы переходим к инсталляции сертификатов для apache, созданных нами ранее. Директивы apache которые вам требуется изменить для этого: </para>
<para>SSLCertificateFile /path/to/certs/new.cert.cert</para>
<para>SSLCertificateKeyFile /path/to/certs/new.cert.key</para>
<para/>
<para>Листинг 8.2: Инсталляция Apache SSL сертификатов</para>
<para># cp /etc/ssl/misc/new.cert.cert /etc/apache/conf/ssl/</para>
<para># cp /etc/ssl/misc/new.cert.key /etc/apache/conf/ssl/</para>
<para># nano -w /etc/apache/conf/vhosts/ssl.default-vhost.conf</para>
<para>(измените следующие параметры)</para>
<para/>
<para>ServerName host.domain.name</para>
<para>ServerAdmin your@email.address</para>
<para>SSLCertificateFile /etc/apache/conf/ssl/new.cert.cert</para>
<para>SSLCertificateKeyFile /etc/apache/conf/ssl/new.cert.key</para>
<para/>
<para># /etc/init.d/apache restart</para>
<para/>
<para>Примечание: Если у вас apache уже проинсталлирован, вам вероятно придется сделать перезагрузку сервера. Проверьте логи системы на предмет корректного запуска apache. </para>
<para/>
<para/>
<para>Дальше настраиваем phpMyAdmin. </para>
<para/>
<para>Листинг 8.3: Настройка phpMyAdmin</para>
<para># nano -w /home/httpd/htdocs/phpmyadmin/config.inc.php</para>
<para>(измените следующие параметры)</para>
<para/>
<para>$cfg['Servers'][$i]['host'] = 'localhost';          // MySQL hostname</para>
<para>$cfg['Servers'][$i]['controluser'] = 'mailsql';     // MySQL настройки системного аккаунта</para>
<para>                                                    // (этот аккаунт должен иметь read-only</para>
<para>$cfg['Servers'][$i]['controlpass'] = '$password';   // доступ к таблицам "mysql/user"</para>
<para>                                                    // и "mysql/db" tables)</para>
<para>$cfg['Servers'][$i]['user'] = 'mailsql';            // MySQL пользователь</para>
<para>$cfg['Servers'][$i]['password'] = '$password';      // MySQL пароль</para>
<para/>
<para/>
<para>Теперь введите адрес phpmyadmin страницы и просмотрите ваши таблицы в базе. Вы можете добавить локальные псевдонимы, поправить таблицу пользователей и добавить тестового пользователя, изменить таблицу транспортов для добавления информации о ваших доменах. Значений по умолчанию которые устанавливаются вместе с dump-файлом должно быть достаточно для примера, чтобы помочь вам настроить систему. Убедитесь что ввели в базу корректную информацию. Для примера, убедитесь что директории локальных пользователей существуют и указаны корректные uid/gid. Почтовые директории пользователей, должны быть созданы postfix, при первой принятой почте для пользователя. Будет неплохо, если вы пошлете "Добро пожаловать!", чтобы убедится, что .maildir создан. </para>
<para/></sect2><sect2><title>9. Vmail-пользователь</title>
<para/>
<para>Здесь вы можете быть удивлены, узнав, что для виртуальных акаунтов, используются пользователи и директории, и будете правы. </para>
<para/>
<para>Листинг 9.1: Adding the vmail user</para>
<para># adduser -d /home/vmail -s /bin/false vmail</para>
<para># uid=`cat /etc/passwd | grep vmail | cut -f 3 -d :`</para>
<para># groupadd -g $uid vmail</para>
<para># mkdir /home/vmail</para>
<para># chown vmail. /home/vmail</para>
<para/>
<para/>
<para>Теперь, когда вы настраиваете виртуальный акаунт, используйте vmail uid, gid , и его домашнюю папку. Когда вы создаете локальный акаунт, используйте uid, gid и домашнюю папку нового пользователя, а не vmail. Мы имеем ввиду, что если вы захотите создать php-страничку для администрирования пользователей, не забывайте, что phpmyadmin в целом справляется с этой работой очень неплохо. </para>
<para/></sect2><sect2><title>10. Настройка MySQL авторизации и виртуальных доменов</title>
<para/>
<para>Дальше мы перенастроим нашу авторизацию, на использование mailsql базы в courier-imap и postfix. Во всех следующих примерах, замените $paasword паролем, который вы задали пользователю mailsql для mysql. </para>
<para/>
<para>Листинг 10.1: </para>
<para># emerge /usr/portage/sys-libs/pam_mysql/pam_mysql-$currentversion.ebuild</para>
<para>(этот пакет здесь задан маской, которую вы должны заменить на текущую </para>
<para>версию пакета. версию пакета вы можете посмотреть в portage )</para>
<para/>
<para># nano -w /etc/pam.d/imap</para>
<para>(закомментируйте существующие строки настройки авторизации, и добавьте </para>
<para>указанные ниже)</para>
<para/>
<para>#auth       required     pam_nologin.so</para>
<para>#auth       required     pam_stack.so service=system-auth</para>
<para>#account    required     pam_stack.so service=system-auth</para>
<para>#session    required     pam_stack.so service=system-auth</para>
<para/>
<para>auth     optional       pam_mysql.so host=localhost db=mailsql user=mailsql \</para>
<para>  passwd=$password table=users usercolumn=email passwdcolumn=clear crypt=0</para>
<para>account  required       pam_mysql.so host=localhost db=mailsql user=mailsql \</para>
<para>  passwd=$password table=users usercolumn=email passwdcolumn=clear crypt=0</para>
<para/>
<para># nano -w /etc/pam.d/pop3</para>
<para># nano -w /etc/pam.d/smtp</para>
<para>(сделайте такие же изменения в pop3 и smtp файлах)</para>
<para/>
<para/>
<para>Далее нам нужно поправить конфигурацию авторизации courier. </para>
<para/>
<para>Листинг 10.2: </para>
<para># nano -w /etc/courier-imap/authdaemonrc</para>
<para>authmodulelist="authmysql authpam"</para>
<para/>
<para># nano -w /etc/courier-imap/authdaemond.conf</para>
<para>AUTHDAEMOND="authdaemond.mysql"</para>
<para/>
<para># nano -w /etc/courier-imap/authmysqlrc</para>
<para>MYSQL_SERVER            localhost</para>
<para>MYSQL_USERNAME       mailsql</para>
<para>MYSQL_PASSWORD      $password</para>
<para>MYSQL_DATABASE          mailsql</para>
<para>MYSQL_USER_TABLE        users</para>
<para>#MYSQL_CRYPT_PWFIELD    crypt (эта строка должна быть закомментирована)</para>
<para>MYSQL_CLEAR_PWFIELD     clear</para>
<para>MYSQL_UID_FIELD         uid</para>
<para>MYSQL_GID_FIELD         gid</para>
<para>MYSQL_LOGIN_FIELD       email</para>
<para>MYSQL_HOME_FIELD        homedir</para>
<para>MYSQL_NAME_FIELD        name</para>
<para>MYSQL_MAILDIR_FIELD     maildir</para>
<para/>
<para># /etc/init.d/authdaemond restart</para>
<para># /etc/init.d/saslauthd restart</para>
<para/>
<para/>
<para>Мы уже почти подошли к тому что вам обещал. Далее мы настроим необходимые конфиги postfix'a для связки с базой данных для всех необходимых необходимых транспортов. </para>
<para/>
<para>Листинг 10.3: /etc/postfix/mysql-aliases.cf</para>
<para># nano -w /etc/postfix/mysql-aliases.cf</para>
<para># mysql-aliases.cf</para>
<para/>
<para>user            = mailsql</para>
<para>password        = $password</para>
<para>dbname          = mailsql</para>
<para>table           = alias</para>
<para>select_field    = destination</para>
<para>where_field     = alias</para>
<para>hosts           = unix:/var/run/mysqld/mysqld.sock</para>
<para/>
<para/>
<para>Листинг 10.4: /etc/postfix/mysql-relocated.cf</para>
<para># nano -w /etc/postfix/mysql-relocated.cf</para>
<para># mysql-relocated.cf</para>
<para/>
<para>user            = mailsql</para>
<para>password        = $password</para>
<para>dbname          = mailsql</para>
<para>table           = relocated</para>
<para>select_field    = destination</para>
<para>where_field     = email</para>
<para>hosts           = unix:/var/run/mysqld/mysqld.sock</para>
<para/>
<para/>
<para>Листинг 10.5: /etc/postfix/mysql-transport.cf (необязательно)</para>
<para># nano -w /etc/postfix/mysql-transport.cf</para>
<para># mysql-transport.cf</para>
<para/>
<para>user            = mailsql</para>
<para>password        = $password</para>
<para>dbname          = mailsql</para>
<para>table           = transport</para>
<para>select_field    = destination</para>
<para>where_field     = domain</para>
<para>hosts           = unix:/var/run/mysqld/mysqld.sock</para>
<para/>
<para/>
<para>Листинг 10.6: /etc/postfix/mysql-virtual-gid.cf (необязательно)</para>
<para># nano -w /etc/postfix/mysql-virtual-gid.cf</para>
<para>#myql-virtual-gid.cf</para>
<para/>
<para>user            = mailsql</para>
<para>password        = $password</para>
<para>dbname          = mailsql</para>
<para>table           = users</para>
<para>select_field    = gid</para>
<para>where_field     = email</para>
<para>additional_conditions = and postfix = 'y'</para>
<para>hosts           = unix:/var/run/mysqld/mysqld.sock</para>
<para/>
<para/>
<para>Листинг 10.7: /etc/postfix/mysql-virtual-maps.cf</para>
<para>#nano -w /etc/postfix/mysql-virtual-maps.cf</para>
<para>#myql-virtual-maps.cf</para>
<para/>
<para>user            = mailsql</para>
<para>password        = $password</para>
<para>dbname          = mailsql</para>
<para>table           = users</para>
<para>select_field    = maildir</para>
<para>where_field     = email</para>
<para>additional_conditions = and postfix = 'y'</para>
<para>hosts           = unix:/var/run/mysqld/mysqld.sock</para>
<para/>
<para/>
<para>Листинг 10.8: /etc/postfix/mysql-virtual-uid.cf (необязательно)</para>
<para># nano -w /etc/postfix/mysql-virtual-uid.cf</para>
<para># mysql-virtual-uid.cf</para>
<para/>
<para>user            = mailsql</para>
<para>password        = $password</para>
<para>dbname          = mailsql</para>
<para>table           = users</para>
<para>select_field    = uid</para>
<para>where_field     = email</para>
<para>additional_conditions = and postfix = 'y'</para>
<para>hosts           = unix:/var/run/mysqld/mysqld.sock</para>
<para/>
<para/>
<para>Листинг 10.9: /etc/postfix/mysql-virtual.cf</para>
<para># nano -w /etc/postfix/mysql-virtual.cf</para>
<para># mysql-virtual.cf</para>
<para/>
<para>user            = mailsql</para>
<para>password        = $password</para>
<para>dbname          = mailsql</para>
<para>table           = virtual</para>
<para>select_field    = destination</para>
<para>where_field     = email</para>
<para>hosts           = unix:/var/run/mysqld/mysqld.sock</para>
<para/>
<para/>
<para>И последнее, правим /etc/postfix/main.cf еще один раз. </para>
<para/>
<para>Листинг 10.10: /etc/postfix/main.cf</para>
<para># nano -w /etc/postfix/main.cf</para>
<para>alias_maps = mysql:/etc/postfix/mysql-aliases.cf</para>
<para>relocated_maps = mysql:/etc/postfix/mysql-relocated.cf</para>
<para/>
<para>local_transport = local</para>
<para>local_recipient_maps = $alias_maps $virtual_mailbox_maps unix:passwd.byname</para>
<para/>
<para>virtual_transport = virtual</para>
<para>virtual_mailbox_domains =</para>
<para>        virt-bar.com,</para>
<para>        $other-virtual-domain.com</para>
<para/>
<para>virtual_minimum_uid = 1000</para>
<para>virtual_gid_maps = static:$vmail-gid</para>
<para>virtual_mailbox_maps = mysql:/etc/postfix/mysql-virtual-maps.cf</para>
<para>virtual_alias_maps = mysql:/etc/postfix/mysql-virtual.cf</para>
<para>virtual_uid_maps = static:$vmail-uid</para>
<para>virtual_mailbox_base = /</para>
<para>#virtual_mailbox_limit =</para>
<para/>
<para/>
<para>Здесь видно чем значительно отличается postfix 2.0.x от 1.1.x. Сильнее всего заметно отсутствие необходимости в таблицах транспорта, virtual-gid и virtual-uid, хотя эти таблицы и вкладываются, чтобы вы могли их использовать при необходимости. </para>
<para>Примечание: Рекомендуем прочесть VIRTUAL_README идущий с postfix, для большего количества информации. </para>
<para/>
<para/>
<para>Листинг 10.11: </para>
<para># postfix reload</para>
<para/>
<para/>
<para>Теперь, если все прошло хорошо, вы должны иметь работающий почтовый сервер. Пользователи должны быть способны авторизоватся в sql базе, использовать свой полный почтовый адрес для pop3, imap, и smtp. Настоятельно рекомендую проверить , что всё это действительно работает. Если вы столкнулись с проблемами, проверьте раздел troubleshooting в конце документа. </para>
<para/></sect2><sect2><title>11. Squirrelmail</title>
<para/>
<para>Листинг 11.1: </para>
<para># emerge squirrelmail</para>
<para>(добавим ссылку на htdocs для более короткого пути)</para>
<para># ln -s /home/httpd/htdocs/squirrelmail/ /home/httpd/htdocs/mail</para>
<para># cd /home/httpd/htdocs/mail/conf</para>
<para># ./conf.pl</para>
<para/>
<para>(измените настройки Organization, Server, и Folder для squirrelmail)</para>
<para>(теперь вы имеете возможность залогинится в squirrelmail, снова с вашим </para>
<para>полным email адресом, и использовать ваш новый webmail setup)</para>
<para/>
<para/></sect2><sect2><title>12. Mailman</title>
<para/>
<para>Последний шаг — mailman. Новая версия имеет великолепную поддержку виртуальных доменов, поэтому я использую его, не говоря уже о том что это просто великолепная программа. Настоятельно рекомендую прочесть документацию mailman, включающую README.POSTFIX.gz, для более полного понимания. </para>
<para/>
<para>Одно замечание, текущая версия mailman инсталируется в /usr/local/mailman. Если вы хотите изменить директорию инсталляции, вы можете изменить в ebuild файле переменную INSTALLDIR. </para>
<para/>
<para>Листинг 12.1: /usr/portage/net-mail/mailman/mailman-$ver.ebuild</para>
<para># nano -w /usr/portage/net-mail/mailman/mailman-$ver.ebuild</para>
<para>MAILGID="280"</para>
<para>(задайте MAILGID для группы mailman взаммен nobody)</para>
<para>(это необходимо для интеграции с postfix)</para>
<para/>
<para/>
<para>Листинг 12.2: </para>
<para># emerge mailman</para>
<para>(имя этого пакета маскировано, поэтому вам надо указать emerge путь к </para>
<para>ebuild. После инсталляции, следуйте инструкциям в README.gentoo.gz *исключая* — </para>
<para>не добавляйте псевдонимы в /etc/mail/aliases. Вместо этого, мы укажем postfix </para>
<para>использовать псевдонимы из базы)</para>
<para/>
<para># zless /usr/share/doc/mailman-$ver/README.gentoo.gz</para>
<para/>
<para/>
<para>Листинг 12.3: Настройки по умолчанию: Mailman/Defaults.py</para>
<para>#  nano -w /var/mailman/Mailman/Defaults.py</para>
<para>(измените значения приведенные ниже на ваши, дальше будем настраивать </para>
<para>виртуальные домены)</para>
<para>DEFAULT_EMAIL_HOST = 'domain.com'</para>
<para>DEFAULT_URL_HOST = 'www.domain.com'</para>
<para/>
<para/>
<para>Листинг 12.4: настройка mailman: mm_cfg.py</para>
<para># nano -w /var/mailman/Mailman/mm_cfg.py</para>
<para>MTA = "Postfix"</para>
<para>POSTFIX_STYLE_VIRTUAL_DOMAINS = ['virt-domain.com', 'virt.domain2.com']</para>
<para>add_virtualhost('www.virt.domain.com', 'virt.domain.com')</para>
<para>add_virtualhost('www.virt.domain2.com', 'virt.domain2.com')</para>
<para>(это нужно для работы mailman с виртуальными доменами)</para>
<para/>
<para/>
<para>Листинг 12.5: </para>
<para>(создадим свой первый список рассылки)</para>
<para/>
<para># su mailman</para>
<para># cd ~</para>
<para># bin/newlist test</para>
<para>Enter the email of the person running the list: your@email.address</para>
<para>Initial test password:</para>
<para>Hit enter to continue with test owner notification...</para>
<para>(листы виртуального домена могут быть указаны в виде list@domain.com)</para>
<para># bin/genaliases</para>
<para>(теперь ваши псевдонимы сгенерированы, проверьте, что они добавлены правильно)</para>
<para/>
<para># nano -w data/aliases</para>
<para># STANZA START: test</para>
<para># CREATED:</para>
<para>test:             "|/var/mailman/mail/mailman post test"</para>
<para>test-admin:       "|/var/mailman/mail/mailman admin test"</para>
<para>test-bounces:     "|/var/mailman/mail/mailman bounces test"</para>
<para>test-confirm:     "|/var/mailman/mail/mailman confirm test"</para>
<para>test-join:        "|/var/mailman/mail/mailman join test"</para>
<para>test-leave:       "|/var/mailman/mail/mailman leave test"</para>
<para>test-owner:       "|/var/mailman/mail/mailman owner test"</para>
<para>test-request:     "|/var/mailman/mail/mailman request test"</para>
<para>test-subscribe:   "|/var/mailman/mail/mailman subscribe test"</para>
<para>test-unsubscribe: "|/var/mailman/mail/mailman unsubscribe test"</para>
<para># STANZA END: test</para>
<para/>
<para># /etc/init.d/mailman start</para>
<para># rc-update add mailman default</para>
<para>(для запуска mailman при каждой загрузке)</para>
<para/>
<para/>
<para>Листинг 12.6: Добавление поддержки псевдонимов mailman в postfix</para>
<para># nano -w /etc/postfix/main.cf</para>
<para>owner_request_special = no</para>
<para>recipient_delimiter = +</para>
<para>(прочтите README.POSTFIX.gz для более детальной информации)</para>
<para/>
<para>alias_maps     =</para>
<para>        hash:/var/mailman/data/aliases,</para>
<para>        mysql:/etc/postfix/mysql-aliases.cf</para>
<para/>
<para>virtual_alias_maps =</para>
<para>        hash:/var/mailman/data/virtual-mailman,</para>
<para>        mysql:/etc/postfix/mysql-virtual.cf</para>
<para>(это добавит поддержку файлов псевдонимов mailman'a в postfix, конечно</para>
<para>вы можете использовать таблицу в mysql для этого, но я ненавижу делать это руками. </para>
<para>Также если вы не используете виртуальных доменов, добавление псевдонимов, может</para>
<para>привести к проблемам)</para>
<para/>
<para/>
<para>Теперь вы можете создавать листы рассылок для каждого домена в вашей системе. Последнее замечание, убедитесь, что mailman запущен из под пользователя mailman (su mailman) иначе у вас будут проблемы с разрешениями. прочтите документацию mailman для более детальной информации по управлению листами рассылки. </para>
<para/></sect2><sect2><title>13. Фильтрация содержимого и Anti-Virus</title>
<para/>
<para>Скоро будет,... это уже существует, но я должен еще немного разобраться в perl'e и протестировать результат. Если вы хотите помочь с этим, свяжитесь со мной. </para>
<para/></sect2><sect2><title>14. Окончание</title>
<para>Итак,. Вы все сделали, теперь поправьте /etc/postfix/master.cf и отключите режим verbose. Возможно вы захотите довавить сервис в автозагрузку. Убедитесь что вы добавили в автозагрузку все сервисы которые используете - apache, mysql, saslauthd, postfix, courier-imapd, courier-imapd-ssl, courier-pop3d, и courier-pop3d-ssl, все зависит от вашего решения какие сервисы предоставлять. Обычно я разрешаю все сервисы. </para>
<para/>
<para>Листинг 14.1: Окончание</para>
<para># postfix reload</para>
<para># rc-update add $service default</para>
<para/>
<para/>
<para>Вобщем инджой и хэв фан! </para>
<para/></sect2><sect2><title>15. Troubleshooting</title>
<para/>
<para>Введение</para>
<para/>
<para>Troubleshooting: Это небольшой список решений для проблем, наиболее часто возникающих в ходе установки. Это не исчерпывающая информация, но вы можете начать поиск решения граблей отсюда. Такая запутанная настройка и инсталляция как в этом документе, может привести к тому что некоторые компоненты будут работать неправильно. Вообще советую сделать несколько следующих шагов. Запустите систему в базовой конфигурации, добавляя компонент за компонентом, чтобы выяснить какой из них сбоит. </para>
<para/>
<para>Шаг 1: Проверьте ваши файлы конфигурации. </para>
<para/>
<para>Опечатки — главный враг, особенно когда идет речь о системе авторизации. Проверьте ваши конфигурационные файлы и базу данных на предмет опечаток. Если вы делаете изменения настроек для сервиса, убедитесь, что вы перезапустили сервиса, дабы изменения вступили в силу. </para>
<para/>
<para>Листинг 15.1: </para>
<para># /etc/init.d/service restart</para>
<para/>
<para/>
<para>Шаг 2: Все необходимые сервисы запущены и работают?</para>
<para/>
<para>Если не запущены, запустите. Крайне сложно отлаживать программу если она не запущена. Иногда сервис запускается, но не функционирует. Иногда, когда используется неправильный файл конфигурации сервис может использовать другой порт предназначенный другому процессу. Иногда вы можете воспользоваться netstat. Или если возможно , перезагрузите ваш сервер, это очистит любой зависший сервис. </para>
<para/>
<para>Листинг 15.2: </para>
<para># /etc/init.d/$service status</para>
<para># netstat -a | grep $service (или $port)</para>
<para/>
<para/>
<para>Шаг 3: Все сервисы используют правильные файлы конфигурации?</para>
<para/>
<para>Если вы внесли изменения в конфигурационные файлы сервиса, убедитесь что он использует новые параметры. Некоторые программы, вроде postfix могут показывать конфигурацию их параметров. </para>
<para/>
<para>Листинг 15.3: </para>
<para># apachectl fullstatus  (необходим lynx)</para>
<para># apachectl configtest (проверка нормальной конфигурации)</para>
<para># postconf -n (показывает текущие параметры используемые postfix)</para>
<para># /etc/init.d/$service restart</para>
<para/>
<para/>
<para>Шаг 4: Проверьте логи.</para>
<para/>
<para>На то логи и существуют, чтобы помочь нам выяснить причину, а иногда и подсказать решение проблемы. Просмотрите все логи, которые имеют отношение к программе, ее сбою. </para>
<para/>
<para>Листинг 15.4: </para>
<para># kill -USR1 `ps -C metalog -o pid=`(для выключения metalog buffering)</para>
<para># nano -w /var/log/mail/current</para>
<para># cat /var/log/mysql/mysql.log</para>
<para># tail /var/log/apache/error_log</para>
<para/>
<para/>
<para>Вы также можете найти параметр debug_peer в main.cf который может быть полезен. Включение этого параметра, увеличит подробность выводящихся сообщений в логи. </para>
<para/>
<para>Листинг 15.5: добавление поддержки debug_peer</para>
<para># nano -w /etc/postfix/main.cf</para>
<para>debug_peer_level = 5</para>
<para>debug_peer_list = $host.domain.name</para>
<para>(раскомментируйте одну из нужных строк)</para>
<para/>
<para/>
<para>Шаг 5: Попробуйте связаться с сервисом.</para>
<para/>
<para>SMTP, IMAP, и POP3 отвечают на telnet сессию, как вы видели немного раньше при конфигурации postfix. Иногда помогает открыть telnet сессию с сервисом, для того чтобы выяснить что случилось. </para>
<para/>
<para>Листинг 15.6: </para>
<para># telnet localhost $port</para>
<para>(SMTP на 25-м, IMAP, на 143-м, POP3 на 110-м порту. по крайней мере вы</para>
<para>должны увидеть слово ОК. Так вы будете знать что сервис запущен, и готов к ответу.)</para>
<para/>
<para>Trying 127.0.0.1...</para>
<para>Connected to localhost.</para>
<para>Escape character is '^]'.</para>
<para>* OK Courier-IMAP ready. Copyright 1998-2002 Double Precision, Inc.</para>
<para/>
<para/>
<para>Шаг 6: Иногда только большая пушка может дать нам информацию: strace.</para>
<para/>
<para>Вы должны иметь эту программу всегда под рукой. Это бесценный инструмент для отлаживания программ. Вы можете запустить из командной строки starce и наблюдать все системные вызовы происходящие в программе. Часто дамп содержит огромное количество информации, так что вы можете либо наблюдать в реальном времени, за транзакцией приводящей к краху программы, или записать его в файл, для неторопливого просмотра позже. </para>
<para/>
<para>Листинг 15.7: </para>
<para># emerge strace</para>
<para># strace $command</para>
<para># strace -p `ps -C $service -o pid=`</para>
<para/></sect2></sect1><sect1><title>Виртуальная почтовая система на основе qmail/vpopmail.</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/qmail-howto.xml">http://www.gentoo.org/doc/ru/qmail-howto.xml</ulink>
</para>
<para>C версии: 1.0</para>
<para/><sect2><title>1. Введение</title>
<para/>
<para>Не важно для чего вы хотите организовать систему электронной почты, только лишь для сервисов, как самостоятельный сервер, или для нескольких виртуальных доменов, qmail может быть легко настроен для любых ваших нужд. Это руководство поможет вам установить и настроить qmail, для любого из этих вариантов с уклоном на удаленный доступ, в том числе через зашифрованные каналы данных. </para>
<para/>
<para>Это руководство поможет вам освоить qmail, courier-imap, vpopmail, и horde/imp. Но вместе с ними так же вступят в "игру" daemontools, ucspi-tcp, mysql, apache, и mod_php. qmail предоставляет функции MTA (Mail Transfer Agent), courier-imap - предоставляет удаленный сбор почты, (pop3/imap сервер. прим.пер.) vpopmail предоставляет функции управления виртуальными доменами, и horde/imp - это почтовый веб-клиент. </para>
<para/>
<para>До установки (emerging) чего-либо, вы должны корректно установить переменную USE. Если у вас уже были установлены какие-нибудь из этих пакетов, то, возможно, вам придется их переустановить. USE="maildir ssl imap mysql". Также, если вы хотите использовать horde/imp как web-клиент, то так же надо добавить USE="nls" до установки mod_php.</para>
<para/>
<para>Примечание: Это руководство написано "по-шагам" Если в какой-то момент вы чувствуете что все то, что нужно готово, то можете не продолжать. </para>
<para/>
<para/>
<para>Cуществует достаточно пакетов, с помошью которых можно построить систему электронной почты. Сейчас самое время осмыслить и решить для вас ли qmail. У нас так же есть прекрасное руководство основанное на Postfix, или вы можете взглянуть на exim. Выбирайте решение для себя, а мы покажем вам, как использовать qmail. </para>
<para/></sect2><sect2><title>2. qmail ("Разговаривая с собой")</title>
<para>Листинг 2.1: Emerge qmail</para>
<para># emerge qmail</para>
<para/>
<para>Важно: Эта часть построена вокруг qmail-1.03-r13 или старше. Будет ли нижеизложенное работать с ранними версиями? Может быть. Должны ли вы обновиться? Да, если вы хотите быть уверены, что это сработает. </para>
<para/>
<para>Предупреждение: Если вы получили сообщение the virtual/mta package conflicts with another package тогда вам необходимо удалить из системы любой другой MTA. Чтобы узнать что это за пакет, просто запустите emerge qmail -p. </para>
<para/>
<para/>
<para>Установка qmail так же "потянет" за собой установку ucspi-tcp и daemontools. О них, если хотите, вы можете прочитать на ucspi-tcp и на daemontools. Обычно, daemontools отвечает за управление qmail'ом как сервисом, тогда как ucspi-tcp отвечает за управление входящими TCP соединениями для сервиса qmail. </para>
<para/>
<para>Для начала проведем несколько пост-инсталяционных мероприятий. :) </para>
<para/>
<para>Листинг 2.2: Конфигурирование qmail</para>
<para>(Измените под свою конфигурацию)</para>
<para># nano /var/qmail/control/servercert.cnf</para>
<para># ebuild /var/db/pkg/mail-mta/qmail-1.03-r*/qmail-1.03-r*.ebuild config</para>
<para/>
<para/>
<para>Qmail проектировался так, чтобы полностью соответствовать требованиям безопасности. Почта никогда не посылается пользователю 'root'. Поэтому вам надо выбрать пользователя на машине, который будет получать почту предназначенную 'root'. С этого момента я предполагаю, что этот пользователь 'vapier'. </para>
<para/>
<para>Листинг 2.3: Установка не-root акаунта для e-mail.</para>
<para># cd /var/qmail/alias</para>
<para># echo vapier &gt; .qmail-root</para>
<para># echo vapier &gt; .qmail-postmaster</para>
<para># echo vapier &gt; .qmail-mailer-daemon</para>
<para/>
<para/>
<para>Теперь, поднимем сервис доставки qmail. </para>
<para/>
<para>Листинг 2.4: Запуск qmail delivery service</para>
<para># rc-update add svscan default</para>
<para># /etc/init.d/svscan start</para>
<para># cd /service</para>
<para># ln -s /var/qmail/supervise/qmail-send qmail-send</para>
<para/>
<para/>
<para>Надо убедиться, что qmail работает корректно, вот небольшой тест. </para>
<para/>
<para>Листинг 2.5: Test delivery service</para>
<para># ssh vapier@localhost</para>
<para># maildirmake .maildir</para>
<para># qmail-inject root &lt;&lt; EOF</para>
<para>test root e-mail!</para>
<para>EOF</para>
<para># qmail-inject postmaster &lt;&lt; EOF</para>
<para>test postmaster e-mail!</para>
<para>EOF</para>
<para># qmail-inject vapier &lt;&lt; EOF</para>
<para>test vapier e-mail!</para>
<para>EOF</para>
<para># mutt</para>
<para/>
<para>(Теперь в вашем ящике должно быть 3 письма)</para>
<para/>
<para/>
<para>Вот и все! Теперь у вас стоит почтовая система способная удовлетворить, потребности локальной машины и системных демонов/пользователей. </para>
<para>Предупреждение: Если вы не получили никаких писем или видите странные ошибки в лог-файлах (проверьте /var/log/qmail/) включающие 'localhost.localhost', это означает что ваша domain/dns информация не корректна. По умолчанию, qmail использует информацию от hostname --fqdn. Если на вашей машине, эта команда выводит 'localhost', тогда проверьте ваши файлы /etc/hostname, /etc/hosts, и настройки dns чтобы убедиться что все правильно. Отредактируйте конфигурационные файлы в каталоге /var/qmail/control/. Используйте их примеры, (там же) если вам нужна помощь. </para>
<para/>
<para/>
<para>Листинг 2.6: Пример /var/qmail/control/ файлов для домена второго уровня</para>
<para># hostname --fqdn</para>
<para>wh0rd.org</para>
<para># cat me</para>
<para>wh0rd.org</para>
<para># cat defaultdomain</para>
<para>wh0rd.org</para>
<para># cat plusdomain</para>
<para>wh0rd.org</para>
<para># cat locals</para>
<para>wh0rd.org</para>
<para># cat rcpthosts</para>
<para>wh0rd.org</para>
<para/>
<para/>
<para>Листинг 2.7: Пример /var/qmail/control/ файлов для домена третьего уровня</para>
<para># hostname --fqdn</para>
<para>mail.wh0rd.org</para>
<para># cat me</para>
<para>mail.wh0rd.org</para>
<para># cat defaultdomain</para>
<para>wh0rd.org</para>
<para># cat plusdomain</para>
<para>wh0rd.org</para>
<para># cat locals</para>
<para>mail.wh0rd.org</para>
<para># cat rcpthosts</para>
<para>mail.wh0rd.org</para>
<para/>
<para/></sect2><sect2><title>3. vpopmail</title>
<para/>
<para>Листинг 3.1: Emerge vpopmail</para>
<para># emerge vpopmail</para>
<para/>
<para>Важно: Эта часть построена вокруг vpopmail-5.4.6 или старше. Будет ли нижеизложенное работать с ранними версиями? Может быть. Должны ли вы обновиться? Да, если вы хотите быть уверены что это сработает. </para>
<para/>
<para/>
<para>vpopmail требует немного больше старания при установке, чем предыдущие пакеты. Мы должны убедиться что он запущен и работает (до mysql). Далее мы можем установить базу данных vpopmail. До того как приступить к следующему шагу, необходимо проверить что mysql корректно установлен. Учтите, пароль для базы данных vpopmail будет 'vpoppw', конечно вы можете выбрать другой. </para>
<para/>
<para>Листинг 3.2: Установка vpopmail в mysql</para>
<para># rc-update add mysql default</para>
<para>Если вы установили mysql в первый раз, убедитесь что была запущена команда </para>
<para>ebuild &lt;mysql.ebuild&gt; config до запуска mysql сервера.</para>
<para># /etc/init.d/mysql start</para>
<para># nano /etc/vpopmail.conf </para>
<para>(Изменим пароль с 'secret' на 'vpoppw')</para>
<para># mysql -p &lt;&lt; EOF</para>
<para>create database vpopmail;</para>
<para>use mysql;</para>
<para>grant select, insert, update, delete, create, drop on vpopmail.* to vpopmail@localhost identified by 'vpoppw';</para>
<para>flush privileges;</para>
<para>EOF</para>
<para>(Следующие шаги могут понадобиться, а могут и нет, но мы выполним их просто чтобы быть уверенными)</para>
<para># chown root:vpopmail /etc/vpopmail.conf</para>
<para># chmod 640 /etc/vpopmail.conf</para>
<para># chown root:vpopmail /var/vpopmail/bin/vchkpw</para>
<para># chmod 4711 /var/vpopmail/bin/vchkpw</para>
<para/>
<para>Предупреждение: Если вы испытываете трудности с доступом в mysql/vpopmail, перезапустите mysql. Выполните /etc/init.d/mysql restart. </para>
<para/>
<para/>
<para>Теперь, vpopmail готов к использованию. В этой части, мы предоставим виртуальный хостинг для домена 'wh0rd.org'. Это означает что мы должны "сообщить" vpopmail об этом домене. Кстати, давайте добавим пользователя 'vapier'. </para>
<para/>
<para>Листинг 3.3: Добавление домена</para>
<para>(это нужно сделать только в том случае если vadddomain выдает "command not found" (см. далее))</para>
<para># source /etc/profile</para>
<para>(при отладке vpopmail, вам может понадобиться просмотр журналов)</para>
<para># mysql -u vpopmail -p</para>
<para>mysql&gt; select * from vpopmail.vlog;</para>
<para># vadddomain wh0rd.org postpass</para>
<para>(теперь проверим, правильно ли установлен домен)</para>
<para># printf "postmaster@wh0rd.org\0postpass\0blah\0" | vchkpw `which id` 3&lt;&amp;0</para>
<para>uid=89(vpopmail) gid=89(vpopmail) groups=0(root)</para>
<para>(если вы не видите что-либо подобное, значит права доступа где-то выставлены некорректно)</para>
<para># vadduser vapier@wh0rd.org vappw</para>
<para/>
<para/>
<para>В каждом домене созданном vpopmail существует аккаунт 'postmaster'. Мы задаем пароль postmaster'а в 'postpass'. Чтобы vpopmail был действительно полезен нам, мы должны получать почту через courier и посылать с помощью qmail и SMTP. </para>
<para/></sect2><sect2><title>4. Courier POP/IMAP</title>
<para/>
<para>Листинг 4.1: Emerge courier-imap</para>
<para># emerge net-mail/courier-imap</para>
<para/>
<para>Важно: Сразу после vpopmail вы должны установить courier-imap Модуль authvchkpw будет встроен.(?) </para>
<para/>
<para>Важно: Эта часть построена вокруг net-mail/courier-imap-3.0.7 или старше. Будет ли нижеизложенное работать с ранними версиями? Может быть. Должны ли вы обновиться? Да, если вы хотите быть уверены что это сработает. </para>
<para/>
<para/>
<para>И еще несколько пост-инсталляционных шагов:). Они необходимы только в том случае если вы будете использовать SSL зашифрованные коммуникации (Рекомендуется!). Иначе вы можете пропустить последние 2 шага, в следующих листингах, удаляя '-ssl' из имени инициализационного скрипта. </para>
<para/>
<para>Листинг 4.2: Конфигурирование POP3/SSL</para>
<para># nano /etc/courier/authlib/authdaemonrc</para>
<para>(Оставьте в переменной authmodulelist только "authvchkpw")</para>
<para># cd /etc/courier-imap</para>
<para># nano pop3d.cnf </para>
<para>(Отредактируйте секцию [ req_dn ] )</para>
<para># mkpop3dcert</para>
<para># rc-update add courier-pop3d-ssl default</para>
<para># /etc/init.d/courier-pop3d-ssl start</para>
<para/>
<para/>
<para>Листинг 4.3: Конфигурирование IMAP/SSL</para>
<para># cd /etc/courier-imap</para>
<para># nano imapd.cnf </para>
<para>(Отредактируйте секцию [ req_dn ] )</para>
<para># mkimapdcert</para>
<para># rc-update add courier-imapd-ssl default</para>
<para># /etc/init.d/courier-imapd-ssl start</para>
<para/>
<para/>
<para>Ваш почтовый клиент теперь может соединиться с сервером (с запущенным на нем courier) и получать почту предназначенную для виртуального хоста. В моем случае, я могу соединиться с именем 'vapier@wh0rd.org' и паролем 'vappw'. </para>
<para/></sect2><sect2><title>5. qmail (разговаривая с миром)</title>
<para/>
<para>Давайте заставим SMTP работать, не причинив ущерба людям, открыв очередную спам-дыру. </para>
<para/>
<para>Листинг 5.1: Запуск qmail SMTP service</para>
<para># cd /var/qmail/control/</para>
<para># nano conf-smtpd</para>
<para>(Раскомментируйте SMTP-AUTH переменную и установите QMAIL_SMTP_CHECKPASSWORD</para>
<para> в /var/vpopmail/bin/vchkpw)</para>
<para># nano servercert.cnf </para>
<para>(Отредактируйте секцию [ req_dn ] )</para>
<para># mkservercert</para>
<para># cd /service</para>
<para># ln -s /var/qmail/supervise/qmail-smtpd qmail-smtpd</para>
<para># /etc/init.d/svscan restart</para>
<para/>
<para/>
<para>Предположим вы не меняли файлов qmail, тогда он теперь принимает почту для виртуального домена wh0rd.org и для пользователей локальной машины. Более того, qmail доверяет любому кто посылает письма через 127.0.0.1 и для любого кто может пройти аутентификацию через vpopmail. При настройке своего почтового клиента для отправки почты, убедитесь что вы включили опцию вроде 'Server requires authentication'. В моем случае, я поставил имя пользователя в 'vapier@wh0rd.org' и пароль - 'vappw'. И последняя деталь - убедитесь что настроили использование SSL/TLS для SMTP в своем клиенте. Qmail не позволит вам пройти аутентификацию если сессия не зашифрована. </para>
<para/></sect2><sect2><title>6. Веб клиент Horde / IMP</title>
<para/>
<para>Несмотря на то что существует множество веб-клиентов электронной почты (и вы свободны выбрать любой из них), я предпочитаю IMP Webmail Client который является частью "окружения Horde". Основная причина заключается в том что Horde предоставляет достаточно прозрачный web доступ к почте, и вы можете очень просто добавить другие компоненты, такие как Адресные Книги, Календари, Задачи, и др. И если он до сих пор вас не устраивает, тогда вам следует прочитать Horde. </para>
<para/>
<para>On to the good stuff! Теперь установим IMP. </para>
<para/>
<para>Листинг 6.1: Emerge IMP</para>
<para># emerge horde-imp</para>
<para/>
<para>Важно: Эта часть построена вокруг horde-2.2.x and horde-imp-3.2.x. CVS версии (и следующие релизы) скорее всего, будут очень различаться в настройках. Так же имейте ввиду php-5.x, скорее всего, нарушит работу horde-2.x. </para>
<para/>
<para/>
<para>Horde не просто настроить если вы точно не знаете что делать. К счастью для вас, я точно знаю что делать, значит и вы будете. :) </para>
<para/>
<para>Листинг 6.2: Конфигурирование Horde</para>
<para># cd /var/www/localhost/htdocs/horde/config/</para>
<para># for f in *.dist ; do mv ${f} ${f/.dist} ; done</para>
<para># nano horde.php</para>
<para>(Ниже 'Horde Authentication':)</para>
<para>$conf['auth']['driver'] = 'imap';</para>
<para>$conf['auth']['params']['dsn'] = '{localhost:993/imap/ssl/novalidate-cert}';</para>
<para/>
<para>(Ниже 'Horde Logging':)</para>
<para>$conf['log']['name'] = '/var/log/apache2/horde.log';</para>
<para/>
<para>(Ниже 'Problem Reporting':)</para>
<para>$conf['problems']['enabled'] = true;</para>
<para>$conf['problems']['email'] = 'webmaster@wh0rd.org';</para>
<para/>
<para># nano registry.php</para>
<para>(Ниже 'Handlers':)</para>
<para>$this-&gt;registry['auth']['login'] = 'imp';</para>
<para>$this-&gt;registry['auth']['logout'] = 'imp';</para>
<para/>
<para>(Ниже 'Application registry':) Установите элемент 'status', раздел</para>
<para> applications['imp'], из 'inactive' в 'active'</para>
<para/>
<para># touch /var/log/apache2/horde.log</para>
<para># chown apache:apache /var/log/apache2/horde.log</para>
<para/>
<para>Примечание: Вы можете поменять аккаунт 'webmaster' на что-нибудь другое. Если вы хотите использовать этот e-mail адрес, тогда вы должны добавить такого пользователя в vpopmail. (или смотрите ниже о qmailadmin). </para>
<para/>
<para/>
<para>Теперь действительно быстро установим IMP. </para>
<para/>
<para>Листинг 6.3: Конфигурирование IMP</para>
<para># cd /var/www/localhost/htdocs/horde/imp/config/</para>
<para># for f in *.dist ; do mv ${f} ${f/.dist} ; done</para>
<para># nano servers.php</para>
<para/>
<para>(Отредактируйте массив $servers['imap'] </para>
<para>$servers['imap'] = array(</para>
<para>        'name' =&gt; 'wh0rd.org',</para>
<para>        'server' =&gt; 'localhost',</para>
<para>        'protocol' =&gt; 'imap/ssl/novalidate-cert',</para>
<para>        'port' =&gt; 993,</para>
<para>        'folders' =&gt; '',</para>
<para>            'namespace' =&gt; 'INBOX.',</para>
<para>        'maildomain' =&gt; 'wh0rd.org',</para>
<para>        'smtphost' =&gt; 'localhost',</para>
<para>        'realm' =&gt; '',</para>
<para>        'preferred' =&gt; ''</para>
<para>);</para>
<para/>
<para/>
<para>Наконец, поднимем apache, чтобы начать использовать webmail. </para>
<para/>
<para>Листинг 6.4: Запуск apache</para>
<para># nano /etc/conf.d/apache2 </para>
<para>(Раскоменнтируйте APACHE2_OPTS="-D SSL -D PHP4")</para>
<para># rc-update add apache2 default</para>
<para># /etc/init.d/apache2 start</para>
<para/>
<para>Предупреждение: Вы должны подумать о том, чтобы заставить работать Horde через https. Это не простая задача, но приглядитесь к ней ради безопасности. </para>
<para/>
<para/>
<para>Чтобы проверить установку IMP, запустите браузер и зайдите http://localhost/horde/ (измените localhost на ваш сервер) Вы должны увидеть страницу приглашения Horde где вы можете войти. Опять же, в моей установке я вхожу с помощью 'vapier@wh0rd.org' и 'vappw' соответственно как логин и пароль. </para>
<para/>
<para>На данный момент, Horde и IMP установлены. Однако, вы можете пройти заново через все дерево конфигурационных директорий и настроить все что вашей душе угодно. </para>
<para/></sect2><sect2><title>7. Дополнительные пакеты</title>
<para/>
<para>qmailadmin</para>
<para/>
<para>Первый пакет на который я обращу ваше внимание это qmailadmin. Это веб интерфейс для управления виртуальными доменами. Просто emerge net-mail/qmailadmin а затем укажите вашему браузеру на http://localhost/cgi-bin/qmailadmin чтобы начать использовать его. qmailadmin делает жизнь намного проще. </para>
<para/>
<para>qmHandle</para>
<para/>
<para>Если вы вляпались в проблемы с очередями qmail и провели много времени над отладкой, то, возможно захотите взглянуть на qmHandle. Это простая перл программа которая позволяет вам видеть и редактировать очередь сообщений qmail. Опять таки все что нужно сделать это emerge net-mail/qmhandle. </para>
<para/>
<para>Дополнения к horde</para>
<para/>
<para>Я очень рекомендую посмотреть на множество приложений Horde. Turba, Kronolith, и Nag эти приложения очень хорошо дополняют IMP для разных случаев. Их настройка схожа с настройкой IMP, так что у вас не будет проблем с ними. Просто не забудьте отредактировать registry.php в директории конфигурации horde, и новые приложения появятся внизу странички Horde. </para>
<para/>
<para>ucspi-tcp</para>
<para/>
<para>qmail использует ucspi-tcp для фильтрации входящих соединений. Если вы хотите настроить правила фильтрации, тогда смотрите файлы в /etc/tcprules.d/ (в старых версиях qmail эти файлы находятся в /etc). Здесь вы найдете по два файла на каждый сервис, конфигурационный файл (tcp.qmail-smtp) и его откомпилированную версию, ту которую и использует ucspi-tcp (tcp.qmail-smtp.cdb). Каждый раз после обновления конфигурационного файла, надо пересобрать бинарную его версию. Запустите tcprules tcp.qmail-smtp.cdb tcp.qmail-smtp.tmp &lt; tcp.qmail-smtp. Каждый раз при соединении с qmail, откомпилированные правила перечитываются с диска, то есть, нет нужды перезапускать сервис. </para>
<para/>
<para>qmail-scanner</para>
<para/>
<para>Если вы хотите обеспечить фильтрацию контента на своем mail сервере (спам, вирусы), тогда вам необходимо использовать другую программу для организации очередей. Одна из хороших программ это qmail-scanner. Наберите emerge qmail-scanner и отредактируйте /etc/tcprules.d/tcp.qmail-smtp. </para>
<para>Важно: Процесс сборки qmail-scanner очень уродлив. Чтобы поддерживать пакеты, они уже должны быть установлены в системе. Это означает что вы должны установить SpamAssassin и/или Clam AntiVirus до qmail-scanner'а. Смотрите подходящие секции ниже. </para>
<para/>
<para/>
<para>Листинг 7.1: Смена программы организации очередей.</para>
<para># cd /etc/tcprules.d/</para>
<para># nano tcp.qmail-smtp</para>
<para>(добавьте QMAILQUEUE="/var/qmail/bin/qmail-scanner-queue" в правило catchall)</para>
<para># tcprules tcp.qmail-smtp.cdb tcp.qmail-smtp.tmp &lt; tcp.qmail-smtp</para>
<para/>
<para/>
<para>Смотрите секции об установке спам и вирус фильтров. Вы можете отредактировать несколько опций в /var/qmail/bin/qmail-scanner-queue.pl. </para>
<para/>
<para>SpamAssassin</para>
<para/>
<para>Один из лучших спам фильтров это SpamAssassin. Чтобы установить emerge mail-filter/spamassassin. Пакет поставляется двояко, как версия для командной строки и как клиент/серверная. Для серверов через которые проходит небольшое количество почты, использование версии для командной строки себя оправдывает. Но любой у кого большая загрузка серверов должен использовать клиент/серверную версию. </para>
<para/>
<para>Листинг 7.2: Конфигурирование SpamAssassin</para>
<para># nano /etc/mail/spamassassin/local.cf</para>
<para>(чтобы обеспечить самый минимум, добавьте следующие опции:)</para>
<para>required_hits 6</para>
<para>skip_rbl_checks 1</para>
<para/>
<para># rc-update add spamd default</para>
<para># /etc/init.d/spamd start</para>
<para># nano /var/qmail/bin/qmail-scanner-queue.pl</para>
<para>(Убедитесь что $spamc_binary variable выставлена в '/usr/bin/spamc'.)</para>
<para>(Если она выставлена в '', тогда смотрите далее.)</para>
<para/>
<para>Важно: Если у вас не был установлен SpamAssassin до установки qmail-scanner'а, Вы должны будете переустановить qmail-scanner. Процесс его сборки очень ужасен, включены будут только те функции, пакеты для которых уже были установлены. </para>
<para/>
<para/>
<para>На этом этапе входящая почта будет проходить через qmail-scanner который в свою очередь пропустит ее через SpamAssassin. </para>
<para/>
<para>Clam AntiVirus</para>
<para/>
<para>Как и SpamAssassin, Clam AntiVirus поставляется в двойном исполнении. Я расскажу как быстро поставить клиент/серверную версию. Во-первых, emerge app-antivirus/clamav. </para>
<para/>
<para>Листинг 7.3: Конфигурирование Clam AntiVirus</para>
<para># nano /etc/conf.d/clamd </para>
<para>(Установите START_CLAMD=yes)</para>
<para># nano /etc/clamav.conf</para>
<para>(Настройте все как хотите)</para>
<para># rc-update add clamd default</para>
<para># /etc/init.d/clamd start</para>
<para># nano /var/qmail/bin/qmail-scanner-queue.pl</para>
<para>(Убедитесь что $clamscan_binary переменная установлена</para>
<para> в '/usr/bin/clamscan'. Если нет, смотрите ниже.)</para>
<para># nano /var/qmail/control/conf-common</para>
<para>(Если ClamAV сообщает о проблемах с памятью попробуйте увеличить</para>
<para> программный лимит (softlimit))</para>
<para/>
<para>Важно: Если у вас не был установлен Clam AntiVirus до установки qmail-scanner'а, Вы должны будете переустановить qmail-scanner. Процесс его сборки очень ужасен, включены будут только те функции, пакеты для которых уже были установлены. </para>
<para/>
<para/>
<para>На этом этапе входящая почта будет проходить через qmail-scanner который в свою очередь пропустит ее через Clam AntiVirus. </para>
<para/></sect2><sect2><title>8. Заключительные примечания</title>
<para/>
<para>У меня нет особых примечаний, но если у вас проблемы с этим руководством, пожалуйста, свяжитесь со мной или разместите сообщение в системе распределения запросов Gentoo. Если у вас есть интересная информация которая вы считаете, может расширить это руководство, то шлите ее мне для включения. Я люблю qmail и с удовольствием добавлю веши, которые могут расширить опыт работы пользователя с mta</para></sect2></sect1><sect1><title>Руководство по электронной почте с использованием Mutt</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/guide-to-mutt.xml">http://www.gentoo.org/doc/ru/guide-to-mutt.xml</ulink>
</para>
<para>C версии: 1.0</para><sect2><title>1. Введение в E-Mail</title>
<para/>
<para>Если вы не любитель e-mail клиентов с замысловатым графическим интерфейсом, или если вы просто хотите поэкспериментировать с другими клиентами, чтобы выбрать подходящий для себя, самым простым способом в вашем случае будет использование связки консольных приложений: </para>
<para/>
<para>fetchmail-&gt;procmail-&gt;mutt-&gt;smtp </para>
<para/>
<para>Программы эти не просто мощны и гибко настраиваемы, они также легковесны и эффективны. Потому, однажды настроив и запустив всю эту e-mail систему, вы будете просто ошеломлены тем, что сможете делать с её помощью. </para>
<para/>
<para>Поскольку это краткое руководство, мы не будем рассматривать службы отправки почты (Mail Transfer Agent), такие как sendmail, postfix или exim. Мы также не будем использовать 25 порт для почтовых служб. </para>
<para/>
<para>Мы можем себе это позволить, так как fetchmail способен передавать принятую почту непосредственно службе доставки почты (MDA) вместо того чтобы перенаправлять её на 25 порт. И мы можем не использовать службу отправки почты (MTA) для простой передачи почты. </para>
<para/>
<para>Для запуска своей e-mail системы вам понадобится установить следующее программное обеспечение. </para>
<para/>
<para>Листинг 1.1: Установка нужных программ</para>
<para># emerge fetchmail procmail mutt nbsmtp</para>
<para/>
<para/>
<para>Теперь от полностью рабочей e-mail системы нас отделяют четыре маленьких шажка в направлении конфигурации файлов. </para>
<para>Важно: После каждого шага необходимо тестировать настройку на корректность. Это конечно же подразумевают, что всё необходимое программное обеспечение у вас уже установлено. </para>
<para/>
<para/></sect2><sect2><title>2. Fetchmail</title>
<para/>
<para>Fetchmail забирает почту с удаленного сервера на вашу локальную машину. Для этого вам необходимо настроить файл .fetchmailrc в вашей домашней директории, подобно примеру:</para>
<para/>
<para/>
<para/>
<para>Листинг 2.1: Пример .fetchmailrc</para>
<para>poll mail.myisp.net  protocol pop3 user "myname" password "mypassword" </para>
<para/>
<para/>
<para>Сразу после создания файла, необходимо выставить права доступа к нему (он должен быть читаем только его владельцем). Сделать это можно следующей командой: </para>
<para/>
<para>Листинг 2.2: Изменение прав доступа</para>
<para># chmod 710 .fetchmailrc</para>
<para/>
<para/>
<para>Чтобы увидеть процесс в действии, используйте ключ -v. Чтоб получить все сообщения, используйте -a. И ещё вы должны использовать ключ -m для того, чтобы передать принятую почту procmail.</para>
<para/>
<para>Предупреждение: Будет также хорошей идеей использовать ключ -k, в этом случае если что-то пойдет не так, ваша почта не будет удалена с сервера и вы сможете её повторно забрать. </para>
<para/>
<para/>
<para>Пришло время проверить fetchmail в действии! </para>
<para/>
<para>Листинг 2.3: Тест Fetchmail #1</para>
<para># fetchmail -akv -m "/usr/bin/procmail -d %T" </para>
<para/>
<para/>
<para>Как только вы добьётесь работающей системы, вы можете добавить процесс в cron или какой-нибудь монитор навроде gkrellm. Fetchmail также может быть запущен как демон с указанием секундного интервала. </para>
<para/></sect2><sect2><title>3. Procmail</title>
<para/>
<para>Procmail - это программа фильтрующая почту получаемую от fetchmail. А далее, также как и MDA, она поставляет отфильтрованную почту в ваши почтовые ящики, откуда её уже можно прочитать программой mutt (это почтовый клиент, который мы будем использовать). </para>
<para/>
<para>Для использования procmail, также необходимо создать файл .procmailrc в своём домашнем каталоге. Для наших целей "быстрой настройки" мы будем использовать простой .procmailrc, который фильтрует почту от трех списков рассылки gentoo в три почтовых ящика: gentoo-dev, gentoo-user и gentoo-announce. </para>
<para>Примечание: Правила фильтра называются условиями. Я также добавил условия для того, чтобы отфильтровать некоторый спам. </para>
<para/>
<para/>
<para>Листинг 3.1: Пример .procmailrc</para>
<para>MAILDIR=$HOME/MuttMail                ##проверьте правильность пути</para>
<para>5LOGFILE=$HOME/.procmaillog</para>
<para>LOGABSTRACT=no</para>
<para>#VERBOSE=on... используется только для отладки</para>
<para>VERBOSE=off</para>
<para>FORMAIL=/usr/bin/formail</para>
<para>NL="</para>
<para>"</para>
<para>##условные строки начинаются с :0</para>
<para>##не записывайте комментарии в строки условия</para>
<para>##отредактируйте ненужные условия!</para>
<para>##строки условий начинаются с *, а регулярные выражения ваши лучшие друзья</para>
<para>##условия добавленные после * попадают прямо в egrep</para>
<para>##строка следущая за условиями, в следующем регистре является именем почтового ящика</para>
<para/>
<para>#отлавливание копий, используя formail</para>
<para>:0 Whc: .msgid.lock</para>
<para>| $FORMAIL -D 16384 .msgid.cache</para>
<para/>
<para>:0 a</para>
<para>$MAILDIR/duplicates</para>
<para/>
<para>#люди которые всегда пишут с одного почтового адреса</para>
<para>:0 </para>
<para>* ^From:.*(craig\@hotmail|renee\@local.com)</para>
<para>$MAILDIR/friends </para>
<para/>
<para>#выборка некоторого спама</para>
<para>:0  </para>
<para>* ^Subject:.*(credit|cash|money|debt|sex|sale|loan)</para>
<para>$MAILDIR/spam</para>
<para/>
<para>#никаких html писем</para>
<para>:0</para>
<para>* ^Content-Type:.*html</para>
<para>$MAILDIR/junk</para>
<para/>
<para>#складировать письма из списков рассылки в мои почтовые ящики</para>
<para>:0 </para>
<para>* ^List-Id:.*gentoo-user</para>
<para>gentoo-user</para>
<para/>
<para>:0 </para>
<para>* ^List-Id:.*gentoo-dev</para>
<para>gentoo-dev</para>
<para/>
<para>:0 </para>
<para>* ^List-Id:.*gentoo-announce</para>
<para>gentoo-announce</para>
<para/>
<para>#получать любую другую почту с gentoo</para>
<para>:0 </para>
<para>* ^From:.*gentoo.org</para>
<para>gentoo</para>
<para/>
<para>:0 </para>
<para>* ^From:.*@freshmeat\.net</para>
<para>freshmeat</para>
<para/>
<para>###########################################</para>
<para># последние условие: складирует остальную #</para>
<para># почту в почтовый ящик по умолчанию      # </para>
<para>###########################################</para>
<para>:0 </para>
<para>* .*</para>
<para>default</para>
<para/>
<para># конец файла</para>
<para/>
<para>Примечание: В данном случае вам только потребуется создать почтовую директорию в $HOME/MuttMail, после чего Procmail создаст все необходимые файлы почтового ящика в этом каталоге, используя названия из строк условий. Для дополнительной информации посетите http://www.procmail.org/</para>
<para/>
<para/>
<para>Для проверки нашего .procmailrc, повторно запустите fetchmail (который мы уже настроили). Помните также, что опция -k оставляет почту на удаленном сервере, потому её можно использовать для нашего теста. </para>
<para/>
<para>Листинг 3.2: Тест Procmail #1</para>
<para># fetchmail -akv -m "/usr/bin/procmail -d %T" </para>
<para/>
<para/>
<para>Ну всё, теперь когда fetchmail и procmail работают, мы можем зайдя в $HOME/MuttMail прочитать нашу почту программой less или вашим любимым файловым менеджером. </para>
<para/></sect2><sect2><title>4. Почтовый клиент Mutt</title>
<para/>
<para>Mutt используется для чтения и написания писем. Это очень мощное, сложно-настраиваемое, легковесное и эффективное приложение. </para>
<para/>
<para>Mutt поддерживает чтение и запись в различных форматах почтового ящика: mbox, MMDF, MH и Maildir. Тип почтового ящика распознается автоматически. В нашем случае мы используем формат mbox, где все сообщения почтового ящика сохраняются в отдельных файлах. </para>
<para/>
<para>Mutt также имеет способность работать с папками, расположенными на удаленном IMAP сервере. См. Поддержку IMAP в разделе 4.11 руководства по Mutt и сайт Mutt http://www.mutt.org/. </para>
<para/>
<para>При установке mutt создаётся основной файл конфигурации /etc/mutt/Muttrc. Вам также необходимо создать файл .muttrc в своём домашнем каталоге. </para>
<para/>
<para>Листинг 4.1: Пример .muttrc</para>
<para/>
<para>(Конечно, неплохо бы прочитать документацию Mutt из /usr/share/doc/mutt*)</para>
<para>(Любые настройки здесь отменяют параметры общей конфигурации из /etc/mutt/Muttrc)</para>
<para/>
<para># cp /etc/mutt/Muttrc ~/.muttrc</para>
<para># nano -w .muttrc</para>
<para>set pager_context=1</para>
<para>set pager_index_lines=6                 #показывать оглавления в окне программы</para>
<para>set menu_scroll</para>
<para>set pgp_verify_sig=no                   #не показывать pgp на странице</para>
<para>set status_on_top                       #разместить статусную строку вверху</para>
<para>set sort=threads                        #сортировать сообщения по заголовкам</para>
<para/>
<para>set status_format=" %r %b %f %n      Del %d      Msgs %m %l %&gt; (%P)"</para>
<para>set pager_format="%-10.10i %[!%a %b %d %R]"</para>
<para>set date_format="!%H:%M %a %d %b     "</para>
<para>set index_format="%4C %Z %[%b%d] %-15.15F %s"</para>
<para>set folder_format="%2C %t %8s %d %N %f"</para>
<para/>
<para>#set sendmail="/usr/bin/nbsmtp -d isp.net -h smtp.isp.net -f yourname@isp.net"</para>
<para/>
<para>#set from="default-mailaddress"         #задаёт ваш адрес в строке "from"</para>
<para>#set realname="myname"</para>
<para/>
<para>set record="$HOME/MuttMail/sent"        #сохранять отправленную почту здесь</para>
<para>set delete=yes                          #удалить без подтверждения</para>
<para>set include=yes                                #выделять сообщение в ответе</para>
<para>set fast_reply=yes                        #не подтверждать ответ</para>
<para>set beep=no                                #не пищать</para>
<para>set markers=no                                #не помечать + сложенные строки</para>
<para>set confirmappend=no                        #не подтверждать сохранение в =keep</para>
<para>set to_chars=" +TCF"                    #нет L для mail_list</para>
<para/>
<para>set folder = $HOME/MuttMail</para>
<para>mailboxes =gentoo-user</para>
<para>mailboxes =gentoo-dev</para>
<para>mailboxes =gentoo-announce</para>
<para>mailboxes =gentoo</para>
<para>mailboxes =freshmeat</para>
<para>mailboxes =duplicates</para>
<para>mailboxes =default</para>
<para>mailboxes =sent</para>
<para>mailboxes =friends</para>
<para>mailboxes =junk</para>
<para>mailboxes =spam</para>
<para>mailboxes =keep</para>
<para/>
<para>save-hook .* =keep                      #mbox по умолчанию сохраняет (s) почту в =keep</para>
<para>subscribe gentoo-user gentoo-dev        #подписанные списки</para>
<para/>
<para>bind pager h display-toggle-weed        #переключать заголовки кнопкой h</para>
<para/>
<para># симулировать старое url меню</para>
<para>macro index \cb |urlview\n 'call urlview to extract URLs out of a message'</para>
<para>macro pager \cb |urlview\n 'call urlview to extract URLs out of a message'</para>
<para/>
<para>#запуск fetchmail нажатием кнопки G</para>
<para>macro index G "!fetchmail -a -m 'procmail -d %T'\r"</para>
<para>macro pager G "!fetchmail -a -m 'procmail -d %T'\r"</para>
<para/>
<para>#редактирование .muttrc... не требует перезапуска</para>
<para/>
<para>macro generic ,sm ":source $HOME/.muttrc\r"</para>
<para>macro generic \cj "!rxvt -bg wheat -e joe $HOME/.muttrc\r"</para>
<para/>
<para>#по умолчанию список заголовков в полях удаляется перед показом почты</para>
<para>#игнорирует всё, кроме того, что вам нужно</para>
<para>ignore *</para>
<para>unignore  Date To From: Subject X-Mailer Organization User-Agent</para>
<para>hdr_order Date From To Subject X-Mailer User-Agent Organization</para>
<para/>
<para>##ваш Mutt должен поддерживать несколько цветов</para>
<para>##для обозначения четырех уровней выделенного текста</para>
<para>##данные настройки отменяют параметры общей конфигурации в /etc/mutt/Muttrc</para>
<para/>
<para>#color quoted green  default</para>
<para>color quoted1 magenta blue</para>
<para>#color quoted2 yellow default</para>
<para>#color quoted3 red default</para>
<para>#color signature cyan cyan</para>
<para/>
<para/>
<para>#эта цветовая схема взята из /etc/mutt/Muttrc.color</para>
<para>#закомментируйте её, если вам нужна цветовая схема по умолчанию из /etc/mutt/Muttrc</para>
<para># Je vois la vie en rose :-)</para>
<para>color        hdrdefault        brightcyan        blue</para>
<para>color        header                brightwhite        blue "^from:"</para>
<para>color   header          brightwhite            blue   "^subject:"</para>
<para/>
<para>color   quoted          brightgreen     blue</para>
<para>color   signature       brightwhite        blue</para>
<para/>
<para>color   indicator       blue                green</para>
<para/>
<para>color   error           red             black</para>
<para>mono    error           bold</para>
<para>color   status          black cyan</para>
<para>mono        status                bold</para>
<para>color   tree            yellow           blue</para>
<para/>
<para>color   tilde           brightmagenta   blue</para>
<para>color        body        brightwhite                blue        "[-a-z_0-9.]+@[-a-z_0-9.]+"</para>
<para>mono    body    bold                    "[-a-z_0-9.]+@[-a-z_0-9.]+"</para>
<para>color   body            brightyellow    black   "^Good signature"</para>
<para>mono    body            bold                    "^Good signature"</para>
<para>color   body            brightwhite     red     "^Bad signature from.*"</para>
<para>mono    body            bold                    "^Bad signature from.*"</para>
<para>color   normal          white                blue</para>
<para>color        message                green        black</para>
<para>color        attachment        brightgreen        blue</para>
<para/>
<para># конец файла... но вы можете его дописывать и дописывать... :)</para>
<para/>
<para/>
<para>Это только маленький пример файла .muttrc. На самом же деле гораздо больше опций поддаются конфигурации, например, те же настройки gpg. Для примеров и помощи посмотрите http://mutt.netliberte.org/. </para>
<para/>
<para>Теперь вы можете протестировать наш .muttrc </para>
<para/>
<para>Листинг 4.2: Тест .muttrc</para>
<para># mutt -y</para>
<para/>
<para/>
<para>После чего должно появиться окно Mutt с почтовыми ящиками, которые мы создали, когда настраивали fetchmail. </para>
<para/>
<para>Нажмите ? для получения помощи в навигации по почтовым ящикам в Mutt. </para>
<para/></sect2><sect2><title>5. SMTP</title>
<para/>
<para>Последний шаг, это настройка nbsmtp ('No-Brainer SMTP'), используемого для отправки почты на ваш сервер SMTP. Данная настройка самая простая и требует лишь добавления нескольких строк в конфигурационный файл .muttrc </para>
<para/>
<para>domain: домен, сообщаемый nbsmtp. Будет почти всегда похож на окончаниее вашего адреса электронной почты. </para>
<para/>
<para>from@addr: Это тот адрес, который будет сообщаться nbsmtp в строке "from". Обратите внимание, что данный адрес может отличаться от того, что записан в поле "From:" вашего почтового клиента (MUA). </para>
<para/>
<para>host: Сервер smtp, куда, собственно, и будет отправляться почта.</para>
<para/>
<para/>
<para/>
<para>Листинг 5.1: Добавление поддержки smtp</para>
<para># nano -w .muttrc</para>
<para>set sendmail="/usr/bin/nbsmtp -d isp.net -h smtp.isp.net -f urname@isp.net"</para>
<para/>
<para/>
<para>Теперь всё готово для создания письма. В окне Mutt нажмите m, для того чтобы написать текстовое сообщение на ваш же почтовый ящик. Mutt использует значение EDITOR или VISUAL, указываемое с помощью опций editor= в .muttrc. После того, как сообщение будет написано, нажмите y для его отправки. Если всё прошло удачно, мы увидим сообщение 'sending mail', следующее за 'New mail in =sent'. </para>
<para/>
<para>Помните, в .muttrc у нас задано сохранять всю отправленную почту при помощи строки :set record="$HOME/MuttMail/sent" </para>
<para/>
<para>Теперь, чтобы завершить испытание, снова запустите fetchmail для получения всей почты и вашего тестового письма, которое вы себе отправили. Как только это тестовое письмо будет найдено, нажмите h для того, чтобы посмотреть все его заголовки и полный путь прохождения почты (mail transfer path). </para>
<para>Примечание: Есть ещё одна программа, которая, возможно, вам пригодится, под названием urlview. Она извлекает ссылки из текстовых сообщений и перенаправляет их в ваш браузер. </para>
<para/>
<para/>
<para>Листинг 5.2: Установка urlview</para>
<para># emerge urlview </para>
<para/>
<para/>
<para>После чего создайте ~/.urlview копируя конфигурационный файл из /usr/share/doc/urlview*/, и подправьте необходимые настройки под свой браузер. </para>
<para/>
<para>Чтож, теперь у нас есть мощная почтовая система. Читайте различную документацию и руководства, а также ищите примеры конфигурационных файлов в 'google' по ключевым словам muttrc и procmailrc.</para></sect2></sect1><sect1><title>Руководство по файловой системе для устройств</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/devfs-guide.xml">http://www.gentoo.org/doc/ru/devfs-guide.xml</ulink>
</para>
<para>C версии: 1.0</para><sect2><title>1. Что такое devfs?</title>
<para/>
<para>Старые (добрые?) времена</para>
<para/>
<para>Традиционная реализация Linux предоставляет пользователю абстрактный каталог устройств, называемый /dev. Внутри этого каталога находятся device nodes, специальные файлы, символизирующие устройства внутри системы. Например, /dev/hda символизирует первое IDE устройство в вашей системе. Файлы устройств позволяют создавать программы, которые взаимодействуют с устройствами так, как если бы устройства были обычными файлами, вместо использования специальных API. </para>
<para/>
<para>Файлы устройств подразделяются на две группы, называемые character devices (символьные устройства) и block devices (блочные устройства). Первая группа содержит устройства, для котрых отсутствует буферизация чтения/записи. Вторая группа, естественно, содержит устройства, для которых чтение/запись буферизируется. Из обоих типов устройств может быть прочитан за раз один символ или блок. Поэтому такой способ присваивания имён может сбивать с толку и на самом деле неправилен. </para>
<para/>
<para>Если посмотреть на конкретное устройство, можно обнаружить что-то, похожее на это: </para>
<para/>
<para>Листинг 1.1: Исследование информации о файле устройства</para>
<para># ls -l /dev/hda</para>
<para>brw-rw----    1 root     disk       3,   0 Jul  5  2000 /dev/hda</para>
<para/>
<para>В предыдущем примере мы увидели, что /dev/hda — это блочное устройство. Однако важнее то, что ему присвоено два специальных номера 3, 0. Эта пара называется major-minor. Она используется ядром, чтобы соотнести файл устройства и реальное устройство. major (старший) относится к типу устройства, minor (младший) к конкретному устройству. Выглядит запутано, не правда ли? </para>
<para/>
<para>Ещё два примера — /dev/hda4 и /dev/tty5. Первое устройство соответствует четвёртому разделу на первом IDE-устройстве. Его пара major-minor 3, 4. Другими словами, minor соответствует разделу, тогда как major соответствует устройству. Во втором примере пара major-minor — 4, 5. В этом случае первое число соответствует драйверу терминала, тогда как второе соответствует номеру терминала (в данном случае пятый терминал). </para>
<para/><sect3><title>Проблемы</title>
<para/>
<para>Если вы заглядывали в папку /dev, вы обнаружили, что там перечислены не только все ваши устройства, но и все возможные устройства, которые только могут быть. Другими словами, у вас есть файлы устройств для устройств, которых у вас нет. Управление такой кучей устройств по крайней мере можно назвать громоздким. Представьте, что надо поменять права на все устройства, реально существующие в вашей системе, оставив остальные без изменений. </para>
<para/>
<para>Затем вы добавили новое оборудование в вашу систему, для него может не оказаться уже существующего файла. Продвинутые пользователи знают, что эта задача может быть выполнена с помощью команды ./MAKEDEV внутри директории /dev, но разве вы сразу знаете, что за устройство вам придётся создать? </para>
<para/>
<para>Когда у вас есть программы, взаимодействующие с оборудованием при помощи файлов устройств, вы не можете смонтировать корневой раздел только для чтения, в то время как в дальнейшем нет необходимости в том, чтобы он был смонтирован на чтение и запись. И вы не можете иметь /dev на отдельном разделе, так как mount необходим, /dev чтобы монтировать разделы. </para>
<para/></sect3><sect3><title>Решения</title>
<para/>
<para>Как вы могли себе представить, kernel hackers нашли достаточно решений для вышеперечисленных проблем. Однако многие из этих решений имеют собственные проблемы описанные в http://www.atnf.csiro.au/people/rgooch/linux/docs/devfs.html#faq-why. Мы не будем обсуждать эти варианты, а сконцентрируемся на одном способе, который был реализован в официальной версии исходников ядра: </para>
<para/>
<para>devfs как абсолютный победитель?</para>
<para/>
<para>devfs решает все перечисленные проблемы. Она просто предоставляет пользователю доступ к существующим устройствам, добавляет новые device nodes (файлы устройств), когда найдены новые устройства, и делает возможным монтировать корневую файловую систему в режиме read only (только чтение). А также решает многие проблемы, которые мы раньше не обсуждали, потому что они не так интересны для пользователей... </para>
<para/>
<para>Как пример, с devfs вам не надо беспокоится о паре major/minor. Она продолжат поддерживаться (для обратной совместимости), но в ней нет необходимости. Это позволяет Linux поддерживать ещё больше устройств, так как больше нет ограничений (числа всегда имеют границы :) </para>
<para/>
<para>Однако у devfs есть свои проблемы, не столь очевидные для пользователей, но достаточно серьезные, чтобы разработчики ядра пометили ее как obsolete (устаревшее), порекомендовав использовать udev, которая также поддерживается Gentoo. </para>
<para/>
<para>Чтобы узнать, почему devfs считается устаревшей, читайте udev FAQ и udev versus devfs document. </para>
<para/></sect3></sect2><sect2><title>2. Навигация через дерево устройств</title>
<para/>
<para>Директории</para>
<para/>
<para>Одна из первых особенностей которые вы можете заметить это то что devfs использует директории для объединения устройств вместе. Это повышает читабельность, так как теперь все связанные между собой устройства находятся внутри одной общей директории. </para>
<para>Например, все устройства, относящиеся к IDE, находятся в директории /dev/ide/, а все относящиеся к SCSI в директории /dev/scsi/. SCSI и IDE диски во многом похожи, у них одинаковая структура поддиректорий. </para>
<para>IDE и SCSI диски управляются при помощи адаптера (встроенного или отдельной платой), называемого host. Каждый адаптер может иметь несколько каналов. Канал называется bus. На каждом канале может быть несколько IDs (идентификаторов). ID служит для идентификации диска. Этот ID называется target. Многие SCSI устройства могут иметь множество LUN (Logical Unit Numbers (Номер Логического Устройства)), Например устройства которые управляют несколькими носителями одновременно (hi-end tapedrives). У вас скорее всего будет только один lun, lun0/. </para>
<para>Итак, несмотря на то, что раньше использовался /dev/hda4, теперь появился /dev/ide/host0/bus0/target0/lun0/part4. Это намного проще... нет, не спорьте со мной... это проще... как бы то ни было! :) </para>
<para>Примечание: Вы также можете использовать более похожие на Unix названия для жёстких дисков, такие как c0b0t0u0p2. Они могут быть найдены в /dev/ide/hd, /dev/scsi/hd и.т.д. </para>
<para>Чтобы дать вам лучше понять идею с директориями, вот листинг директорий которые есть у меня: </para>
<para/>
<para>Листинг 2.1: Дирректории в /dev</para>
<para>cdroms/     cpu/        discs/          floppy/</para>
<para>ide/        input/      loop/           misc/</para>
<para>netlink/    printers/   pts/            pty/</para>
<para>scsi/       sg/         shm/            sound/</para>
<para>sr/         usb/        vc/             vcc/</para>
<para/>
<para/>
<para/>
<para>Обратная совместимость при помoщи devfsd</para>
<para/>
<para>Использование этой новой структуры выглядит здорово, но многие утилиты и программы используют предыдущую, старую структуру. Для уверенности, что система не будет нарушена, был создан devfsd. Этот демон создаёт символьные ссылки на новые файлы устройств, но со старыми именами (compatibility symlinks). </para>
<para/>
<para>Листинг 2.2: Созданные символьные ссылки</para>
<para>$ ls -l /dev/hda4</para>
<para>lr-xr-xr-x    1 root     root           33 Aug 25 12:08 /dev/hda4 -&gt; ide/host0/bus0/target0/lun0/part4</para>
<para/>
<para/>
<para>При помощи devfsd, вы можете устанавливать права доступа, создавать новые файлы устройств и т.д. Всё это описывается в следующей главе. </para>
<para/></sect2><sect2><title>3. Администрирование дерева устройств</title>
<para/>
<para>Перезагрузка devfsd</para>
<para/>
<para>Если вы изменили файл /etc/devfsd.conf, и хотите чтобы изменения вступили в силу, вым не обязательно перезагружаться. В зависимости от того, что вы хотите, вы можете использовать любой из следующих сигналов: </para>
<para/>
<para>SIGHUP заставит devfsd перечитать конфигурационный файл, перегрузить разделяемые объекты (shared objects) и сгенерировать событие REGISTER для каждого листа в дереве устройств. </para>
<para/>
<para>SIGUSR1 сделает то же самое, но не будет событий REGISTER. </para>
<para/>
<para>Чтобы послать сигнал, просто используйте kill или killall: </para>
<para/>
<para>Листинг 3.1: Посылка сигнала SIGHUP демону devfsd</para>
<para># kill -s SIGHUP `pidof devfsd`</para>
<para>или</para>
<para># killall -s SIGHUP devfsd</para>
<para/>
<para>Удаление compatibility symlinks</para>
<para>Предупреждение: В настоящее время Gentoo не может существовать без этих ссылок. </para>
<para/>
<para>Если вы хотите удалить из вашей системы ссылки которые засоряют /dev (в Gentoo они используются по умолчанию), отредактируйте /etc/devfsd.conf и удалите следующие две строчки: </para>
<para/>
<para>Листинг 3.2: /etc/devfsd.conf для обратной совместимости</para>
<para># Закоментируйте эти две строчки для удаления симлинков</para>
<para>REGISTER        .*  MKOLDCOMPAT</para>
<para>UNREGISTER      .*  RMOLDCOMPAT</para>
<para/>
<para>Вам придётся перезагрузится, чтобы изменения вступили в силу. </para>
<para/>
<para>Удаление возможности автосоздания файлов устройств</para>
<para/>
<para>Когда вы загружаете модуль, devfs автоматически создаёт файлы устройств. Если вы не хотите, чтобы он так делал, удалите эту строчку из /etc/devfsd.conf: </para>
<para/>
<para>Листинг 3.3: /etc/devfsd.conf, autoload functionality</para>
<para>LOOKUP      .*  MODLOAD</para>
<para/></sect2><sect2><title>4. Вопросы, относящиеся к правам доступа</title>
<para/>
<para>Установка/изменение прав доступа при помощи PAM</para>
<para/>
<para>Хотя вы можете установить права доступа в /etc/devfsd.conf, мы советуем использовать PAM (Pluggable Authentification Modules (). Так как PAM имеет решающий голос при установке прав доступа, и может проигнорировать изменения, которые вы сделали в /etc/devfsd.conf. </para>
<para/>
<para>PAM использует /etc/security/console.perms для установки прав доступа. Файл состоит из двух частей: в первой описываются группы, а во второй права. </para>
<para/>
<para>Давайте сначала взглянем на часть с группами. Как пример мы рассмотрим sound-group: </para>
<para/>
<para>Листинг 4.1: Sound group в /etc/security/console.perms</para>
<para>&lt;sound&gt;=/dev/dsp* /dev/audio* /dev/midi* \</para>
<para>    /dev/mixer* /dev/sequencer* \</para>
<para>    /dev/sound/* /dev/snd/* /dev/beep \</para>
<para>    /dev/admm* \</para>
<para>    /dev/adsp* /dev/aload* /dev/amidi* /dev/dmfm* \</para>
<para>    /dev/dmmidi* /dev/sndstat</para>
<para/>
<para/>
<para>Синтаксис достаточно прост: вы начинаете с имени группы, и заканчиваете списком устройств, принадлежащих этой группе. </para>
<para>Теперь для того, чтобы с группами можно было что-нибудь сделать, рассмотрим следующую часть, описывающую, как управлять правами. </para>
<para/>
<para>Листинг 4.2: Права доступа для sound group в /etc/security/console.perms</para>
<para>&lt;console&gt;  0600 &lt;sound&gt;      0600 root.audio</para>
<para/>
<orderedlist>
<listitem>
<para>Первое поле — это проверка терминала. На большинстве систем это console-group. PAM будет проверять это поле при каждом входе в систему. Если вход произошёл на устройстве, содержащемся в console-group, PAM проверит и возможно сменит права на некоторые файлы устройств. </para>
</listitem>
<listitem>
<para>Второе поле содержит права, которые установятся на файл устройства после удачного входа в систему. Когда человек вошел в систему, а файлы устройств принадлежат пользователю и группе по умолчанию, PAM сменит владельца на вошедшего пользователя и установит на них права из второго поля. В данном случае используется 0600 (пользователь имеет право на чтение/запись, все остальные нет). </para>
</listitem>
<listitem>
<para>В третьем поле содержатся группы устройств, чьи права будут изменены. В данном случае, вторая группа (все устройства, относящиеся к звуку) будут изменены. </para>
</listitem>
<listitem>
<para>Четвёртое поле определяет права, которые будут установлены на файлы устройств после возврата в состояние по умолчанию. Другими словами, если человек, который владеет правами на все файлы устройств, выйдет из системы, PAM установит права обратно в состояние по умолчанию, описанному в этом четвёртом поле. </para>
</listitem>
<listitem>
<para>Пятое поле определяет собственника (с группой если вам надо) к которому будут установлены атрибуты устройства после возврата в состояние по умолчанию Другими словами, если человек, владеющий правами на все файлы устройств, выйдет из системы, PAM установит собственника обратно в состояние по умолчанию, описанному в пятом поле. </para>
</listitem>
</orderedlist>
<para/>
<para>Установка/изменение прав доступа при помощи devfsd</para>
<para/>
<para>Если вы действительно хотите установить права, используя /etc/devfsd.conf, тогда используйте синтаксис приведённый в этом примере: </para>
<para/>
<para>Листинг 4.3: Права в /etc/devfsd.conf</para>
<para>REGISTER    ^cdroms/.*  PERMISSIONS root.cdrom 0660</para>
<para/>
<para/>
<para>Второе поле — это группа устройств, начиная с /dev. Это регулярное выражение, означающее, что вы можете выбрать несколько файлов устройств с одним правилом. </para>
<para>Четвёртое поле — это владелец файла устройства. В отличие от PAM, он не изменяется (если он не упоминается в console.perms, так как PAM главнее). </para>
<para>Пятое поле содержит права на файлы устройств. </para>
<para/>
<para>Ручная установка прав и их сохранение devfsd</para>
<para/>
<para>Это обычная ситуация для Gentoo: если вы делаете chown (CHange OWNer (Смена владельца)) и chmod (CHange MODe (Смена вида)) некоторым файлам устройств, то devfsd сохраняют информацию, когда вы вы выключаете систему. Это происходит из-за того, что файл /etc/devfsd.conf содержит следующие строчки: </para>
<para/>
<para>Листинг 4.4: /etc/devfsd.conf для сохранения прав доступа</para>
<para>REGISTER        ^pt[sy]/.*   IGNORE</para>
<para>CHANGE          ^pt[sy]/.*   IGNORE</para>
<para>CREATE          ^pt[sy]/.*   IGNORE</para>
<para>DELETE          ^pt[sy]      IGNORE</para>
<para>REGISTER        ^log         IGNORE</para>
<para>CHANGE          ^log         IGNORE</para>
<para>CREATE          ^log         IGNORE</para>
<para>DELETE          ^log         IGNORE</para>
<para>REGISTER        .*           COPY    /lib/dev-state/$devname $devpath</para>
<para>CHANGE          .*           COPY    $devpath /lib/dev-state/$devname</para>
<para>CREATE          .*           COPY    $devpath /lib/dev-state/$devname</para>
<para>DELETE          .*           CFUNCTION GLOBAL unlink</para>
<para>/lib/dev-state/$devname</para>
<para>RESTORE         /lib/dev-state</para>
<para/>
<para/>
<para>Другими словами, изменённые файлы устройств копируются в /lib/dev-state, когда выключается система, и копируются в /dev, когда система грузится. </para>
<para/>
<para>Другая возможность - монтировать /lib/dev-state в /dev во время загрузки. Чтобы это сделать, вы должны быть уверены, что devfs не монтируется автоматически (это значит, что вы должны перекомпилировать ядро), и что /dev/console существует. Затем, где-то в начале bootscripts (загрузочных скриптов) вашей системы, вы должны разместить: </para>
<para>Листинг 4.5: Монтирование /lib/dev-state в /dev</para>
<para>mount --bind /dev /lib/dev-state</para>
<para>mount -t devfs none /dev</para>
<para>devfsd /dev</para></sect2></sect1><sect1><title>Ebuild HOWTO (Англ.)</title>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/proj/en/devrel/handbook/handbook.xml?part=2&amp;chap=1">http://www.gentoo.org/proj/en/devrel/handbook/handbook.xml?part=2&amp;chap=1</ulink>
</para>
<para>С версии: 1.4</para>
<para/><sect2><title>1.a. The Portage tree</title>
<para>Introduction</para>
<para>The Portage tree is typically found at /usr/portage and is organized in a hierarchical structure consisting of category directories, followed by specific package directories. Here's an example; you can find the util-linux-2.11y.ebuild file in the /usr/portage/sys-apps/util-linux directory. There may be several other versions of util-linux ebuilds alongside util-linux-2.11y.ebuild. This is because all ebuilds for a particular package (regardless of version), share the same mycat/mypkg directory in /usr/portage. </para>
<para/>
<para>Checking Out the Portage Tree from CVS</para>
<para/>
<para>If you are unfamiliar with the CVS system, please read the <ulink url="http://www.gentoo.org/doc/en/cvs-tutorial.xml">CVS Tutorial</ulink> for more information. </para>
<para>The Portage tree can be found in the gentoo-x86 module of the Gentoo Linux tree. To check out the module (about 350 megabytes) you would first set up CVS via the above guide, then check out the gentoo-x86 module. </para>
<para/>
<para>What (not) to put in the Portage tree</para>
<para/>
<para>Before writing a new ebuild, check <ulink url="http://bugs.gentoo.org/">bugs.gentoo.org</ulink> to see if an ebuild has already been written for the package, but has not yet been added to the Portage tree. Go to <ulink url="http://bugs.gentoo.org/">bugs.gentoo.org</ulink>, choose query and select Advanced Search; as product select Gentoo Linux, as component select ebuilds. In the search field put the name of the ebuild and as status select NEW, ASSIGNED, REOPENED and RESOLVED (RESOLVED is important), then submit the query. For you lazy people, click <ulink url="http://bugs.gentoo.org/query.cgi?product=Gentoo%20Linux&amp;component=Ebuilds&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;bug_status=RESOLVED">here</ulink>. </para>
<para>In general, the Portage tree should only be used for storing .ebuild files, as well as any relatively small companion files, such as patches or sample configuration files. These types of files should be placed in the /usr/portage/mycat/mypkg/files directory to keep the main mycat/mypkg directory uncluttered. Exceptions to this rule are for larger patch files (we recommend this for patches above 20KB) which should be put onto the Gentoo mirrors so that people do not waste excessive amounts of bandwidth and hard drive space. Also, you should not add binary (non-ASCII) files to the Portage CVS tree. If you need to do this in another CVS tree, for example, if you need to add a small PNG graphic for whatever reason, be sure to add it to CVS by using the -kb option, like so: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 1.1: Adding binary files to CVS</para>
</entry>
</row>
<row>
<entry>
<para># cvs add -kb myphoto.png</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>The -kb option tells CVS that myphoto.png is a binary file and should be treated specially. For example, merging the differences between two different versions of this file should not be allowed to happen, for obvious reasons. Also, speaking of merging changes, any patches you add to Portage should generally not be compressed. This will allow CVS to merge changes and correctly inform developers of conflicts. </para>
<para>Remember, the packages that you commit must be ready out of the box for end users when committed as stable. Make sure that you have a good set of default settings that will satisfy the majority of systems and users that will use your package. If your package is broken, and you are not sure how to get it to work, check some other distributions that have done their own versions of the package. You can check <ulink url="http://cvs.mandriva.com/cgi-bin/viewvc.cgi/SPECS/">Mandriva</ulink> or <ulink url="http://www.debian.org/distrib/packages">Debian</ulink> or <ulink url="http://cvs.fedora.redhat.com/">Fedora</ulink> for some examples. </para>
<para>When committing to CVS, all developers should use repoman commit instead of cvs commit to submit their ebuilds. Before committing, please run repoman full to make sure you didn't forget something. </para>
<para>CVS Commit Policy</para>
<orderedlist>
<listitem>
<para>Always run repoman scan before you commit. </para>
</listitem>
<listitem>
<para>Please run repoman full before you commit. </para>
</listitem>
<listitem>
<para>Always test that package.mask is okay by doing emerge --pretend mypkg before you commit and check that it doesn't contain any conflicts. </para>
</listitem>
<listitem>
<para>Always update the ChangeLog before you commit. </para>
</listitem>
<listitem>
<para>Always commit the updated package.mask before the updated package, in case conflicts occur while you commit package.mask. </para>
</listitem>
<listitem>
<para>Always do atomic commits; if you commit a package with a new license, or that is masked, then first commit the revised package.mask and/or license, then commit the ebuild, ChangeLog, patches and <ulink url="http://www.gentoo.org/proj/en/devrel/handbook/handbook.xml?part=2&amp;chap=4">metadata.xml</ulink> all in one go to avoid breaking users' installations. </para>
</listitem>
</orderedlist>
<para>The files Directory</para>
<para>As noted earlier, under each package subdirectory is a files/ directory. Any patches, configuration files, or other ancillary files your package might require should be added to this directory; any files bigger than 20KB-or-so should go to the mirrors to lower the amount of (unneeded) files our users have to download. You may want to consider naming patches you create yourself just to get your package to build with a version-specific name, such as mypkg-1.0-gentoo.diff, or more simply, 1.0-gentoo.diff. Also note that the gentoo extension informs people that this patch was created by us, the Gentoo Linux developers, rather than having been grabbed from a mailing list or somewhere else. Again, you should not compress these patches because CVS does not play well with binary files. </para>
<para>Consider prefixing or suffixing (such as mypkg-1.0) every file you put into the files/ directory, so that the files used for each individual version on an ebuild are distinguishable from one another, and so that the changes between different revisions are visible. This is generally a really good idea :). You may want to use a different suffix if you wish to convey more meaning with the patch name. </para>
<para>If you have many files that should go into the files/ directory, consider creating subdirectories such as files/1.0/ and putting the relevant files in the appropriate subdirectory. If you use this method, you do not need to add version information to the names of the files, which is often more convenient. </para></sect2><sect2><title>1.b. Ebuild scripts</title>
<para>Introduction</para>
<para>Ebuild scripts are the basis for the entire portage system. They contain all the information required to download, unpack, compile and install a set of sources, as well as how to perform any optional pre/post install/removal or configuration steps. While most of Portage is written in Python, the ebuild scripts themselves are written in bash, since using bash allows us to call commands as we would from the command-line. One of the important design principles behind ebuild scripts is to have the commands therein be analogs of those one would type on the command-line if installing the package manually. For this purpose, using bash syntax is a very good thing. </para>
<para>Ebuild scripts are interpreted by the ebuild and emerge commands. Think of the ebuild command as a low-level building tool. It can build and install a single ebuild, but no more. It will check to see if dependencies are satisfied, but it will not attempt to auto-resolve them. On the other hand emerge is a high level engine for ebuild, and has the ability to auto-merge dependencies if needed, perform pretend merges so that user can see what ebuilds would be merged, and more. Generally, emerge blows ebuild out of the water except in one area. With ebuild, you can incrementally step through the various parts of a package emerge (fetching, unpacking, compiling, installing and merging) one at a time. For developers, this is an invaluable debugging tool, because it allows you to isolate ebuild problems to a specific portion of the ebuild. </para>
<para>Naming ebuild files</para>
<para>Ebuild file names consist of four logical subsections:</para>
<para>pkg-ver{_suf{#}}{-r#}.ebuild</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Note: The brackets ({}) delineate optional fields and do not appear in the literal package name. # represents any non-zero positive integer.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>The first subsection, pkg, is the package name, which should only contain lowercase letters, the digits 0-9, and any number of single hyphen (-), underscore (_) or plus (+) characters. Examples: util-linux, sysklogd and gtk+. We have some packages in Portage that don't follow these rules, but your packages should. </para>
<para>The second subsection, ver, is the version of the package, which should normally be same as the version on the main source tarball. The version is normally made up of two or three (or more) numbers separated by periods, such as 1.2 or 4.5.2, and may have a single letter immediately following the last digit; e.g., 1.4b or 2.6h. The package version is joined to the package name with a hyphen. For example: foo-1.0, bar-2.4.6. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Important: If you're thinking of using a trailing letter in your version string, note that the trailing letter should not be used to signify alpha or beta status for the package, since alphas and betas are prereleases and letter revisions are newer versions. This is an important distinction because Portage uses an ebuild's version number to determine if it is newer or older than other packages with the same category and name. It's very important that version numbers faithfully represent the version of the package so that Portage properly performs its dependency checking duties. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>The third subsection, {_suf{#}}, is optional may contain one of these predefined suffixes, listed in least-recent to most-recent order: </para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>Suffix</para>
</entry>
<entry>
<para>Meaning</para>
</entry>
</row>
<row>
<entry>
<para>_alpha</para>
</entry>
<entry>
<para>Alpha release</para>
</entry>
</row>
<row>
<entry>
<para>_beta</para>
</entry>
<entry>
<para>Beta release</para>
</entry>
</row>
<row>
<entry>
<para>_pre</para>
</entry>
<entry>
<para>Prerelease</para>
</entry>
</row>
<row>
<entry>
<para>_rc</para>
</entry>
<entry>
<para>Release candidate</para>
</entry>
</row>
<row>
<entry>
<para>(none)</para>
</entry>
<entry>
<para>Normal release</para>
</entry>
</row>
<row>
<entry>
<para>_p</para>
</entry>
<entry>
<para>Patch level (normally accompanied by trailing integer)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Any of these suffixes may be immediately followed by a non-zero positive integer, e.g., linux-2.4.0_pre10. Assuming identical version parts, the suffixes are ordered as follows (lower means older): _alpha &lt; _beta &lt; _pre &lt; _rc &lt; (no suffix) &lt; _p. </para>
<para>When comparing identical suffixes with trailing integers, the one with the larger integer will be considered most recent. Example: foo-1.0_alpha4 is more recent than foo-1.0_alpha3. </para>
<para>The fourth subsection of the package name is the Gentoo Linux-specific revision number ({-r#}). This subsection, like the suffix, is also optional. # is a non-zero positive integer; e.g., package-4.5.3-r3. </para>
<para>This revision number is independent of the version of the source tarball and is used to inform people that a new and improved Gentoo Linux revision of a particular package is available. Initial releases of ebuilds must have no revision number; e.g., package-4.5.3 and are considered by Portage to have a revision number of zero. This means that counting goes as follows: 1.0 (initial version), 1.0-r1, 1.0-r2, etc. </para>
<para>If you make non-trivial improvements to an existing ebuild file, you should copy the ebuild file to a new file with the revision number incremented by 1. Remember to always make mentions of your changes in the ChangeLog when you bump a revision and in your CVS commit message; not doing so is against policy. </para>
<para>... and I suppose that we actually have a fifth section of the ebuild name as well -- the .ebuild extension itself. </para>
<para>Contents of an ebuild file</para>
<para>This section is an introduction to ebuilds. For the full listing of everything possible in an ebuild, there is a manpage which talks about the internal format, variables, and functions in an ebuild script: man 5 ebuild. </para>
<para>Headers</para>
<para>When you submit your ebuilds, the header should be exactly the same as the one in /usr/portage/header.txt. Most importantly, do not modify it in anyway and make sure that the $Header: $ line is intact. </para>
<para>The first three lines should look something like this: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.1: Valid Header</para>
</entry>
</row>
<row>
<entry>
<para># Copyright 1999-2005 Gentoo Foundation</para>
<para># Distributed under the terms of the GNU General Public License v2</para>
<para># $Header: $</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Variables</para>
<para>The first part of every ebuild file is made up of a number of variables. They fall under 3 categories (and are marked below): </para>
<orderedlist>
<listitem>
<para>READ: variables you can utilize but never set </para>
</listitem>
<listitem>
<para>MUST: variables you must always set </para>
</listitem>
<listitem>
<para>OPT: variables that you should set </para>
</listitem>
</orderedlist>
<informaltable frame="all">
<tgroup cols="3"><tbody>
<row>
<entry>
<para>Variable</para>
</entry>
<entry>
<para>Usage</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
<row>
<entry>
<para>P</para>
</entry>
<entry>
<para>READ</para>
</entry>
<entry>
<para>The name and version of the package.</para>
</entry>
</row>
<row>
<entry>
<para>PN</para>
</entry>
<entry>
<para>READ</para>
</entry>
<entry>
<para>The name of the package.</para>
</entry>
</row>
<row>
<entry>
<para>PV</para>
</entry>
<entry>
<para>READ</para>
</entry>
<entry>
<para>The version of the package.</para>
</entry>
</row>
<row>
<entry>
<para>PR</para>
</entry>
<entry>
<para>READ</para>
</entry>
<entry>
<para>Contains the revision number or r0 if no revision number exists.</para>
</entry>
</row>
<row>
<entry>
<para>PVR</para>
</entry>
<entry>
<para>READ</para>
</entry>
<entry>
<para>Contains the version number with the revision.</para>
</entry>
</row>
<row>
<entry>
<para>PF</para>
</entry>
<entry>
<para>READ</para>
</entry>
<entry>
<para>Contains the full package name ${PN}-${PVR}.</para>
</entry>
</row>
<row>
<entry>
<para>A</para>
</entry>
<entry>
<para>READ</para>
</entry>
<entry>
<para>Space delimited list of the filenames in SRC_URI. This does not contain the URL paths, just the filename. </para>
</entry>
</row>
<row>
<entry>
<para>DISTDIR</para>
</entry>
<entry>
<para>READ</para>
</entry>
<entry>
<para>Contains the path to the distfiles directory where all the files fetched for a package are stored. Typically, this is /usr/portage/distfiles. </para>
</entry>
</row>
<row>
<entry>
<para>FILESDIR</para>
</entry>
<entry>
<para>READ</para>
</entry>
<entry>
<para>Contains the path to the files sub folder in the package specific location in the portage tree. Do not modify this variable. </para>
</entry>
</row>
<row>
<entry>
<para>WORKDIR</para>
</entry>
<entry>
<para>READ</para>
</entry>
<entry>
<para>Base of the build root for the ebuild. Nothing should be built outside of this directory. </para>
</entry>
</row>
<row>
<entry>
<para>S</para>
</entry>
<entry>
<para>OPT</para>
</entry>
<entry>
<para>The source directory for your package; commonly ${WORKDIR}/${P}. Portage will default to this value so you may not have to set it! </para>
</entry>
</row>
<row>
<entry>
<para>T</para>
</entry>
<entry>
<para>READ</para>
</entry>
<entry>
<para>The temporary directory for your package. It is used as a virtual /tmp directory while processing the ebuild. </para>
</entry>
</row>
<row>
<entry>
<para>D</para>
</entry>
<entry>
<para>READ</para>
</entry>
<entry>
<para>The root directory that the package is installed to, treat it as the virtual /. </para>
</entry>
</row>
<row>
<entry>
<para>SLOT</para>
</entry>
<entry>
<para>MUST</para>
</entry>
<entry>
<para>Portage handles different versions of the same installed programs. If you would want, say GCC 2.95 and GCC 3.2 installed at the same time, you would specify the SLOT in each ebuild. Here we would set the SLOT of GCC 2.95 to 2 while we would set the SLOT of GCC 3.2 to 3. Note: Using 0 as the SLOT value signifies that this package only has 1 SLOT setting (in other words, this package is not SLOTable). </para>
</entry>
</row>
<row>
<entry>
<para>LICENSE</para>
</entry>
<entry>
<para>MUST</para>
</entry>
<entry>
<para>This variable specifies what license the program is covered under, i.e. GPL-2, BSD, etc... This field must be set to a valid license (which is any license found in /usr/portage/license/). If the license does not already exist there, it must be added before the ebuild can be added to the portage tree. If the license does not allow redistribution, make sure you place RESTRICT="nomirror" in the ebuild. </para>
</entry>
</row>
<row>
<entry>
<para>KEYWORDS</para>
</entry>
<entry>
<para>MUST</para>
</entry>
<entry>
<para>This variable now supports a couple of different functions. First of all, this variable specifies what architecture the ebuild is meant for. Some example keywords include: x86, ppc, sparc, mips, alpha, arm, hppa, amd64 and ia64. See the profiles/arch.list file in the Portage tree for more details. Obviously, you would set this to reflect the architecture of the target machine. Portage will not allow an x86 machine to build anything but x86, as specified by the KEYWORDS variable. Packages that do not support the native architecture are automatically masked by Portage. If the KEYWORDS flag has a preceding ~, then that indicates that the particular ebuild works, but needs to be tested in several environments before being moved to the stable profile with the given keyword. If the KEYWORDS flag has a preceding -, then the package does not work with the given keyword. If there is nothing leading KEYWORDS, then the package is considered stable. You can allow installation of these different types of packages through the ACCEPT_KEYWORDS variable in make.conf. </para>
</entry>
</row>
<row>
<entry>
<para>DESCRIPTION</para>
</entry>
<entry>
<para>MUST</para>
</entry>
<entry>
<para>A short, one line description of your package.</para>
</entry>
</row>
<row>
<entry>
<para>SRC_URI</para>
</entry>
<entry>
<para>MUST</para>
</entry>
<entry>
<para>The URLs for every source file in your package, separated by whitespace. You should try not to include version numbers in the SRC_URI and S. Always try to use ${PV} or ${P}, and if a version number is not consistent with the name of the source package, make a ${MY_P} variable and use that instead. </para>
</entry>
</row>
<row>
<entry>
<para>HOMEPAGE</para>
</entry>
<entry>
<para>MUST</para>
</entry>
<entry>
<para>The homepage of the package. If you are unable to locate an official one, try to provide a link from <ulink url="http://freshmeat.net/">freshmeat.net</ulink> or a similar package tracking site. Never refer to a variable name in the string; include only raw text. </para>
</entry>
</row>
<row>
<entry>
<para>IUSE</para>
</entry>
<entry>
<para>MUST</para>
</entry>
<entry>
<para>This is set to whatever USE variables your package utilizes. Remember that KEYWORDS should not be listed in here! </para>
</entry>
</row>
<row>
<entry>
<para>DEPEND</para>
</entry>
<entry>
<para>OPT</para>
</entry>
<entry>
<para>The package's build dependencies are listed here. See the section <ulink url="http://www.gentoo.org/proj/en/devrel/handbook/handbook.xml?part=2&amp;chap=1#doc_chap5">Package Dependencies</ulink> for more details on proper syntax. </para>
</entry>
</row>
<row>
<entry>
<para>RDEPEND</para>
</entry>
<entry>
<para>OPT</para>
</entry>
<entry>
<para>The package's runtime dependencies are listed here. Once again, see <ulink url="http://www.gentoo.org/proj/en/devrel/handbook/handbook.xml?part=2&amp;chap=1#doc_chap5">Package Dependencies</ulink> for more details. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Functions</para>
<para>There are a number of different functions that you can define in ebuild files that control the building and installation process of your package. </para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>Function</para>
</entry>
<entry>
<para>Purpose</para>
</entry>
</row>
<row>
<entry>
<para>pkg_setup</para>
</entry>
<entry>
<para>Use this function to perform any miscellaneous prerequisite tasks. This might include checking for an existing configuration file. </para>
</entry>
</row>
<row>
<entry>
<para>pkg_nofetch</para>
</entry>
<entry>
<para>Inform the user about required actions if for some reason (such as licensing issues) the sources may not be downloaded by Portage automatically. Use this in conjunction with RESTRICT="fetch". You only should display messages in this function, never call die. </para>
</entry>
</row>
<row>
<entry>
<para>src_unpack</para>
</entry>
<entry>
<para>Use this function to unpack your sources, apply patches, and run auxiliary programs such as the autotools. By default, this function unpacks the packages listed in A. The initial working directory is defined by WORKDIR. </para>
</entry>
</row>
<row>
<entry>
<para>src_compile</para>
</entry>
<entry>
<para>Use this function to configure and build the package. The initial working directory is S. </para>
</entry>
</row>
<row>
<entry>
<para>src_install</para>
</entry>
<entry>
<para>Use this function to install the package to an image in D. If your package uses automake, you can do this simply with emake DESTDIR="${D}" install. Make sure your package installs all its files using D as the root! The initial working directory is S. </para>
</entry>
</row>
<row>
<entry>
<para>src_test</para>
</entry>
<entry>
<para>Executed only when FEATURES="test" is set and RESTRICT="test" is unset, the default of this function executes an available testing function from any Makefiles in the ${S} directory, running either "make test" or "make check" depending on what is provided. It can be overriden to create a custom test setup. </para>
</entry>
</row>
<row>
<entry>
<para>pkg_preinst</para>
</entry>
<entry>
<para>The commands in this function are run just prior to merging a package image into the file system. </para>
</entry>
</row>
<row>
<entry>
<para>pkg_postinst</para>
</entry>
<entry>
<para>The commands in this function are run just following merging a package image into the file system. </para>
</entry>
</row>
<row>
<entry>
<para>pkg_prerm</para>
</entry>
<entry>
<para>The commands in this function are run just prior to unmerging a package image from the file system. </para>
</entry>
</row>
<row>
<entry>
<para>pkg_postrm</para>
</entry>
<entry>
<para>The commands in this function are run just following unmerging a package image from the file system. </para>
</entry>
</row>
<row>
<entry>
<para>pkg_config</para>
</entry>
<entry>
<para>You use this function to setup an initial configuration for the package after it's installed. All paths in this function should be prefixed with ROOT which points to user-specified install root which may not happen to be /. This function is only executed if and when the user runs: emerge --config =${PF}. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Helper Functions</para>
<para>You can also use the following helper functions in your ebuilds. </para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>Function</para>
</entry>
<entry>
<para>Purpose</para>
</entry>
</row>
<row>
<entry>
<para>use</para>
</entry>
<entry>
<para>Check if one or more given USE-flags are defined. If so, the function will return shell true. In either case, nothing is echoed to standard output. For a verbose version, please use usev which will echo the USE flag if it is defined. </para>
</entry>
</row>
<row>
<entry>
<para>has_version</para>
</entry>
<entry>
<para>Returns 1 if the system has the requested version of a certain package. For instance has_version &gt;=sys-libs/glibc-2.3.0. </para>
</entry>
</row>
<row>
<entry>
<para>best_version</para>
</entry>
<entry>
<para>Returns category/package-version of the requested category/package. For instance best_version x11-libs/gtk+extra. </para>
</entry>
</row>
<row>
<entry>
<para>use_with</para>
</entry>
<entry>
<para>This function checks if a use-flag has been defined and returns "--with-foobar" or "--without-foobar" accordingly. If you only use one argument, that argument is both use-flag and with(out)-string. Otherwise the first argument is the use-flag and the second argument the with(out)-string. For instance use_with truetype freetype will echo "--with-freetype" if truetype is in USE. </para>
</entry>
</row>
<row>
<entry>
<para>use_enable</para>
</entry>
<entry>
<para>The same as use_with, but returns "--enable-foobar" or "--disable-foobar" accordingly. </para>
</entry>
</row>
<row>
<entry>
<para>check_KV</para>
</entry>
<entry>
<para>Checks if Portage knows kernel version. If not, display an error and die. If you need the kernel version in your script, use the KV variable which is automatically defined by Portage. On a system running gentoo-sources-2.4.20-r6, KV would have the value "2.4.20". </para>
</entry>
</row>
<row>
<entry>
<para>keepdir</para>
</entry>
<entry>
<para>Creates (if necessary) a .keep file in the given directory so that it isn't auto-cleaned. Never create a .keep file yourself. If portage changes how keepdir works, then creating the file yourself will break the package. </para>
</entry>
</row>
<row>
<entry>
<para>econf</para>
</entry>
<entry>
<para>Issues ./configure with the necessary path-changes (prefix, host, mandir, infodir, datadir, sysconfdir, localstatedir). You can optionally pass extra arguments to ./configure by specifying them when you call econf, and users can set the environment variable EXTRA_ECONF if they need to. Options passed to configure take precedence in the reverse order that they were given. In other words, the first argument passed will always be overridden by the last. </para>
</entry>
</row>
<row>
<entry>
<para>einstall</para>
</entry>
<entry>
<para>Issues make install with the necessary path-changes (prefix, datadir, mandir, infodir, datadir, sysconfdir, localstatedir). Again, you can pass extra arguments to the make command by specifying them when you call einstall. Please note that the preferred way to install a package is via the emake install DESTDIR="${D}" command and not via einstall. This command is only a fall back to override broken make files. </para>
</entry>
</row>
<row>
<entry>
<para>die</para>
</entry>
<entry>
<para>Causes the current process to be aborted. It will notify the user using the given arguments as a reason. Do not neglect to pass a message to die if you have more than one call to it in a single function. It is harder to track down a failure if you're not sure where the package failed. </para>
</entry>
</row>
<row>
<entry>
<para>elog</para>
</entry>
<entry>
<para>Inform the user about something important. The argument given to elog is the message that the user will see. Do not use elog to display banners such as "*************************************". The fact that you're using elog is enough to get the user's attention. The message is also logged using portages ELOG system. </para>
</entry>
</row>
<row>
<entry>
<para>einfo</para>
</entry>
<entry>
<para>Display informative but non-important messages that don't need to be logged. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Helper Functions provided by eutils.eclass</para>
<para>You can use the following helper functions that are provided by the "eutils" eclass in your ebuilds. You must make sure that inherit eutils is present for these functions to work. </para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>Function</para>
</entry>
<entry>
<para>Purpose</para>
</entry>
</row>
<row>
<entry>
<para>epatch</para>
</entry>
<entry>
<para>This function acts as a friendlier replacement to the patch command and epatch works with .bz2, .gz, .zip and plain text patches. You do not need to specify a "-p" option, any options that do need to be explicitly specified should be set in EPATCH_OPTS. The function expects either a file or a directory as an argument - if you specify a directory, all patches in the form of "??_${ARCH}_..." will be applied: for a patch to be applied, it needs to match the running architecture, have "_all_" in the name, or EPATCH_FORCE must be set to "yes". </para>
</entry>
</row>
<row>
<entry>
<para>gen_usr_ldscript</para>
</entry>
<entry>
<para>This function generates linker scripts in /usr/lib for dynamic libraries in /lib. This fixes linking problems when a .so is in /lib while a .a is in /usr/lib. </para>
</entry>
</row>
<row>
<entry>
<para>edos2unix</para>
</entry>
<entry>
<para>This function performs the same action as the dos2unix binary. </para>
</entry>
</row>
<row>
<entry>
<para>egetent</para>
</entry>
<entry>
<para>egetent acts as a wrapper for getent for Linux or nidump for Mac OS X (R). </para>
</entry>
</row>
<row>
<entry>
<para>enewuser</para>
</entry>
<entry>
<para>Creates a new user. This function expects a mandatory argument with the username, and several optional arguments can be specified: $2 contains a UID, pass -1 for the next available ID; $3 contains the shell, pass -1 for the default; $4 contains a home directory with /dev/null being the default, $5 contains any groups to which the user should be added, empty by default and $6 contains any extra options that you may wish to pass to useradd. </para>
</entry>
</row>
<row>
<entry>
<para>enewgroup</para>
</entry>
<entry>
<para>Adds a new group. This function expects a mandatory argument with the group name - an optional second argument makes the group have a specific GID. </para>
</entry>
</row>
<row>
<entry>
<para>make_desktop_entry</para>
</entry>
<entry>
<para>Makes a desktop entry: the first argument contains the path to the binary. Optionally, the second contains a name for the icon - the default is ${PN}; the third can contain a path to the icon relative to /usr/share/pixmaps or a full path - the default is ${PN}.png; the fourth can contain an <ulink url="http://standards.freedesktop.org/menu-spec/latest/apa.html">application category</ulink>, and the fifth argument contains an optional application startup path. </para>
</entry>
</row>
<row>
<entry>
<para>check_license</para>
</entry>
<entry>
<para>Displays a license for the user to accept, if no arguments are specified then the license specified by ${LICENSE} is used. </para>
</entry>
</row>
<row>
<entry>
<para>unpack_pdv</para>
</entry>
<entry>
<para>Unpacks a pdv generated archive, the first argument must contain the file to unpack and the second should contain "off_t" which has to be manually generated: strace -elseek ${file} and for something like "lseek(3, -4, SEEK_END)" you would pass the value "4". </para>
</entry>
</row>
<row>
<entry>
<para>unpack_makeself</para>
</entry>
<entry>
<para>Unpacks a makeself generated archive, requires a file to unpack as the argument. </para>
</entry>
</row>
<row>
<entry>
<para>cdrom_get_cds</para>
</entry>
<entry>
<para>Attempts to get a CD, present with files specified by the arguments present on the system and mounted at ${CDROM_ROOT}. </para>
</entry>
</row>
<row>
<entry>
<para>cdrom_load_next_cd</para>
</entry>
<entry>
<para>Loads the next CD once you are done with the first CD. If the function returns, ${CDROM_ROOT} would point to the next CD. </para>
</entry>
</row>
<row>
<entry>
<para>strip-linguas</para>
</entry>
<entry>
<para>This function makes sure that LINGUAS contains only the languages that a package can support specified by the arguments to the function. If the first argument is -i, then a list of .po files in the specified directories is built and the intersection of the lists is used. If the first argument is -u, then a list of .po files in the specified directories is built and the union of the lists is used. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Helper Functions provided by flag-o-matic.eclass</para>
<para>You can use the following helper functions that are provided by the "flag-o-matic" eclass in your ebuilds. You must make sure that inherit flag-o-matic is present for these functions to work. You should never modify any compiler settings directly, instead please use flag-o-matic to perform any actions such as filtering flags that cause trouble. </para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>Function</para>
</entry>
<entry>
<para>Purpose</para>
</entry>
</row>
<row>
<entry>
<para>filter-flags</para>
</entry>
<entry>
<para>This function removes particular flags from C[XX]FLAGS - only complete flags are matched. </para>
</entry>
</row>
<row>
<entry>
<para>append-flags</para>
</entry>
<entry>
<para>This function adds extra flags to the existing C[XX]FLAGS variables. </para>
</entry>
</row>
<row>
<entry>
<para>replace-flags</para>
</entry>
<entry>
<para>This replaces the flag specified by the first argument with the one in the second argument in the current C[XX]FLAGS. </para>
</entry>
</row>
<row>
<entry>
<para>replace-cpu-flags</para>
</entry>
<entry>
<para>Needs two arguments. Replace a given mtune/mcpu/mtune value with the new one (maybe like this: replace-cpu-flags 'i686' 'i586' will replace -mtune/-march/-mcpu=i686 with -mtune/-march/-mcpu=i586). </para>
</entry>
</row>
<row>
<entry>
<para>strip-flags</para>
</entry>
<entry>
<para>Strips all flags, except those specified in ALLOWED_FLAGS. </para>
</entry>
</row>
<row>
<entry>
<para>strip-unsupported-flags</para>
</entry>
<entry>
<para>Strips C[XX]FLAGS of any flags not supported by the running version of GCC. </para>
</entry>
</row>
<row>
<entry>
<para>get-flag</para>
</entry>
<entry>
<para>Finds a flag and outputs its value. </para>
</entry>
</row>
<row>
<entry>
<para>is-flag</para>
</entry>
<entry>
<para>This returns true if the flag is set in the current C[XX]FLAGS; only complete matches are performed. </para>
</entry>
</row>
<row>
<entry>
<para>append-ldflags</para>
</entry>
<entry>
<para>This function adds extra flags to the existing LDFLAGS variable. </para>
</entry>
</row>
<row>
<entry>
<para>filter-ldflags</para>
</entry>
<entry>
<para>Removes the specified flags from LDFLAGS, only complete flags are matched. </para>
</entry>
</row>
<row>
<entry>
<para>fstack-flags</para>
</entry>
<entry>
<para>Appends -fno-stack-protector which suppresses -fstack-protector and -fstack-protector-all. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Helper Functions provided by toolchain-funcs.eclass</para>
<para>You can use the following helper functions that are provided by the "toolchain-funcs" eclass in your ebuilds. You must make sure that inherit toolchain-funcs is present for these functions to work. You should never explicitly specify any compiler or binutils settings directly, instead please use toolchain-funcs to specify compilers and binutils. </para>
<para>The purpose of using the below functions is to support cross-compiling and the icc compiler. These should be used whenever a package explicitly uses gcc, g++, ld, ranlib or any of the below tools. In general packages that use autoconfiguration tools detect cross compiling automatically and do not need the following functions. </para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>Function</para>
</entry>
<entry>
<para>Purpose</para>
</entry>
</row>
<row>
<entry>
<para>tc-getAR </para>
</entry>
<entry>
<para>Returns the name of the archiver </para>
</entry>
</row>
<row>
<entry>
<para>tc-getAS </para>
</entry>
<entry>
<para>Returns the name of the assembler</para>
</entry>
</row>
<row>
<entry>
<para>tc-getCC </para>
</entry>
<entry>
<para>Returns the name of the C compiler</para>
</entry>
</row>
<row>
<entry>
<para>tc-getCXX </para>
</entry>
<entry>
<para>Returns the name of the C++ compiler</para>
</entry>
</row>
<row>
<entry>
<para>tc-getLD </para>
</entry>
<entry>
<para>Returns the name of the linker</para>
</entry>
</row>
<row>
<entry>
<para>tc-getNM </para>
</entry>
<entry>
<para>Returns the name of the symbol/object inspection tool</para>
</entry>
</row>
<row>
<entry>
<para>tc-getRANLIB </para>
</entry>
<entry>
<para>Returns the name of the archiver indexer</para>
</entry>
</row>
<row>
<entry>
<para>tc-getF77 </para>
</entry>
<entry>
<para>Returns the name of the fortran compiler</para>
</entry>
</row>
<row>
<entry>
<para>tc-getGCJ </para>
</entry>
<entry>
<para>Returns the name of the java compiler</para>
</entry>
</row>
<row>
<entry>
<para>tc-getBUILD_CC </para>
</entry>
<entry>
<para>Returns the name of the C compiler for build</para>
</entry>
</row>
<row>
<entry>
<para>tc-is-cross-compiler </para>
</entry>
<entry>
<para>A simple way to see if we're using a cross-compiler</para>
</entry>
</row>
<row>
<entry>
<para>gcc-fullversion </para>
</entry>
<entry>
<para>Returns the version as by $($CC -dumpversion)</para>
</entry>
</row>
<row>
<entry>
<para>gcc-version </para>
</entry>
<entry>
<para>Returns the version, but only the &lt;major&gt;.&lt;minor&gt;</para>
</entry>
</row>
<row>
<entry>
<para>gcc-major-version </para>
</entry>
<entry>
<para>Returns the Major version</para>
</entry>
</row>
<row>
<entry>
<para>gcc-minor-version </para>
</entry>
<entry>
<para>Returns the Minor version</para>
</entry>
</row>
<row>
<entry>
<para>gcc-micro-version </para>
</entry>
<entry>
<para>Returns the Micro version</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Rules for writing an ebuild file</para>
<para>Since ebuild files are really just shell scripts, you should use your editor's shell-script mode for editing them. You should use proper indentation, using only tab characters -- no spaces. Make sure you set up your editor to put tab stops at 4 spaces. Always make sure you use braces around your environment variables; e.g. ${P} instead of just $P. </para>
<para>Long lines are wrapped with ' \', thus: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.2: Wrapping lines in ebuilds</para>
</entry>
</row>
<row>
<entry>
<para>./configure \</para>
<para>--prefix=/usr || die "configure failed"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>For further details, refer to skel.ebuild (usually residing in /usr/portage). </para>
<para>If you use Vim for ebuild/eclass editing, the default Gentoo vimrc file, /etc/vim/vimrc, already ensures that correct indentation and filetype settings are used for ebuild and eclass files. For better results, including special syntax highlighting for ebuild keywords, emerge app-vim/gentoo-syntax. </para>
<para>On non-Gentoo systems, you can obtain similar results by using the following lines in your vimrc, or better yet by installing the gentoo-syntax scripts which can be downloaded from Gentoo mirrors. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.3: Configuring vimrc for ebuild-editing</para>
</entry>
</row>
<row>
<entry>
<para>au BufRead,BufNewFile *.e{build,class} let is_bash=1|setfiletype sh</para>
<para>au BufRead,BufNewFile *.e{build,class} set ts=4 sw=4 noexpandtab</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>If you're using Emacs, you should emerge app-emacs/gentoo-syntax (for GNU Emacs) or app-xemacs/gentoo-syntax (for XEmacs). These packages provide Emacs major modes for automatic indentation and syntax highlighting of ebuilds and other Gentoo specific file types. </para>
<para>If you're using nano, then you're in luck! Just edit /etc/nanorc and uncomment the section referring to ebuild's. </para>
<para>USE Variables</para>
<para>The purpose of USE variables is to allow you to configure Portage to globally and automatically enable or disable certain optional build-time features. Here's an example. Let's say you're a GNOME fan, and you'd like any ebuild that has the option of compiling-in optional GNOME support to do so. In this case, you'd add gnome to the USE variable in /etc/make.conf, and then Portage will automatically add optional GNOME functionality to packages if it is available. Likewise, if you don't want optional GNOME features to be added to your ebuilds if they are available, simply edit /etc/make.conf and make sure that gnome is not set in the USE variable. Gentoo Linux has an almost overwhelming number of USE options, allowing you to have your system configured exactly the way you want it. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Note: If you unset a USE variable (for example, removing gnome from USE), this will only instruct Portage to disable optional build-time support for GNOME. However, if you emerge an ebuild that requires GNOME, the package will obviously have GNOME support enabled, as you would expect. This also means that GNOME will be automatically installed (as a dependency) if it hasn't been already. That's why it's always a good idea to do an emerge --pretend before doing the "real" emerge; that way, you'll always know exactly what you're going to get! </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>In your own ebuilds, you can check whether a USE variable is set by using the use &lt;variable&gt; command. You would normally use this command as follows: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.4: Finding out if a USE-flag is set</para>
</entry>
</row>
<row>
<entry>
<para>if use X; then</para>
<para>  # Commands specific to X...</para>
<para>fi</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>USE variables can also be used to set dependencies. For example, you may only want to require a package if a certain USE variable is set. This is done by using the syntax flag? ( mycat/mypackage ) in the DEPEND variable for your ebuild. In this example, mycat/mypackage will only be required if flag is present in USE. It is also possible to specify what dependency should be used if some USE flag is set, and what dependency to use if it is not set: flag? ( mycat/mypackage) and !flag? ( othercat/otherpackage ). In this case, if flag is not set, othercat/otherpackage is used instead of mycat/mypackage. Make sure that your ebuilds use this syntax and not Bash IFS. Bash conditionals interfere with Portage's dependency caching, and the use of them will break your ebuild. </para>
<para>Here's an important tip about how to use USE. Most of the time, a package will have a ./configure script used to perform configuration steps. Generally, if your ebuild uses ./configure, any optional build-time functionality will be enabled or disabled by passing the appropriate arguments to the ./configure command. Here's the best way to handle this: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.5: Conditionals based on USE-settings</para>
</entry>
</row>
<row>
<entry>
<para>DEPEND="X? ( &gt;=x11-base/xfree-4.3 )</para>
<para>mysql? ( &gt;=dev-db/mysql-3.23.49 )</para>
<para>apache2? ( &gt;=net-www/apache-2 )</para>
<para>!apache2? ( =net-www/apache-1* )"</para>
<para/>
<para>src_compile() {</para>
<para>  econf \</para>
<para>    $(use_enable X x11) \</para>
<para>    $(use_enable mysql) \</para>
<para>    || die "Error: econf failed!"</para>
<para>  emake || die "Error: emake failed!"</para>
<para>}</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>This approach has a very nice result. We don't have to worry about what the default setting is for mysql or X (enable/disabled), we explicitly tell econf what we want it to do based upon the USE variable. Not to mention it's quite clean in terms of readability :). </para>
<para>Occasionally, ebuilds will have conflicting optional features. Checking for these conflicts and returning an error is not a viable solution. Instead, you must favor one of the features over the others. As to which, consult upstream (what they use as typical default), or consider which option provides more common functionality, or just flip a coin. One example comes from the msmtp ebuilds. The package can use either SSL with GnuTLS, SSL with OpenSSL, or no SSL at all. Because GnuTLS has a lot more features compared to OpenSSL, it is favoured: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 2.6: Handling conflicting features</para>
</entry>
</row>
<row>
<entry>
<para>src_compile() {</para>
<para>    local myconf</para>
<para/>
<para>    if use gnutls ; then</para>
<para>        myconf="${myconf} --enable-ssl --with-ssl=gnutls"</para>
<para>    elif use ssl ; then</para>
<para>        myconf="${myconf} --enable-ssl --with-ssl=openssl"</para>
<para>    else</para>
<para>        myconf="${myconf} --disable-ssl"</para>
<para>    fi</para>
<para/>
<para>    econf \</para>
<para>        # Other stuff</para>
<para>        ${myconf} \</para>
<para>        || die "configure failed"</para>
<para/>
<para>    emake || die "make failed"</para>
<para>}</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>To view a continuously updated table of USE variables, please go <ulink url="http://www.gentoo.org/dyn/use-index.xml">here</ulink>. </para></sect2><sect2><title>1.c. File system Locations</title>
<para>Introduction to the FHS</para>
<para>The file system layout standards used in Gentoo Linux closely follow the FHS, short for File system Hierarchy Standard. A simplified description of the standard is given here; for a complete specification go to <ulink url="http://www.pathname.com/fhs/">http://www.pathname.com/fhs/</ulink>. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Note: The /opt hierarchy is addressed in section 3.12 of the FHS. Section 4.4 deals with the /usr/X11R6 directory. KDE and GNOME are not specifically addressed, and are in fact not even mentioned in the current version of the FHS. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>How to fit your packages into the file system</para>
<para>Usually, if the package uses autoconf and automake, the default installation destinations are mostly correct, with a few exceptions: </para>
<orderedlist>
<listitem>
<para>If you're installing a program into /bin, /sbin, /usr/bin, or /usr/sbin, then the program's corresponding man page should be installed into the /usr/share/man tree. This can often be accomplished by specifying a ./configure --mandir=/usr/share/man in the ebuild. </para>
</listitem>
<listitem>
<para>GNU info files should always be installed to /usr/share/info, even if the info files are about X11, GNOME or KDE-specific programs or tools. Make a note: /usr/share/info is the only official location for GNU info files. Since many ./configure scripts default to installing GNU info files in /usr/info, it's often necessary to call ./configure with the --infodir=/usr/share/info argument. </para>
</listitem>
<listitem>
<para>Documentation files are installed in /usr/share/doc, into a subdirectory reflecting the name, version, and revision of the particular program. This applies to all programs: GNOME, KDE, X11 and console alike. However, some programs may install additional documentation and support files into a /usr/share hierarchy for their own purposes. </para>
</listitem>
<listitem>
<para>X11-specific programs and libraries should always be installed into /usr, not directly into /usr/X11R6. We reserve the /usr/X11R6 hierarchy for the X Window System, Version 11 Release 6 itself. This is perhaps a more to-the-letter interpretation of the FHS than some other distributions have made. </para>
</listitem>
<listitem>
<para>GNOME and KDE programs, similarly, should always be installed into /usr. </para>
</listitem>
</orderedlist>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Important: Some distributions choose to install GNOME and KDE into /opt. There exists no standard for these desktop environments in terms of where to actually install their files. In the interests of simplicity and consistency, we elect to install all KDE and GNOME packages into the /usr hierarchy. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>In general, you should have ebuilds install their files into the /usr tree. Some programs can be compiled and linked with or without GNOME, KDE, and X11 libraries, which can cause confusion. Our solution is to install everything into /usr which avoids ambiguity and needless complexity for ebuild authors. The location in which to install a program's files should not depend on the presence or absence of specific USE variables. Therefore, the ebuilds in the portage tree almost always install into the /usr hierarchy exclusively. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Note: The /opt directory is reserved in Gentoo Linux for binary-only packages. Examples include mozilla-bin, acroread, netscape and realplayer. Packages that get installed here will usually require a /etc/env.d/foo stub file. This is so that paths and additional variables can be included into the environment. For more information on /etc/env.d, please visit <ulink url="http://www.gentoo.org/doc/en/handbook/handbook-x86.xml?part=2&amp;chap=5">this</ulink> document. </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>1.d. The Portage scripts and utilities</title>
<para>Public scripts</para>
<para>These are scripts used by the system-administrator to install and remove packages, and maintain the package database. </para>
<para>ebuild is the main engine of the Portage system; it performs all major tasks such as unpacking, compiling, installing, merging, and unmerging packages. It is called using the command: ebuild path/to/package.ebuild command. The commands available are: </para>
<informaltable frame="all">
<tgroup cols="3"><tbody>
<row>
<entry>
<para>Command</para>
</entry>
<entry>
<para>Description</para>
</entry>
<entry>
<para>Related ebuild Function</para>
</entry>
</row>
<row>
<entry>
<para>setup*</para>
</entry>
<entry>
<para>Performs any miscellaneous commands required before the ebuild can proceed </para>
</entry>
<entry>
<para>pkg_setup</para>
</entry>
</row>
<row>
<entry>
<para>depend</para>
</entry>
<entry>
<para>Displays the dependencies required to build the package</para>
</entry>
<entry>
<para>N/A</para>
</entry>
</row>
<row>
<entry>
<para>merge*</para>
</entry>
<entry>
<para>Unpacks, compiles, installs, and merges the package into your file system </para>
</entry>
<entry>
<para>N/A</para>
</entry>
</row>
<row>
<entry>
<para>qmerge*</para>
</entry>
<entry>
<para>Merges the package into your file system, assuming that the unpack, compile, and install stages have already been executed </para>
</entry>
<entry>
<para>N/A</para>
</entry>
</row>
<row>
<entry>
<para>unpack*</para>
</entry>
<entry>
<para>Unpacks the source tarballs into the work directory </para>
</entry>
<entry>
<para>src_unpack</para>
</entry>
</row>
<row>
<entry>
<para>compile*</para>
</entry>
<entry>
<para>Compiles the package</para>
</entry>
<entry>
<para>src_compile</para>
</entry>
</row>
<row>
<entry>
<para>rpm</para>
</entry>
<entry>
<para>Creates an RPM from the package</para>
</entry>
<entry>
<para>N/A</para>
</entry>
</row>
<row>
<entry>
<para>package</para>
</entry>
<entry>
<para>Creates a Gentoo tbz2 package</para>
</entry>
<entry>
<para>N/A</para>
</entry>
</row>
<row>
<entry>
<para>prerm*</para>
</entry>
<entry>
<para>Executes the pre-removal stage of the package</para>
</entry>
<entry>
<para>pkg_prerm</para>
</entry>
</row>
<row>
<entry>
<para>postrm*</para>
</entry>
<entry>
<para>Executes the post-removal stage of the package</para>
</entry>
<entry>
<para>pkg_postrm</para>
</entry>
</row>
<row>
<entry>
<para>preinst*</para>
</entry>
<entry>
<para>Executes the pre-installation stage of the package</para>
</entry>
<entry>
<para>pkg_preinst</para>
</entry>
</row>
<row>
<entry>
<para>postinst*</para>
</entry>
<entry>
<para>Executes the post-installation stage of the package</para>
</entry>
<entry>
<para>pkg_postinst</para>
</entry>
</row>
<row>
<entry>
<para>config</para>
</entry>
<entry>
<para>Sets up a default configuration once the package is merged</para>
</entry>
<entry>
<para>pkg_config</para>
</entry>
</row>
<row>
<entry>
<para>touch*</para>
</entry>
<entry>
<para>Updates the mtimes for each source archive in the package</para>
</entry>
<entry>
<para>N/A</para>
</entry>
</row>
<row>
<entry>
<para>clean*</para>
</entry>
<entry>
<para>Cleans the work directory for the package</para>
</entry>
<entry>
<para>N/A</para>
</entry>
</row>
<row>
<entry>
<para>fetch*</para>
</entry>
<entry>
<para>Fetches the package source tarballs</para>
</entry>
<entry>
<para>N/A</para>
</entry>
</row>
<row>
<entry>
<para>digest*</para>
</entry>
<entry>
<para>Creates a digest file for the package</para>
</entry>
<entry>
<para>N/A</para>
</entry>
</row>
<row>
<entry>
<para>test*</para>
</entry>
<entry>
<para>Runs the self-test routine for the package</para>
</entry>
<entry>
<para>src_test</para>
</entry>
</row>
<row>
<entry>
<para>install*</para>
</entry>
<entry>
<para>Installs the package into the image directory</para>
</entry>
<entry>
<para>src_install</para>
</entry>
</row>
<row>
<entry>
<para>unmerge</para>
</entry>
<entry>
<para>Unmerges the package from your file system</para>
</entry>
<entry>
<para>N/A</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Note: Commands with an asterisk (*) are normally only used by the developer. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>emerge recursively merges a package and all of its dependencies into your file system. This command has many options, try emerge --help for a list of them. </para>
<para>env-update updates the configuration files (including, but not limited to /etc/ld.so.conf and /etc/profile.env) to include changes made by installed packages. </para>
<para>Private Scripts and Commands</para>
<para>These are scripts you can use in your ebuild files to perform common tasks. </para>
<para>For you down and dirty people, look at the scripts themselves in /usr/lib/portage/bin. </para>
<informaltable frame="all">
<tgroup cols="4"><tbody>
<row>
<entry>
<para>Command</para>
</entry>
<entry>
<para>Default Value</para>
</entry>
<entry>
<para>Description</para>
</entry>
<entry>
<para>Example</para>
</entry>
</row>
<row>
<entry>
<para>diropts</para>
</entry>
<entry>
<para>-m0755</para>
</entry>
<entry>
<para>Sets the options used when running dodir </para>
</entry>
<entry>
<para>diropts -m0750</para>
</entry>
</row>
<row>
<entry>
<para>dobin</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Installs the specified binaries into DESTTREE/bin </para>
</entry>
<entry>
<para>dobin wmacpi</para>
</entry>
</row>
<row>
<entry>
<para>docinto</para>
</entry>
<entry>
<para>""</para>
</entry>
<entry>
<para>Sets the relative subdir used by dodoc </para>
</entry>
<entry>
<para>docinto examples</para>
</entry>
</row>
<row>
<entry>
<para>dodir</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Creates a directory, handling ${D} transparently</para>
</entry>
<entry>
<para>dodir /usr/lib/newpackage</para>
</entry>
</row>
<row>
<entry>
<para>dodoc</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Installs the specified files into the package's documentation directory (/usr/share/doc/${PF}/DOCDESTTREE) (see docinto) </para>
</entry>
<entry>
<para>dodoc README *.txt</para>
</entry>
</row>
<row>
<entry>
<para>doexe</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Installs the specified files with mode EXEOPTIONS (see exeopts) into PATH defined by EXEINTO (see exeinto). </para>
</entry>
<entry>
<para>doexe ${FILESDIR}/quake3</para>
</entry>
</row>
<row>
<entry>
<para>dohard</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Creates a hard link, handling ${D} transparently</para>
</entry>
<entry>
<para>dohard ls /bin/dir</para>
</entry>
</row>
<row>
<entry>
<para>dohtml</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Installs the specified files and directories into /usr/share/doc/${PF}/html </para>
</entry>
<entry>
<para>dohtml -r doc/html/*</para>
</entry>
</row>
<row>
<entry>
<para>doinfo</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Installs the specified files into /usr/share/info, then compresses them with gzip </para>
</entry>
<entry>
<para>doinfo doc/*.info</para>
</entry>
</row>
<row>
<entry>
<para>doins</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Installs the specified files with mode INSOPTIONS (see insopts) into INSDESTTREE (see insinto) </para>
</entry>
<entry>
<para>doins *.png icon.xpm</para>
</entry>
</row>
<row>
<entry>
<para>dolib</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Installs the specified libraries into DESTTREE/lib with mode 0644 </para>
</entry>
<entry>
<para>dolib *.a *.so</para>
</entry>
</row>
<row>
<entry>
<para>dolib.a</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Installs the specified libraries into DESTTREE/lib with mode 0644 </para>
</entry>
<entry>
<para>dolib.a *.a</para>
</entry>
</row>
<row>
<entry>
<para>dolib.so</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Installs the specified libraries into DESTTREE/lib with mode 0755 </para>
</entry>
<entry>
<para>dolib.so *.so</para>
</entry>
</row>
<row>
<entry>
<para>doman</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Installs the specified files into /usr/share/man/manX, according to the suffix of the file (file.1 will go into man1) </para>
</entry>
<entry>
<para>doman *.1 *.5</para>
</entry>
</row>
<row>
<entry>
<para>dosbin</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Installs the files into DESTTREE/sbin, making sure they are executable </para>
</entry>
<entry>
<para>dosbin ksymoops</para>
</entry>
</row>
<row>
<entry>
<para>dosym</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Creates a symlink, handles ${D} transparently</para>
</entry>
<entry>
<para>dosym gzip /bin/zcat</para>
</entry>
</row>
<row>
<entry>
<para>emake</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Runs make with MAKEOPTS. Some packages cannot be made in parallel; use emake -j1 instead. If you need to pass any extra arguments to make, simply append them onto the emake command. Users can set the EXTRA_EMAKE environment variable to pass extra flags to emake. </para>
</entry>
<entry>
<para>emake</para>
</entry>
</row>
<row>
<entry>
<para>exeinto</para>
</entry>
<entry>
<para>/</para>
</entry>
<entry>
<para>Sets the root (EXEDESTTREE) for the doexe command</para>
</entry>
<entry>
<para>exeinto /usr/lib/${PN}</para>
</entry>
</row>
<row>
<entry>
<para>exeopts</para>
</entry>
<entry>
<para>-m0755</para>
</entry>
<entry>
<para>Sets the options used when running doexe </para>
</entry>
<entry>
<para>exeopts -m1770</para>
</entry>
</row>
<row>
<entry>
<para>fowners</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Applies the specified ownership to the specified file via the chown command, handles ${D} transparently </para>
</entry>
<entry>
<para>fowners root:root /sbin/functions.sh</para>
</entry>
</row>
<row>
<entry>
<para>fperms</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Applies the specified permissions to the specified file via the chmod command, handles ${D} transparently </para>
</entry>
<entry>
<para>fperms 700 /var/consoles</para>
</entry>
</row>
<row>
<entry>
<para>insinto</para>
</entry>
<entry>
<para>/usr</para>
</entry>
<entry>
<para>Sets the root (INSDESTTREE) for the doins command</para>
</entry>
<entry>
<para>insinto /usr/include</para>
</entry>
</row>
<row>
<entry>
<para>insopts</para>
</entry>
<entry>
<para>-m0644</para>
</entry>
<entry>
<para>Sets the options used when running doins </para>
</entry>
<entry>
<para>insopts -m0444</para>
</entry>
</row>
<row>
<entry>
<para>into</para>
</entry>
<entry>
<para>/usr</para>
</entry>
<entry>
<para>Sets the target prefix (DESTTREE) for all the 'do' commands (like dobin, dolib, dolib.a, dolib.so, domo, dosbin) </para>
</entry>
<entry>
<para>into /</para>
</entry>
</row>
<row>
<entry>
<para>libopts</para>
</entry>
<entry>
<para>-m0644</para>
</entry>
<entry>
<para>Sets the options used when running dolib </para>
</entry>
<entry>
<para>libopts -m0555</para>
</entry>
</row>
<row>
<entry>
<para>newbin</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Wrapper around dobin which installs the specified binary transparently renaming to the second argument </para>
</entry>
<entry>
<para>newbin ${FILESDIR}/vmware.sh vmware</para>
</entry>
</row>
<row>
<entry>
<para>newdoc</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Wrapper around dodoc which installs the specified file transparently renaming to the second argument </para>
</entry>
<entry>
<para>newdoc README README.opengl</para>
</entry>
</row>
<row>
<entry>
<para>newexe</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Wrapper around doexe which installs the specified file transparently renaming to the second argument </para>
</entry>
<entry>
<para>newexe ${FILESDIR}/xinetd.rc xinetd</para>
</entry>
</row>
<row>
<entry>
<para>newins</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Wrapper around doins which installs the specified file transparently renaming to the second argument </para>
</entry>
<entry>
<para>newins ntp.conf.example ntp.conf</para>
</entry>
</row>
<row>
<entry>
<para>newman</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Wrapper around doman which installs the specified file transparently renaming to the second argument </para>
</entry>
<entry>
<para>newman xboing.man xboing.6</para>
</entry>
</row>
<row>
<entry>
<para>newsbin</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Wrapper around dosbin which installs the specified file transparently renaming to the second argument </para>
</entry>
<entry>
<para>newsbin strings strings-static</para>
</entry>
</row>
<row>
<entry>
<para>prepall</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Runs prepallman, prepallinfo and prepallstrip. Also ensures all libraries in /opt/*/lib, /lib, /usr/lib and /usr/X11R6/lib are executable. also moves any stray aclocal macros into /usr/share/aclocal </para>
</entry>
<entry>
<para>prepall</para>
</entry>
</row>
<row>
<entry>
<para>prepalldocs</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Recursively gzips all doc files in /usr/share/doc, transparently fixing up any symlink paths </para>
</entry>
<entry>
<para>prepalldocs</para>
</entry>
</row>
<row>
<entry>
<para>prepallinfo</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Recursively gzips all info files in /usr/share/info </para>
</entry>
<entry>
<para>prepallinfo</para>
</entry>
</row>
<row>
<entry>
<para>prepallman</para>
</entry>
<entry>
<para>N/A</para>
</entry>
<entry>
<para>Recursively gzips all man pages in /opt/*/man/*, /usr/share/man/*, /usr/local/man/*, /usr/X11R6/share/man/* and transparently fixes up any symlink paths </para>
</entry>
<entry>
<para>prepallman</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect2><sect2><title>1.e. Package Dependencies</title>
<para>Why dependencies are important</para>
<para>Portage is more than just a convenience script that gives you a unified way to build any one project (program, library) from source. It will also fetch and install any necessary dependencies if you take care to specify these in your ebuild. </para>
<para>In the official ebuilds, all dependencies have already been specified, so when you issue emerge net-www/mozilla/mozilla-1.0, Portage will insure that all libraries necessary for Mozilla to build and run are properly installed before Mozilla itself is built. </para>
<para>Portage even distinguishes between build-time dependencies and run-time dependencies. (Caveat: Currently, Portage installs all build-time and run-time dependencies and leaves it at that. At a later stage, it will be possible to trim your installation so that only the run-time dependencies are left installed). </para>
<para>How to Specify Dependencies in Your ebuild Files (a.k.a. DEPEND Atoms)</para>
<para>The DEPEND variable inside your foo-x.y.z.ebuild tells Portage about which packages are needed to build foo. The RDEPEND variable specifies which packages are needed for foo to run. RDEPEND should be set explicitly even if it's the same as DEPEND because in the future it defaulting to DEPEND is planned to be removed from Portage. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 5.1: Depend example</para>
</entry>
</row>
<row>
<entry>
<para>DEPEND="virtual/opengl</para>
<para>        dev-libs/libxml2"</para>
<para>RDEPEND="${DEPEND}"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>This tells Portage that to build foo-x.y.z, the packages virtual/opengl (more on virtuals in a bit) and dev-lib/libxml2 are needed. It does not say anything about which version of opengl or libxml2 that are needed, which means "anything goes". </para>
<para>The "anything goes" is of course a bit scary, and will not work in the general case. But for libraries, which strive very hard to be 100% binary compatible all the time, it actually works. For other libraries, we can of course specify version dependencies. </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 5.2: Version example</para>
</entry>
</row>
<row>
<entry>
<para>&gt;=sys-apps/bar-1.2</para>
<para>=sys-apps/baz-1.0</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>&gt;= and = do what you would expect; sys-apps/bar version 1.2 or newer is okay (this means that sys-apps/bar-2.0 is okay), while sys-apps/baz version 1.0 is the only version that is accepted. For more information on the version schema of packages, see the section above on <ulink url="http://www.gentoo.org/proj/en/devrel/handbook/handbook.xml?part=2&amp;chap=1#doc_chap2_sect2">Naming ebuild Files</ulink>. </para>
<para>Other methods of specifying version dependencies are as follows: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code Listing 5.3: Specifying version dependencies</para>
</entry>
</row>
<row>
<entry>
<para>~sys-apps/qux-1.0</para>
<para>=sys-apps/foo-1.2*</para>
<para>!sys-libs/gdbm</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>~sys-apps/qux-1.0 will select the newest portage revision of qux-1.0. </para>
<para>=sys-apps/foo-1.2* will select the newest member of the 1.2 series, but will ignore 1.3 and later/earlier series. That is, foo-1.2.3 and foo-1.2.0 are both valid, while foo-1.3.3, foo-1.3.0, and foo-1.1.0 are not. </para>
<para>!sys-libs/gdbm will prevent this package from being emerged while gdbm is already emerged. </para>
<para>Important Notes</para>
<para>There are many things that go wrong with the DEPEND and RDEPEND variables. Here are some important points to follow when you write the dependencies. </para>
<orderedlist>
<listitem>
<para>Always include the CATEGORY.For example, use &gt;=x11-libs/gtk+-2 and not &gt;=gtk+-2. </para>
</listitem>
<listitem>
<para>Do not put an asterisk (*) for &gt;= dependencies.For example, it should be &gt;=x11-libs/gtk+-2 rather than &gt;=x11-libs/gtk+-2*. </para>
</listitem>
<listitem>
<para>Never depend on a meta-package.So don't depend on gnome-base/gnome, always depend on the specific libraries like libgnome. </para>
</listitem>
<listitem>
<para>One dependency per line.Don't put multiple dependencies on the same line. It makes it ugly to read and hard to follow. </para>
</listitem>
<listitem>
<para>GTK: Always use =x11-libs/gtk+-1.2* for GTK+1 apps. </para>
</listitem>
</orderedlist>
<para>Additionally, it is important to ensure that all the dependencies are complete for your package: </para>
<orderedlist>
<listitem>
<para>Look in configure.in or configure.acLook for checks for packages in here. Things to look out for are pkg-config checks or AM_* functions that check for a specific version. </para>
</listitem>
<listitem>
<para>Look at included .spec filesA good indication of dependencies is to look at the included .spec files for relevant deps. However, do not trust them to be the definitive complete list of dependencies. </para>
</listitem>
<listitem>
<para>Look at the application/library websiteCheck the application website for possible dependencies that they suggest are needed. </para>
</listitem>
<listitem>
<para>Read the README and INSTALL for the packageThey usually also contain useful information about building and installing packages. </para>
</listitem>
<listitem>
<para>Remember non-binary dependencies such as pkg-config, doc generation programs, etc.Usually the build process requires some dependencies such as intltool, libtool, pkg-config, doxygen, scrollkeeper, gtk-doc, etc. Make sure those are clearly stated. </para>
</listitem>
</orderedlist>
<para>For all the latest details about these DEPEND Atoms, please see the section 5 manpage on ebuilds: man 5 ebuild. </para></sect2><sect2><title>1.f. Testing and deploying</title>
<para>ChangeLog</para>
<para>Whenever you update (or write a new) an ebuild, you must also update its (or create a new) ChangeLog. The skel.ChangeLog contains a sample ChangeLog that you can use as a basis. </para>
<para>The purpose of the ChangeLog is to document what is being done, why it is being done, and by whom. This allows both developers and users to trace the changes made in an easy way. </para>
<para>The ChangeLog is primarily targeted at users, so be sure to keep your writing short, to the point, and avoid getting verbose about the internal technical details. </para>
<para>Storing your own ebuilds locally</para>
<para>In order to be able to test your ebuilds and let Portage know about them, you must place those in a known directory. Portage will use the PORTDIR_OVERLAY variable which you can define in /etc/make.conf. You should set this variable to your directory (e.g. /usr/local/portage). </para>
<para>In that directory, you must use the same structure (and categories) as in /usr/portage. </para>
<para>Using this PORTDIR_OVERLAY, your ebuilds remain on your system, even after an emerge sync, and they are still known to Portage. </para>
<para>Testing the package</para>
<para>Have a think about how you will test whether this package works. Sometimes the developers have already included a make test or make check routine that will test the basic functionality of the package. If so, then running env FEATURES=test ebuild foo-x.y.z.ebuild test will execute it. If it is broken try to fix it so that it works (and submit the patch to the upstream developers). </para>
<para>If this is not the case consider adding a src_test routine to your ebuild. This is executed before the src_install routine and can be very helpful for testing the program works across various architectures. The architecture developers will appreciate if you add a routine here so that they do not require knowledge of the package's functionality. </para>
<para>Please keep in mind the general requirements of an ebuild here. The src_test routine must not be interactive. If the test routine depends on other packages use the test USE flag to specify the optional compile time DEPENDancies. Also, please note that src_test routines are not recommended for graphical X applications as the user running portage often cannot run them successfully. </para>
<para>Useful testing tools</para>
<para>We have a few useful tools to help you with writing and maintaining your ebuilds. </para>
<informaltable frame="all">
<tgroup cols="3"><tbody>
<row>
<entry>
<para>Tool</para>
</entry>
<entry>
<para>Package</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
<row>
<entry>
<para>repoman</para>
</entry>
<entry>
<para>sys-apps/portage</para>
</entry>
<entry>
<para>Developer-only tool to assist with the CVS check in procedure. It does a lot of common QA and tries to make sure that files added to cvs will not break the portage tree. </para>
</entry>
</row>
<row>
<entry>
<para>ccache</para>
</entry>
<entry>
<para>dev-util/ccache</para>
</entry>
<entry>
<para>Tool that keeps pre-processed files so that recompilation gets done much faster. Be sure to add ccache to the FEATURES variable in /etc/make.conf! </para>
</entry>
</row>
<row>
<entry>
<para>sandboxshell</para>
</entry>
<entry>
<para>app-shells/sandboxshell</para>
</entry>
<entry>
<para>Launch a shell that creates a sandbox environment. Useful for entering the same environment that portage builds packages inside of and debugging things by hand. </para>
</entry>
</row>
<row>
<entry>
<para>echangelog</para>
</entry>
<entry>
<para>app-portage/gentoolkit-dev</para>
</entry>
<entry>
<para>Can create a new ChangeLog or add an entry to an existing one.</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/></sect2></sect1><sect1><title>Использование rpm-пакетов в Gentoo</title>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/en/java.xml">http://ylsoftware.com/?action=news&amp;na=viewfull&amp;news=402</ulink>            </para>
<para>Автор: <ulink url="mailto:bulvinkl@gmail.com?subject=По%20поводу%20Вашей%20статьи%20об%20использовании%20rpm-пакетов%20в%20Gentoo">Калинников В.В. a.k.a. MooSe</ulink>
</para>
<para>С версии: 1.5.</para>
<para>Дата оригинала:  15.02.2008</para>
<para/>
<para>Эта статья написана для <ulink url="http://code.google.com/p/gentoo-doc/">сборника статей о Gentoo</ulink> по просьбе одного из его авторов - Евгения Батогова a.k.a JohnBat26. Здесь я постараюсь описать возможные способы установки rpm-пакетов в Gentoo. Сразу хочу отметить, что в любом случае лучше всего ставить программы из исходных текстов, используя команду emerge. Использовать же rpm нужно только в самом крайнем случае, когда архив с исходными текстами не доступен (например для коммерческих программ).</para>
<para>Итак. Есть два способа установить rpm-пакет:</para>
<orderedlist>
<listitem>
<para>Установить в систему менеджер пакетов rpm и пользоваться им. </para>
</listitem>
<listitem>
<para>Написать ebuild для распаковки и установки rpm-пакета. </para>
</listitem>
</orderedlist>
<para>Первый способ проще, но пакет придётся устанавливать с ключом --nodeps и есть большой риск сломать систему или просто получить не рабочий пакет. Второй способ сложнее. Он тоже не решает всех проблем первого, но по крайней даёт возможность избежать поломки системы.</para>
<para>Будем полагать что мы хотим установить в систему пакет prog-0.1.i386.rpm. Независимо от того, какой способ выбран понадобиться утилита rpm:</para>
<para/>
<para>emerge rpm</para>
<para/>
<para>Теперь рассмотрим первый способ установки. Для начала полезно просмотреть зависимости пакета:</para>
<para/>
<para>rpm -qp --qf "[%{REQUIRENAME} %{REQUIREFLAGS:depflags} %{REQUIREVERSION}\n]" prog-0.1.i386.rpm</para>
<para/>
<para>Получаем примерно вот такой список:</para>
<para>/bin/bash</para>
<para>/bin/sh</para>
<para>/bin/sh</para>
<para>/bin/sh</para>
<para>/bin/sh</para>
<para>libX11.so.6</para>
<para>libXext.so.6</para>
<para>libXt.so.6</para>
<para>libc.so.6</para>
<para>libc.so.6(GCC_3.0)</para>
<para>libc.so.6(GLIBC_2.0)</para>
<para>libc.so.6(GLIBC_2.1)</para>
<para>libc.so.6(GLIBC_2.1.2)</para>
<para>libc.so.6(GLIBC_2.1.3)</para>
<para>libc.so.6(GLIBC_2.2)</para>
<para>libc.so.6(GLIBC_2.3)</para>
<para>libdl.so.2</para>
<para>libdl.so.2(GLIBC_2.0)</para>
<para>libdl.so.2(GLIBC_2.1)</para>
<para>libfontconfig.so.1</para>
<para>libfreetype.so.6</para>
<para>libglib-2.0.so.0</para>
<para>libgobject-2.0.so.0</para>
<para>libgtk-x11-2.0.so.0</para>
<para>libm.so.6</para>
<para>libm.so.6(GLIBC_2.0)</para>
<para>libpthread.so.0</para>
<para>libpthread.so.0(GLIBC_2.0)</para>
<para>libpthread.so.0(GLIBC_2.1)</para>
<para>libpthread.so.0(GLIBC_2.2)</para>
<para>libpthread.so.0(GLIBC_2.2.3)</para>
<para>libpthread.so.0(GLIBC_2.3.2)</para>
<para>rpmlib(CompressedFileNames) &lt;= 3.0.4-1</para>
<para>rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1</para>
<para/>
<para>Убеждаемся что всё это у нас есть. Если чего-то не хватает - прикидываем в каком пакете оно может быть и ставим этот пакет. Наконец, когда всё что нужно у нас установлено, устанавливаем сам rpm-пакет:</para>
<para/>
<para>rpm -Uvh --nodeps prog-0.1.i386.rpm</para>
<para>Всё. Пакет установлен. Однако всё-таки лучше было бы написать для него ebuild. Для работы с rpm-пакетами в portage есть класс rpm. Самый простой способ ознакомиться с ним это прочитать его исходный код, которые расположен в файле /usr/portage/eclass/rpm.eclass. Приведу простой пример ebuild'а для установки rpm:</para>
<para># Подключаем класс rpm</para>
<para>inherit rpm</para>
<para/>
<para># Описываем программу</para>
<para>DESCRIPTION="Cool prog"</para>
<para>HOMEPAGE="http://example.com"</para>
<para>SLOT="0"</para>
<para>KEYWORDS="~x86"</para>
<para>IUSE=""</para>
<para>RESTRICT="nomirror"</para>
<para/>
<para># Описываем зависимости</para>
<para>DEPENDS="x11-libs/qt"</para>
<para/>
<para># Указываем откуда брать пакет</para>
<para>SRC_URI="http://example.com/files/prog-0.1.i386.rpm"</para>
<para/>
<para># Дальше всё будет сделано само. Кроме собственно установки.</para>
<para/>
<para># Устанавливаем пакет:</para>
<para>src_install() {</para>
<para>        cp -vR ${S}/* ${D}/</para>
<para>}</para>
<para/>
<para>Дальше нужно сохранить этот ebuild в нужном месте (обратитесь к документации portage) и выполнить:</para>
<para>ebuild /path/to/file.ebuild digest</para>
<para>ebuild /path/to/file.ebuild merge</para>
<para>Всё. Пакет установлен. Причём штатными средствами Gentoo (что немало важно).</para>
<para>Огромное спасибо пользователю <ulink url="http://ylsoftware.com/?action=viewprofile&amp;user=Alex">Alex</ulink> за помощь в написании статьи.</para>
<para/>
<para/></sect1><sect1><title>Изучаем параметры gcc</title>
<para>Ссылка на оригинал: <ulink url="http://www.onlamp.com/pub/a/onlamp/2007/04/03/getting-familiar-with-gcc-parameters.html">Getting Familiar with GCC Parameters</ulink>
</para>
<para>Ссылка на перевод: <ulink url="http://netsago.org/ru/docs/1">http://netsago.org/ru/docs/1/9/</ulink>
</para>
<para>С версии: 1.5</para>
<para>Перевод: n0xi0uzz </para>
<para/>
<para>Перевод статьи «<ulink url="http://www.onlamp.com/pub/a/onlamp/2007/04/03/getting-familiar-with-gcc-parameters.html">Getting Familiar with GCC Parameters</ulink>», автор — Mulyadi Santosa</para>
<para/>
<para>gcc (GNU C Compiler) — набор утилит для компиляции, ассемблирования и компоновки. Их целью является создание готового к запуску исполняемого файла в формате, понимаемом вашей ОС. Для Linux, этим форматом является ELF (Executable and Linking Format) на x86 (32- и 64-битных). Но знаете ли вы, что могут сделать для вас некоторые параметры gcc? Если вы ищете способы оптимизации получаемого бинарного файла, подготовки сессии отладки или просто наблюдать за действиями, предпринимаемыми gcc для превращения вашего исходного кода в исполняемый файл, то знакомство с этими параметрами обязательно. Так что, читайте.</para>
<para>Напомню, что gcc делает несколько шагов, а не только один. Вот небольшое объяснение их смысла:</para>
<orderedlist>
<listitem>
<para>Препроцессирование: Создание кода, более не содержащего директив. Вещи вроде «#if» не могут быть поняты компилятором, поэтому должны быть переведены в реальный код. Также на этой стадии разворачиваются макросы, делая итоговый код больше, чем оригинальный. [1]</para>
</listitem>
<listitem>
<para>Компиляция: Берется обработанный код, проводятся лексический и синтаксический анализы, и генерируется ассемблерный код. В течение этой фазы, gcc выдает сообщения об ошибках или предупреждениях в случае, если анализатор при парсинге вашего кода находит там какие-либо ошибки. Если запрашивается оптимизация, gcc продолжит анализировать ваш код в поисках улучшений и манипулировать с ними дальнейшем. Эта работа происходит в многопроходном стиле, что показывает то, что иногда требуется больше одного прохода по коду для оптимизации. [2]</para>
</listitem>
<listitem>
<para>Ассемблирование: Принимаются ассемблерные мнемоники и производятся объектные коды, содержащие коды команд. Часто недопонимают то, что на стадии компиляции не производятся коды команд, это делается на стадии ассемблирования. В результате получаются один или более объектных файла, содержащие коды команд, которые являются действительно машинозависимыми. [3]</para>
</listitem>
<listitem>
<para>Компоновка: Трансформирует объектные файлы в итоговые исполняемые. Одних только кодов операции недостаточно для того, чтобы операционная система распознала и выполнила их. Они должны быть встроены в более полную форму. Эта форма, известная как бинарный формат, указывает, как ОС загружает бинарный файл, компонует перемещение и делает другую необходимую работу. ELF является форматом по умолчанию для Linux на x86. [4]</para>
</listitem>
</orderedlist>
<para/>
<para/>
<para/>
<orderedlist>
<listitem>
<para>Параметры gcc описаны здесь, прямо и косвенно затрагивая все четыре стадии, поэтому для ясности, эта статья построена следующим образом:</para>
<para>— Параметры, относящиеся к оптимизации</para>
<para>— Параметры, относящиеся к вызову функций</para>
<para>— Параметры, относящиеся к отладке</para>
<para>— Параметры, относящиеся к препроцессированию</para>
<para/>
<para>Прежде всего, давайте ознакомимся с вспомогательными инструментами, которые помогут нам проникать в итоговый код:</para>
<para>— Коллекция утилит ELF, которая включает в себя такие программы, как objdump и readelf. Они парсят для нас информацию о ELF.</para>
<para>— <ulink url="http://oprofile.sourceforge.net/">Oprofile</ulink>, один из стандартных путей подсчета производительности аппаратного обеспечения. Нам нужна эта утилита для просмотра нескольких аспектов производительности кода.</para>
<para>— time, простой способ узнать общее время работы программы.</para>
<para>Следующие инструкции могут быть применены в gcc версий 3.x и 4.x, так что они достаточно общие. Начнем копать?</para>
</listitem>
</orderedlist><sect2><title/><sect3><title>Параметры, относящиеся к оптимизации кода</title>
<para>gcc предоставляет очень простой способ производить оптимизацию:</para>
<para> опция -O. Она и ускоряет выполнение вашего кода, и сжимает размер итогового кода. У неё существует пять вариантов:</para>
<orderedlist>
<listitem>
<para>от -O0 (O ноль) до -O3. "0" означает отсутствие оптимизации, а "3" — наивысший уровень оптимизации. "1" и "2" находятся между этими краями. Если просто используете -O без указания номера, это будет означать -O1.</para>
</listitem>
<listitem>
<para>— -Os говорит gcc оптимизировать размер. В общем-то, это похоже на -O2, но пропускает несколько шагов, которые могут увеличить размер.</para>
<para>Какое ускорение в действительности можно от них получить? Что ж, предположим, у нас есть такой код:</para>
</listitem>
</orderedlist>
<para>#include </para>
<para/>
<para>int main(int argc, char *argv[])</para>
<para/>
<para>{</para>
<para/>
<para>   int i,j,k;</para>
<para/>
<para>   unsigned long acc=0; </para>
<para/>
<para>   for(i=0;i&lt;10000;i++)</para>
<para/>
<para>        for(j=0;j&lt;5000;j++)</para>
<para/>
<para>                for(k=0;k&lt;4;k++)</para>
<para/>
<para>                        acc+=k;</para>
<para/>
<para>   printf("acc = %lu\n",acc);</para>
<para/>
<para>   return 0;</para>
<para/>
<para>}</para>
<para>С помощью gcc, создадутся четыре разных бинарных файла, используя каждый из -O вариантов (кроме -Os). Утилита time запишет их время исполнения, таким образом:</para>
<para>$ time ./non-optimized</para>
<para/>
<informaltable frame="all">
<tgroup cols="3">
<colspec colnum="1" colname="c1"/>
<colspec colnum="2" colname="c2"/>
<colspec colnum="3" colname="c3"/><tbody>
<row>
<entry>
<para/>
</entry>
<entry>
<para>Без оптимизации</para>
</entry>
<entry>
<para>-O1</para>
</entry>
<entry>
<para>-O2</para>
</entry>
<entry>
<para>-O3</para>
</entry>
</row>
<row>
<entry>
<para>real</para>
</entry>
<entry>
<para>0.728</para>
</entry>
<entry>
<para>0.1</para>
</entry>
<entry>
<para>0.1</para>
</entry>
<entry>
<para>0.1</para>
</entry>
</row>
<row>
<entry>
<para>user</para>
</entry>
<entry>
<para>0.728</para>
</entry>
<entry>
<para>0.097</para>
</entry>
<entry>
<para>0.1</para>
</entry>
<entry>
<para>0.1</para>
</entry>
</row>
<row>
<entry>
<para>sys</para>
</entry>
<entry>
<para>0.000</para>
</entry>
<entry>
<para>0.002</para>
</entry>
<entry>
<para>0.000</para>
</entry>
<entry>
<para>0.000</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Для упрощения, будем использовать следующие обозначения:</para>
<para>— Non-optimized обозначает исполняемый файл, скомпилированный с опцией -O0.— OptimizedO1 обозначает исполняемый файл, скомпилированный с опцией -O1.— OptimizedO2 обозначает исполняемый файл, скомпилированный с опцией -O2.— OptimizedO3 обозначает исполняемый файл, скомпилированный с опцией -O3.</para>
<para>Как вы могли заметить, время выполнения программы, скомпилированной с -O1 в семь раз меньше, чем время выполнения программы, при компиляции которой не использовалась оптимизация. Обратите внимание, что нет большой разницы между -O1, -O2 и -O3, — на самом деле, они почти одинаковы. Так в чем же магия -O1?</para>
<para>После беглого изучения исходного кода, вы должны отметить, что такой код конечен для оптимизации. Прежде всего, давайте посмотрим на короткое сравнение дизассемблированных версий non-optimized и optimizedO1:</para>
<para>$ objdump -D non-optimized</para>
<para/>
<para>$ objdump -D optimizedO1</para>
<para>(Примечание: вы можете получить другие результаты, поэтому используйте эти как основные)</para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>Non-optimized</para>
</entry>
<entry>
<para>OptimizedO1</para>
</entry>
</row>
<row>
<entry>
<para>mov 0xfffffff4(%ebp)add %eax,0xfffffff8(%ebp)addl $0x1,0xfffffff4(%ebp)cmpl $0x3,0xfffffff4(%ebp)</para>
</entry>
<entry>
<para>add $0x6,%edxadd $0x1,%eaxcmp $0x1388,%eax</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Приведенные примеры реализуют самый вложенный цикл (for (k=0;k&lt;4;k++)). Обратите внимание на различие: неоптимизированный код напрямую загружает и хранит из адреса памяти, в то время как optimized01 использует регистры ЦПУ в качестве сумматора и счетчик цикла. Как вам, возможно, известно, доступ к регистрам может быть получен в сотни или тысячи раз быстрее, чем к ячейкам ОЗУ.Не удовлетворяясь простым использованием регистров ЦПУ, gcc использует другой трюк оптимизации. Давайте снова посмотрим дизассемблированный код optimizedO1 и обратим внимание на функцию main():</para>
<para>......</para>
<para/>
<para>   08048390 :</para>
<para/>
<para>   ...</para>
<para/>
<para>   80483a1:       b9 00 00 00 00          mov    $0x0,%ecx</para>
<para/>
<para>   80483a6:       eb 1f                   jmp    80483c7 </para>
<para/>
<para>   80483a8:       81 c1 30 75 00 00       add    $0x7530,%ecx</para>
<para>0x7530 это 30000 в десятичной форме, поэтому мы можем быстро угадать цикл. Этот код представляет собой самый вложенный и самый внешний циклы (for(j=0;j&lt;5000;j++) ... for(k=0;k&lt;4;k++)), так как они являются буквальным запросом на 30000 проходов. Примите во внимание, что вам нужно всего лишь три прохода внутри. Когда k=0, acc остается прежним, поэтому первый проход можно проигнорировать.</para>
<para>   80483ae:       81 f9 00 a3 e1 11       cmp    $0x11e1a300,%ecx</para>
<para/>
<para>   80483b4:       74 1a                   je     80483d0 </para>
<para/>
<para>   80483b6:       eb 0f                   jmp    80483c7 </para>
<para>Хмм, теперь это соответствует 300 000 000 (10 000*5 000*6). Представлены все три цикла. После достижения этого числа проходов, мы переходим прямо к printf() для вывода суммы (адреса 0x80483d0 - 0x80483db).</para>
<para>   80483b8:       83 c2 06                add    $0x6,%edx</para>
<para/>
<para>   80483bb:       83 c0 01                add    $0x1,%eax</para>
<para/>
<para>   80483be:       3d 88 13 00 00          cmp    $0x1388,%eax</para>
<para/>
<para>   80483c3:       74 e3                   je     80483a8 </para>
<para/>
<para>   80483c5:       eb f1                   jmp    80483b8 </para>
<para>Шесть добавляется в сумматор при каждой итерации. В итоге, %edx будет содержать всю сумму после выполнения всех трех циклов. Третья и четвертая строки показывают нам, что после выполнения 5000 раз, должен быть переход к адресу 0x80483a8 (как указано ранее).</para>
<para>Мы можем заключить, что gcc создает здесь упрощение. Вместо прохода три раза в самый вложенный цикл, он просто добавляет шесть для каждого среднего цикла. Это звучит просто, но это заставляет вашу программу сделать только 100 000 000 проходов вместо 300 000 000. Это упрощение, называемое разворачиванием цикла, одно из тех задач, которые делают -O1/2/3. Конечно же, вы и сами можете это сделать, но иногда неплохо знать, что gcc может определить такие вещи и оптимизировать их.</para>
<para>С опциями -O2 и -O3 gcc тоже пытается произвести оптимизацию. Обычно она достигается посредством переупорядочивания [5] и трансформацией кода. Целью этой процедуры является устранить столько ошибочных ветвей, сколько возможно, что повышает качество использования конвейера. Например, мы можем сравнить, как non-optimized и optimizedO2 выполняет самый внешний цикл.</para>
<para> 80483d4:       83 45 ec 01             addl   $0x1,0xffffffec(%ebp)</para>
<para/>
<para> 80483d8:       81 7d ec 0f 27 00 00    cmpl   $0x270f,0xffffffec(%ebp)</para>
<para/>
<para> 80483df:       7e c4                   jle    80483a5 </para>
<para>Бинарный файл non-optimized использует jle для выполнения перехода. Математически это означает, что вероятность выбора ветви 50%. С другой стороны, версия optimizedO2 использует следующее:</para>
<para>80483b4:       81 c1 30 75 00 00       add    $0x7530,%ecx</para>
<para/>
<para>80483ba:       81 f9 00 a3 e1 11       cmp    $0x11e1a300,%ecx</para>
<para/>
<para>80483c0:       75 e1                   jne    80483a3 </para>
<para>Теперь, вместо jle используется jne. При условии, что любое целое может быть сопоставлено в предыдущем cmp, нетрудно сделать вывод, что это увеличит шанс выбора ветви почти до 100%. Это небольшое, но полезное указание процессору для определения того, какой код должен быть выполнен. Хотя, для большинства современных процессоров, этот вид трансформации не является ужасно необходимым, так как предсказатель переходов достаточно умен для того, чтобы сделать это сам.</para>
<para>Для доказательства того, как сильно это изменение может помощь, к нам на помощь придет OProfile. Oprofile выполнен для записи числа изолированных ветвей и изолированных ошибочных ветвей. Изолированные здесь обозначает «выполненные внутри конвейера данных ЦПУ»</para>
<para>$ opcontrol --event=RETIRED_BRANCHES_MISPREDICTED:1000 --event=RETIRED_BRANCHES:1000;</para>
<para>Мы запустим non-optimized и optimizedO2 пять раз каждый. Затем мы возьмем максимум и минимум примеров. Мы посчитаем степень ошибки, используя эту формулу (выведена <ulink url="http://developer.amd.com/articles.jsp?id=90&amp;num=23">отсюда</ulink>).</para>
<para>Степень ошибки = изолированные ошибочные ветви / изолированные ветви</para>
<para>Теперь вычислим степень ошибки для каждого бинарного файла. Для non-optimized получилось 0,5117%, в то время как optimizedO2 получил 0,4323% — в нашем случае, выгода очень мала. Фактическая выгода может различаться для реальных случаев, так как gcc сам по себе не может много сделать без внешних указаний. Пожалуйста, прочтите о __builtin_expect() в <ulink url="http://gcc.gnu.org/onlinedocs/">документации по gcc</ulink> для подробной информации.</para>
<para/></sect3></sect2><sect2><title/><sect3><title>Параметры, относящиеся к вызову функций</title>
<para>По существу, gcc предоставляет вам несколько путей управления тем, как вызывается функция. Сначала давайте рассмотрим встраивание. С помощью встраивания, вы сокращаете стоимость вызова функции, так как тело функции подставлено прямо в вызывающую функцию. Пожалуйста, учтите, что это не по умолчанию, а только когда вы используете -O3 или, по крайней мере, -finline-functions.</para>
<para>Как полученный бинарный файл выглядит после того, как gcc сделает встраивание? Рассмотрим следующий листинг:</para>
<para>#include </para>
<para/>
<para/>
<para>inline test(int a, int b, int c)</para>
<para/>
<para>{</para>
<para/>
<para>        int d;</para>
<para/>
<para>        d=a*b*c;</para>
<para/>
<para>        printf("%d * %d * %d is %d\n",a,b,c,d);</para>
<para/>
<para>}</para>
<para/>
<para/>
<para>static inline test2(int a, int b, int c)</para>
<para/>
<para>{</para>
<para/>
<para>         int d;</para>
<para/>
<para>         d=a+b+c;</para>
<para/>
<para>         printf("%d + %d + %d is %d\n",a,b,c,d);</para>
<para/>
<para>}</para>
<para/>
<para/>
<para>int main(int argc, char *argv[])</para>
<para/>
<para>{</para>
<para/>
<para>        test(1,2,3);</para>
<para/>
<para>        test2(4,5,6);</para>
<para/>
<para>}</para>
<para>Скомпилируем этот код со следующим параметром:</para>
<para>$ gcc -S -O3 -o  </para>
<para>-S указывает gcc остановиться сразу после стадии компиляции (мы расскажем о ней позже в этой статье). Результат будет следующим:</para>
<para>....</para>
<para/>
<para>test:</para>
<para/>
<para>        pushl   %ebp</para>
<para/>
<para>        movl    %esp, %ebp</para>
<para/>
<para>        pushl   %ebx</para>
<para/>
<para>....</para>
<para/>
<para>main:</para>
<para/>
<para>        leal    4(%esp), %ecx</para>
<para/>
<para>        andl    $-16, %esp</para>
<para/>
<para>        pushl   -4(%ecx)</para>
<para/>
<para>...</para>
<para/>
<para>        movl    $6, 16(%esp)</para>
<para/>
<para>        movl    $3, 12(%esp)</para>
<para/>
<para>        movl    $2, 8(%esp)</para>
<para/>
<para>        movl    $1, 4(%esp)</para>
<para/>
<para>        movl    $.LC0, (%esp)</para>
<para/>
<para>        call    printf</para>
<para/>
<para>...</para>
<para/>
<para>        movl    $15, 16(%esp)</para>
<para/>
<para>        movl    $6, 12(%esp)</para>
<para/>
<para>        movl    $5, 8(%esp)</para>
<para/>
<para>        movl    $4, 4(%esp)</para>
<para/>
<para>        movl    $.LC1, (%esp)</para>
<para/>
<para>        call    printf</para>
<para/>
<para>...</para>
<para>И test(), и test() действительно встроены, но вы также можете видеть test(), который остался вне main(). Вот где играет роль ключевое слово static. Написав, что функция — static, вы сообщаете gcc, что эта функция не будет вызываться из какого-либо внешнего объектного файла, поэтому нет нужды порождать коды. Таким образом, это экономит размер, и если вы можете сделать функцию статичной, сделайте это где только возможно. С другой стороны, будьте благоразумны при решении, какая функция должна быть встраиваемой. Увеличение размера для небольшого увеличения скорости не всегда оправдано.С помощью некоторой эвристики, gcc решает, должна быть функция встраиваемой, или нет. Одним из таких доводов является размер функции в терминах псевдо-инструкций. По умолчанию, лимитом является 600. Вы можете поменять этот лимит, используя -finline-limit. Проэксперементируйте для нахождения лучших лимитов встраивания для вашего конкретного случая. Также возможно переделать эвристику так, чтобы gcc всегда встраивал функцию. Просто объявите вашу функцию так:</para>
<para>__attribute__((always_inline)) static inline test(int a, int b, int c)</para>
<para>Теперь перейдем к передаче параметров. На архитектуре x86, параметры помещаются в стек и позже достаются из стека для дальнейшей обработки. Но gcc дает вам возможность изменить это поведение и использовать вместо этого регистры. Функции, у которых меньше трех параметров могут использовать эту возможность указанием -mregparm=</para>
<para>...</para>
<para/>
<para>test:</para>
<para/>
<para>        pushl   %ebp</para>
<para/>
<para>        movl    %esp, %ebp</para>
<para/>
<para>        subl    $56, %esp</para>
<para/>
<para>        movl    %eax, -20(%ebp)</para>
<para/>
<para>        movl    %edx, -24(%ebp)</para>
<para/>
<para>        movl    %ecx, -28(%ebp)</para>
<para/>
<para>...</para>
<para/>
<para>main:</para>
<para/>
<para>...</para>
<para/>
<para>        movl    $3, %ecx</para>
<para/>
<para>        movl    $2, %edx</para>
<para/>
<para>        movl    $1, %eax</para>
<para/>
<para>        call    test</para>
<para>Вместо стека, используются EAX, EDX и ECX для хранения первого, второго и третьего параметров. Поскольку доступ к регистру происходит быстрее, чем к ОЗУ, это будет одним из способов уменьшить время работы. Хотя вы должны обратить внимание на следующие вещи:— Вы ДОЛЖНЫ компилировать весь ваш код с таким же числом -mregparm регистров. Иначе у вас будут проблемы с вызовом функций из другого объектного файла, если они будут принимать разные соглашения.— Используя -mregparm, вы разрушаете совместимый с Intel x86 бинарный интерфейс приложений (ABI). Поэтому, вы должны учитывать это, если вы распространяете свое ПО только в бинарной форме.</para>
<para>Возможно, вы заметили эту последовательность в начале каждой функции:</para>
<para>push   %ebp</para>
<para/>
<para>mov    %esp,%ebp</para>
<para/>
<para>sub    $0x28,%esp</para>
<para>Эта последовательность, также известная как пролог функции, написана чтобы установить указатель фрейма (EBP). Это приносит пользу, помогая отладчику делать трассировку стека. Следующая структура поможет вам понять это [6]:[ebp-01] Последний байт последней локальной переменной</para>
<para>[ebp+00] Старое значение ebp</para>
<para>[ebp+04] Возвращает адрес</para>
<para>[ebp+08] Первый аргумент</para>
<para>Можем мы пренебречь этим? Да, с помощью -fomit-frame-pointer, пролог будет укорочен, так что функция начнется просто с выделения стека (если есть локальные переменные):</para>
<para>sub    $0x28,%esp</para>
<para>Если функция вызывается очень часто, вырезание пролога спасет несколько тактов ЦПУ. Но будьте осторожны: делая это, вы также усложняете отладчику задачу по изучению стека. Например, давайте добавим test(7,7,7) в конец test2() и перекомпилируем с параметром -fomit-frame-pointer и без оптимизации. Теперь запустите gdb для исследования бинарного файла:</para>
<para>$ gdb inline</para>
<para/>
<para>(gdb) break test</para>
<para/>
<para>(gdb) r</para>
<para/>
<para>Breakpoint 1, 0x08048384 in test ()</para>
<para/>
<para>(gdb) cont</para>
<para/>
<para>Breakpoint 1, 0x08048384 in test ()</para>
<para/>
<para>(gdb) bt</para>
<para/>
<para>#0  0x08048384 in test ()</para>
<para/>
<para>#1  0x08048424 in test2 ()</para>
<para/>
<para>#2  0x00000007 in ?? ()</para>
<para/>
<para>#3  0x00000007 in ?? ()</para>
<para/>
<para>#4  0x00000007 in ?? ()</para>
<para/>
<para>#5  0x00000006 in ?? ()</para>
<para/>
<para>#6  0x0000000f in ?? ()</para>
<para/>
<para>#7  0x00000000 in ?? ()</para>
<para>При втором вызове test, программа остановилась, и gdb вывел трассировку стека. В нормальной ситуации, main() должна идти в фрейме №2, но мы видим только знаки вопроса. Запомните, что я сказал про расположение стека: отсутствие указателя фрейма мешает gdb находить расположение сохраненного возвращаемого адреса в фрейме №2.</para></sect3></sect2><sect2><title/><sect3><title>Опции, относящиеся к отладке.</title>
<para>Каждый иногда нуждается в отладке его или её кода. Когда это время приходит, обычно вы запускаете gdb, ставите точки останова там и тут, анализируете бэктрейсы, и так далее, чтобы выявить расположение нарушающего работу кода. А что получаете на самом деле? Если вы не используете опции отладки, вы просто получаете адрес, указывающий на регистр EIP.</para>
<para>Вот в чем проблема, в действительности вы не хотите адрес. Вы хотите, чтобы gdb или другой отладчик просто показал требуемые строки. Но gdb не может этого сделать без определенного вида помощи. Эта помощь, называемая отладкой с приписываемыми форматами записи (Debugging With Attributed Record Formats — DWARF), помогает вам выполнять отладку на уровне исходного кода.</para>
<para>Как это сделать? Используйте -g при компиляции в объектный код, то есть:</para>
<para>  gcc -o -g test test.c</para>
<para>Что такого добавляет gcc, что отладчик может сопоставлять адрес с исходным кодом? Вам нужна dwarfdump [7] чтобы узнать это. Это утилита находится внутри тарболла libdwarf или в RPM, так что вы не найдете её в виде отдельного пакета. Скомпилируйте её сами или просто установите из репозитория вашего дистрибутива; оба варианта должны сработать. В этой части статьи я использую версию 20060614 RPM.</para>
<para>Используя readelf, вы можете отметить, что в неотлаженной версии первого листинга существует 28 разделов:</para>
<para> $ readelf -S ./non-optimized</para>
<para>Но в отлаженной версий есть 36 разделов. Новые разделы:* debug_arranges* debug_pubnames* debug_info* debug_abbrev* debug_line* debug_frame* debug_str* debug_locВам не нужно копаться во всех этих разделах; для быстрого изучения, будет достаточно рассмотреть .debug_line. Команда, которая вам нужна:</para>
<para>$ /path/to/dwarfdump -l </para>
<para>Вот пример того, что вы получите:</para>
<para> .debug_line: line number info for a single cu</para>
<para/>
<para>   Source lines (from CU-DIE at .debug_info offset 11):</para>
<para/>
<para>         [row,column]        //</para>
<para/>
<para> /code/./non-optimized.c:  [  3,-1]        0x8048384       // new statement</para>
<para/>
<para> /code/./non-optimized.c:  [  5,-1]        0x8048395       // new statement</para>
<para/>
<para> ...............</para>
<para>Интерпретация этих сообщений довольно простая. Возьмите первую запись (идущую за строкой </para>
<para>  line number 3 in file non-optimized.c is located in address 0x8048384.</para>
<para>gdb дает ту же информацию:</para>
<para> $ gdb non-optimized-debugging</para>
<para/>
<para>   (gdb) l *0x8048384</para>
<para/>
<para>   0x8048384 is in main (./non-optimized.c:3).</para>
<para>readelf также предоставляет похожую информацию, используя --debug-info:</para>
<para> $ readelf --debug-dump=line </para>
<para/>
<para>   Line Number Statements:</para>
<para/>
<para>   Extended opcode 2: set Address to 0x8048384</para>
<para/>
<para>   Special opcode 7: advance Address by 0 to 0x8048384 and Line by 2 to 3</para>
<para/>
<para>   Advance PC by constant 17 to 0x8048395</para>
<para/>
<para>   Special opcode 7: advance Address by 0 to 0x8048395 and Line by 2 to 5</para>
<para/>
<para>   ....</para>
<para>И readelf, и dwarfdump могут анализировать информацию отладки, так что вы вольны выбирать сами.</para>
<para>Что вы должны понимать, так это то, что исходный код сам по себе не встроен в объектный файл. На самом деле, отладчик должен проверять отдельный файл исходного кода. Запись в колонке</para>
<para/>
<para> $ gcc -O2 -ggdb -o debug-optimized listing-one.c</para>
<para/>
<para>   $ readelf --debug-dump=line debug-optimized</para>
<para/>
<para>   ..</para>
<para/>
<para>   Special opcode 107: advance Address by 7 to 0x80483aa and Line by 4 to 11</para>
<para/>
<para>   ...</para>
<para>Но что говорит gdb?</para>
<para> $ gdb debug-optimized</para>
<para/>
<para>   (gdb) l *0x80483aa</para>
<para/>
<para>   0x80483aa is in main (./non-optimized.c:11).</para>
<para/>
<para>   ...</para>
<para/>
<para>   11              printf("acc = %lu\n",acc);</para>
<para/>
<para>   ...</para>
<para/>
<para>   (gdb) disassemble main</para>
<para/>
<para>   ...</para>
<para/>
<para>   0x080483aa :   add    $0x6,%edx</para>
<para/>
<para>   0x080483ad :   cmp    $0x1388,%eax</para>
<para/>
<para>   ...</para>
<para>Здесь вы видите полное расхождение. Изучая одну информацию об отладке, вы будете ожидать, что указанный адрес содержит что-то вроде инструкции CALL. Но в действительности, вы получите инструкции ADD и CMP, что больше похоже на конструкцию цикла. Это побочный эффект действий оптимизации — в этом случае меняется порядок инструкций. Так что возьмите себе за правило не смешивать опции -g (или её варианты) c -O.</para></sect3></sect2><sect2><title/><sect3><title>Опции, управляющие стадиями компиляции.</title>
<para>В целях изучения, иногда вы хотите узнать, как ваш исходный код трансформируется в исполняемый. К счастью, gcc предоставляет вам опции для остановки на любой стадии обработки. Вспомните, что gcc имеет несколько стадий завершения, — например, компоновку. Есть такие опции:</para>
<orderedlist>
<listitem>
<para>-c останавливает на стадии ассемблирования, но пропускает компоновку. Результатом является объектный код.</para>
</listitem>
<listitem>
<para>-E останавливает на стадии препроцессинга. Все директивы препроцессора развернуты, так что вы видите только чистый код.</para>
</listitem>
<listitem>
<para>-S останавливает после компиляции. Она оставляет вас с ассемблерным кодом.</para>
<para>c наиболее часто используется, когда у вас есть несколько исходных файлов и вы хотите скомбинировать их для получения итогового исполняемого файла. Так что, вместо такого:</para>
</listitem>
</orderedlist>
<para>$ gcc -o final-binary test1.c test2.c</para>
<para>будет лучше разделить их так:</para>
<para>$ gcc -c -o test1.o test1.c</para>
<para/>
<para>$ gcc -c -o test2.o test2.c</para>
<para>и затем:</para>
<para>$ gcc -o final-binary ./test1.o ./test1.o</para>
<para>Возможно, вы заметили, что такая же последовательность используется, если вы собираете программу, используя Makefile. Преимущество использования -c ясно: вам нужно перекомпилировать только измененные исходные файлы. Только фаза, на которой переделывается компоновка всех объектных файлов, и это очень экономит время, особенно в больших проектах. Очевидным примером этого является ядро Linux.</para>
<para>E будет полезна, если вы хотите посмотреть, как ваш код в действительности выглядит после разворачивания макросов, определений и т.п. Возьмите следующий листинг в качестве примера:</para>
<para>#include </para>
<para/>
<para/>
<para>#define A 2</para>
<para/>
<para>#define B 4</para>
<para/>
<para>#define calculate(a,b) a*a + b*b</para>
<para/>
<para/>
<para>void plain_dummy()</para>
<para/>
<para>{</para>
<para/>
<para>    printf("Just a dummy\n");</para>
<para/>
<para>}</para>
<para/>
<para/>
<para>static inline justtest()</para>
<para/>
<para>{</para>
<para/>
<para>    printf("Hi!\n");</para>
<para/>
<para>}</para>
<para/>
<para/>
<para>int main(int argc, char *argv[])</para>
<para/>
<para>{</para>
<para/>
<para>#ifdef TEST</para>
<para/>
<para>    justtest();</para>
<para/>
<para>#endif</para>
<para/>
<para>    printf("%d\n", calculate(A,B));</para>
<para/>
<para>    return 0;</para>
<para/>
<para>}</para>
<para>Скомпилируем его следующим образом:</para>
<para>$ gcc -E -o listing2.e listing2.c</para>
<para>Учтите, что мы не указываем параметров -D, что означает, что TEST не определен. Так и что мы имеем в препроцессорном файле?</para>
<para>void plain_dummy()</para>
<para/>
<para>{</para>
<para/>
<para>    printf("Just a dummy\n");</para>
<para/>
<para>}</para>
<para/>
<para/>
<para>static inline justtest()</para>
<para/>
<para>{</para>
<para/>
<para>    printf("Hi!\n");</para>
<para/>
<para>}</para>
<para/>
<para/>
<para>int main(int argc, char *argv[])</para>
<para/>
<para>{</para>
<para/>
<para>    printf("%d\n", 2*2 + 4*4);</para>
<para/>
<para>    return 0;</para>
<para/>
<para>}</para>
<para>А где вызов justtest() внутри main()? Нигде. TEST не определен — вот почему код исключен. Вы также можете видеть, что макрос calculate уже развернут в умножение и сложение констант. В конечной исполняемой форме, эти числа будут заменены результатами операций. Как вы видите, -E довольно удобна для проверки корректности директив.</para>
<para>Обратите внимание, что plain_dummy() все ещё здесь, не смотря на то, что она ни разу не вызывается. Это не удивительно, так как ещё не была произведена компиляция, вот почему не произошло исключение «мертвого» кода на этой стадии. stdio.h также развернут, но не показан в листинге выше.</para>
<para>Я нашел интересное приложение использования -E в качестве утилиты создания HTML. Вкратце, она помогает вам перенимать обычные действия в программировании, такие как модуляризация кода и макросы в мир HTML — то, что не может быть сделано на чистом HTML.-S дает вам код на ассемблере, больше похожий на то, что вы видите с помощью objdump -d/-D. Хотя с помощью -S вы продолжите видеть директивы и имена символов, который делают код проще к изучению. Например, вызов printf("%d\n", 20) может быть трансформирован в:</para>
<para>.section        .rodata.str1.1,"aMS",@progbits,1</para>
<para/>
<para>.LC0:</para>
<para/>
<para>        .string "%d\n"</para>
<para/>
<para>...</para>
<para/>
<para>        movl    $20, 4(%esp)</para>
<para/>
<para>        movl    $.LC0, (%esp)</para>
<para/>
<para>        call    printf</para>
<para>Вы можете видеть, что format string %d помещена в область данных, доступную только для чтения (.rodata). Также, вы можете удостовериться, что аргументы помещаются в стек справа налево, со строкой форматирования на верху стека.</para></sect3></sect2><sect2><title/><sect3><title>Заключение.</title>
<para>gcc дает нам много полезных опций для превращения нашего кода во что угодно. Понимая, что эти опции делают на самом деле, мы можем сделать программу быстрее и ловчее. Хотя, не будьте целиком от них зависимы: вы должны больше внимания уделять написанию эффективного и хорошо структурированного кода.</para></sect3></sect2><sect2><title/><sect3><title>Благодарности.</title>
<para>Я хочу поблагодарить сообщества на irc каналах OFTC (#kernelnewbies и #gcc) и #osdev (Freenode) за их полезные идеи.</para></sect3></sect2><sect2><title/><sect3><title>Ссылки</title>
<para>1. <ulink url="http://ru.wikipedia.org/wiki/Препроцессор">Статья в Википедии о Препроцессоре</ulink>;2. <ulink url="http://ru.wikipedia.org/wiki/Компилятор">Статья в Википедии о Компиляторе</ulink>;3. <ulink url="http://ru.wikipedia.org/wiki/Язык_ассемблера">Статья в Википедии об Ассемблере</ulink>;4. <ulink url="http://ru.wikipedia.org/wiki/Компоновщик">Статья в Википедии о Компоновщике</ulink>.5. <ulink url="http://www.gnu.org/software/gcc/news/reorder.html">Пример переупорядочивания кода</ulink> (англ.);6. Frame pointer omission (FPO) optimization and consequences when debugging, <ulink url="http://www.nynaeve.net/?p=91">Часть 1</ulink> и <ulink url="http://www.nynaeve.net/?p=92">Часть 2</ulink> (англ.);7. <ulink url="http://reality.sgiweb.org/davea/dwarf.html">Описание DWARF</ulink> (англ.);8. <ulink url="http://linux.sns.it/cygwin/stabs_toc.html">Описание stabs</ulink> (англ.);9. <ulink url="http://en.wikipedia.org/wiki/COFF">Описание COFF</ulink> (англ.);10. <ulink url="http://en.wikipedia.org/wiki/XCOFF">Описание XCOFF (варианта COFF)</ulink> (англ.);11. <ulink url="http://www.cs.tut.fi/%7Ejkorpela/html/cpre.html">Использование препроцессора C в качестве утилиты создания HTML</ulink> (англ.);12. <ulink url="http://gcc.gnu.org/onlinedocs/">Документация по gcc</ulink> (англ.);13. <ulink url="http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/22007.pdf">AMD Athlon Processor x86 Code Optimization Guide</ulink> (англ., pdf).</para>
<para/></sect3></sect2></sect1><sect1><title>Создание LiveCD дистрибутива на базе Gentoo Linux</title>
<para>Ссылка на оригинал: <ulink url="http://linuxportal.vrn.ru/?q=node/58">http://linuxportal.vrn.ru/?q=node/58</ulink>
</para>
<para>Автор: <ulink url="mailto:pizgin?subject=pizgin@gmail.com">Pizgin</ulink>
</para>
<para>С версии: 1.5</para>
<para>Версия статьи: 1.4 от 23.03.2008</para><sect2><title>Введение</title>Введение<para>В руководстве рассказывается о том как создать свой LiveCD диск на основе Gentoo Linux. Диск будет полностью русифицирован, произведена установка KDE и обеспечено автоматическое монтирование flash накопителей. В качестве загрузчика рассматривается ISOLINUX. Раньше был GRUB, но пришлось от него отказаться, так как он не работает на некоторых ноутбуках. Созданный по этой инструкции диск можно будет постоянно совершенствовать, устанавливать новые пакеты, вообщем можно делать все то что можно делать с обычным дистрибутивом установленным на вашем ПК.</para></sect2><sect2><title>Подготовительные действия</title>Подготовительные действия<para>Для сборки необходимо создать определенную структуру каталогов, где создавать- в принципе без разницы. Я создавал в домашней директории. Структураследующая: </para>
<para>livecd</para>
<para> conf           // набор конфигурационных файлов</para>
<para> source         // создаваемый дистрибутив</para>
<para> scripts        // набор вспомогательных скриптов</para>
<para> distr          // исходники: portage, stage, может картинки какие-то и пр.</para>
<para> target         // здесь сборочный скрипт будет создавать squashfs образ</para>
<para>Создаем: </para>
<para>$ cd ~</para>
<para>$ mkdir -p livecd/{conf,distrib,scripts,source,target}</para>
<para/>
<para>Теперь из прикрепленного к статье файла, берем его содержимое и распихиваем поуказанным директориям.</para>
<para>Собирать livecd будем из второй стадии. Скачиваем ее из сети и копируем в distr и распаковываем в каталог сборки. Распаковывать следует с root правами, иначе будут проблемы с созданием устройств в каталоге /dev.</para>
<para># tar -C source/ -pxjvf distrib/stage2-i686-2007.0.tar.bz2</para>
<para>Архив с портежами и дистфайлами распаковывать в каталог сборки не будем. Вместо этого скрипты будут автоматически монтировать эти каталоги от основной системы. </para>
<para>Для того чтобы легко отличать консоль в chroot окружении от консоли основной системы, рекомендую для первой изменить приглашение коммандной строки и вместо просто "#"написать например "(LIVECD) #". Для этого копируем заготовленный в conf директории файл root/bashrc в каталог source/root/ (добавив в начало названия точку).</para>
<para>Для сборки образа, на ПК предварительно должны быть установлены пакеты squashfs-tools и cdrtools. Первый для работы с файловой системой SquashFS, второй для записи CD дисков. </para>
<para># emerge -av squashfs-tools cdrtools</para></sect2><sect2><title>Собираем базовую систему</title>Собираем базовую систему<para>Сейчас можно входить (chroot'иться как еще говорят) в собираемую систему и начинать подгонять ее под свои потребности.</para>
<para># cd scripts </para>
<para># ./enter.sh</para>
<para>Если все прошло нормально - на экране не должно быть никаких ругательных сообщений, а приглашение командной строки выглядеть вот так: "(LIVECD) #". Сейчас мы находимся в только-что распакованной из stage2 системе.</para>
<para>Общий план работ таков: </para>
<orderedlist>
<listitem>
<para>Установить имя машины/домена, профиль, дописать USE флагов в make.conf,создать /etc/fstab.</para>
</listitem>
<listitem>
<para>Установить часовой пояс, перевести часы в режим Local, сгенерировать русские локали, установить русскую расскладку клавиатуры и экранный шрифт.</para>
</listitem>
<listitem>
<para>Выполнить emerge -e system и emerge -e world для получения Stage3.</para>
</listitem>
<listitem>
<para>Не забыть установить пароль root'у.</para>
</listitem>
<listitem>
<para>Собрать ядро, настроить загрузчик и попробовать перезагрузиться.</para>
</listitem>
<listitem>
<para>Установить свои приложения.</para>
<para>Создать ISO образ и записать его на диск.</para>
<para/>
</listitem>
</orderedlist>
<para>Первые два пункта за вас может выполнить подготовленный скрипт "_prepare.sh". Написан он был потому как собрать livecd получилось не с первого раза, и делать одно и тоже на только-что распакованных stage-2 порядком надоело. Его нужно скопировать куда нибудь в source директорию и выполнить один раз для свеже распакованного stage-2. Скопировать можно например в /root или пря мо в корень (важно не забыть перед созданием ISO образа его оттуда удалить).</para>
<para>Итак начинаем: </para>
<para>Напомню что все действия происходят в chroot окружении.</para>
<orderedlist>
<listitem>
<para>Подготавливаем и русифицируем систему. </para>
<para>(LIVECD) # ./_prepare.sh</para>
<para> (LIVECD) # rm _prepare.sh</para>
</listitem>
<listitem>
<para>Устанавливаем основные утилиты для управления пакетами</para>
<para>(LIVECD) # emerge -av gentoolkit</para>
</listitem>
<listitem>
<para> Собираем Stage3 </para>
<para>(LIVECD) # emerge -e system </para>
<para>Обновляем конфигурационные файлы обновленных приложений </para>
<para>(LIVECD) # dispatch-conf</para>
<para>Здесь нужно быть внимательным и не затереть те конфигурационные файлы которые</para>
<para>мы сами изменяли (или их изменил скрипт _prepare.sh). Это касается русского шрифта, раскладки клавиатуры и прочее. Вообщем прежде чем в ответ на вопрос dispatch-conf'a жать 'u', внимательно посмотрите какой файл он хочет обновить. Если это файлы: clock, consolefont, hostname или keymaps - жмите 'z' (не обновлять).</para>
<para>Проверяем целостность зависимостей системы </para>
</listitem>
</orderedlist>
<para>        (LIVECD) # revdep-rebuild</para>
<para>        Тоже самое про мир, пересобираем, обновляем конфигурационные файлы         и проверяем целостность зависимостей. </para>
<para>        (LIVECD) # emerge -e world</para>
<para>        (LIVECD) # dispatch-conf</para>
<para>        (LIVECD) # revdep-rebuild</para>
<para>Пересборка system на Turion64X2 заняла приблизительно 2.5 часа, world - 3 ч.</para>
<para>При emerge -e system могут быть проблемы с perl. Если такое случиться </para>
<para>-делать так (ставиться будет примерно минут 15):</para>
<para>(LIVECD) # emerge --oneshot gdbm db</para>
<para>(LIVECD) # emerge -N --oneshot --nodeps perl</para>
<para/>
<para>После можно снова пробовать emerge -e system.</para>
<para>Возможно где-то в середине сборка system прервется с ошибкой на пакете sys-apps/attr. Ошибка будет выглядеть так: "libexpat.so.0: cannot open shared objects file: No such file or directory". Если это случилось - создаем сиволическую ссылку с libexpat.so на libexpat.so.0, и затем пробуем продолжить сборку, т.е. делаем</para>
<para>(LIVECD) # ln -s /usr/lib/libexpat.so /usr/lib/libexpat.so.0  </para>
<para>(LIVECD) # emerge --resume</para>
<para>Обнаружил небольшой недочет при сборке с использованием portage от 05.03.2008. emerge -e system прерывается на пакете 'which-2.19' с ошибкой "error: readline/rlstdc.h: No such file or directory". На момент сборки этого пакета уже должна стоять библиотека readline, но ее нет. Устанавливаем ее сами и продолжаем сборку system. Если подробно, то:</para>
<para>(LIVECD) # emerge -av readline</para>
<para>(LIVECD) # emerge --resume</para>
<para>Если будут еще какие-либо проблемы - скачайте или обновитесь до самого свежего архива портежей. Не поможет - идите на bugzilla.gentoo.org. </para>
<para>     4.Устанавливаем пароль root'у</para>
<para>        (LIVECD) # passwd </para>
<orderedlist>
<listitem>
<para>Создаем пользователя livecd</para>
<para>(LIVECD) # useradd -m -G users,wheel,audio,video,cdrom,cdrw,usb -s /bin/bash livecd</para>
<para>(LIVECD) # passwd livecd</para>
</listitem>
<listitem>
<para>Устанавливаем splash темы для красивой графической загрузки </para>
<para>(LIVECD) # emerge -av splash-themes-livecd</para>
</listitem>
</orderedlist>
<orderedlist>
<listitem>
<para>Устанавливаем и компилируем ядро</para>
<para>(LIVECD) # emerge -av gentoo-sources</para>
</listitem>
</orderedlist>
<para>genkernel должен быть не старее чем 3.4.10_pre4. На момент написания этого руководства такой версии в стабильной ветке небыло. Если у вас тоже-самое -разрешаем устанавливать его из тестовой (~x86), для этого выполним</para>
<para>           (LIVECD) # echo 'sys-kernel/genkernel ~x86' &gt;&gt;         /etc/portage/package.keywords</para>
<para>        (LIVECD) # emerge -av genkernel</para>
<para>        (LIVECD) # genkernel all —gensplash=livecd-2007.0</para>
<para/>
<orderedlist>
<listitem>
<para>Устанавливаем и добавляем в автозагрузку Gentoo LiveCD скрипты</para>
<para>Снимаем маскировку (установлена разработчиками для того чтобы предупредить о том, что скрипты предназначены только для использования вместе с livecd)</para>
<para>(LIVECD) # echo 'app-misc/livecd-tools' &gt;&gt; /etc/portage/package.unmask</para>
<para>(LIVECD) # echo 'x11-misc/mkxf86config' &gt;&gt; /etc/portage/package.unmask</para>
<para>(LIVECD) # echo 'sys-apps/hwsetup' &gt;&gt; /etc/portage/package.unmask</para>
</listitem>
</orderedlist>
<para>livecd-tools нужен версии не ниже 1.0.40_pre1. На момент написания этого руководства такой версии в стабильной ветке небыло. Если у вас тоже-самое - разрешаем устанавливать его из тестовой (~x86), для этого выполним </para>
<para>        (LIVECD) # echo 'app-misc/livecd-tools ~x86' &gt;&gt;                 /etc/portage/package.keywords</para>
<para>        (LIVECD) # emerge -av livecd-tools</para>
<para>libkudzu нужен не ниже чем 1.2.57.1, если будет устанавливаться более старая версия - отвечаем 'no' и разрешаем libkudzu из тестовой ветки.</para>
<para>        (LIVECD) # echo 'sys-libs/libkudzu ~x86' &gt;&gt; /etc/portage/package.keywords</para>
<para>        (LIVECD) # rc-update add autoconfig default</para>
<orderedlist>
<listitem>
<para>Устанавливаем загрузчик</para>
<para>(LIVECD) # emerge -av syslinux</para>
<para>(LIVECD) # mkdir /boot/isolinux</para>
<para>(LIVECD) # cp /usr/lib/syslinux/isolinux.bin /boot/isolinux</para>
<para>(LIVECD) # cp /boot/kernel-genkernel-x86-2.6.23-gentoo-r6/boot/isolinux/vmlinuz</para>
<para>(LIVECD) # cp /boot/initramfs-genkernel-x86-2.6.23-gentoo-r6 /boot/isolinux/initrd</para>
<para>Из директории с конфиг. файлами копируем в /boot/isolinux файл isolinux.cfg.</para>
</listitem>
<listitem>
<para>Создаем образ и пробуем его загрузить. Выходим из chroot окружения и запускаем скрипт "build.sh"</para>
<para>(LIVECD) # exit</para>
<para># ./build.sh</para>
<para>Процесс сборки образа длиться примерно минут 5. После него забираем iso файл в директории livecd. Можно записать его на болванку, но лучше для этих целей поставить например VirtualBox или VMWare, потому как удобнее и быстрее. </para>
</listitem>
</orderedlist>
<para>Записать на CD можно так:</para>
<para># cdrecord -v -eject speed=10 fs=8m dev=/dev/cdrw image.iso</para>
<para>или если это DVD то так:</para>
<para># growisofs -dvd-compat -Z /dev/dvd=image.iso</para>
<para>Образ должен загрузиться, когда дойдет до приглашения - введите root и ваш пароль. Если все так - пол дела сделано. LiveCD грузиться. Сейчас желательно создать архив с каталогом livecd на случай если при дальнейших манипуляциях что нибудь пойдет не так - можно будет откатиться.</para></sect2><sect2><title>Установка KDE</title>Установка KDE<orderedlist>
<listitem>
<para>Устанавливаем Xorg </para>
<para>(LIVECD) # emerge -av xorg-server</para>
</listitem>
<listitem>
<para>Устанавливаем оригинальный драйвера nVidia </para>
</listitem>
</orderedlist>
<para>        (LIVECD) # emerge -av nvidia-drivers</para>
<orderedlist>
<listitem>
<para>Правим таблицу соответсвия устройство - драйвер для nVidia карт. Открываем файл /usr/share/hwdata/Cards.</para>
<para>3.1. Находим строку NAME NVIDIA Legacy и меняем название драйвера 'vesa' на 'nv'. </para>
<para>3.2. Находим строку NAME NVIDIA GeForce и меняем название драйвера с 'vesa' на 'nvidia'.</para>
</listitem>
<listitem>
<para>Устанавливаем минимальный набор KDE(LIVECD) # emerge -av kdm kdebase-startkde kde-i18n</para>
</listitem>
<listitem>
<para>Добавляем в автозапуск xdm и указываем в нем запускемый оконный менеджер В файле /etc/conf.d/xdm переменной DISPLAYMANAGER присваиваем значение "kdm" </para>
<para>(LIVECD) # rc-update add xdm default</para>
</listitem>
</orderedlist>
<orderedlist>
<listitem>
<para>Настройка автомонтирования съемных устройств</para>
<para>(LIVECD) # emerge -auv dbus hal pmount</para>
<para>(LIVECD) # rc-update add dbus default</para>
<para>(LIVECD) # rc-update add hald default</para>
<para>(LIVECD) # gpasswd -a livecd plugdev</para>
</listitem>
</orderedlist>
<orderedlist>
<listitem>
<para>Включаем русскую раскладку и переключатель en/ru</para>
<para>7.1. Открываем файл /usr/sbin/mkxf86config.sh и удаляем строку вида</para>
<para>"-e 's|"XkbLayout" *"[^"]*"|"XkbLayout" "'"${XKEYBOARD}"'"|g;'"${DEADKEYS}" \"</para>
<para>7.2. Открываем файл /etc/X11/xorg.conf.in и в секции InputDevice, Keyboard0 меняем последние три строчки на следующие:</para>
</listitem>
</orderedlist>
<para>Option "XkbLayout" "us,ru(winkeys)" </para>
<para>Option "XkbVariant" "us"</para>
<para>Option "XkbOptions" "grp:alt_shift_toggle,grp_led:scroll"</para></sect2><sect2><title>Что еще можно сделать</title>Что еще можно сделать<para>* Автологин в текстовой консоли не под root'ом</para>
<orderedlist>
<listitem>
<para>Устанавливаем mingetty</para>
<para>(LIVECD) # emerge -av mingetty</para>
</listitem>
</orderedlist>
<orderedlist>
<listitem>
<para>Прописываем его в /etc/inittab вместо agetty.</para>
<para>Как было:</para>
<para>c1:12345:respawn:/sbin/agetty 38400 tty1 linux</para>
<para>Как нужно исправить:</para>
<para>c1:12345:respawn:/sbin/mingetty --autologin root --noclear tty1</para>
<para>Естественно что вместо root можно вписать любого пользователя.</para>
</listitem>
<listitem>
<para>Правим файл /sbin/rc</para>
<para>Находим вот такую секцию (приблизительно это строка N 500)</para>
<para>if [ -f "/sbin/livecd-functions.sh" -a -n "${CDBOOT}" ] </para>
<para>then ebegin "Updating inittab" livecd_fix_inittab eend $? /sbin/telinit q &amp;&gt;/dev/null fi</para>
<para>и делаем ее такой</para>
<para>if [ -f "/sbin/livecd-functions.sh" -a -n "${CDBOOT}" ] </para>
<para>then ebegin "Updating inittab" /bin/true #livecd_fix_inittab eend $? /bin/true #/sbin/telinit q &amp;&gt;/dev/null </para>
<para>fi</para>
</listitem>
</orderedlist><sect3><title/><sect4><title>Свое сообщение после init'a</title>
<para>Открываем файл /sbin/rc, ищем строку вида 'echo -e " Copyright' и добавляемниже нее свое сообщение.</para></sect4></sect3><sect3><title/><sect4><title>Автологин в KDE</title>
<para>Открываем файл /usr/kde/3.5/share/config/kdm/kdmrc и прописываем пользователяв строки 'DefaultUser' и 'AutoLoginUser'.</para></sect4></sect3><sect3><title/><sect4><title>Красивый, настроенный и подогнанный под себя рабочий стол</title>
<para>Запускаем созданный LiveCD, загружаемся в KDE и настраиваем его под себя. Все, шрифты, поведение окон, курсор занятости, панели и пр. Затем сжимаем свой домашний каталог (/home/livecd) и копируем его на флешку. Выходим из LiveCD, chroot'имся в source и распаковываем в каталог /home/livecd/ сохраненные на флешке настройки.</para>
<para>Приложение</para>
<para>Версии основных используемых пакетов</para>
<para>sys-fs/squashfs-tools-3.1_p2app-misc/livecd-tools-1.0.40_pre1sys-kernel/genkernel-3.4.10_pre4sys-kernel/gentoo-sources-2.6.23-r9sys-apps/hwdata-gentoo-0.3sys-apps/hwsetup-1.2x11-misc/mkxf86config-0.9.9</para>
<para>stage2-i686-2007.0.tar.bz2portage-20080305.tar.bz2</para>
<para/></sect4></sect3></sect2></sect1><sect1><title>Тюнинг Gentoo</title><sect2><title>Ядро 2.6: Тонкости настройки</title>
<para>Ссылка на оригинал: <ulink url="http://ru.gentoo-wiki.com/Ядро_2.6">http://ru.gentoo-wiki.com/Ядро_2.6</ulink>
</para>
<para>С версии: 1.5</para>
<para/><sect3><title>Параметры виртуальной памяти </title>
<para>Ядро Linux позволяет регулировать параметры свопинга двумя способами: автоматически, исходя из того, насколько активно используется та или иная программа, либо вручную задавая агрессивность свопинга. </para>
<para>Содержимое файла /proc/sys/vm/swappiness определяет агрессивность свопинга, а истинность (неравенство нулю) значения в файле /proc/sys/vm/autoswappiness определяет какой из двух режимов будет использоваться. Таким образом, если вы хотите установить агрессивность свопинга вручную, то следует воспользоваться командой: </para>
<para>echo 0 &gt; /proc/sys/vm/autoswappiness </para>
<para>чтобы отключить автоматический режим и уже затем установить желаемый режим вручную. Значения в файле /proc/sys/vm/swappiness изменяются от 0 до 100. При минимальном значении ядро стремится большую часть содержимого держать в физической памяти, при максимальном стремится к экономии физической памяти.Чтобы максимльно сэкономить оперативную память введите: </para>
<para>echo 100 &gt; /proc/sys/vm/swappiness </para>
<para>По умолчанию значение 60, но если поставить 0, это должно побудить систему пользоваться подкачкой только в критических ситуациях. Для медленных систем может ускорить работу. Значение 100 не рекомендуется для тех у кого достаточно медленный жесткий диск. Казалось бы, это значение вообще не желательно для использования, однако, Andrew Morton, один из разработчиков ядра Linux, заявляет, что на своих рабочих компьютерах (десктопах, не серверах) использует значение 100, т.к. считает, что ему совершенно ни к чему эти сотни занятых мегабайт оперативной памяти. И он в некоторых случаях прав, так как известно, что Linux использует свободную оперативную память для кэширования дисковых операций, таким образом, значение близкое или равное 100 может и ускорить систему. Таким образом, решать вам, исходя из количества и ресурсоемкости используемых вами задач. Хотя, вряд ли вы так же активно используете свой десктоп, как Эндрю ;) </para>
<para>Также, возможно заставить систему устанавливать нужный режим при загрузке, прописав в файл /etc/sysctl.conf строку </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/sysctl.conf </para>
</entry>
</row>
<row>
<entry>
<para>vm.swappiness=100 </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>разумеется, вместо 100 следует подставить то значение, которое вам подходит. </para>
<para/>
<para/></sect3></sect2><sect2><title>Руководство по предварительному связыванию в Gentoo Linux</title>
<para>Ссылка на оригинал: <ulink url="http://www.gentoo.org/doc/ru/prelink-howto.xml">http://www.gentoo.org/doc/ru/prelink-howto.xml</ulink>
</para>
<para>C версии: 1.0</para>
<para>Перенесено в: 1.5</para>
<para/><sect3><title>1. Введение</title>
<para/><sect4><title>Что такое предварительное связывание (Prelink) и как оно может помочь мне? </title>
<para>Большинство приложений используют разделяемые библиотеки. Эти разделяемые библиотеки должны быть загружены в память во время выполнения программы, при этом необходимо определить различные символьные ссылки. Для большинства небольших программ динамическое связывание происходит очень быстро. Но для программ, написанных на C++, имеющих много библиотечных зависимостей, динамическое связывание может занять много времени. </para>
<para/>
<para>На большинстве систем, библиотеки обычно остаются неизменными и когда программа запускается, операции необходимые для связывания, каждый раз одинаковы. Предварительное связывание использует данную особенность, выполняя связывание и сохраняя библиотеки в выполняемом файле, фактически уже связанными. Для связывания, вам потребуется ld-linux.so в glibc; для распознавания предварительного связывания версия glibc должна быть &gt;= 2.3.1-r2 </para>
<para/>
<para>Предварительное связывание может уменьшить время загрузки приложений. Например, типичные программы KDE могут загружаться на 50% быстрее. Необходимым условием является перезапуск процесса предварительного связывания каждый раз при обновлении библиотек для программ, которые на них ссылаются. </para></sect4><sect4><title>Резюме</title>
<para>Предварительное связывание производится программой, имеющей название, как не странно, prelink. Она изменяет выполняемый файл таким образом, что он запускается быстрее. </para>
<para>Если зависимые от приложения библиотеки были изменены после того, как были предварительно связаны с приложением, то они потребуют повторного предварительного связывания, иначе вы потеряете преимущества в скорости загрузки. </para>
<para>Изменения выполняемого файла полностью обратимы, поскольку программа prelink имеет функцию undo. </para>
<para>Новые версии portage могут обрабатывать, при помощи программы prelink, изменяющиеся контрольные суммы MD5 и поля mtime выполняемых файлов. </para>
<para>У вас должен быть glibc-2.3.1-r2 или более новый, и бинарные файлы должны быть скомпилированы с binutils-2.13.90.0.xx или выше. </para>
<para/></sect4></sect3><sect3><title>2. Инициализация предварительного связывания</title>
<para/><sect4><title>Установка программ</title>
<para>Примечание: Я подразумеваю, что у вас есть Gentoo-1.4, который был собран при помощи gcc-3.2 или более поздней версии и binutils-2.13.90.0.xx. Это требуется для того, что бы выполняемые файлы могли быть предварительно связаны. </para>
<para/>
<para>Предупреждение: Должен быть установлен glibc 2.3.1 или более новый, иначе программа prelink может испортить все ваши выполняемые файлы! </para>
<para/>
<para>Для начала обновите свое дерево портежей, потому что многие из необходимых приложений часто обновляются и постоянно выходят исправления ошибок. </para>
<para/>
<para>Листинг 2.1: Обновление вашего дерева портежей</para>
<para># emerge sync</para>
<para/>
<para>Далее, убедитесь, что у вас установлен portage-2.0.26 или более новый. Это требуется для того, что бы portage могло распознать предварительно связанные выполняемые файлы и при необходимости корректно их деинсталлировать. Т.к. предварительное связывание изменяет контрольную сумму MD5 бинарных файлов. </para>
<para/>
<para>Листинг 2.2: Проверка версии дерева портежей</para>
<para># emerge "&gt;=portage-2.0.46"</para>
<para/>
<para>Теперь вы можете вызвать emerge для программы предварительного связывания. Процесс emerge автоматически проверит, что ваша система может безопасно выполнять предварительное связывание. </para>
<para/>
<para>Листинг 2.3: Устанавливаем предварительное связывание</para>
<para># emerge prelink</para>
<para/>
<para>Некоторые люди, в ходе выполнения тестов, получают ошибки выполняя emerge для программы prelink. Тесты размещены в пакете из соображений безопасности, предварительное связывание будет непредсказуемым, если их отменить. Эти ошибки обычно связаны с базовыми пакетами, такими как binutils, gcc и glibс. В таком случае попробуйте выполнить emerge этих пакетов повторно.</para>
<para/>
<para>Примечание: Если ошибки продолжают появляться, попробуйте скомпилировать и протестировать программу prelink самостоятельно (./configure ; make ; make check ). В случае сбоя вы можете просмотреть *.log файлы в директории с набором тестов. Они могут дать вам некоторые полезные подсказки. </para>
<para/>
<para>Если вы имеете набор действий, которые демонстрируют ошибки в другой системе, пожалуйста отправьте его на Stefan Jones. </para>
<para/></sect4><sect4><title>Настройка</title>
<para/>
<para>Portage автоматически генерирует файл /etc/prelink.conf, который говорит программе prelink какие файлы требуется предварительно связать. </para>
<para>К сожалению, вы не сможете предварительно связать файлы, которые были скомпилированы старыми версиями пакета binutils. Большинство таких приложений поставляется уже скомпилированными, не имея исходных кодов, и устанавливаются в каталоге /opt. Создайте следующий файл, для того, что бы запретить программе prelink использовать предварительное связывание для подобных файлов. </para>
<para/>
<para>Листинг 2.4: /etc/env.d/99prelink</para>
<para>PRELINK_PATH_MASK="/opt"</para>
<para/>
<para>Примечание: Вы можете добавить больше или меньше директорий, в список, разделенный двоеточиями. </para>
<para/></sect4></sect3><sect3><title>3. Предварительное связывание</title><sect4><title>Применение предварительного связывания</title>
<para/>
<para>Я использую следующую команду для предварительного связывания всех бинарных файлов в директориях, заданных в файле /etc/prelink.conf. </para>
<para/>
<para>Листинг 3.1: Предварительное связывание заданных файлов</para>
<para># prelink -afmR</para>
<para/>
<para>Предупреждение: Наблюдалось, что при наличии небольшого свободного пространства в момент выполнения предварительного связывания для всей системы, существует вероятность усечения выполняемых файлов. Результатом может стать испорченная система. Используйте команду file или readelf для проверки целостности выполняемых файлов. Также вы можете заранее проверить наличие свободного места коммандо df -h </para>
<para>Описание опций:</para>
<orderedlist>
<listitem>
<para>-a        All, применить предварительное связывание ко всем выполняемым файлам. </para>
</listitem>
<listitem>
<para>-f        Вынуждает повторить предварительное связывание для файлов, которые уже подвергались ему. Это требуется т.к. программа prelink прекращает обработку существующих старых связанных файлов, зависимые библиотеки которых могли измениться. </para>
</listitem>
<listitem>
<para>-m        Сохраняет пространство виртуальной памяти. Это требуется, если вы имеете много библиотек, которые необходимо связать. </para>
</listitem>
<listitem>
<para>-R        Random, -- Выбирает случайный порядок адресов, это увеличивает безопасность против переполнений буферов. </para>
</listitem>
</orderedlist>
<para/>
<para>Примечание: Более подробно об опциях можно узнать, набрав man prelink </para>
<para/>
<para/>
<para/></sect4></sect3><sect3><title>4. Известные проблемы и методы их решения</title>
<para/>
<para>"Предварительное связывание не работает с разделяемой библиотекой, собранной без опции PIC" </para>
<para/>
<para>Причиной данной проблемы являются объектные файлы разделяемой библиотеки, скомпилированные без опции gcc -fPIC. </para>
<para/>
<para>Далее следует список проблемных библиотек и список пакетов, для которых требуется повторно вызвать emerge, в случае возникновения данной проблемы. </para>
<para/>
<para>Листинг 4.1: Исправления</para>
<para>(Для библиотеки ORBit /usr/lib/libIIOP.so.0.5.17)</para>
<para>emerge "&gt;=sys-apps/tcp-wrappers-7.6-r4" ORBit</para>
<para>(Для библиотеки zlib  /usr/lib/libz.so.1.1.4)</para>
<para>emerge "&gt;=sys-libs/zlib-1.1.4"</para>
<para>(Для svgalib, /usr/lib/libsvga.so.xx)</para>
<para>emerge "&gt;=media-libs/svgalib-1.9.16"</para>
<para>(Для библиотеки XFree openGL, libGLU.so.1)</para>
<para>emerge "&gt;=x11-base/xfree-4.2.1-r2"</para>
<para>(Для libpcap.so.0.6)</para>
<para>emerge "&gt;=net-libs/libpcap-0.7.1-r2"</para>
<para>(Для библиотеки lcms, /usr/lib/liblcms.so.1)</para>
<para>emerge "&gt;=media-libs/lcms-1.09"</para>
<para/>
<para>Примечание: Многие библиотеки статично связаны с zlib и/или tcp-wrappers, так что сначала попробуйте выполнить emerge для них, после чего, повторно запустите emerge для проблемных библиотек. </para>
<para/>
<para>Если вы имеете проблемы с предварительным связыванием QT/KDE, то сначала попытайтесь обновить x11-base/xfree до версии 4.2.1-r2 или более новой и x11-libs/qt до версии 3.1.0-r1 или более новой. Если QT так и не работает, тогда попробуйте скомпилировать его без поддержки xinerama, задав строку myconf="-no-xinerama ${myconf}" в файле ebuild для qt. </para>
<para/>
<para>Далее приводится список библиотек, которые пока не работают или не могут работать вообще: </para>
<orderedlist>
<listitem>
<para>Библиотеки в пакете wine, включая windex. Они в любом случае не могут ускорить выполняемые файлы MS Windows. </para>
</listitem>
<listitem>
<para>Библиотека в media-video/mjpgtools, /usr/lib/liblavfile-1.6.so.0 </para>
</listitem>
</orderedlist>
<para/>
<para>Если у вас есть проблемы с библиотекой, которой нет в списке, пожалуйста сообщите об этом, предпочтительно, добавив -fPIC к соответствующим CFLAGS. </para>
<para/>
<para>Прерывание предварительного связывания файла, с выводом сообщения, вида: "1631 Aborted ...." </para>
<para/>
<para>Вам необходимо использовать опцию -f программы prelink; т.е. повторить предварительное связывание для всей системы с нуля. Попробуйте запустить prelink -af </para>
<para/>
<para>"Ошибка: &lt;file&gt;: error while loading shared libraries: unexpected reloc type..." </para>
<para/>
<para>Это было исправлено в пакете sys-libs/glibc-2.3.1-r2 2002/11/18, выполните emerge для glibc, если у вас более старая версия. </para>
<para/>
<para>Так же запустите prelink -u -a -m ; prelink -a -m это должно помочь. Если все это не помогает, просто запустите prelink -u &lt;file&gt; </para>
<para/>
<para>У меня проблемы с библиотеками Nvidia openGL</para>
<para/>
<para>Ускоренные библиотеки openGL идущие с пакетом nvidia-glx скомпилированы нестандартным образом, и программа prelink выводит массу предупреждений. Здесь нет повода для беспокойства, и это не может быть исправленo кем-либо помимо компании nvidia. Вы всегда можете вернуться к xfree версии библиотеки libGL.so, если вам не требуется ускорение 3D. Хотя драйвер xfree nvidia работает нормально. </para>
<para/>
<para>После предварительного связывания моей системы, некоторые статичные выполняемые файлы более не работают </para>
<para/>
<para>Там где участвует glibc, не бывает такой вещи как 100% статичный выполняемый файл. Если вы статично скомпилировали выполняемый файл с glibс, он может продолжать оставаться зависимым от других системных файлов. Далее приводится объяснение от Dick Howell. </para>
<para/>
<para>"Я предполагал, что все должно находиться в скачанном файле и не должно быть никаких зависимостей с локальными библиотеками на целевой системе. К сожалению, в Linux, и я думаю везде, где используется GLIBC, это до сих пор не совсем верно. Существует библиотека "libnss" (name service switch - переключатель сервиса имен, некоторые люди думают, что это network secutiry system - сетевая система безопасности) которая предоставляет функции для доступа к различным базам данных для аутентификации, сетевой информации и для других вещей. Эта библиотека предполагает сделать приложения независимыми от отдельно сконфигурированных сетевых окружений машины. Хорошая идея, но изменения GLIBC может вести к проблемам ее загрузки. И вы не можете статически связать "libnss" так как она сконфигурирована для каждой машины индивидуально. Я думаю, что, главным образом, это происходит из-за статического связывания других GLIBC библиотек, особенно "libpthread, "libm" и "libc", откуда приходят несовместимые вызовы к функциям "libnss"" </para>
<para/>
<para>Предварительное связывание обрывается с ошибкой"prelink: dso.c:306: fdopen_dso: Assertion `j == k' failed." </para>
<para/>
<para>Это известная проблема, любезно продиагностирована здесь. Программа prelink не может справиться с выполняемыми файлами сжатыми методом UPX. Для версии prelink-20021213 нет другого способа решить эту проблему, кроме как спрятать выполняемые файлы во время предварительного связывания. Смотрите раздел конфигурации выше, где обсуждается вопрос о том, как это осуществить. </para>
<para/></sect3><sect3><title>5. Заключение</title>
<para/>
<para>Предварительное связывание может решительно ускорить время запуска для некоторых больших приложений. Его поддержка встроена в дерево портежей. Предварительное связывание безопасно, т.к. вы всегда можете отменить его действие для любого выполняемого файла, если вы столкнетесь с какими-либо проблемами. Помните что когда вы обновляете glibc или другие библиотеки, с которыми вы осуществили предварительное связывание, вам надо будет перезапустить prelink. В общем, удачи!</para>
<para/></sect3></sect2><sect2><title>Тюнинг системы и запуска некоторых программ</title>
<para/>
<para>Ссылка на оригинал: <ulink url="http://ru.gentoo-wiki.com/Тюнинг_сис%D1%25">http://ru.gentoo-wiki.com/Тюнинг системы и запуска некоторых программ</ulink>
</para>
<para>С версии: 1.5</para><sect3><title>Введение</title>
<para>Многие программы и части системы Linux работают по-умолчанию не на полную "мощность", т.к. они должны корректно работать на широком спектре системных конфигураций. Иногда, это может создать иллюзию о том, что Linux - более медленная система чем другие. Это не так. В данной статье будут рассмотренны наиболее важные настройки, которые дадут вам наибольший прирост скорости и эффективности системы. </para>
<para>Тонкая настройка дисковой подсистемы (hdparm, планировщики ввода-вывода) перенесена в <ulink url="http://ru.gentoo-wiki.com/Hастройка_дисковой_подсистемы">отдельную статью</ulink> </para></sect3></sect2><sect2><title> mplayer</title>
<orderedlist>
<listitem>
<para>Желательно использовать -vo xvidix или -vo xv, чтобы перенести нагрузку с CPU на вашу видео-карту </para>
</listitem>
<listitem>
<para>Собирайте mplayer с поддержкой особенностей именно вашего процессора (используйте emerge mplayer -pv - там много всего полезного), многие части кода mplayer оптимизированы для использования на конкретных процессорах. </para>
</listitem>
<listitem>
<para>При проигрывании используйте </para>
</listitem>
</orderedlist>
<para>hdparm -u1 -A1 -a 128 /dev/hda (или что там у вас вместо hda) </para>
<orderedlist>
<listitem>
<para>Ипользование команды nice при запуске mplayer с приоритетами -5 и -10 также дает преимущества </para>
</listitem>
</orderedlist></sect2><sect2><title>XMMS</title>
<orderedlist>
<listitem>
<para>Как и для mplayer не забудьте собрать XMMS с поддержкой особенностей вашего процессора </para>
</listitem>
<listitem>
<para>Установите значение для output-buffer побольше (где-то 2500-3000) </para>
</listitem>
</orderedlist>
<para>Preferences → Output Plugin → Configure → Buffering → Buffer size(ms) </para>
<para>или то же самое, но для локализованной версии </para>
<para>Настройки → ВАШ плагин вывода звука → Настройка → Дополнительные настройки → Размер буфера (милисек) </para>
<orderedlist>
<listitem>
<para>Старайтесь использовать качественные звуковые карты, которые имеют более полную обработку звука на уровне железа </para>
</listitem>
</orderedlist>
<para/>
<para/>
<para/>
<para/>
<para/></sect2><sect2><title>Тюнинг настроек программ из семейства Mozilla</title>Тюнинг настроек программ из семейства Mozill<para>Ссылка на оригинал: <ulink url="http://ru.gentoo-wiki.com/Тюнинг_настроек_программ_из_семейства_Mozilla">http://ru.gentoo-wiki.com/Тюнинг настроек программ из семейства Mozilla</ulink>
</para>
<para>С версии: 1.5</para>
<para/><sect3><title>Navigator(Seamonkey/Firefox)</title>
<para>Браузеры семейства Mozilla имеют большое количество настроек, все из которых легко доступны, если набрать в строке адреса вместо URL строку 'about:config'. Следующие пять настроек позволят ускорить загрузку страниц: </para>
<orderedlist>
<listitem>
<para>network.http.pipelining </para>
</listitem>
<listitem>
<para>network.http.pipelining.firstrequest </para>
</listitem>
<listitem>
<para>network.http.pipelining.maxrequests </para>
</listitem>
<listitem>
<para>network.http.proxy.pipelining </para>
</listitem>
<listitem>
<para>nglayout.initialpaint.delay </para>
</listitem>
</orderedlist>
<para>Настройка pipelining позволит браузеру делать одновременно несколько запросов к серверу. По-умолчанию используется одно соединение. Соответственно, значения network.http.pipelining, network.http.pipelining.firstrequest и network.http.proxy.pipelining следует выставить в true. Параметр network.http.pipelining.maxrequests отвечает за максимальное количество соединений. Но не стоит его делать слишком большим, т.к. это может привести к ошибкам при загрузке, рекомендуется выставить его в районе 12. И, наконец, nglayout.initialpaint.delay это визуальное ускорение, то есть задержка между тем как браузер начал получать ответ от сервера и началом отображения в окне браузера. Стоит поставить здесь 0 т.к. это позволит вам получить доступ к уже загруженной части страницы. </para>
<para>Примечание: вторая и пятая настройки по пока невыясненным причинам могут отсутствовать в вашем браузере. Чтобы их задействовать, можно добавить их вручную (правая кнопка мыши→New→тип значения). </para>
<para>browser.turbo.enabled </para>
<para>И выставляем ему значение 'true' </para>
<para>Далее ищем </para>
<orderedlist>
<listitem>
<para>network.http.max-connections-per-server </para>
</listitem>
<listitem>
<para>network.http.max-persistent-connections-per-proxy </para>
</listitem>
<listitem>
<para>network.http.max-persistent-connections-per-server </para>
</listitem>
</orderedlist>
<para>Выставляем всем этим параметрам значение '8' </para>
<para/></sect3><sect3><title>Управление Кешем в Firefox и Seamonkey</title>
<para>С версий Firefox 1.5.x и Seamonkey 1.0.x стала доступна функция быстрого перехода по открытым ранее страницам за счет хранения отрендереной страницы в оперативной памяти. Не всем это понравилось т.к. броузер стал потреблять больше оперативной памяти и много и в качестве лекарства предлагали отключить эту функцию, установив в about:config опцию </para>
<orderedlist>
<listitem>
<para>browser.cache.memory.enable </para>
</listitem>
</orderedlist>
<para>соответственно в false. В то время как можно тонко оттюнинговать отведенный для этой функции размер памяти с помощью опции </para>
<orderedlist>
<listitem>
<para>browser.cache.memory.capacity </para>
</listitem>
</orderedlist>
<para>Которая по умолчанию отсутствует, соответственно тип имеет - integer, а значение задается в килобайтах. Проверить изменения, а также просто просматривать сатистику кешей (memory и disk) можно открыв about:cache до и после.</para></sect3><sect3><title> Управление логотипами сайтов</title>
<para>Есть две опции для включени/выключения логотипов сайтов в табах и адресной стрке: </para>
<orderedlist>
<listitem>
<para>browser.chrome.favicons boolean </para>
</listitem>
<listitem>
<para>browser.chrome.site_icons boolean </para>
</listitem>
</orderedlist>
<para>Как я понял это два стандарта (если не прав, поправьте[favicon.ico обычно лежит в корне сайта, как обстоит с site_icon не знаю]). Например gentoo.ru использует favicon, а на странице mult.ru (непосредственно на той на каторой загружается выбранный мульт, на главной странице никакого лого не показывается) показывалось лого при выключенном favicons и включенном site_icons. </para></sect3><sect3><title>Для перешедших с Firefox на Seamonkey.</title>
<para>Не знаю как вам а мне в Firefox нравится функция сохраняющая и соответственно показывающая эти самые лого при просмотре закладок. И перейдя с недавних пор на Seamonkey мне очень ее недоставало, ибо зрительно с ней гораздо удобней отыскивать нужную закладку, но по умолчанию эта функция там отключена. А управляется она оказывается опцией </para>
<orderedlist>
<listitem>
<para>browser.chrome.load_toolbar_icons integer </para>
</listitem>
</orderedlist></sect3><sect3><title>Thumbnail'ы просматриваемых картинок в табах</title>
<para>Итак с недавних пор появилась такая небольшая функция как thumbnail просматриваемой картинки на табе и в адресной строке, но к сожалению у некоторых эта малозначимая функция вызывает тормоза интерфейса, но не все знают как ее отключить не отключая favicon(логотип сайта). Делается это с помощью опции </para>
<orderedlist>
<listitem>
<para>browser.chrome.image_icons.max_size </para>
</listitem>
</orderedlist>
<para>для которой можно задать размер картинки, по умолчанию ее значение 1024 (килобайт или разрешение?), соответственно чтобы отключить ее, нужно установить значение 0. </para></sect3></sect2><sect2><title>Тонкая настройка IDE дисков с помощью hdparm</title>
<para>Ссылка на оригинал: <ulink url="http://www.opennet.ru/base/sys/htparm_tune.txt.html">http://www.opennet.ru/base/sys/htparm_tune.txt.html</ulink>
</para>
<para>Перенесено в: 1.5</para><sect3><title/><sect4><title>Введение</title>
<para>К сожалению настройки по-умолчанию для IDE жёстких дисков сделаны с уклоном в надёжность работы, в том числе на некачественном оборудовании. На большинстве же современных материнских плат и жёстких дисков можно заметно увеличить производительность IDE подсистемы, причём это не потребует много времени. </para></sect4></sect3><sect3><title/><sect4><title>Характеристики IDE устройства</title>
<para/>
<para>Для получения характеристик IDE устройства выполните команду: </para>
<para>hdparm -i /dev/hda</para>
<para>Вместо /dev/hda можно указать любое другое IDE устройство </para>
<para>Расшифровка</para>
<para/>
<para>Max Mult Sect?: Это поле содержит максимальное число секторов, которое ваш жесткий диск может прочитать за «один присест». </para>
<para>Mult Sect?: Текущая настройка количества секторов, считываемых за один раз. </para>
<para>PIO modes и DMA modes: Здесь перечисляются режимы, которые поддерживает жесткий диск. Режим, помеченный символом «звездочка» (*), является текущим. </para>
<para>Advanced PM?: Признак 'yes' указывает на то, что жесткий диск поддерживает APM (Advanced Power Management – Расширенное Управление Питанием). </para>
<para/>
<para>Запустив другую команду, вы получите дополнительную информацию: </para>
<para>darkstar:$ hdparm /dev/hda </para>
<para/>
<para>Результат работы команды: </para>
<para>/dev/hda: </para>
<para>multcount = 0 (on) </para>
<para>I / O? support = 0 (16-bit) </para>
<para>unmaskirq = 0 (off) </para>
<para>using_dma = 0 (off) </para>
<para>keepsettings = 0 (off) </para>
<para>nowerr = 0 (off) </para>
<para>readonly = 0 (off) </para>
<para>readahead = 8 (on) </para>
<para>geometry = 2482/255/63, sectors = 39876480, start = 0 </para>
<para/>
<para/>
<para>Коротко... </para>
<orderedlist>
<listitem>
<para>multcount – число секторов, считываемых одновременно; </para>
</listitem>
<listitem>
<para>I / O? support – режим обмена с жестким диском (16/32/32sync); </para>
</listitem>
<listitem>
<para>using_dma – указывает, используется ли в настоящий момент режим DMA или нет; </para>
</listitem>
<listitem>
<para>keepsettings – указывает, сохраняются ли настройки после программного сброса (изменять эту настройку не рекомендуется, если вы не уверены в том, что делаете); </para>
</listitem>
<listitem>
<para>readonly – обычно установлен в 1 только для CD-ROM, этот флаг сообщает системе  является ли устройство read-only или нет; </para>
</listitem>
<listitem>
<para>readahead – количество секторов для опережающего чтения; </para>
</listitem>
</orderedlist>
<para/></sect4></sect3><sect3><title/><sect4><title>Настройка</title>
<para/>
<para>ПРЕДУПРЕЖДЕНИЕ! Неправильная настройка может привести к потере данных на </para>
<para>жёстком диске, а возможно и самого дика. </para>
<para/>
<para>I / O? Support</para>
<para/>
<para>-с0 — установка 16-и битного режима (по-умолчанию)\\ </para>
<para>-c1 — установка 32-х битного режима (обычно то, что вам нужно)\\ </para>
<para>-c3 — установка 32-х битного синхронного режима (мне не известно, когда именно это надо)</para>
<para/>
<para>Multicount</para>
<para/>
<para>Количество секторов передаваемых сразу (одним блоком). Степень двойки, максимальное число — параметр Max Mult Sect? в выводе hdparm -i. Чаще всего вам именно его и нужно указывать. </para>
<para/>
<para>Включение DMA</para>
<para/>
<para>Большинство современных чипсетов и HDD поддерживают DMA под линуксом. Для некоторых �амых новых чипсетов в данный момент поддержки DMA может не быть, однако это не так часто бывает. Обычно в течении нескольких недель после выхода нового чипсета появляется его поддержка в последнем ядре, так что если DMA у вас не включается, то следует, скорее всего, обновить ядро. </para>
<para/>
<para>-d0 — запрещение DMA\\ </para>
<para>-d1 — включение DMA </para>
<para/>
<para>DMA mode и PIO mode</para>
<para/>
<para>Самая опасная настройка — её неправильное использование чаще всего приводит </para>
<para>к повреждению данных или оборудования. </para>
<para/>
<para>-X&lt;число&gt; — установка режима PIO или DMA </para>
<para/>
<para>Режимы multiword DMA: </para>
<para/>
<para>32 (базовое число) + номер режима: </para>
<para/>
<para>-X32 — mdma0 </para>
<para>-X33 — mdma1 </para>
<para>-X34 — mdma2 </para>
<para/>
<para>Для PIO базовое число 8, для Ultra DMA? 64. </para>
<para/>
<para>-X64 — udma0 </para>
<para>-X65 — udma1 </para>
<para>-X66 — udma2 </para>
<para>-X67 — udma3 </para>
<para>-X68 — udma4 </para>
<para>-X69 — udma5 </para>
<para/>
<para>Readahead (опережающее чтение)</para>
<para/>
<para>На сколько секторов вперёд читать при запросе. Ускоряет производительность </para>
<para>при чтении файлов большого размера, однако замедляет работу с файлами </para>
<para>небольшого размера. </para>
<para>Лучше всего установить то же значение, что и для multicount. </para>
<para/>
<para>-aN — опережающее чтение N секторов </para>
<para/>
<para>Тестирование</para>
<para/>
<para>Для тестирования наберите: </para>
<para/>
<para>hdparm -t &lt;имя устройства&gt; </para>
<para/>
<para>Желательно это делать, когда заметной дисковой активности нет. </para>
<para/>
<para>Потом попробуйте какой-нибудь вариант конфигурации, например: </para>
<para>hdparm -u1c1d1m8a8 &lt;имя устройства&gt; </para>
<para/>
<para>После чего опять повторите: </para>
<para/>
<para>hdparm -t &lt;имя устройства&gt; </para>
<para/>
<para>И сравните результаты. </para>
<para>По результату этого теста не стоит подбирать опции -a и -m, для этого лучим тестом будут реальные приложения, исполняемые на вашей машине. Если это домашняя машина, а не боевой сервер, на котором важна сверхтонкая подстройка (но на таких серверах редко оказываются IDE-диски, о которых здесь идёт речь), то тогда параметр multicount (-m) ставите на максимум, а параметр read-ahead (-a) равным multicount. </para></sect4></sect3></sect2><sect2><title>Ускорение загрузки системы</title>
<para>Ссылка на оригинал: <ulink url="http://ru.gentoo-wiki.com/Ускорение_загрузки_системы">http://ru.gentoo-wiki.com/Ускорение загрузки системы</ulink>
</para>
<para>Перенесено в: 1.5</para>
<para/><sect3><title/><sect4><title>Введение</title>
<para/>
<para>Одно из достоинств Gentoo Linux - это возможность настроить и оптимизировать буквально ВСЮ систему, в том числе и её загрузку. Данное направление оптимизации практически неисчерпаемо. При желании (но и при большом риске убить систему) загрузку можно довести и до нескольких секунд. Здесь же мы рассмотрим некоторые наиболее простые и безопасные методы ускорения загрузки. </para>
<para/>
<para>Параллельный запуск</para>
<para/>
<para>Первое, что может дать заметный прирост скорости загрузки, это распараллеливание запуска системных сервисов. В файле /etc/conf.d/rc замените NO на YES в переменной RC_PARALLEL_STARTUP. Файл: /etc/conf.d/rc </para>
<para>...</para>
<para>RC_PARALLEL_STARTUP="YES"</para>
<para>... </para>
<para/>
<para>Если у вас нет такой переменной, обновите пакет baselayout emerge -u baselayout </para>
<para/>
<para>Примечание: Если эта настройка создаст проблемы при загрузке (некоторые сервисы могут пытаться загрузиться не тогда, когда это нужно), то верните значение NO. </para>
<para/>
<para>Значительно был улучшен механизм параллельного запуска в новых (нестабильных) версиях baselayout echo "sys-apps/baselayout ~x86" &gt;&gt; /etc/portage/package.keywords emerge sync &amp;&amp; emerge sys-apps/baselayout -u </para>
<para/>
<para>Для совсем реактивного запуска используйте initng </para>
<para>emerge sys-apps/initng </para>
<para/></sect4></sect3><sect3><title/><sect4><title>Локальная сеть</title>
<para/>
<para>Если вы часто работаете без подключения к локальной сети, то наверняка заметили, как много времени уходит на определение настроек сети (точнее, на определение того, что настраивать нечего). В этом случае поможет демон ifplugd, который определяет, подключен ли сетевой кабель (точнее, активна ли сеть). Итак: </para>
<para/>
<para>emerge -n ifplugd </para>
<para/>
<para>теперь добавляем ifplugd в список запускаемых сервисов: </para>
<para/>
<para>rc-update add ifplugd boot </para>
<para/>
<para>Обновление зависимостей и переменных окружения</para>
<para/>
<para>Каждый раз при загрузке Gentoo обновляет зависимости модулей и переменные окружения, разумеется, что это имеет смысл лишь тогда, когда вы действительно внесли изменения в вашу систему. Чтобы это осуществить, сделаем следующие изменения. </para>
<para/>
<para>Меняем:</para>
<para> Файл: /etc/init.d/modules - оригинал </para>
<para>...</para>
<para>ebegin "Calculating module dependencies"</para>
<para>    /sbin/modules-update &amp;&gt;/dev/null</para>
<para>    eend $? "Failed to calculate dependencies"</para>
<para>...</para>
<para> Файл: /etc/init.d/modules - замена </para>
<para>...</para>
<para>if [ /etc/modules.d -nt /etc/modules.conf ]</para>
<para>    then</para>
<para>        ebegin "Calculating module dependencies"</para>
<para>        /sbin/modules-update &amp;&gt;/dev/null</para>
<para>        eend $? "Failed to calculate dependencies"</para>
<para>    else</para>
<para>        einfo "Module dependencies are up-to-date"</para>
<para>fi</para>
<para>... </para>
<para>Меняем: </para>
<para>Файл: /etc/init.d/bootmisc - оригинал </para>
<para>...</para>
<para>if [ -x /sbin/env-update.sh ]</para>
<para>    then</para>
<para>        ebegin "Updating environment"</para>
<para>        /sbin/env-update.sh &gt;/dev/null</para>
<para>        eend 0</para>
<para>fi</para>
<para>...  </para>
<para>Файл: /etc/init.d/bootmisc - замена </para>
<para>...</para>
<para>if [ -x /sbin/env-update.sh ]</para>
<para>  then</para>
<para>    if [ /etc/env.d -nt /etc/profile.env ]</para>
<para>      then</para>
<para>        ebegin "Updating environment"</para>
<para>        /sbin/env-update.sh &gt;/dev/null</para>
<para>        eend 0</para>
<para>      else</para>
<para>        einfo "Environment up-to-date"</para>
<para>    fi</para>
<para>fi</para>
<para>... </para>
<para/>
<para>Примечание: при использовании данного трюка следует быть внимательным при обновлении baselayout, т.к. обновление каждый раз будет пытаться вернуть изменения, сделанные вами. </para></sect4></sect3><sect3><title/><sect4><title>Монтирование локальных файловых систем</title>
<para/>
<para>Можно подправить сервис localmount, чтобы он монтировал локальные файловые системы не одну за другой, а все сразу. </para>
<para/>
<para>Замените: </para>
<para>Файл: /etc/init.d/localmount - оригинал </para>
<para>...</para>
<para>mount -at ... &gt;/dev/null</para>
<para>...                 </para>
<para>Файл: /etc/init.d/localmount - замена </para>
<para>...</para>
<para>mount -aFt ... &gt;/dev/null</para>
<para>... </para>
<para/></sect4></sect3></sect2></sect1><sect1><title>Что делать, если система «зависла»</title>
<para>Ссылка на оригинал: <ulink url="http://perlovka.homelinux.net/?node=gentoo_articles&amp;id=4">http://perlovka.homelinux.net/?node=gentoo_articles&amp;id=4</ulink>
</para>
<para>Автор: Perlovka</para>
<para>С версии: 1.5</para>
<para/>
<para>«Подвесить» Линукс вполне реально, несмотря на стабильность системы. «Подвесить» взято в кавычки потому, что при кажущихся признаках капитального останова системы ядро продолжает работать.</para>
<para>Рассмотрим некоторые ситуации, в которые может попасть пользователь:</para><sect2><title>1. «Завис» X сервер</title>
<para>При зависании или неадекватном поведении X сервера, можно воспользоваться командой перезапуска сервера — Ctrl+Alt+Backspace. При этом, если сервер был запущен командой startx, вы вернетесь в приглашение консоли; если же он был запущен c помощью менеджера дисплея xdm (gdm,kdm), то вы окажетесь на экране вашего графического менеджера загрузки.</para></sect2><sect2><title>2. Приложение не воспринимает команды</title>
<para>Если система перестала отвечать на команды клавиатуры, и Ctrl+Alt+Backspace не помогает, приходится использовать более жесткие методы воздействия. Один из этих методов заключается в использовании низкоуровневых сигналов ядра. Они реализуются с помощью клавиши SysRq (System Request), также известной как PrintScreen.</para>
<para>Для использования этих сигналов вам может понадобиться пересобрать ядро с их поддержкой:</para>
<para>Kernel hacking ---&gt;</para>
<para>[*] Magic SysRq key</para>
<para>Также можно включить эту опцию «на лету», но работать это будет до первой перезагрузки компьютера:</para>
<para>echo "1" &gt; /proc/sys/kernel/sysrq</para>
<para>Итак, вы можете использовать следующие комбинации клавиш в аварийной ситуации:</para>
<para>Alt+SysRq+R — изменение режима клавиатуры с Raw в XLAT. Если приложение зависло, и заблокировало клавиатуру, не оставляя вам возможности перейти в консоль простым нажатием Ctrl+Alt+F1, воспользуйтесь этой комбинацией. Теперь вы сможете перейти в консоль и прервать выполнение приложения.</para>
<para>Alt+SysRq+K — эта комбинация носит название Secure Access Key (SAK). Она убивает все запущенные в текущей виртуальной консоли процессы. Исторически SAK предназначался для других целей. Применять его советовали пользователям перед тем как залогиниться в систему. Дело в том, что довольно легко написать программу или скрипт, эмулирующие логин. Неискушенный пользователь вводит свой логин и пароль, а «троянский конь» сохраняет их в надежном месте, чтобы злоумышленник воспользовался плодами вашей доверчивости. Если же юзер перед тем как зайти в систему нажмет SAK, то прибьет трояна и получит нормальное, «оригинальное» приглашение системы.</para>
<para>Alt+SysRq+E — посылает сигнал SIGTERM всем процессам, кроме init. Сигнал SIGTERM означает, что система завершает некий процесс и прибирает за ним мусор — закрывает открытые процессом файлы, убивает временные и так далее;</para>
<para>Alt+SysRq+I — посылает сигнал SIGKILL всем процессам, кроме init. В отличие от предыдущего сигнала, SIGKILL грубо прерывает выполнение программы, не выполняя после этого «зачистку».</para>
<para>Alt+SysRq+L — посылает сигнал SIGKILL всем процессам, включая init. В этом случае система уходит в полный даун. Эту команду лучше не трогать.</para>
<para>Alt+SysRq+S — запускает аварийную синхронизацию (запись кэша) всех примонтированных дисков. Позволяет избежать потери данных.</para>
<para>Alt+SysRq+U — Перемонтировать все примонтированные файловые системы в режиме «только для чтения». Если операция прошла успешно, fsck не будет проверять файловые системы после «жесткого» перезапуска системы.</para>
<para>Alt+SysRq+B — перезагрузка системы. Очень быстрая, потому что этапы синхронизации и размонтирования пропускаются. Употреблять только в самых крайних случаях. С таким же успехом можете нажать на Reset.</para>
<para>Alt+SysRq+O — действует на систему подобно выстрелу в висок. Никакой синхронизации буфера, размонтирования и прочего. Сразу гасится свет, то бишь вырубается питание. Поэтому до нажатия этих клавиш следует синхронизировать буфер (Alt+SysRq+S), затем перемонтировать файловые системы в режиме «только для чтения» (Alt+SysRq+U) и только потом — Alt+SysRq+O. И запомните — сначала синхронизация, потом размонтирование, однако не наоборот.</para>
<para/></sect2></sect1><sect1><title>Русское WIKI</title>
<para>Ссылка на оригинал: <ulink url="http://ru.gentoo-wiki.com/">http://ru.gentoo-wiki.com</ulink>
</para>
<para>С версии: 1.0</para>
<para>Обновлено: 1.5</para>
<para/><sect2><title>HOWTO hal и устройства ввода</title>
<para>Дата:  28.01.2008</para><sect3><title>hal-0.5.10 </title>
<para>В связи с выходом hal-0.5.10 и включении поддержки hal в xorg возникло много вопросов: где раскладки, где мышка, где тачпад, и прочее. </para>
<para>Сейчас xorg использует hal для устройств ввода и xorg.conf игнорирует Данное руководство предназначенно для безболезненного перехода на новую систему </para>
<para>В данном руководстве используются пакеты из ~x86(~amd64) ветки. Посему заботу о keywords оставляю на вашей совести. </para></sect3><sect3><title>Обновляем portage </title>
<para># emerge --sync</para>
<para>(# eix-sync -v) </para></sect3><sect3><title>Обновляем установку xorg </title>
<para>#emerge -avDNt  xorg-x11</para>
<para>убеждаемся в наличии флага hal. При отсутствии — включаем. / В окончании сборки пакета xorg-server выведется список пакетов для пересборки, их надо пересобрать. Если не заметили или пропустили вот комманда для получения списка пакетов: </para>
<para>emerge portage-utils; qlist -I -C x11-drivers/</para></sect3><sect3><title>Клавиатура </title>
<para>Правила(rules) пользователя можно разместить в каталогах: </para>
<para>/usr/share/hal/fdi/policy/20thirdparty/</para>
<para>или аналогичном /etc/hal/fdi/policy</para>
<para>получить список устройств "узнанных" hal можно командой lshal у меня системе(ноутбук с мультимедийными клавишами) оказалось несколько устройств которые совместимы с понятием "клавиатура", но основная была описана так: </para>
<para>udi = '/org/freedesktop/Hal/devices/platform_i8042_i8042_KBD_port_logicaldev_input'</para>
<para> info.addons.singleton = {'hald-addon-input'} (string list)</para>
<para> info.capabilities = {'input', 'input.keyboard', 'input.keypad', 'input.keys', 'button'} (string list)</para>
<para> info.category = 'input'  (string)</para>
<para> info.parent = '/org/freedesktop/Hal/devices/platform_i8042_i8042_KBD_port' (string)</para>
<para> info.product = 'AT Translated Set 2 keyboard'  (string)</para>
<para> info.udi = '/org/freedesktop/Hal/devices/platform_i8042_i8042_KBD_port_logicaldev_input'  (string)</para>
<para> input.device = '/dev/input/event2'  (string)</para>
<para> input.originating_device = '/org/freedesktop/Hal/devices/platform_i8042_i8042_KBD_port'  (string)</para>
<para> input.physical_device = '/org/freedesktop/Hal/devices/platform_i8042_i8042_KBD_port'  (string)</para>
<para> input.product = 'AT Translated Set 2 keyboard'  (string)</para>
<para> input.x11_driver = 'evdev'  (string)</para>
<para> input.xkb.layout = 'us'  (string)</para>
<para> input.xkb.model = 'evdev'  (string)</para>
<para> input.xkb.rules = 'base'  (string)</para>
<para> input.xkb.variant =   (string)</para>
<para> linux.device_file = '/dev/input/event2'  (string)</para>
<para> linux.hotplug_type = 2  (0x2)  (int)</para>
<para> linux.subsystem = 'input'  (string)</para>
<para> linux.sysfs_path = '/sys/devices/platform/i8042/serio0/input/input2/event2'  (string)</para>
<para>Заметно что </para>
<para>input.xkb.layout = 'us'</para>
<para>input.xkb.rules = 'base'</para>
<para>input.xkb.variant = </para>
<para>нас не устраивает </para>
<para>Создаём новый файл </para>
<para>nano /usr/share/hal/fdi/policy/20thirdparty/10russian-layout.fdi</para>
<para>со следующим содержимым: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /usr/share/hal/fdi/policy/20thirdparty/10russian-layout.fdi </para>
</entry>
</row>
<row>
<entry>
<para>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;&lt;!-- -*- SGML -*- --&gt; &lt;match key="input.product" contains="AT Translated Set 2 keyboard"&gt;&lt;merge key="input.xkb.layout" type="string"&gt;us,ru&lt;/merge&gt;&lt;merge key="input.xkb.variant" type="string"&gt;,winkeys&lt;/merge&gt; &lt;merge key="input.xkb.options" type="string"&gt;grp:alt_shift_toggle,grp_led:scroll&lt;/merge&gt;&lt;/match&gt; </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>если у вас одно устройство ввода типа "клавиатура",то можно сточку </para>
<para>&lt;match key="input.product" contains="AT Translated Set 2 keyboard"&gt;</para>
<para>заменить на </para>
<para>&lt;match key="info.capabilities" contains="input.keyboard"&gt;</para>
<para>Так мы получим более универсальное правило. Можно заметить что названия опций перекликается с аналогами xorg.conf. Так и есть, в принципе здесь можно записать все те параметры которые вы использовали в xorg.conf только в приложении к XML. </para>
<para>ВАЖНО: Если у вас остались проблемы с расположением клавиш, то возможно так и следует сделать? </para>
<para>например: </para>
<para>Option "XkbRules" "xorg"</para>
<para>тоже самое что </para>
<para>       &lt;merge key="input.xkb.rules" type="string"&gt;xorg&lt;/merge&gt;</para>
<para/>
<para>Driver "kbd" </para>
<para>= </para>
<para>    &lt;merge key="input.x11_driver" type="string"&gt;kbd&lt;/merge&gt;</para>
<para>Сохраняем файл. </para>
<para>#/etc/init.d/hald restart</para>
<para>Проверяем системный лог и убеждаемся, что правило успешно добавленно. </para>
<para>#lshal </para>
<para>должно вывести следующие строчки: </para>
<para>...</para>
<para> input.x11_driver = 'evdev'  (string)</para>
<para> input.xkb.layout = 'us,ru'  (string)</para>
<para> input.xkb.model = 'evdev'  (string)</para>
<para> input.xkb.options = 'grp:alt_shift_toggle,grp_led:scroll'  (string)</para>
<para> input.xkb.rules = 'base'  (string)</para>
<para> input.xkb.variant = ',winkeys'  (string)</para>
<para>...</para>
<para>Если так и есть, то дело сделано. Если нет--внимательно перечитываем до просветления. </para></sect3><sect3><title>Перезапускаем X-ы </title>
<para>После чего можно перезапустить X-ы(перезагрузить компьтер, перезапустить xdm). Проверяем. Радуемся. Если не получаеться, то внимательно читаем лог Xorg, Скорее всего там можно найти ответ. </para></sect3><sect3><title>Мышка</title>
<para>Пока проблема одна. Hal по умолчанию использует драйвер evdev,которые не всегда корректно работает в полноэкранных приложениях(игры) </para>
<para>#echo "SDL_VIDEO_X11_DGAMOUSE=0" &gt;&gt;/etc/env.d/02locale</para>
<para>#env-update</para>
<para>#source /etc/profile</para>
<para>Должно решить эту проблему. </para></sect3><sect3><title>Touchpad</title>
<para>Пока в разработке. </para></sect3></sect2><sect2><title>HOWTO Ivman</title><sect3><title>Цель</title>
<para>Целью статьи является установка <ulink url="http://ivman.sourceforge.net/">ivman</ulink> для автомонтирования устройств. </para>
<para>Внимание: часть информации может быть недействительна для старых версий Ivman, особенно Ivman 0.5.x. Пожалуйста, используйте последние стабильные версии Ivman. </para></sect3><sect3><title>Требуемые программы</title>
<orderedlist>
<listitem>
<para>
<ulink url="http://ru.gentoo-wiki.com/HOWTO_Udev">UDEV</ulink> </para>
</listitem>
<listitem>
<para>HAL </para>
</listitem>
<listitem>
<para>D-BUS </para>
</listitem>
<listitem>
<para>pmount </para>
</listitem>
<listitem>
<para>
<ulink url="http://ivman.sourceforge.net/">ivman</ulink> </para>
</listitem>
</orderedlist>
<para/>
<para>Все требуемые пакеты есть в портежах, поэтому минимальным действием будет: </para>
<para>emerge -av ivman</para>
<para>Размаскируйте требуемые пакеты, если необходимо. </para>
<para>Если установка HAL выдаёт предупреждения, что не установлены "u64" или "BLKGETSIZE64"и вы используете ядро 2.6, обновите пакет linux-headers: </para>
<para>emerge --oneshot linux-headers</para>
<para>Когда linux-headers полностью обновится, пересоберите glibc: </para>
<para>emerge --oneshot glibc</para></sect3><sect3><title>Использование</title>
<para>Есть два пути использования Ivman: от root, или от обычного пользователя. У любого из методов имеются как преимущества, так и недостатки. </para><sect4><title>Запуск Ivman от root</title>
<orderedlist>
<listitem>
<para>Для запуска Ivman выполните: /etc/init.d/ivman start </para>
</listitem>
<listitem>
<para>Чтобы Ivman стартовал при каждом запуске выполните: rc-update add ivman default </para>
</listitem>
<listitem>
<para>Все действия Ivman после запуска выполняются с привилегиями пользователя «ivman» и группы «plugdev». </para>
</listitem>
<listitem>
<para>По умолчанию, сменные устройства будут монтироваться для доступа на чтение/запись только входящим в группу «plugdev» (группа пользователей, которым разрешено использовать pmount). Это более безопасно, чем запуск Ivman от обычного пользователя. </para>
</listitem>
<listitem>
<para>Размонтирование дисков обычным пользователем может быть затруднено. Вам может потребоваться использование sudo pumount или sudo umount. Размонтирование используя 'media:/' ioslave в KDE может не работать. </para>
</listitem>
<listitem>
<para>Для легкого размонтирования дисков обычными пользователями отредактируйте файл /usr/share/hal/fdi/policy/10osvendor/10-storage-policy.fdi, изменив user на users в строке &lt;merge key="storage.policy.default.mount_option.user" type="bool"&gt;true&lt;/merge&gt;. Если у вас нет такого файла, поищите похожий в /usr/share/hal. (Внимание: это работает для ivman 0.5.x, но не для последних версий ivman.) </para>
</listitem>
</orderedlist></sect4><sect4><title>Запуск Ivman от обычного пользователя</title>
<orderedlist>
<listitem>
<para>Для начала, у вас должен быть запущен HAL. Выполните как root: /etc/init.d/hald start </para>
</listitem>
<listitem>
<para>Для запуска HAL каждый раз при загрузке выполните: rc-update add hald default </para>
</listitem>
<listitem>
<para>Для запуска Ivman единично выполните команду ivman под вашим пользовательским аккаунтом. Чтобы Ivman запускался автоматически, когда вы входите в систему, вы должны сделать следующее: </para>
</listitem>
<listitem>
<para>Ivman запустится под вашим пользовательским аккаунтом. </para>
</listitem>
</orderedlist>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Вы можете не находиться в группе plugdev, потому что сейчас устройства монтируются так, что только вы имеете к ним доступ. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<orderedlist>
<listitem>
<para>По умолчанию сменные устройства будут монтироваться на запись/чтение для вас и не допускать больше никого. </para>
</listitem>
<listitem>
<para>Размонтирование работает как обычно. Работает стандартный pumount. Размонтирование используя 'media:/' ioslave в KDE работает. </para>
</listitem>
<listitem>
<para>Когда возможно (а, как правило, это возможно), запускайте Ivman одновременно от root и от обычного пользователя. В этом случае автомонтирование будет произведено от пользовательского запуска Ivman, а если пользовательский Ivman отсутствует, автомонтирование будет автоматически передано запуску Ivman от root. Не запускайте более одного пользовательского Ivman, даже под различающимися пользовательскими аккаунтами – это приведёт к войне за ресурсы. </para>
</listitem>
</orderedlist>
<para>Ivman не требует дополнительной конфигурации для автомонтирования. Данные fstab игнорируются, сменные устройства/диски будут смонтированы в /media. Однако, Ivman может быть использован не только для монтирования. Обретите свободу для добавления ваших супер-правил на этой странице  :-) </para></sect4><sect4><title> Примеры некоторых правил</title>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Смонтировать всё, что есть </para>
</entry>
</row>
<row>
<entry>
<para>    &lt;ivm:Match name="ivm.mountable" value="true"&gt;</para>
<para>        &lt;ivm:Option name="mount" value="true" /&gt;</para>
<para>    &lt;/ivm:Match&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Открыть мой MP3-плеер в mc, когда он подключен </para>
</entry>
</row>
<row>
<entry>
<para>    &lt;ivm:Match name="hal.info.product" value="IAUDIO"&gt;</para>
<para>        &lt;ivm:Option name="exec" value="xterm -e mc /home/share/music /media/IAUDIO" /&gt;</para>
<para>    &lt;/ivm:Match&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Открыть мою камеру в mc, когда она подключена </para>
</entry>
</row>
<row>
<entry>
<para>    &lt;ivm:Match name="hal.info.vendor" value="FUJIFILM"&gt;</para>
<para>        &lt;ivm:Option name="exec" value="xterm -e mc /home/share/pics /media/usbdisk/DCIM/100_FUJI" /&gt;</para>
<para>    &lt;/ivm:Match&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Для KDE </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Выводит всплывающее окошко, когда что-нибудь подключено </para>
</entry>
</row>
<row>
<entry>
<para>    &lt;ivm:Match name="hal.info.category" value="storage"&gt;</para>
<para>      &lt;ivm:Match name="hal.storage.bus" value="usb"&gt;</para>
<para>         &lt;ivm:Option name="exec" value="kdialog --passivepopup 'USB storage device detected: $hal.info.vendor$ $hal.info.product$' 4" /&gt;</para>
<para>      &lt;/ivm:Match&gt;</para>
<para>   &lt;/ivm:Match&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4></sect3><sect3><title> Проблемы </title>
<para> Использование записей в fstab (ivman 0.6.x или более новый)</para>
<para>Ivman 0.6.x или более новый использует pmount для монтирования устройств, и не нуждается в записях fstab. Но если хочеться, то можно. </para>
<para>pmount (и Ivman, таким образом) будет автоматически учитывать записи fstab. С версии 0.6.0, на каждую символьную ссылку будет создано правило, без использования IvmConfigMappings.xml. Устройства, не отмеченные в fstab, будут монтироваться в /media. </para>
<para>Использование записей в fstab (ТОЛЬКО ivman 0.5.x!)</para>
<para>Ivman 0.5.x может использовать ваш /etc/fstab. Если вы до этого пользовались supermount, вам необходимо изменить записи для использования ivman. Например: </para>
<para>/dev/cdroms/cdrom0      /mnt/cdrom      iso9660   noauto,ro     0 0</para>
<para>Может также потребоваться отключение devfs. </para>
<para/>
<para>Монтирование устройств с размонтированием от обычного пользователя (ТОЛЬКО ivman 0.5.x!)</para>
<para>Когда вы подключаете USB-носитель, ivman, запущеный от root монтирует его автоматически, но вы не можете размонтировать его иначе, чем от root. Это можно устранить, настроив HAL на монтирование всех устройств хранения данных с опцией "users", чего вам может очень не хотеться. </para>
<para>Создайте файл с названием whatever.fdi в директории /usr/share/hal/fdi/95userpolicy/ со следующим содержимым: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: whatever.fdi </para>
</entry>
</row>
<row>
<entry>
<para> &lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; &lt;!-- -*- SGML -*- --&gt; </para>
<para>  &lt;deviceinfo version="0.2"&gt; </para>
<para>    &lt;!-- Append users to default mount options --&gt; </para>
<para>   &lt;device&gt; </para>
<para>     &lt;merge key="storage.policy.default.mount_option.users" type="bool"&gt;true&lt;/merge&gt; </para>
<para>   &lt;/device&gt; </para>
<para>  &lt;/deviceinfo&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Для дополнительной информации смотрите <ulink url="http://cvs.freedesktop.org/*checkout*/hal/hal/doc/spec/hal-spec.html">HAL Specifications</ulink>. </para>
<para/>
<para>Решение проблемы неразмонитирования флешки после ее физического удаления</para>
<para>Иногда может возникать ситуация что после удаления флешки команда mount выдает что она подмонтирована, в результате следующие подсоединение флешки приводит к тому что ей присваевается следующая буква и в резульатет чего возникает множество мертвых точек монтирования </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Пример ситуации когда два раза вынута и вставлена одна и таже флешка </para>
</entry>
</row>
<row>
<entry>
<para>#mount</para>
<para>/dev/sdb1 on /media/sdb1 type vfat (rw,noexec,nosuid,nodev,quiet,shortname=mixed,uid=104,gid=412,umask=007,fmask=0117,dmask=0007,iocharset=utf8)</para>
<para>/dev/sdc1 on /media/sdc1 type vfat (rw,noexec,nosuid,nodev,quiet,shortname=mixed,uid=104,gid=412,umask=007,fmask=0117,dmask=0007,iocharset=utf8)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>это происходит из за того что по умолчанию ivman для размонтирования вызывает команду pumount /dev/sdb1, которая нечего не выполняет выдавая что /dev/sdb1 нет (udev успевает удалить это устройсво) </para>
<para>решение проблемы следующее правим /etc/ivman/IvmConfigBase.xml таким образом </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/ivman/IvmConfigBase.xml </para>
</entry>
</row>
<row>
<entry>
<para>    &lt;!-- mount command.  default is autodetected.  Must be specified with</para>
<para>         umountcommand. --&gt;</para>
<para>    &lt;ivm:Option name="mountcommand" value="/usr/bin/pmount -u 007 '$hal.block.device$'" /&gt;</para>
<para/>
<para>    &lt;!-- umount command.  default is autodetected.  Must be specified with</para>
<para>         mountcommand. --&gt;</para>
<para>    &lt;ivm:Option name="umountcommand" value="/usr/bin/sudo /bin/umount -l '$hal.block.device$'" /&gt;</para>
<para/>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>а так же добавляя в /etc/sudoers строчку </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/sudoers </para>
</entry>
</row>
<row>
<entry>
<para>   ivman   ALL = NOPASSWD: /bin/umount</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>sudo конечно же должен быть установлен. </para></sect3><sect3><title>Разное</title>
<para>HAL может потребовать добавление coldplug на уровень загрузки boot для работы распознавания USB-устройств. </para>
<para>Если у вас проблемы с пользовательскими запусками ivman для автомонтирования USB flash, вам может потребоваться включить поддержку utf-8 в вашем ядре. Смотрите это <ulink url="http://forums.gentoo.org/viewtopic-p-3283175.html#3283175">обсуждение на форуме</ulink> для подробностей. </para></sect3><sect3><title>Другие проблемы</title>
<para>Если ivman не работает, для начала остановите его: </para>
<para>/etc/init.d/ivman stop </para>
<para>Отредактируйте базовые настройки: </para>
<para>nano -w /etc/ivman/IvmConfigBase.xml </para>
<para>Отключите fork, и включите отладку. Потом запустите ivman из консоли. Смотрите сообщения. </para>
<para>Источник — «<ulink url="http://ru.gentoo-wiki.com/HOWTO_Ivman">http://ru.gentoo-wiki.com/HOWTO_Ivman</ulink>»</para>
<para/>
<para/>
<para/></sect3></sect2><sect2><title>Настройка дисковой подсистемы</title><sect3><title>Всеобщий ликбез</title>
<para/>
<para>Под IDE понимаются устройства, подключаемые к IDE-интерфейсу. Обычно это жесткие диски и дисководы CD-ROM. Эти устройства должны быть документированы, как:</para>
<para/>
<orderedlist>
<listitem>
<para>IDE </para>
</listitem>
<listitem>
<para>ATA </para>
</listitem>
<listitem>
<para>ATAPI </para>
</listitem>
<listitem>
<para>Enhanced IDE (EIDE) </para>
</listitem>
<listitem>
<para>Fast ATA или Fast ATA-2 </para>
</listitem>
</orderedlist>
<para/>
<para>IDE устройства могут передавать данные по шине в двух режимах - PIO и DMA. Учтите, что это именно передача данных по шине, с пластины данные читаются медленнее, а вот из аппаратного кеша на полной скорости. </para>
<para/>
<para>PIO - Программный ввод/вывод, метод передачи данных между двумя устройствами, использующий процессор как часть маршрута данных (процессор выполняет команду чтения порта, считывает байт или слово данных в свой регистр, после чего переписывает его в память, затем повторяет эту процедуру до тех пор, пока вся необходимая информация не будет считана из устройства в память). </para>
<para/>
<para>Бывает PIO Mode 0 1 2 3 4. Чем больше номер режима, тем быстрее. IDE ZIP100 приводы от Iomega например умеют только PIO mode 0. Старые CD-ROM обычно умеют PIO mode 4, если не могут DMA.</para>
<para/>
<orderedlist>
<listitem>
<para>PIO Mode 0 = 3.3 Mb/s </para>
</listitem>
<listitem>
<para>PIO Mode 1 = 5.2 Mb/s </para>
</listitem>
<listitem>
<para>PIO Mode 2 = 8.3 Mb/s </para>
</listitem>
<listitem>
<para>PIO Mode 4 = 11.1 Mb/s </para>
</listitem>
<listitem>
<para>PIO Mode 5 = 16.7 Mb/s </para>
</listitem>
</orderedlist>
<para/>
<para>DMA - Direct Memory Access - прямой доступ к памяти - собирательное название протоколов, позволяющих периферийному устройству передавать информацию непосредственно в системную память без участия центрального процессора, жесткие диски используют эту возможность в сочетании с возможностью перехватывать управление шиной и самостоятельно управлять передачей информации (bus mastering), что уменьшает нагрузку на процессор и повышает скорость передачи данных. </para>
<para/>
<para>DMA встречается двух типов: UDMA и MDMA. </para>
<para/>
<para>UDMA - ultra DMA - наиболее предпочитаемый тип, основной на сегодня. Бывает UDMA 0 1 2 3 4 5 6. Реально встречаются:</para>
<para/>
<orderedlist>
<listitem>
<para>UDMA 2 = 33 mb/s </para>
</listitem>
<listitem>
<para>UDMA 4 = 66 mb/s </para>
</listitem>
<listitem>
<para>UDMA 5 = 100 mb/s </para>
</listitem>
<listitem>
<para>UDMA 6 = 133 mb/s </para>
</listitem>
</orderedlist>
<para/>
<para>Последний встречается на не Intel матерях и не все винты его умеют. Кстати SATA винчестеры используют UDMA = 150 Mb/s. </para>
<para>Для UDMA 66 - 100 - 133 необходим 80-жильный шлейф, кроме того старые матери умеют его не на всех каналах, смотрите в инструкцию. Форсирование этих режимов с 40-жильным шлейфом может убить Ваши данные. </para>
<para>MDMA - multiword dma, более древний режим, предпочтителен для старых винчестеров и CD-ROM.</para>
<para/>
<orderedlist>
<listitem>
<para>MDMA0 = 4.2 mb/s </para>
</listitem>
<listitem>
<para>MDMA1 = 13.3 mb/s </para>
</listitem>
<listitem>
<para>MDMA2 = 16.7 mb/s </para>
</listitem>
</orderedlist>
<para/>
<para>На большинстве современных систем ядро автоматически определяет и настраивает IDE подсистему на максимальную производительность, если правильно его сконфигурировать. Но настроить что-нибудь всё равно можно. </para>
<para/>
<para>ОЧЕНЬ ВАЖНО </para>
<para>Всё нижеописанное может убить Ваши данные, сломать Вам винчестер, спалить Вашу машину, удивить Вашу кошку и т.п. отмазы :) </para>
<para>Всё нижеописанное тестировалось, работало и работает на пяти машинах с ядром 2.6.9-gentoo-r4 и hdparm-5.7-r1, ACCEPT_KEYWORDS="~x86". </para>
<para/>
<para>У Вас что-нибудь может не работать, работать не так. </para>
<para/>
<para>ВАЖНО </para>
<para>Всё нижеописанное не относится к SATA дискам работающим через libata интерфейс (то есть видимым как sdX а не hdX). Поскольку sata интерфейс гораздо ближе к scsi чем к pata, разработчики вполне обоснованно используют scsi подсистему для работы с sata. Поэтому на текущий момент настройка sata винчестеров средствами hdparm невозможна, так как в libata не реализована специфичная для подобных програм функциональность. </para>
<para/>
<para>В Сети есть патчик на ядро, добавляющий нужный функционал, но он ОЧЕНЬ сыр и с вероятностью в 100% убьёт вам раздел. Даже ссылку давать не буду, если Вы камикадзе, сами найдёте. </para><sect4><title>Для начала</title>
<para>Убедитесь, что Ваши IDE диски используют DMA интерфейс, и ядро правильно настроено. </para>
<para>Для этого сделайте :</para>
<para>dmesg | less </para>
<para>или загляните в логи. </para>
<para>Нас будут интересовать сообщения о настройке ide контроллера и дисков. Мой кусок kern.log выглядит так (с моими комментариями): </para>
<para>Nov 14 17:45:54 tsoptimus kernel: ide: Assuming 33MHz system bus speed for PIO modes; override with idebus=xx</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Можно при загрузке сказать ядру idebus=66, но это работает только для                                        не использующих DMA винчестеров и сидиромов. Подробности в /usr/src/linux/Documentation/ide.txt</para>
<para>Nov 14 17:45:54 tsoptimus kernel: ICH2: IDE controller at PCI slot 0000:00:1f.1</para>
<para>Nov 14 17:45:54 tsoptimus kernel: ICH2: chipset revision 2</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Определили первый контроллер.</para>
<para>Nov 14 17:45:54 tsoptimus kernel: ICH2: not 100%% native mode: will probe irqs later</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Это из-за того что интеловский контроллер использует разные прерывания для</para>
<para>каждого из каналов. Это нормально.</para>
<para>Nov 14 17:45:54 tsoptimus kernel:     ide0: BM-DMA at 0xf000-0xf007, BIOS settings: hda:DMA, hdb:pio</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>контроллер работает в busmaster режиме, dma для первого диска включен в BIOS. </para>
<para>Nov 14 17:45:54 tsoptimus kernel:     ide1: BM-DMA at 0xf008-0xf00f, BIOS settings: hdc:pio, hdd:DMA</para>
<para>Nov 14 17:45:54 tsoptimus kernel: Probing IDE interface ide0...</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hda: ST340016A, ATA DISK drive</para>
<para>Nov 14 17:45:54 tsoptimus kernel: ide0 at 0x1f0-0x1f7,0x3f6 on irq 14</para>
<para>Nov 14 17:45:54 tsoptimus kernel: Probing IDE interface ide1...</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hdd: DV-516E, ATAPI CD/DVD-ROM drive</para>
<para>Nov 14 17:45:54 tsoptimus kernel: ide1 at 0x170-0x177,0x376 on irq 15</para>
<para>Nov 14 17:45:54 tsoptimus kernel: PDC20265: IDE controller at PCI slot 0000:02:0a.0</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Определили интегрированный promise контроллер</para>
<para>Nov 14 17:45:54 tsoptimus kernel: ACPI: PCI interrupt 0000:02:0a.0[A] -&gt; GSI 17 (level, low) -&gt; IRQ 17</para>
<para>Nov 14 17:45:54 tsoptimus kernel: PDC20265: chipset revision 2</para>
<para>Nov 14 17:45:54 tsoptimus kernel: PDC20265: 100%% native mode on irq 17</para>
<para>Nov 14 17:45:54 tsoptimus kernel: PDC20265: (U)DMA Burst Bit ENABLED Primary MASTER Mode Secondary MASTER Mode.</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>BIOS этого уродца не включает DMA, поэтому его включило ядро :)</para>
<para>Nov 14 17:45:54 tsoptimus kernel:     ide2: BM-DMA at 0xac00-0xac07, BIOS settings: hde:pio, hdf:pio</para>
<para>^^^^^^^</para>
<para>Что мы собственно и наблюдаем.</para>
<para>Nov 14 17:45:54 tsoptimus kernel:     ide3: BM-DMA at 0xac08-0xac0f, BIOS settings: hdg:pio, hdh:pio</para>
<para>Nov 14 17:45:54 tsoptimus kernel: Probing IDE interface ide2...</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hde: FUJITSU MPG3204AT E, ATA DISK drive</para>
<para>Nov 14 17:45:54 tsoptimus kernel: ide2 at 0x9c00-0x9c07,0xa002 on irq 17</para>
<para>Nov 14 17:45:54 tsoptimus kernel: Probing IDE interface ide3...</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hda: max request size: 128KiB</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hda: 78165360 sectors (40020 MB) w/2048KiB Cache, CHS=65535/16/63, UDMA(100)</para>
<para>^^^^^^^^</para>
<para>Говорит само за себя</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hda: cache flushes not supported</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>А вот это странно :( Ядро не сможет принудительно синхронизировать аппаратный кеш винчестера, в случае panic или oops будет не сладко. До этого было supported, разберусь...</para>
<para>Nov 14 17:45:54 tsoptimus kernel:  /dev/ide/host0/bus0/target0/lun0: p1 p2 p3 p4</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hde: max request size: 128KiB</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hde: 40031712 sectors (20496 MB) w/512KiB Cache, CHS=39714/16/63, UDMA(100)</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hde: cache flushes not supported</para>
<para>Nov 14 17:45:54 tsoptimus kernel:  /dev/ide/host2/bus0/target0/lun0: p1 p2</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hdd: ATAPI 48X DVD-ROM drive, 256kB Cache, UDMA(33)</para>
<para>Nov 14 17:45:54 tsoptimus kernel: Uniform CD-ROM driver Revision: 3.20 </para>
<para>Проверьте настройки ядра. Мой кусок касающийся IDE выглядит так (с моими комментариями) </para>
<para># ATA/ATAPI/MFM/RLL support</para>
<para>#</para>
<para>CONFIG_IDE=y</para>
<para>CONFIG_BLK_DEV_IDE=y</para>
<para/>
<para>#</para>
<para># Please see Documentation/ide.txt for help/info on IDE drives</para>
<para>#</para>
<para># CONFIG_BLK_DEV_IDE_SATA is not set</para>
<para># CONFIG_BLK_DEV_HD_IDE is not set</para>
<para>CONFIG_BLK_DEV_IDEDISK=y</para>
<para>#CONFIG_IDEDISK_MULTI_MODE is not set</para>
<para>CONFIG_BLK_DEV_IDECD=y</para>
<para># CONFIG_BLK_DEV_IDETAPE is not set</para>
<para># CONFIG_BLK_DEV_IDEFLOPPY is not set</para>
<para># CONFIG_BLK_DEV_IDESCSI is not set</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Был нужен для пишущих cdrom, сейчас не нужен (даже вреден)</para>
<para/>
<para>CONFIG_IDE_TASK_IOCTL=y</para>
<para>CONFIG_IDE_TASKFILE_IO=y</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Не разбирался :)</para>
<para>#</para>
<para># IDE chipset support/bugfixes</para>
<para>#</para>
<para># CONFIG_IDE_GENERIC is not set</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Не нужен если Ваши IDE контроллеры известны ядру. У 99% людей они известны. Посему выключен.</para>
<para># CONFIG_BLK_DEV_CMD640 is not set</para>
<para>CONFIG_BLK_DEV_IDEPCI=y</para>
<para>CONFIG_IDEPCI_SHARE_IRQ=y</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Разрешает устройству совместно использовать одно прерывание с другими устройствами. </para>
<para>В случае проблем можно выключить.</para>
<para># CONFIG_BLK_DEV_OFFBOARD is not set</para>
<para># CONFIG_BLK_DEV_GENERIC is not set</para>
<para># CONFIG_BLK_DEV_OPTI621 is not set</para>
<para># CONFIG_BLK_DEV_RZ1000 is not set</para>
<para>CONFIG_BLK_DEV_IDEDMA_PCI=y</para>
<para># CONFIG_BLK_DEV_IDEDMA_FORCED is not set</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>ОПАСНО!!!! Если ваш винт или контроллер совсем никак не умеет DMA</para>
<para>или blacklisted, то есть риск потерять раздел.</para>
<para>CONFIG_IDEDMA_PCI_AUTO=y</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>А вот это значительно нежнее :) Если с винтом и контроллером всё в порядке, ядро само включит Вам DMA.</para>
<para># CONFIG_IDEDMA_ONLYDISK is not set</para>
<para>Ежели ваш CDROM глючит с DMA или работает медленне чем в PIO режиме, ядро включит DMA только для винчестеров.</para>
<para># CONFIG_BLK_DEV_AEC62XX is not set</para>
<para># CONFIG_BLK_DEV_ALI15X3 is not set</para>
<para># CONFIG_BLK_DEV_AMD74XX is not set</para>
<para># CONFIG_BLK_DEV_ATIIXP is not set</para>
<para># CONFIG_BLK_DEV_CMD64X is not set</para>
<para># CONFIG_BLK_DEV_TRIFLEX is not set</para>
<para># CONFIG_BLK_DEV_CY82C693 is not set</para>
<para># CONFIG_BLK_DEV_CS5520 is not set</para>
<para># CONFIG_BLK_DEV_CS5530 is not set</para>
<para># CONFIG_BLK_DEV_HPT34X is not set</para>
<para># CONFIG_BLK_DEV_HPT366 is not set</para>
<para># CONFIG_BLK_DEV_SC1200 is not set</para>
<para>CONFIG_BLK_DEV_PIIX=y</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Контроллер моей материнки</para>
<para># CONFIG_BLK_DEV_NS87415 is not set</para>
<para>CONFIG_BLK_DEV_PDC202XX_OLD=y</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Второй контроллер моей материнки</para>
<para>CONFIG_PDC202XX_BURST=y</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Форсируем DMA для promise, так как его биос DMA не включает. Странный он.</para>
<para># CONFIG_BLK_DEV_PDC202XX_NEW is not set</para>
<para># CONFIG_BLK_DEV_SVWKS is not set</para>
<para># CONFIG_BLK_DEV_SIIMAGE is not set</para>
<para># CONFIG_BLK_DEV_SIS5513 is not set</para>
<para># CONFIG_BLK_DEV_SLC90E66 is not set</para>
<para># CONFIG_BLK_DEV_TRM290 is not set</para>
<para># CONFIG_BLK_DEV_VIA82CXXX is not set</para>
<para># CONFIG_IDE_ARM is not set</para>
<para>CONFIG_BLK_DEV_IDEDMA=y</para>
<para># CONFIG_IDEDMA_IVB is not set</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Форсирование UDMA4 5 6 если ядро само его не включает. </para>
<para>ОПАСНО - если у Вас 40-жильный или повреждённый шлейф, вы можете убить данные.</para>
<para>CONFIG_IDEDMA_AUTO=y</para>
<para># CONFIG_BLK_DEV_HD is not set</para>
<para/></sect4><sect4><title/></sect4><sect4><title>Ускоряемся :)</title>
<para>Сделайте, если ещё не сделали, </para>
<para>emerge hdparm </para>
<para>На одной консоли сделайте:</para>
<para>man hdparm </para>
<para>А на другой мы начнём играться :) </para>
<para>Делайте: </para>
<para>hdparm -tT /dev/hdX </para>
<para/>
<para>Где X - буква вашего винчестера </para>
<para>Мы запустили тест скорости чтения из кеша и с пластины. Для усреднения результатов запустите его несколько раз. </para>
<para>Должны увидеть следующее:</para>
<para/>
<para>/dev/hda:</para>
<para>Timing cached reads:   616 MB in  2.00 seconds = 307.74 MB/sec</para>
<para>Timing buffered disk reads:   74 MB in  3.04 seconds =  42.33 MB/sec</para>
<para/>
<para>Первый результат с учётом программного кеширования, он у всех большой :) </para>
<para/>
<para>Второй - собственно чтение с диска с учётом аппаратного кеширования. </para>
<para/>
<para>Второй результат мы собственно и будем улучшать :) Цифры в районе 35-55 mb/s хороший результат, выше 50 без raid контроллера вы на парралельном интерфейсе вряд ли получите (хотя... кто знает...). Но в любом случае кроме скорости можно </para>
<para>Разбираемся с железом на железном уровне</para>
<para/>
<para>Имеет смысл заглянуть в BIOS и в корпус. </para>
<para/>
<para>ВНИМАНИЕ!!! Если вы страдаете хронической неуверенностью, криворукостью, боитесь потерять гарантию, пропустите этот раздел! </para>
<para/>
<para>Иногда сборщики компьютеров страдают излишней жадностью или криворукостью, поэтому всегда имеет смысл проверить, всё ли внутри корпуса как надо. </para>
<para/>
<para>Каждый канал IDE/AТА интерфейса поддерживает подключение двух устройств - master и slave. Конфигурация обычно задается перемычкой на устройстве. Кроме этих двух позиций там обычно присутствует и третья - cable select. Для работы устройств в положении перемычки cable select требуется специальный Y-образный шлейф, центральный разъем которого подключается к материнской плате. Крайние разъемы такого кабеля неравноправны - устройство, подключенное к одному разъему, автоматически становится master, к другому - slave. </para>
<para>Проверьте, чтобы шлейфы были 80-жильные, на 40-жильных вы не сильно ускоритесь :). </para>
<para>Каждый канал в каждый момент времени может обрабатывать только один запрос к одному устройству. Следующий запрос, пусть даже к другому устройству, будет ожидать завершения текущего. Разные каналы при этом могут работать независимо. Поэтому не стоит подключать два активно используемых устройства (например, два жестких диска), к одному каналу. </para>
<para>В идеале каждое IDE-устройство стоит подключать к отдельному каналу (в этом заключается основное преимущество SATA). </para>
<para>Практически все современные чипсеты поддерживают возможность использования различных режимов передачи данных для устройств, подключенных к одному каналу. Однако злоупотреблять этим все-таки не стоит. Два устройства, существенно различающихся по скорости, лучше все-таки разнести по разным каналам. </para>
<para>Не рекомендуется подключать к одному каналу жесткий диск и ATAPI-устройство (например, CD-ROM). Как было сказано выше, протокол ATAPI использует другую систему команд, и, кроме того, даже самые быстрые ATAPI-устройства намного медленнее жесткого диска, что может замедлить работу последнего.</para>
<para/>
<para/>
<para>Идеальная конфигурация. </para>
<para>Каждый винт и CD-ROM на отдельном шлейфе. </para>
<para/>
<para>Приемлемая конфигурация. </para>
<para>На первом канале основной винт, на втором дополнительный master и CD-ROM slave</para>
<para/>
<para>Тоже неплохо. </para>
<para>На первом канале два винчестера одного поколения, CD-ROM на втором.</para>
<para/>
<para>Плохо!!! </para>
<para>На одном канале современный винт и древняя древность на полтора гига :) </para>
<para/>
<para>Смотрим в BIOS. Включаем UDMA где только можно, включаем Bus master для контроллеров IDE, включаем IDE Block mode. </para>
<para/></sect4><sect4><title>Разбираемся с железом на софтварном уровне</title>
<para>А что умеет наш винчестер? И что у него включено сейчас?</para>
<para/>
<para>Делаем: </para>
<para>hdparm -iIv /dev/hdX | less </para>
<para/>
<para>Получаем длинный листинг с описанием возможностей нашего винчестера. Пример моего с комментариями приведён ниже. </para>
<para>Эта секция коротко описывает, что у нас включено прямо сейчас.</para>
<para/>
<para>/dev/hda:</para>
<para>multcount    = 16 (on)</para>
<para>IO_support   =  1 (32-bit)</para>
<para>unmaskirq    =  1 (on)</para>
<para>using_dma    =  1 (on)</para>
<para>keepsettings =  0 (off)</para>
<para>readonly     =  0 (off)</para>
<para>readahead    = 256 (on)</para>
<para>geometry     = 65535/16/63, sectors = 40020664320, start = 0</para>
<para>Эта секция показывает необработанные для читабельности данные, прочитанные напрямую с винчестера. </para>
<para>Model=ST340016A, FwRev=3.19, SerialNo=3HS9R2GG</para>
<para>Config={ HardSect NotMFM HdSw&gt;15uSec Fixed DTR&gt;10Mbs RotSpdTol&gt;.5% }</para>
<para>RawCHS=16383/16/63, TrkSize=0, SectSize=0, ECCbytes=4</para>
<para>BuffType=unknown, BuffSize=2048kB, MaxMultSect=16, MultSect=16</para>
<para>CurCHS=4047/16/255, CurSects=16511760, LBA=yes, LBAsects=78165360</para>
<para>IORDY=on/off, tPIO={min:240,w/IORDY:120}, tDMA={min:120,rec:120}</para>
<para>PIO modes:  pio0 pio1 pio2 pio3 pio4</para>
<para>DMA modes:  mdma0 mdma1 mdma2</para>
<para>UDMA modes: udma0 udma1 udma2 udma3 udma4 *udma5</para>
<para>AdvancedPM=no WriteCache=enabled</para>
<para>Drive conforms to: device does not report version:</para>
<para/>
<para>* signifies the current active mode</para>
<para>А вот это более интересно. Читайте комментарии в ней самой. </para>
<para>ATA device, with non-removable media</para>
<para>       Model Number:       ST340016A</para>
<para>       Serial Number:      3HS9R2GG</para>
<para>       Firmware Revision:  3.19</para>
<para>Standards:</para>
<para>       Supported: 5 4 3 2</para>
<para>       Likely used: 6</para>
<para>Configuration:</para>
<para>       Logical         max     current</para>
<para>       cylinders       16383   4047</para>
<para>       heads           16      16</para>
<para>       sectors/track   63      255</para>
<para>       --</para>
<para>       CHS current addressable sectors:   16511760</para>
<para>       LBA    user addressable sectors:   78165360</para>
<para>       device size with M = 1024*1024:       38166 MBytes</para>
<para>       device size with M = 1000*1000:       40020 MBytes (40 GB)</para>
<para>Capabilities:</para>
<para>       LBA, IORDY(can be disabled)</para>
<para>       bytes avail on r/w long: 4      Queue depth: 1</para>
<para>       Standby timer values: spec'd by Standard</para>
<para>       R/W multiple sector transfer: Max = 16  Current = 16</para>
<para>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>       Аппаратное блочное чтение. Может читать зараз 16 блоков. Так и делает.</para>
<para/>
<para>       Recommended acoustic management value: 128, current value: 254</para>
<para>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>       Управление акустикой. Чем больше значение, тем шумнее и быстрее.</para>
<para/>
<para>       DMA: mdma0 mdma1 mdma2 udma0 udma1 udma2 udma3 udma4 *udma5</para>
<para>            Cycle time: min=120ns recommended=120ns</para>
<para>       PIO: pio0 pio1 pio2 pio3 pio4</para>
<para>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>       Поддерживаемые режимы передачи. Звёздочка показывает текущий. </para>
<para> </para>
<para>            Cycle time: no flow control=240ns  IORDY flow control=120ns</para>
<para>Commands/features:</para>
<para>       Enabled Supported:</para>
<para>          *    READ BUFFER cmd</para>
<para>          *    WRITE BUFFER cmd</para>
<para>          *    Host Protected Area feature set</para>
<para>          *    Look-ahead</para>
<para>          *    Write cache</para>
<para>          *    Power Management feature set</para>
<para>               Security Mode feature set</para>
<para>          *    SMART feature set</para>
<para>               Device Configuration Overlay feature set</para>
<para>          *    Automatic Acoustic Management feature set</para>
<para>               SET MAX security extension</para>
<para>          *    DOWNLOAD MICROCODE cmd</para>
<para>Security:</para>
<para>       Master password revision code = 65534</para>
<para>               supported</para>
<para>       not     enabled</para>
<para>       not     locked</para>
<para>       not     frozen</para>
<para>       not     expired: security count</para>
<para>       not     supported: enhanced erase </para>
<para>HW reset results:</para>
<para>       CBLID- above Vih</para>
<para>       Device num = 1</para>
<para>Checksum: correct</para>
<para/>
<para>Имея эту информацию, мы можем ручками настраивать наш винчестер. Те параметры, которые и так настроены, настраивать не обязательно :). Сверяйтесь с man для hdparm, я расскажу про наиболее интересные параметры. \</para>
<para>Собственно настраиваем</para>
<para>Итак, параметры мы передаём как:</para>
<para> </para>
<para>hdparm -параметр /имя/диска</para>
<para/>
<para>Если hdparm ругается, значит или режим не поддерживается, или параметр не верный. Если режим не поддерживается, команда dmesg покажет нам последней строчкой ругань драйвера.</para>
<para/></sect4><sect4><title>Интересные параметры </title>
<para/>
<para>-a Количество секторов упреждающего чтения для файловой системы, то есть софтварное упреждающее чтение. Обычно значение по дефолту приемлемое, а наличие аппаратного упреждающего чтения смазывает эффект. Чем меньше, тем лучше в случае чтения кучи мелких файлов разбросанных хаотично по диску. Чем больше число, тем лучше для копирования фильмов и mp3. </para>
<para/>
<para>-A Включение аппаратного упреждающего чтения винчестером. Обычно всегда включено по дефолту. Изменять следует, если в вышеописаном информационном выводе не стоит звёздочка перед Look-ahead в разделе Enabled Supported. 1 - включено, 0 - выключено. </para>
<para/>
<para>-B Имеет смысл для нотебуков, управляет настройкой энергосбережения. Чем значение ниже, тем больше у винта желание остановить блин и заснуть :), от чего растёт время отклика. Значение 255 вырубает управление питанием, соответственно уменьшая время отклика. Не все винчестеры имеют собственное управление питанием. Проверьте параметр AdvancedPM= в коротком листинге с сырыми данными. </para>
<para/>
<para>-c Значение 1 включает 32 битную передачу по внутренней шине, по шлейфу возможно только 16 бит. Значение 3 включает то-же самое с контролем чётности. Это более надёжно, но чуть медленне чем 1. По умолчанию всегда выключено, имеет смысл включить. разницы между 1 и 3 не заметил ни по скорости, ни по надёжности. </para>
<para/>
<para>-d 1 - включено, 0 - нет. Признак использования DMA. Если у Вас стоит звёздочка напротив одного из dma режимов в вышеприведённых листингах, значит Вам этот параметр не нужен. Если не стоит, можно попробовать включить. ВНИМАНИЕ!!! Машина может зависнуть, раздел может навернуться!!! Если это случилось, что-то крепко не в порядке с железом или ядром!!! </para>
<para/>
<para>-E Скорость cdrom. Если сильно воет... Просто укажите желаемую скорость. Для винтов бесполезен :) </para>
<para/>
<para>-k и -K Сохранение настроек и опций винчестером. Это не означает что они автоматически сохранятся после перезагрузки. Это означает, что они сохранятся, если драйвер сделает reset контроллеру, или после спячки, но не гибернации (aka suspend to disk). 1 - сохранять. 0 - нет. </para>
<para/>
<para>-m Количество секторов для аппаратного упреждающего чтения. Не может быть больше чем умеет винт. Смотреть в диагностический листинг, параметр MaxMultSect=. По дефолту обычно всегда максимум. </para>
<para/>
<para>-M Управление акустикой. 254 - шумно и быстро. 0 - медленно и тихо. Многие драйвы умеют только 128 и 254. Многие вообще нисколько не умеют :) </para>
<para/>
<para>-P Ещё одна ручка для регулирования аппаратного упреждающего чтения. Не работает ни на одном виденном мною винте. Может у Вас заработает? </para>
<para/>
<para>-u Включить размаскирование прерываний. Если значение 1, то контроллер разрешает другие прерывания во время операции ввода-вывода. Это снижает нагрузку на систему и повышает отклик. Нужно включать. По умолчанию выключено. На оччень древних контроллерах система может повиснуть. </para>
<para/>
<para>-W 1 - включает кеширование записи. Включено по дефолту у всех виденных мною винтов. Но пригодится может. </para>
<para/>
<para>-X Самый мощный параметр. Позволяет вам принудительно выставить режим работы DMA. В последних версиях hdparm задаётся буквенно, например -X udma5. Внимание!!! Не включайте режимы, не поддерживаемые Вашим контроллером, или с плохим (40-жильным) шлейфом!!! Обычно ядро само выбирает максимальный режим DMA, и если оно не смогло, или выбрало как Вам кажется меньший режим чем можно, ПОДУМАЙТЕ!!! Вдруг тому есть ОБЪЕКТИВНЫЕ причины?.</para>
<para/>
<para>Пробуйте параметры по одному, запускайте hdparm -tT, смотрите в dmesg. </para>
<para>Сидиромы понимают не все параметры из указанных выше. У разных винчестеров понимание тоже может отличаться :)</para>
<para>После того как наиграетесь, будем закреплять. </para></sect4><sect4><title>Закрепляем</title>
<para>В /etc/conf.d/hdparm заносим понравившиеся параметры. У меня это выглядит так: </para>
<para>hda_args="-u1c3M254Kk"</para>
<para>hde_args="-u1c3M254Kk"</para>
<para>#hdd - cdrom</para>
<para>hdd_args="-u1c3Kk"</para>
<para/>
<para>Делаем: rc-update add hdparm default </para>
<para>Затем: /etc/init.d/hdparm start </para>
<para/></sect4><sect4><title>Выбор планировщика ввода-вывода</title>
<para/>
<para>В ядрах 2.6 появилась возможность выбирать между четырьмя планировщиками ввода-вывода. У каждого планировщика есть свои достоинства и недостатки. По дефолту в ядро всунуты все четыре, и выбран anticipatory io cheduler. Кратенько опишу их. </para>
<para>no-op - очень мелкий и лёгкий планировщик. Мало чего умеет. Для винтов не пригоден. В основном используется если вместо винта - флеш. </para>
<para>anticipatory - выбирается по дефолту. Середина-наполовину для всего на свете. И там хорош, и тут хорош. </para>
<para>deadline - более лёгкий и простой чем anticipatory, лучше себя ведёт при "взрывных" нагрузках. При равномерной нагрузке имеет особенность задумываться и притормаживать. </para>
<para>CFQ - размазывает ввод-вывод равномерно между всеми процессами. Ввод-вывод медленный, но плавный и равномерный независимо от загрузки. Это мой выбор на сегодня. </para></sect4><sect4><title>Как попробовать?</title>
<para>Передайте ядру в строке загрузки GRUB или другого загрузчика параметр elevator=[cfq|as|deadline|noop], поработайте, сравните. Ненужные планировщики ввода/вывода можно убрать из конфигурации ядра перед его компиляцией. Подробней можно узнать в статье "Компиляция ядра Linux". Они в </para>
<para>general setup -&gt;</para>
<para>   Configure standart kernel features...</para>
<para/>
<para>Как нибудь потом расскажу про тюнинг vm и свопа ... </para>
<para/>
<para/></sect4></sect3></sect2><sect2><title>Работа с CD/DVD</title><sect3><title>Основные программы </title>
<para/>
<para>Для начала, убедитесь что у вас установлены программы cdrecord и mkisofs, которые входят в пакет cdrtools. Если нет -- установите его: </para>
<para/>
<para>emerge cdrtools </para>
<para/>
<para>Конфигурация ядра и загрузчика </para>
<para/>
<para>Убедитесь, что у вас ядро настроено соответствующим образом. </para>
<para/>
<para>Ядра серии 2.4.x </para>
<para/>
<para>Для ядер серии 2.4.x в ядро необходимо включить поддержку SCSI эмуляции: Linux Kernel Configuration: </para>
<para/>
<para>Конфигурация ядра 2.4.x </para>
<para>ATA/IDE/MFM/RLL Support --&gt;</para>
<para>    IDE, ATA, and ATAPI Block Devices --&gt;</para>
<para>        &lt;M&gt; SCSI Emulation Support</para>
<para>SCSI Support --&gt;</para>
<para>    &lt;M&gt; SCSI Support</para>
<para>    &lt;M&gt; SCSI CDROM Support</para>
<para>    &lt;M&gt; SCSI Generic Support</para>
<para/>
<para/>
<para>Теперь, еще необходимо ядру при загрузке передать параметр hdc=ide-scsi (в данном случае предполагается, что ваш CD привод - это hdc). </para>
<para/>
<para>Т.е. если вы используете grub, то его конфиг должен выглядеть примерно так: </para>
<para/>
<para>Файл: /boot/grub/grub.conf </para>
<para>title Gentoo Linux</para>
<para> root (hd#,#)</para>
<para> kernel (hd#,#)/YOUR_KERNEL_NAME_HERE root=/dev/hdx# hdc=ide-scsi ANY_OTHER_KERNEL_OPTIONS_NEEDED</para>
<para/>
<para>Т.е. если вы используете grub, то его конфиг должен выглядеть примерно так: </para>
<para>Файл: /boot/grub/grub.conf </para>
<para>title Gentoo Linux</para>
<para> root (hd#,#)</para>
<para> kernel (hd#,#)/YOUR_KERNEL_NAME_HERE root=/dev/hdx# hdc=ide-scsi ANY_OTHER_KERNEL_OPTIONS_NEEDED</para>
<para/>
<para>Если вы ипользуете lilo, то соответсвующая часть конфига: </para>
<para>Файл: /etc/lilo.conf </para>
<para># Linux bootable partition config</para>
<para>    image  = /boot/YOUR_KERNEL_NAME_HERE</para>
<para>    append = "hdc=ide-scsi"</para>
<para>    root   = /dev/hdx#</para>
<para>    label  = Gentoo</para>
<para>    read-only</para>
<para/>
<para>Ядра серии 2.6.x </para>
<para/>
<para>В ядрах серии 2.6.x вам уже нет необходимости включать SCSI (и, следовательно, не надо переконфигурировать загрузчик). Вместо этого, надо указать поддержку ATAPI CDROM: Linux Kernel Configuration:</para>
<para> Конфигурация ядра 2.6.x </para>
<para>Device Drivers  --&gt;</para>
<para>    ATA/ATAPI/MFM/RLL support --&gt;</para>
<para>        &lt;*&gt; Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support</para>
<para>            &lt;*&gt; Include IDE/ATAPI CDROM support</para>
<para/>
<para/>
<para>Подготовка ISO образа </para>
<para>Для начала, создайте папку: </para>
<para>mkdir /tmp/iso </para>
<para>а затем скопируйте все файлы, которые вы хотите записать, в созданную папку. cp *.doc /tmp/iso </para>
<para>Затем создайте image.iso mkisofs -o /tmp/image.iso /tmp/iso </para>
<para/>
<para>Дополнительные опции при создании ISO образа </para>
<para>-r : добавляет (частично) поддержку так называемых расширений Rock Ridge, т.е. сохраняет специфичные для unix аттрибуты файлов. Например, добавляет поддержку длинных имён (до 255 символов, но не для MS Windows), символических ссылок. В отличие от опции -R, которая полностью соответсвует Rock Ridge, права доступа на файлы не сохраняются, они становятся доступны для чтения любому пользователю. </para>
<para>-jcharset=koi8-r: подразумевает под собой 2 опции: 1) -J включает поддержку Joliet, которая используется для распознавания длинных имён файлов под MS Windows; 2) -input-charset: устанавливает перекодировку символов для корректного отображения русских имён файлов. ("koi8-r" здесь дано для примера - замените на кодироку, используемую в вашей системе) </para>
<para>-joliet-long: Позволяет, чтобы имена Joliet могли быть установлены в 103 Unicode сивволы.  Это нарушает Joliet спецификацию - но работает. Используйте с осторожностью.</para>
<para>-f : следование символическим ссылкам. Если вместо копирования файлов в /tmp/iso, вы просто создаёте в этой директории симлинки на них, то вы должны включить эту опцию. </para>
<para>-C : эта опция необходима, если вы хотите дописать мультисессионный диск (см. раздел [Как дописывать диски]) </para><sect4><title>Определение ATAPI-приводов </title>
<para/>
<para>Выполните cdrecord --dev=ATAPI --scanbus </para>
<para/>
<para>Вы должны увидеть нечто похожее на следующее: </para>
<para/>
<para>Cdrecord-Clone 2.01a25 (i686-pc-linux-gnu) Copyright (C) 1995-2004 J?rg Schilling</para>
<para>scsidev: 'ATAPI'</para>
<para>devname: 'ATAPI'</para>
<para>scsibus: -2 target: -2 lun: -2 </para>
<para>Warning: Using ATA Packet interface.</para>
<para>Warning: The related libscg interface code is in pre alpha. </para>
<para>Warning: There may be fatal problems. </para>
<para>Using libscg version 'schily-0.8'.</para>
<para>scsibus0:</para>
<para>       0,0,0     0) 'SONY    ' 'CD-RW  CRX175A1 ' '5YS2' Removable CD-ROM</para>
<para>       0,1,0     1) *</para>
<para>       0,2,0     2) *</para>
<para>       0,3,0     3) *</para>
<para>       0,4,0     4) *</para>
<para>       0,5,0     5) *</para>
<para>       0,6,0     6) *</para>
<para>       0,7,0     7) *</para>
<para/>
<para>Здесь показано, что на шине 0,0,0 есть CD-RW привод. Предупреждение: В новых версиях cdrtools (2.01.01) и ядра 2.6.x надо писать cdrecord --dev=ATA --scanbus </para>
<para/></sect4><sect4><title>Запись ISO образа </title>
<para/>
<para>cdrecord --dev=ATA:0,0,0 /tmp/image.iso </para>
<para/>
<para>(Замените шину 0,0,0 на необходимую) Примечание: Вместо dev=ATA:0,0,0 можно указывать просто имя устройства, напирмер, dev=/dev/cdrw </para>
<para/></sect4><sect4><title>Дополнительные возможности </title>
<para/>
<para>Используйте опцию --speed=# для указания скорости записи </para>
<para/>
<para>cdrecord --dev=ATAPI:0,0,0 --speed=4 /tmp/image.iso </para>
<para/>
<para>Используйте --blank=fast для быстрой очистки CD-RW диска. </para>
<para/>
<para>cdrecord --dev=ATAPI:0,0,0 --blank=fast </para>
<para/>
<para>Большинство современных записывающих устройств поддерживает технологию BURN-free. К сожалению она не включена по умолчанию при запуске cdrecord. Для включения, добавьте опцию --driveropts=burnfree. Вы можете посмотреть, какие ещё опции поддерживает ваш CD-ROM посредством команды</para>
<para> cdrecord dev=/dev/cdrw driveropts=help -checkdrive </para>
<para/>
<para>Если в файле /etc/default/cdrecord установить переменную CDR_DEVICE=ATAPI:0,0,0 (можно и CDR_DEVICE=/dev/hdc), то не придется каждый раз указывать устройство (ключ --dev=ATAPI:0,0,0) и тогда для очистки CD-RW диска понадобится набрать только следуюшее: </para>
<para/>
<para>cdrecord --blank=fast </para>
<para>Если нужно разрешить пользователю запись на CD, то включите его в группу cdrom. </para>
<para/></sect4><sect4><title>Копирование дисков </title>
<para/>
<para>Если у вас всего один CD-ROM, то необходимо вначале создать файл-образ диска. Это можно сделать многими способами (с помощью dd, cat, cdrdao, readcd и т.д.). Лучше воспользоваться readcd, т.к. он уже входит в пакет cdrtools, и имеет множество интересных опций (смотри man readcd): readcd dev=/dev/cdrw -clone f=/tmp/image.iso </para>
<para>После этого запишем образ на болванку с помощью cdrecord:</para>
<para> cdrecord -v -eject dev=/dev/cdrw -raw96r -clone /tmp/image.iso </para>
<para/>
<para>ВАЖНО: Ключи -raw96r и -clone необходимы ТОЛЬКО если вы создавали файл-образ с помощью команды readcd -clone. </para>
<para/></sect4><sect4><title>Как дописывать диски </title>
<para/>
<para>Прежде всего, при создании и последующем дописывании мульти-сессионных дисков, необходимо всегда для cdrecord указывать опцию -multi, а для mkisofs использовать ключ -r или -R (т.е. включать расширение Rock Ridge). Таким образом создание первой сессий будет выглядить примерно так: Code: Запись первой сессии </para>
<para/>
<para>mkisofs -r -f -jcharset=koi8-r -o /tmp/image.iso /tmp/iso/ </para>
<para/>
<para>cdrecord -v -multi driveropts=burnfree -eject dev=/dev/cdrw /tmp/image.iso </para>
<para/>
<para>Для создания последующих сессий, нам нужна информация о номере начального сектора последней сессии и о номере сектора с которого будет начинаться новая сессия. Эта пара чисел выводится командой cdrecord -msinfo dev=/dev/cdrw. После этого данные числа указываются в команде mkisofs в качетстве аргументов к опции -C. Также, чтобы были видны файлы из предыдущей сессии, необходим ключ -M, аргументом к ключу -М служит имя устройства вашего CD-ROM (т.е. в нашем примере - это /dev/cdrw). Команда cdrecord остаётся такой же. Резюмируя вышесказанное получаем для записи последующей сессии: Code: Запись последующих сессий </para>
<para/>
<para>mkisofs -r -f -jcharset=koi8-r -C $(cdrecord dev=/dev/cdrw -msinfo) -M /dev/cdrw -o /tmp/image.iso /tmp/iso/ </para>
<para/>
<para>cdrecord -v -multi driveropts=burnfree -eject dev=/dev/cdrw /tmp/image.iso </para>
<para/>
<para/></sect4><sect4><title>Полезные ссылки </title>
<para>Классическое how-to по записи дисков на английском языке: <ulink url="http://www.tldp.org/HOWTO/CD-Writing-HOWTO.html%20">http://www.tldp.org/HOWTO/CD-Writing-HOWTO.html </ulink>
</para>
<para>То же самое на русском:</para>
<para>
<ulink url="http://www.opennet.ru/docs/HOWTO-RU/CD-Writing-HOWTO.html%20">http://www.opennet.ru/docs/HOWTO-RU/CD-Writing-HOWTO.html </ulink>
</para>
<para>Создание аудио дисков (на английском языке): en:</para>
<para>
<ulink url="http://gentoo-wiki.com/HOWTO_Create_an_Audio_CD">HOWTO Create an Audio CD</ulink>
</para>
<para/></sect4></sect3></sect2><sect2><title>Создание DVD</title><sect3><title>Введение</title><sect4><title>О чем эта статья</title>
<para/>
<para>В данной статье будет подробно рассмотрен вопрос формирования и записи видео дисков формата DVD в Gentoo Linux. </para>
<para/></sect4><sect4><title>Необходимые программы</title>
<para/>
<para>Для начала, убедитесь что у вас установлены следующие программы: transcode </para>
<para/>
<para>emerge -n transcode </para>
<para>cdrecord и mkisofs </para>
<para/>
<para>emerge -n cdrtools </para>
<para>growisofs </para>
<para/>
<para>emerge -n dvd+rw-tools </para>
<para>dvdauthor </para>
<para/>
<para>emerge -n dvdauthor </para>
<para/>
<para>также могут пригодиться: kino </para>
<para/>
<para>emerge -n kino </para>
<para/>
<para>cinelerra </para>
<para/>
<para>emerge -n cinelerra-cvs </para>
<para/>
<para>dvdrip </para>
<para/>
<para>USE='cdr mplayer ogg subtitles xvid rar' emerge -n dvdrip </para>
<para/>
<para>replex </para>
<para/>
<para>emerge -n replex </para>
<para>cdrecord-prodvd </para>
<para/>
<para>emerge -n cdrecord-prodvd </para>
<para/></sect4><sect4><title>Кодирование видео в формате DVD</title>
<para/>
<para>Использование transcode для декодирования видео произвольного формата и кодирования его в формат MPEG2, совместимый с DVD</para>
<para/>
<para>Хотелось бы заметить, что если вы не любители программ с кучей непонятных опций, то вам следует попробовать программу dvdrip, которая является неплохим фронтендом для transcode с понятным интерфейсом. </para>
<para/>
<para>Transcode, пожалуй, лучший инструмент для нашей задачи. Вам, возможно, придётся заглянуть в man страницу по transcode, чтобы понять те команды, которые используются здесь. Также вам могут пригодиться и другие инструменты для декодирования и кодирования вашего формата, так что не поленитесь заглянуть и в их man странички. Здесь будет приведен пример того, как конвертировать стандартный divx файл в широэкранный формат (без черных полос сверху и снизу). Затем мы конвертируем все это в формат letterbox 1.5:1. Зачем, спросите вы. Затем, что изначально широкоэкранный формат имеет соотношение 1.73 (16:9) с разрешением 720x416. DVD в свою очередь поддерживает размеры изображения только 720x480, 704x480, 352x480 и 352x240 (возможно это не все). Поэтому самое простое и качественное решение здесь - это привести наше видео к формату 720x480 (соотношение 1.5), добавив по 32 черных полоски сверху и снизу к изображению. </para>
<para/>
<para>transcode -i test-divx.avi -V -y mpeg -F d -Y -32,0,-32,0 -E 44100 -b 128 -o showgirls-dvd</para>
<para/>
<para>Отрицательные значения для параметра -Y сообщают transcode о том, чтобы добавить нужное количество черных полосок сверху и снизу. Если использовать положительные значения, то полоски будут соответственно убираться сверху и снизу. Часто вам может попасться видео уже в формате 720x480 или еще каком-то "хорошем" формате, тогда не нужно изменять его размеры, то есть просто не используйте опцию -Y. </para>
<para/>
<para>Here's what some of those command line arguments mean: Вот, что означают остальные опции: </para>
<para>-V     использовать YV12/I420 в качестве встроенного видео кодека [выключено изначально]</para>
<para>       Это, как правило, намного быстрее чем RGB процессинг, но </para>
<para>       некоторые импортированные модули могут не поддерживать этот формат.</para>
<para>       Используйте эту опцию всегда, когда это возможно.</para>
<para>-y vmod[,amod]</para>
<para>       видео[,аудио] модули для эксопртирования [отсутствуют изначально].  </para>
<para>       Если опустить, то transcode не будет кодировать никаким модулем.</para>
<para>       Полностью установленный transcode имеет следующие модули:</para>
<para> &lt;вырезано&gt;</para>
<para> mpeg - (видео) MPEG 1/2 | (аудио) MPEG 1 Layer II</para>
<para>     nasm должен быть доступен во время компиляции. Этот модуль не имеет</para>
<para>     зависимостей.  Этот модуль хорошо поддерживается.</para>
<para>         Инетрфейс к библиотеке bbmpeg (включена в transcode). Может</para>
<para>         кодировать в mpeg1, VCD, SVCD, MPEG2 и DVD видео форматы.</para>
<para>         Кодированое видео является отдельным файлом, который следует объединить</para>
<para>         с соответствующим аудио файлом после кодирования.</para>
<para>-F codec_string</para>
<para>       параметры енкодера [зависят от модуля].</para>
<para>       Параметр -F имеет разные значения для разных модулей.</para>
<para>&lt;вырезано&gt;</para>
<para>        -y mpeg:</para>
<para>          Синтаксис: -F "&lt;base-profile&gt;[,&lt;resizer-mode&gt;[,user-profile]]"</para>
<para>            &lt;base-profile&gt; может быть одним из:</para>
<para>              '1' = MPEG 1 (по умолчанию)</para>
<para>              'b' = big MPEG 1 (экспериментальный)</para>
<para>              'v' = VCD</para>
<para>              's' = SVCD</para>
<para>              '2' = MPEG2</para>
<para>              'd' = DVD совместимый</para>
<para>            &lt;resizer-mode&gt; может быть одним из:</para>
<para>               0 = выключить resizer (по умолчанию)</para>
<para>               1 = 352x288</para>
<para>               2 = 480x480</para>
<para>               3 = 480x576</para>
<para>               4 = 352x240</para>
<para>            &lt;user-profile&gt; Имя файла профиля. Вы можете</para>
<para>        можно указать как абсолютный путь так и относительный</para>
<para>        (относительно директории из которой запускаете transcode).</para>
<para>-Y top[,left[,bottom[,right]]]</para>
<para>       определить (для енкодера) рамку по котрой будет обрезано изображение. </para>
<para>       Отрицаельные значения будут добавлять рамку [отключено изначально].</para>
<para>-E r[,b[,c]]</para>
<para>       частота сэмплирования выходного аудио [Гц], битов на сэмпл и каналы</para>
<para>       [входящие данные]. Опция "-J resample" должна быть передана</para>
<para>       не совместимым с ресэмплингом.</para>
<para>-B n[,m[,M]]</para>
<para>       изменить размеры до высота-n*M горизонтальных полосок </para>
<para>       [,ширина-m*M] вертикальных полосок [отключено изначально,32].</para>
<para>       M должно иметь одно из значений 8, 16 или 32. Неважно какое M </para>
<para>       вы используете. Также взгляниет на флаг fast опции -Z если</para>
<para>       не хотите считать n и m вручную.</para>
<para>-b b[,v,[q,[m]]]</para>
<para>       битрейт аудио енкодера кБит/с [,vbr[,quality[,mode]]] [128,0,5,0]</para>
<para>       Параметр mode оперделяет какие модули будет использовать lame</para>
<para>       при кодировании.  Возможные значения для mode:</para>
<para>          0    Joint Stereo (по умолчанию)</para>
<para>          1    Full stereo</para>
<para>          2    Mono</para>
<para>-o file</para>
<para>       имя выходного файла, по умолчанию [/dev/null].</para>
<para/>
<para>Если бы, к примеру, наше видео имело формат 728x424, то следовало бы воспользоватья командой типа следующей: </para>
<para>transcode -i showgirls-divx.avi -V -y mpeg -F d -B 1,1,8 -E 44100 -b 128 -o showgirls-dvd</para>
<para/>
<para>Также обратитесь к опции -X для того, чтобы увеличить размеры видео. </para>
<para/>
<para>Использование tcmplex для объединения аудио и видео данных</para>
<para/>
<para>Transcode должен был создать *.m2v (mpeg-2 видео) и *.mpa (аудио) файлы в текущей директории. Теперь мы их объединим так: </para>
<para>tcmplex -o showgirls-dvd.vob -i showgirls-dvd.m2v -p showgirls-dvd.mpa -m d</para>
<para/></sect4><sect4><title>Использование kino (альтернатива transcode+tcmplex)</title>
<para/>
<para>Kino используется для получения видео с dv камер. Эта программа имеет возможности простейшего видеомонтажа (вырезать сцену, вставить, поменять местами). Она имеет удобный интерфейс для захвата видео (хотя вы можете использовать dvgrab для этой цели). Она использует фомат qt4linux mov по умолчанию для захвата. </para>
<para>Для более продвинутого монтажа cinelerra, пожалуй, пока единственный выбор под Linux. Это достаточно мощная, но достаточно долгая в освоении и пока что нестабильная (сохраняйтесь как можно чаще) программа. Вы можете просто импортировать тот же .mov полученный с помощью kino (dvgrab) в cinelerra (на самом деле, она падает при работе с большинством других форматов). Затем вы можете использовать cinelerra, чтобы привести оконченный фильм обратно к формату mov. </para>
<para>Как только вы наконец получите тот .mov файл, какой вы хотели, загрузите его опять в kino и перейдите в закладку export. Здесь вы уже можете экспортировать video в формат vcd, svcd или dvd. Формат DVD потребует достаточно много времени для конвертирования (желателен мощный процессор). </para>
<para/>
<para>Использование replex (подготовка DVB записей с цифрового телевидения (Digital Television))</para>
<para/>
<para>"Эти инструкции были испробованы на записях формата DVB-C, сделанных в Финляндии" </para>
<para/>
<para>Примечание: пожалуй, для России эта глава абсолютно бесполезна, но если есть большое желание, то я переведу и её. Мало ли, кто где живет ;) </para>
<para/>
<para>Digital television streams are transmitted as MPEG2-TS in which the TS stands for Transport Stream. This means that extra information, such as multiple audio streams, could be transferred along with the actual video. Quite fortunately, the video stream is already suitable for DVD without re-encoding which is both time consuming and stupid as it lowers the quality. Enter replex. First use czap for tuning into some channel: </para>
<para>czap -r -n 3</para>
<para/>
<para>This tunes the DVB card to channel number 3. Now, record some data by typing: </para>
<para>cat /dev/dvb/adapter0/dvr0 &gt; stream.ts</para>
<para/>
<para>This simply writes raw data from the first tuner card into a file. After awhile press CTRL-C to stop recording. </para>
<para/>
<para>Now, you should have a blob of data which could be played with e.g. mplayer. Next, you should use replex to transform TS format suitable for DVD. Enter following command: </para>
<para>replex -k -i TS -t DVD -o stream.dvd stream.ts</para>
<para/>
<para>This command ignores possible errors in original stream (-k), assumes that input file is in TS format (-i TS), outputs format suitable for DVD (-t DVD), writes to a file called stream.dvd (-o stream.dvd) and reads its input from the file entered as a last parameter (stream.ts). </para>
<para/>
<para>After a moment a file called stream.dvd should appear in the same directory where above command was entered. Now just follow the instructions from the next chapter onwards to burn this baby on a DVD. </para>
<para/></sect4><sect4><title>Создание структуры директорий (authoring) с использованием dvdauthor</title>
<para/>
<para>Это самый сложный этап! Имея готовый MPEG2 файл, воспользуйтесь программой dvdauthor (или вашим любимым графическим фронтендом к ней (например, dvdstyler)), чтобы создать структуру директорий для записи DVD (VIDEO_TS и AUDIO_TS). </para>
<para/>
<para>dvdauthor -o . showgirls-dvd.vob &amp;&amp; dvdauthor -o . -T </para>
<para/>
<para>Создание DVD образа для записи</para>
<para/>
<para>Если директории AUDIO_TS и VIDEO_TS созданы у вас в директории bar, которая в свою очередь находится в текущей директории, то введите команду: </para>
<para>mkisofs -dvd-video -o ./bar.img ./bar/</para>
<para/>
<para>и вы получите образ bar.img в текущей директории, который теперь следует записать на диск вашей любимой программой для записи дисков. </para>
<para/>
<para>Или можете записать диретории AUDIO_TS и VIDEO_TS прямо из каталога bar/ набрав: </para>
<para/>
<para>growisofs -Z /dev/dvd -dvd-video -V название_диска . </para>
<para/>
<para>Где /dev/dvd - ваш DVD-writer. </para>
<para/></sect4><sect4><title>Запись</title>
<para/>
<para>В Linux существует множество способов записи DVD. Из уже показанных можно использовать cdrecord или growisofs. </para>
<para/>
<para>С помощью графического интерфейса</para>
<para/>
<para>Формат ISO можно записать с помощью программы X-CDroast (она использует cdrecord-ProDVD, которая требует ключ, что доставляет определенное неудобство). </para>
<para/>
<para>Также можно воспользоваться прораммой k3b, котрая использует growisofs. Это, пожалуй, самый простой способ. </para>
<para/>
<para>Из командной строки</para>
<para/>
<para>Можно записать образ ещё и так: </para>
<para>cdrecord-ProDVD -dao -speed=4 -dev=/dev/dvd ./bar.img</para>
<para/>
<para>Воспользуйтесь командой cdrecord -scanbus предварительно, чтобы определить какое устройство использовать для записи. Для устройств ATAPI используйте формат -dev=/dev/dvd или -dev=/dev/hdd (зависит от машины), для эмуляции SCSI устройств используйте -dev=0,0,0 или -dev=0,0,1 (зависит от машины). </para>
<para/>
<para>Если у вас нет cdrecord-ProDVD можете использовать growisofs. </para>
<para>growisofs -dvd-compat -Z /dev/dvd=./bar.img</para>
<para/>
<para>Подсказка: С помощью growisofs вы можете писать диски налету (без создания четырёхгигабайтного файла .iso): </para>
<para>growisofs -dvd-compat -Z /dev/dvd -dvd-video ./bar</para>
<para/>
<para>Можно также воспользоваться скриптом, который расположен по адресу http://james.nontrivial.org/projdvd.htm </para>
<para/></sect4></sect3></sect2><sect2><title>Система Portage</title><sect3><title>Portage через NFS</title><sect4><title>Проблемы </title>
<para>Слишком долгое время выполнения 'emerge --sync' на всех серверах в LAN. Согласно этикету gentoo, вы не можете синхронизироваться чаще одного раза в день </para>
<para/></sect4><sect4><title>Решение </title>
<para/>
<para>Общий NFS portage. Одна машина синхронизируется под управлением cron, остальные машины монтируют свою директорию /usr/portage с помощью NFS. </para>
<para/>
<para>Общее представление </para>
<para/>
<para>1. Обязательная поддержка nfs в ядре. В случае компиляции ее как модуля, добавить соответствующие строчки в modules.autoload </para>
<para>2. Если потребуется, перезагрузить или загрузить модуль nfs </para>
<para>3. Выполнить emerge nfs-utils </para>
<para>4. Настроить NFS/fstab для автоматического монтирования общего репозитария portage. </para>
<para>5. Установить локальный PORTAGE_TMPDIR на локальную файловую систему. </para>
<para/></sect4><sect4><title>Выгоды </title>
<para>Только один сервер заботится о синхронизации portage (ночью по заданию cron'а). </para>
<para>Не нужен локальный rsync сервер. </para>
<para>Общий для всех каталог /usr/portage/distfiles означает, что вам не нужно скачивать одно и то же каждый раз, чтобы синхронизировать репозитарий portage на ваших ваши компьютерах. </para>
<para>И вообще, NFS - это классная штука ;) </para>
<para/>
<para>Предупреждение: NFS является очень скудным протоколом по части безопасности. Убедитесь, что используете его только в пределах вашей локальной сети, где вы полностью доверяете вашим пользователям. Мы вас предупредили! </para>
<para/>
<para/></sect4><sect4><title>Подробный процесс </title>
<para/>
<para>Поддержка ядра </para>
<para/>
<para>У вас ДОЛЖНА быть включена поддержка NFS в вашем ядре, либо вкомпиленная в ядро (в таком случае необходимо будет перезагрузиться): </para>
<para/>
<para>Linux Kernel Configuration: Встроенная поддержка </para>
<para>File systems ---&gt; </para>
<para>  Network File Systems ---&gt;</para>
<para>    &lt;*&gt; NFS file system support                                                                                                </para>
<para>    [*]   Provide NFSv3 client support                                                                                         </para>
<para>    [ ]   Provide NFSv4 client support (EXPERIMENTAL)                                                                          </para>
<para>    [ ]   Allow direct I/O on NFS files (EXPERIMENTAL)                                                                         </para>
<para>    &lt;*&gt; NFS server support                                                                                                     </para>
<para>    [*]   Provide NFSv3 server support                                                                                         </para>
<para>    [ ]     Provide NFSv4 server support (EXPERIMENTAL)                                                                        </para>
<para>    [ ]   Provide NFS server over TCP support (EXPERIMENTAL)                                                                   </para>
<para/>
<para/>
<para>либо в качестве модулей: </para>
<para>Linux Kernel Configuration: Включение модулей </para>
<para>File systems ---&gt; </para>
<para>  Network File Systems ---&gt;</para>
<para>    &lt;M&gt; NFS file system support                                                                                                </para>
<para>    [*]   Provide NFSv3 client support                                                                                         </para>
<para>    [ ]   Provide NFSv4 client support (EXPERIMENTAL)                                                                          </para>
<para>    [ ]   Allow direct I/O on NFS files (EXPERIMENTAL)                                                                         </para>
<para>    &lt;M&gt; NFS server support                                                                                                     </para>
<para>    [*]   Provide NFSv3 server support                                                                                         </para>
<para>    [ ]     Provide NFSv4 server support (EXPERIMENTAL)                                                                        </para>
<para>    [ ]   Provide NFS server over TCP support (EXPERIMENTAL)                                                                   </para>
<para/>
<para/>
<para>Добавляем NFS server support, так как на данной машине будет размещаться общий каталог portage. Поддержку клиента NFS можно добавить по желанию. </para>
<para/>
<para>Сохраните конфиг вашего ядра и пересоберите его. Code: Пересборка ядра </para>
<para/>
<para>gentoo # mount /boot //если это еще не сделано</para>
<para>gentoo # cd /usr/src/linux</para>
<para/>
<para>Для ядер 2.4:</para>
<para/>
<para>gentoo # make dep &amp;&amp; make bzImage modules modules_install install</para>
<para>Для ядер 2.6:</para>
<para>gentoo # make &amp;&amp; make modules_install </para>
<para/>
<para/></sect4><sect4><title>Включение поддержки</title>
<para/>
<para>Перезагрузитесь, если включили поддержку NFS в ядро, или, если вы собрали ее как модули, просто запустите: modprobe nfs </para>
<para/></sect4><sect4><title>Установка и настройка</title>
<para/>
<para>Установите пакет </para>
<para>nfs-utils: emerge nfs-utils</para>
<para>Настраиваем автоматическое монтирование общего portage </para>
<para>rc-update add portmap default </para>
<para>rc-update add nfs default </para>
<para>Отредактируйте crontab на сервере (метод зависит от того, какой cron вы используете). Для vixie-cron и dcron команда выглядит так: crontab -e Добавьте код: </para>
<para/>
<para>0 0 * * * emerge --sync &gt; /dev/null 2&gt;&amp;1 || true --nospinner &amp;&amp; emerge world -vup</para>
<para/>
<para>Отредактируйте файл /etc/exports на сервере, чтобы в нем были следующие строчки: </para>
<para>/usr/portage    ip_range/subnet(sync,no_root_squash,rw)</para>
<para/>
<para>Отредактируйте /etc/fstab на клиентах, добавив в него следующий код: </para>
<para>SERVER_IP:/usr/portage  /usr/portage  nfs  bg,hard 0 0</para>
<para/>
<para>Отредактируйте /etc/modules.autoload.d/kernel-version, добавив следующую строку: nfs</para>
<para>Примечание: Кеш портежей не расшарен через nfs. Если каждый раз вас докучает обновление кеша при команде emerge сразу после синхронизации, попробуйте добавить следующее в crontab клиентов. Это обновит кеш на компьютерах ваших клиентов спустя 10 минут после старта синхронизации на сервере. Установите время согласно скорости вашего подключения. </para>
<para/>
<para>10 0 * * * emerge --metadata </para>
<para/>
<para/>
<para>PORTAGE_TMPDIR</para>
<para/>
<para>PORTAGE_TMPDIR должен быть локальным каталогом (для скорости). </para>
<para/>
<para>Переменная PORTAGE_TMPDIR устанавливается в файле /etc/make.conf и по умолчанию указывает на /var/tmp, то есть на локальную файловую систему, но просто для того, чтобы увериться в том, что это так, а не иначе, сделайте: emerge info Если всё прошло успешно (а всё так и должно быть), вы спокойно можете очистить содержимое каталога /usr/portage на КЛИЕНТСКОЙ машине (например, чтобы освободить дополнительное свободное место на диске) </para>
<para/>
<para>Пояснение кода </para>
<para/>
<para>Запись crontab'а </para>
<para>0 0 * * * emerge --sync &gt; /dev/null 2&gt;&amp;1 || true --nospinner &amp;&amp; emerge world -vup</para>
<para/>
<para>говорит о том, что раз в сутки, в полночь будут выполнятся синхронизация с перенаправлением вывода в мусор и без бегунка и emerge world -vup и отправка письма root'у о том, что должно быть обновлено - настройте корректно почту). </para>
<para/>
<para>/etc/exports:</para>
<para>"/usr/portage" - каталог для экспорта</para>
<para>"ip_range/subnet" - только компьютеры из этого диапазона могут подключать его по сети</para>
<para>"(sync,no_root_squash,rw)" - полезные параметры, всегда мною используемые </para>
<para/>
<para>/etc/fstab:</para>
<para>"SERVER_IP:/usr/portage" - что вы хотите подключить</para>
<para>"/usr/portage" - куда вы хотите подключить</para>
<para>"nfs" - ФС ресурса</para>
<para>"bg,hard 0 0" - полезные параметры, всегда мною используемые </para>
<para/>
<para>/etc/modules.autoload.d/kernel-version:</para>
<para>"nfs" сообщает какой модуль загружать при загрузке ядра версии kernel-version </para>
<para/></sect4><sect4><title>Комментарии </title>
<para/>
<para>Советы? Пожелания? Похвала? Дайте нам знать. </para>
<para/>
<para>Если вы получаете ошибку "Error starting NFS daemon" попробуйте </para>
<para/>
<para># mount -t nfsd nfsd /proc/fs/nfsd </para>
<para/>
<para>это работает для меня.</para>
<para/></sect4></sect3></sect2><sect2><title>Настройка Portage</title><sect3><title>Portage Setup Howto </title>
<para/><sect4><title>Целевая аудитория </title>
<para/>
<para>Это руководство создается для людей, которые хотят использовать все возможности системы Portage. </para>
<para/></sect4><sect4><title>Зачем нужно это howto? </title>
<para/>
<para>Portage — это система управления пакетами Gentoo Linux. Ее возможности довольно велики — сборка пакетов из исходников, включая конфигурирование пакета на основе пользовательских USE-флагов; начальная настройка приложений; установка предкомпилированных пакетов; удаление програм; автоматическое обновление, и т. д. Однако, как показывает опыт, несмотря на отличную документацию, большинство пользователей не знают всех возможностей этой замечательной системы, поэтому очень часто Gentoo Linux подвергается незаслуженной критике. Данный документ — это попытка восполнить этот пробел. </para>
<para/></sect4><sect4><title>Профили Portage (Portage profiles) </title>
<para/>
<para>Gentoo — многоплатформенная система, при этом количество поддерживаемых архитектур постоянно увеличивается. Поэтому возникает необходимость в так называемых профилях сборки. Профиль — это набор настроек по умолчанию для определенной архитектуры, или определенного класса задач (например, для систем с повышенной безопасностью существуют профили hardened и selinux). Наличие профилей, которые легко создавать, позволяет называть Gentoo не дистрибутивом, а метадистрибутивом, то есть дистрибутивом для создания других дистрибутивов ;). Но не об этом сейчас разговор. </para>
<para/>
<para>Итак, для того, чтобы иметь работающую Gentoo-систему, необходимо выбрать себе нужный профиль. Профили по умолчанию находятся в каталоге /usr/portage/profiles. По названию профиля легко определить тот, который нужен вам. Например, 'default-x86-2004.2' — это стандартный профиль для архитектуры x86 версии 2004.2. Если в каталоге с профилем есть файл deprecated, то это означает, что данный профиль больше не поддерживается и выбирать его не следует. </para>
<para/>
<para>После того как вы определились с выбранным профилем необходимо создать симлинк /etc/make.profile на каталог с выбранным профилем. Например, ln -s /usr/portage/profiles/default-x86-2004.2 /etc/make.profile Когда выйдет новая версия Gentoo, вам не надо бежать в магазин, покупать новые диски. Достаточно просто поменять симлинк /etc/make.profile на симлинк, указывающий на каталог с новым профилем. </para>
<para/>
<para>Примечание: Сейчас идет переход на новый вид профилей — Cascading </para>
<para/>
<para>Profiles. Такие профили имеют вид: </para>
<para/>
<para>default-linux/x86/2004.2/ </para>
<para/>
<para>То есть настройки, общие для нескольких профилей не надо записывать по несколько раз. Пока что это экспериментальная фича, но если вы хотите помочь ее протестировать, то используйте на здоровье ;). </para>
<para/>
<para>Примечание: Вообще-то переход на cascading profiles уже произошел, посему надо обновить то, что написано выше в этой секции "Portage profiles" </para>
<para/>
<para/></sect4><sect4><title>Настройки профилей </title>
<para/>
<para>В профилях содержится следующая информация: </para>
<orderedlist>
<listitem>
<para>use-флаги использующиеся по умолчанию; </para>
</listitem>
<listitem>
<para>системные пакеты, то есть такие пакеты, которые устанавливаются при   emerge system; </para>
</listitem>
<listitem>
<para>маскированные пакеты; </para>
</listitem>
<listitem>
<para>Настройки сборки пакетов по умолчанию. (CFLAGS, CHOST и другие);</para>
</listitem>
<listitem>
<para>Какие пакеты надо устанавливать при наличии альтернативных. (например, xorg или xfree) </para>
</listitem>
</orderedlist>
<para/>
<para>Конфигурацию профилей напрямую менять не следует, так как ваши настройки будут удалены после следующей синхронизации с rsync-сервером. О том как правильно настраивать portage будет рассказано в следующем разделе. </para>
<para/>
<para>/etc/portage и /etc/make.conf </para>
<para>Для того, чтобы изменить конфигурацию выбранного профиля, нужно использовать конфигурационные файлы в /etc/portage. Если у вас нет этого каталога, то его необходимо создать. Вот список конфигурационных файлов, которые читает Portage во время своей работы: </para>
<para/>
<para>/etc/portage/package.mask </para>
<para>Синтаксис: в каждой строке содержится DEPEND ATOM, то есть один из знаков &gt;, &lt;, &gt;=, &lt;=, =, категорию, название и версию пакета. Логические знаки обязательны если указана версия пакета. </para>
<para>Например: &gt;=net-www/mozilla-1.7 </para>
<para/>
<para>Неправильные примеры: </para>
<para>net-www/mozilla-1.7 (нет логической операции) </para>
<para>&gt;=mozilla-1.7 (нет категории) </para>
<para/>
<para>Предназначение: Маскирует пакеты. Может использоваться для того, чтоб Portage не обновлял нужный вам пакет. Например, если вы хотите использовать apache-1.3 вместо apache-2.0 </para>
<para/>
<para>/etc/portage/package.unmask </para>
<para>Синтаксис: такой же, как и у package.mask </para>
<para>Предназначение: Демаскирует пакеты, которые маскированы в профиле. Используется для установки нестабильных пакетов. Рекомендуется использовать только тем, кто хочет протестировать какой-то нестабильный пакет. </para>
<para/>
<para>/etc/portage/profile/package.provided </para>
<para>Синтаксис: В каждой строчке содержится полное имя пакета, то есть category/name-version</para>
<para>Например: dev-lang/ghc-6.2.1-r1 </para>
<para>Предназначение: Замена 'emerge --inject'. При наличии пакета в package.provided Portage будет считать, что этот пакет уже установлен в системе.</para>
<para>Примечание: Иногда этого бывает недостаточно и пакет приходится вносить в /etc/make.profile/package.provided (который удаляется после каждого emerge sync) </para>
<para/>
<para/>
<para>/etc/portage/mirrors </para>
<para>Синтаксис: Такой же как и у файла /usr/portage/profiles/thirdpartymirrors. Предназначение: Список зеркал, которые будут использоватся в первую очередь. Можно также указать зеркала sourceforge или gnu, которые будут использоватся в первую очередь. </para>
<para>Например:  sourceforge http://keihanna.dl.sourceforge.net/sourceforge </para>
<para/>
<para>Так же можно использовать тип миррора 'local'. Такое зеркало будет проверятся, даже если в ebuild'е пакета есть RESTRICT="NOMIRROR". Например: </para>
<para/>
<para>local ftp://gentoo.linux.kiev.ua/pub/Linux/Gentoo/distfiles/ </para>
<para/>
<para/>
<para>/etc/portage/package.use </para>
<para>Синтаксис: DEPEND ATOM USE-флаги </para>
<para>Например: x11-libs/gtk+ doc </para>
<para>Предназначение: Установка индивидуальных USE-флагов для отдельных пакетов </para>
<para/>
<para>/etc/portage/package.keywords </para>
<para>Синтаксис: DEPEND ATOM KEYWORD KEYWORD — это идентификатор, который показывает, насколько стабилен пакет на данной архитектуре. Всего есть 4 вида KEYWORDS: </para>
<para>  arch — пакет стабилен на архитектуре arch </para>
<para>~arch — пакет стабилен на архитекруре arch, но еще не прошло время тестирования </para>
<para> -arch — у пакета наблюдаются проблемы на архитектуре arch. </para>
<para>      -* — пакет нестабилен на всех архитектурах </para>
<para/>
<para>Например: &gt;=app-editors/emacs-cvs-21.3 ~x86 </para>
<para>Предназначение: Установка индивидуальных KEYWORDS для отдельных пакетов. Используйте если хотите, чтоб в вашей стабильной системе были отдельные нестабильные пакеты или наоборот :) </para>
<para/>
<para>/etc/portage/categories </para>
<para>Синтаксис: В каждой строке содержится название категории. Предназначение: Используется для создание новых категорий для Portage. </para>
<para>Например: app-vasia </para>
<para>Теперь вы можете создать ebuild для пакетов категории app-vasia. emacs ${PORTDIR_OVERLAY}/app-vasia/pupkin/pupkin-0.0.1.ebuild </para>
<para/>
<para>/etc/make.conf </para>
<para>Файл /etc/make.conf служит для настройки самого процесса сборки пакетов. Никаких сложных опций там нет, читайте внимательно комментарии в /etc/make.conf.example. </para>
<para/>
<para>$PORTDIR_OVERLAY </para>
<para>Представьте себе такую ситуацию: вы хотите установить пакет, ebuild'а которого нет в официальном дереве, но кто-то уже его написал. Или вы собираетесь самостоятельно научится писать ebuild'ы, и вы хотите, чтоб Portage мог устанавливать нужные вам программы. Если вы запишете свой ebuild в /usr/portage, то он сотрется при следующей синхронизации с rsync-сервером. Для того, чтобы third-party ebuild'ы сохранялись, необходимо создать каталог для их хранения (например, /usr/local/portage) и записать его имя в переменную $PORTDIR_OVERLAY в файле /etc/make.conf. Теперь вы можете размещать свои ebuild'ы в этом каталоге, пример был показан в предыдущем разделе.</para></sect4></sect3></sect2><sect2><title>Portage Overlay</title><sect3><title>Введение</title>
<para>Это руководство расскажет о том как установить ebuild который не включен в официальное дерево портежей. </para></sect3><sect3><title>Установка Portage Overlay</title>
<para>Первым делом мы должны указать PORTAGE_OVERLAY директорию, для этого необходимо отредактировать файл /etc/make.conf </para>
<para/>
<para>Файл: /etc/make.conf </para>
<para>PORTDIR_OVERLAY="/usr/local/portage" </para>
<para/>
<para>Таким образом мы позволяем устанавливать дополнительные ebuild'ы при этом не нарушая процесс синхронизации основного дерева портежей. </para>
<para/></sect3><sect3><title>Месторасположение ebuild</title>
<para>Проверьте наличие директории /usr/local/portage, и если ее нет создайте ее install -d /usr/local/portage </para>
<para>Когда помещаете новый ebuild в /usr/local/portage, вы должны использовать такую же схему как в /usr/portage (category/program/program.ebuild) </para></sect3><sect3><title>Создание digest-файлов</title>
<para/>
<para>digest-файлы -- это файлы, которые содержат md5 суммы файлов, необходимых для установки пакетов. После того, как Portage скачает необходимые файлы, будет сделана проверка на соответствие файлов их md5-суммам (это дает возможность убедиться в целостности файлов). Для того, чтобы Portage мог устанавливать пакеты, необходим digest-файл. Digest-файл можно создать с помощью команды ebuild /usr/local/portage/category/program/program.ebuild digest Вручную редактировать созданные этой командой файлы не следует. При этом надо учитывать требования к имени ebuild-а. При переименовании ebuild-а в произвольное имя, команда </para>
<para/>
<para>ebuild /usr/local/portage/category/program/program.ebuild digest выдаст ошибку: </para>
<para/>
<para>!!! /usr/local/portage does not seem to have a valid PORTDIR structure. </para>
<para/>
<para>Чтобы этого не произошло необходимо переименовывать ebuild в то же самое имя, но с приставкой номера релиза. </para>
<para>Пример: </para>
<para>В портежах имеется ebuild: </para>
<para>/usr/portage/media-sound/ncmpc/ncmpc-0.11.1-r1.ebuild </para>
<para>И архив исходных кодов: </para>
<para>/usr/portage/distfiles/ncmpc-0.11.1.tar.gz для этого ebuild-а. </para>
<para>Вы хотите наложить свой патч и добавить ebuild вашего пропатченного пакета в систему. Для этого вы должны скопировать исходный ebuld в ваш новый, но добавить к нему приставку '-rN', где N - номер релиза. Если такая преставка уже есть - изменить её номер: </para>
<para>cp /usr/portage/media-sound/ncmpc/ncmpc-0.11.1-r1.ebuild /usr/local/portage/media-sound/ncmpc/ncmpc-0.11.1-r2.ebuild </para>
<para/>
<para/>
<para>После этого пропатчите исходные коды пакета, на который ссылается исходный </para>
<para>ebuild /usr/portage/distfiles/ncmpc-0.11.1.tar.gz</para>
<para>и сохраните его в /usr/portage/distfiles/ncmpc-0.11.1-r2.tar.gz </para>
<para/>
<para>Далее, нам нужно будет поправить наш новый ebuild: </para>
<para/>
<para>vi /usr/local/portage/media-sound/ncmpc/ncmpc-0.11.1-r2.ebuild </para>
<para>И изменить строку:</para>
<para>SRC_URI="http://mercury.chem.pitt.edu/~shank/${P}.tar.gz mirror://sourceforge/musicpd/${P}.tar.gz" </para>
<para/>
<para>На строку: </para>
<para>SRC_URI="http://mercury.chem.pitt.edu/~shank/${P}-r2.tar.gz mirror://sourceforge/musicpd/${P}-r2.tar.gz" </para>
<para/>
<para>Т.е. добавив наш префикс '-r2', чтобы система знала, какой именно файл с исходными кодами ей необходимо прописать. В данном случае скачать с сайта этот пакет конечно же не удастся, но нам этого и не требуется - нам необходимо установить нами поправленный пакет. </para>
<para/>
<para>После этого даём команду </para>
<para>ebuild /usr/local/portage/media-sound/ncmpc/ncmpc-0.11.1-r2.ebuild digest, </para>
<para>после чего emerge будет знать о вашем пакете. </para>
<para/><sect4><title>Установка нового ebuild</title>
<para/>
<para>Когда вы будете устанавливать пакет используя новый ebuild, скорее всего он будет masked, поэтому надо добавить имя пакета в /etc/portage/package.keywords </para>
<para>Создайте директорию /etc/portage/, если она еще не создана, и затем выполните команду: </para>
<para>echo "&lt;category&gt;/&lt;package&gt; ~x86" &gt;&gt;/etc/portage/package.keywords </para>
<para/>
<para>Теперь этот пакет можно установить как и любой другой: </para>
<para>emerge -p package </para>
<para>emerge package </para>
<para/></sect4><sect4><title>Дополнительно</title>
<para/>
<para>Unofficial ebuilds содержит список с коротким описанием сайтов где можно найти неофициальные пакеты Многие, написанные юзерами ebuild'ы, которые еще не попали в официальное дерево, находятся в Bugzill'е Gentoo. Найти нужные ebuild'ы можно с помощью поиска</para>
<para/></sect4></sect3></sect2><sect2><title>Экономия трафика с помощью deltup</title><sect3><title>Что это такое?</title>
<para>Как известно, программы в Gentoo Linux устанавливаются из исходников. Это чистый текст. Однако, такие программы как, например, gcc или openoffice весят непростительно много. А у большинства из нас интернет не позволяет качать файлы больших объемов, а пользователи модемов вообще толком ничего обновить не могут. Для людей, которые экономят свои деньги, и была написана программа deltup. Вместо wget мы заставляем emerge использовать getdelta. Эта программа скачивает со специального сайта не весь архив программы, а только разницу между требуемой версией и тем, что у вас есть. Если у вас нет предыдущей версии программы, то придется качать весь архив. </para></sect3><sect3><title>Установка и настройка</title>
<para>Установка deltup</para>
<para>Теперь установим deltup:</para>
<para>emerge deltup и getdelta: emerge getdelta </para>
<para/>
<para>Примечание: Если при выполнении emerge deltup выйдет ошибка "!!!All ebuilds that could satisfy "deltup" have been masked." перед командой добавьте ACCEPT_KEYWORDS="~x86" </para><sect4><title>Настройка emerge</title>
<para>Теперь нужно предупредить emerge о том что мы хотим использовать getdelta вместо wget. Для этого добавим в /etc/make.conf параметр FETCHCOMMAND: Файл: File /etc/make.conf </para>
<para>FETCHCOMMAND="/usr/bin/getdelta.sh \${URI}"</para>
<para/></sect4><sect4><title>Конфигурация getdelta</title>
<para/>
<para>У getdelta есть свой файл конфигурации:/etc/deltup/getdelta.rc. Рассмотрим некоторые полезные параметры: </para>
<para>DELTUP_SERVER - указывает на используемый deltup сервер. Рекомендуется оставить без изменений, так как deltup-сервера сейчас собраны в сеть обращение к которой идёт через один сервер linux01.gwdg.de. </para>
<para>QUEUERETRY - количество секунд, которые будет ждать getdelta,пока сервер не сделает dtu-файл. </para>
<para>MAXIMUM_ACCEPTABLE_QUEUEPOS - максимальный номер в очереди ожидания. В связи с ростом загруженности deltup-сервера имеет смысл установить число побольше. </para>
<para>REMOVE_OLD - удалять старые версии файлов. Полезно, если вы не хотите складировать дистфайлы. </para>
<para>DO_NOT_REMOVE - путь к файлу, содержащему имена файлов, которые не следует удалять при включенной опции REMOVE_OLD </para></sect4><sect4><title>Дополнительно</title>
<para>Могут возникнуть проблемы если вы скачали часть файла нужного для установки. Дело в том, что для продолжения докачки emerge использует не FETCHCOMMAND, а RESUMECOMMAND. Однако не следует менять RESUMECOMMAND на getdelta, так как getdelta не поддерживает докачку.</para>
<para/></sect4></sect3></sect2><sect2><title>Обновление портежей без доступа в интернет непосредственно из системы</title>
<para/>
<para>Данное руководство может помочь вам если с доступом в интернет из системы Gentoo проблемы. Однако у вас есть свежий portage-xxxxxxxx.tar.bz2. Если portage-xxxxxxxx.tar.bz2.md5sum не старше 40 дней(возможно это ограничение можно убрать, но автор этих строк не знает как) тогда проще сделать так : </para>
<para>Создаем папку /var/tmp/emerge-webrsync/ командой: </para>
<para># mkdir /var/tmp/emerge-webrsync/ </para>
<para>Копируем фаилы portage-xxxxxxxx.tar.bz2 и portage-xxxxxxxx.tar.bz2.md5, которые находятся к примеру, в корневом каталоге на CD-ROM диске (/mnt/cdrom/portage-xxxxxxxx.tar.bz2 и /mnt/cdrom/portage-xxxxxxxx.tar.bz2.md5sum), командами: </para>
<para># cp /mnt/cdrom/portage-xxxxxxxx.tar.bz2 /var/tmp/emerge-webrsync/ </para>
<para>#cp /mnt/cdrom/portage-xxxxxxxx.tar.bz2.md5sum /var/tmp/emerge-webrsync/</para>
<para>и обновляем портежи при помощи </para>
<para>emerge -webrsync: # emerge-webrsync </para>
<para/>
<para>Теперь мы получили систему портежей по состоянию на xxxxxxxx. </para>
<para>Если же portage-xxxxxxxx.tar.bz2 старше 40 дней тогда: </para>
<para>Первым делом переименовываем каталог /usr/portage например в /usr/portage2: </para>
<para># mv /usr/portage /usr/portage2 </para>
<para>затем создаем переименнованный /usr/portage: </para>
<para># mkdir /usr/portage </para>
<para>Перемещаем из /usr/portage2/distfiles исходники (если вам они нужны :) ) обратно в /usr/portage/distfiles: </para>
<para># cp /usr/portage2/distfiles /usr/portage/distfiles </para>
<para>Теперь можно распаковывать наш новый portage-xxxxxxxx.tar.bz2, который находится, к примеру, в корневом каталоге на CD-ROM диске (/mnt/cdrom/portage-xxxxxxxx.tar.bz2), командой: </para>
<para/>
<para># tar -xvjpf /mnt/cdrom/portage-xxxxxxxx.tar.bz2 -C /usr/portage </para>
<para>После достаточно продолжительной распаковки нужно обновить кэш системы портежей: </para>
<para># emerge metadata</para>
<para>Теперь мы получили систему портежей по состоянию на xxxxxxxx, а в каталоге /usr/portage2 - её бэкап. </para>
<para>Дополнительно можно прочитать:</para>
<para>
<link linkend="">HOWTO Обновление пакетов без доступа в интернет непосредственно из системы.</link>
</para>
<para/></sect2><sect2><title>Обновление пакетов без доступа в интернет непосредственно из системы</title>
<para/>
<para>В моем случае это понадобилось в следующей (я полагаю довольно распространенной) ситуации: дома - нет интернета (дорогой, медленный - нужное подчеркнуть :) ), а на работе - хороший и бесплатный. Итак для начала необходимо получить список нужных пакетов. В этом примере мы хотим установить/обновить glibc baselayout texinfo gettext zlib binutils gcc ncurses. Список мы сохраняем на устаревший магнитный носитель, но счастливые обладатели более надежных носителей естественно могут пользоваться ими. </para>
<para>Получение списка для скачивания: </para>
<para>(Не забывайте '2' перед '&gt;') Code: </para>
<para># emerge -fp glibc baselayout gettext zlib binutils gcc ncurses 2&gt; stage1.list</para>
<para># mount -t vfat /dev/fd0 /mnt/floppy</para>
<para># cp /mnt/gentoo/stage1.list /mnt/floppy</para>
<para># umount /mnt/floppy </para>
<para/>
<para>Теперь вставляем дискету в компьютер с хорошим каналом. (В моем случае это рабочий компьютер.) Если заглянуть в файл stage1.list, можно увидеть, что в нем перечисляются несколько ссылок на каждую загрузку. К сожалению, это не совсем то, что нам надо. Сначала список надо почистить от лишнего: </para>
<para/>
<para>Очистка от лишних ссылок: </para>
<para/>
<para>Этот скрипт привязан к формату вывода emerge, который может измениться без предварительного предупреждения - используйте с осторожностью! # cut -f 1 -d ' ' stage1.list &gt; stage1.download </para>
<para>Теперь используем wget для загрузки списка пакетов: </para>
<para># wget -N -i stage1.download </para>
<para>Получив все файлы, переносим их в наш компьютер в /mnt/gentoo/usr/portage/distfiles. И для проверки запустим </para>
<para># emerge -pv glibc baselayout gettext zlib binutils gcc ncurses </para>
<para>Если в строке Total Download: указана цифра 0 - значит все было сделано верно. Можно теперь запускать установку: </para>
<para># emerge glibc baselayout gettext zlib binutils gcc ncurses </para>
<para>У всего вышеописанного есть один недостаток. В фаиле stage1.download есть все необходимые для установки фаилы. Даже те, которые у вас могут быть в distfiles. А как вырезать ссылки из stage1.download на имеющиеся в distfiles фаилы я не знаю. Если кто знает - напишите. </para>
<para>Взято с Gentoo.org: <ulink url="http://www.gentoo.org/doc/ru/altinstall.xml">http://www.gentoo.org/doc/ru/altinstall.xml </ulink>
</para>
<para/></sect2><sect2><title>Полное обновление системы</title>
<para/><sect3><title/><sect4><title>Приведение в порядок /var/lib/portage/world </title>
<para/>
<para>В world должен быть список программ, которые нужно доустановить к тем, которые уже входят в "system" (т.е. в текущий профайл). </para>
<para>в world не должно быть никаких библиотек, и т.д., которые не нужны сами по себе, а нужны только для удовлетворения чьих-то зависимостей (чтобы не продолжать устанавливать/обновлять их, если они уже станут не нужны по какой-то причине) программ, которые уже входят в "system", не должно быть в world. В world нельзя указывать определенную версию софта, это лучше делать в /etc/portage/package.mask. </para>
<para>Скрипт regenworld может помочь восстановить world путем анализа /var/log/emerge.log и генерации на его базе файла world (он перезапишет текущий world!).</para>
<para>Скрипт dep -p -w поможет найти избыточные записи в world(которые всё-равно нужны другим записям в world или входят в system). </para>
<para/>
<para>Перед серьёзными обновлениями желательно просмотреть /etc/portage/*, т.к. там могут быть уже не актуальные записи мешающие текущему обновлению. </para>
<para/>
<para>Обновление profile </para>
<para>Не каждый Gentoo release включает в себя новый profile (например, 2004.1 был без profile). Даже если новый profile есть, то переходить на него не обязательно (если это будет обязательно, то старый профайл будет deprecated и emerge об этом должен будет громко кричать). </para>
<para>Инструкции по обновлению profile будут выкладываться здесь:</para>
<para>
<ulink url="http://www.gentoo.org/doc/en/gentoo-upgrading.xml">http://www.gentoo.org/doc/en/gentoo-upgrading.xml</ulink>
</para>
<para> и как правило сводиться к изменению симлинка /etc/make.profile </para></sect4></sect3><sect3><title/><sect4><title>USE-флаги </title>
<para>Запустить emerge -uDpv --newuse world и проверить что USE-флаги для всех пакетов выставлены корректно, и при необходимости скорректировать </para>
<para>USE-флаги выставляются в /etc/make.conf и /etc/portage/package.use </para>
<para>Запуск обновления системы (если не нужно обновлять toolchain) </para>
<para/>
<para/>
<para>Если </para>
<para>emerge -uDav --newuse world </para>
<para>показывает что будет обновляться пакет входящий в toolchain (linux-headers, glibc, binutils или gcc), то крайне рекомендуется полностью перекомпилировать всю систему - см. следующий пункт - а иначе можно вместо следующего пункта просто запустить: </para>
<para>emerge -uDav --newuse world </para>
<para>Некоторые причины не использовать emerge -U вместо -u </para>
<para>Причина 1: Проблемы со SLOT </para>
<para>Это, к примеру, происходит потому, что некоторые люди хотели gimp-2 вместо gimp-1.2. Представьте ситуацию, где gimp-1.2 помечен stable и находится в SLOT 1, gimp-2 помечен unstable и находится в SLOT 2. Теперь при выполнении ACCEPT_KEYWORDS=~x86 emerge gimp получите gimp-2. </para>
<para>Позже, когда вы посчитаете, что наступило время обновить свою систему чем-либо похожим на "emerge -U world", эта команда установит gimp-1.2, потому, что gimp находится в world-файле, и флаг "-U" не обрабатывает SLOT должным образом. </para>
<para/>
<para>Причина 2: Проблемы, в случае удаления ebuild-ов с Portage-дерева. </para>
<para>Допустим, в Portage находятся 2 версии пакетов foo, foo-1.4 (помеченный как stable) и foo-1.6 (помеченный как unstable). Вы хотите вариант unstable и делаете emerge, как с вышеуказанным gimp. Позже обновляете world как было сказано выше, но в промежутке этого времени вышло критическое обновление для foo-1.6 - foo-1.6.1. Теперь появляется несколько возможностей обработки. </para>
<para>foo-1.6 был удален из Portage. Будет установлен foo-1.4, несмотря на "снижение" версии вместо флага "-U" </para>
<para>Ситуация будет еще хуже, если foo-1.6 не был удалён из Portage по какой-либо причине: foo-1.6 (тот, что с критической уязвимостью) будет оставаться на вашей системе до тех пор, пока не будет помечено stable что-либо выше чем foo-1.6. </para>
<para/>
<para>Обновление одного из пакетов входящих в toolchain </para>
<para/>
<para>Если обновляется хотя-бы один из linux-headers, glibc, binutils или gcc, то рекомендуется пересобрать их дважды, после чего весь system, после чего весь world.</para>
<para>Примечание: Цель двойной компиляции toolchain - получить гарантированно стабильный и корректный toolchain не зависящий от предыдущего. Перекомпилировать system/world после этого жёсткой необходимости нет, по крайней мере если остальной софт продолжает работать (возможно даже используя библиотеки из старого toolchain - см. предыдущие пункты об апгрейде). </para>
<para>Цель перекомпиляции system/world - чтобы весь софт получил потенциальное преимущество от установки нового toolchain. system перекомпилируется перед world из тех-же соображений, т.к. при компиляции программ из world используются утилиты из system. </para>
<para>Если увеличивается первая или вторая цифра версии gcc, то перед второй сборкой нужно переключиться на новую версию через gcc-config - иначе новый gcc просто установится параллельно со старым в "новый слот", но по умолчанию использоваться будет старый. </para>
<para>При сборке system после двойной перекомпиляции toolchain нет необходимости опять компилировать toolchain как часть system. Аналогично при сборке world после system нет небходимости опять компилировать пакеты из system как часть world. Это можно попробовать обойти либо вручную, либо используя скрипты [1], либо через бинарные пакеты и `emerge -k` (я предпочитаю последний вариант). </para>
<para>Итак, рекомендованный набор команд: </para>
<para># для того, чтобы безопасно использовать `emerge -k` нужно очистить</para>
<para># каталог с текущими бинарными пакетами</para>
<para># (напр., переместить его в /tmp/portage-packages)</para>
<para>pkgdir=$(portageq pkgdir)</para>
<para>mv $pkgdir /tmp/portage-packages1</para>
<para>install -d -o portage -g portage $pkgdir</para>
<para># первая сборка toolchain</para>
<para>emerge linux-headers glibc binutils gcc-config gcc</para>
<para># выбрать новый gcc если он установился в новый слот</para>
<para>gcc-config имя_или_номер_нового_gcc</para>
<para># см. `gcc-config -l`</para>
<para>source /etc/profile</para>
<para># компиляция toolchain с созданием бинарных пакетов</para>
<para>emerge -b glibc binutils gcc portage</para>
<para># не компилить glibc, binutils и gcc</para>
<para>emerge -bke system </para>
<para># не компилить предыдущие пакеты (включая system)</para>
<para>emerge -bke world</para>
<para>Примечание: Чисто теоретически существует пакет binutils-config, который когда-нибудь может потребоваться использовать аналогично gcc-config. </para>
<para/></sect4></sect3><sect3><title/><sect4><title>Обновление безопасности. </title>
<para/>
<para>Примечание: Даже после `emerge -uDav --newuse world` в системе могут оставаться </para>
<para>устаревшие пакеты с дырами в безопасности - в слотах! </para>
<para/>
<para>glsa-check -l | grep '\[N\]'</para>
<para>emerge ... # если нужно</para>
<para/></sect4></sect3><sect3><title/><sect4><title>Удаление неиспользуемых пакетов. </title>
<para/>
<para>После обновления системы в ней могут оказаться пакеты, которые никто не использует. Эти пакеты желательно удалить, т.к. они не будут в дальнейшем обновляться при `emerge -uDav --newuse world`. </para>
<para>emerge -a depclean # очень осторожно!!!</para>
<para>После обновления библиотек может потребоваться перекомпилировать программы, которые эти библиотеки используют: </para>
<para/>
<para>Примечание: Для glsa-check, revdep-rebuild необходимо установить пакет gentoolkit </para>
<para/>
<para>rm /root/.revdep-rebuild*.?_*</para>
<para>revdep-rebuild -p</para>
<para>revdep-rebuild</para>
<para/></sect4></sect3><sect3><title/><sect4><title>Обновление конфигов. </title>
<para>dispatch-conf</para>
<para>Если используется runit-init и обновлялся пакет baselayout, то нужно восстановить /sbin/init: </para>
<para>ls -l /sbin/*init*</para>
<para>if (/sbin/init это бинарник, а не симлинк) {</para>
<para>mv /sbin/init /sbin/init-sysv</para>
<para>ln -s runit-init /sbin/init</para>
<para>}</para>
<para/></sect4></sect3><sect3><title/><sect4><title>Отслеживание важных сообщений при установке пакетов. </title>
<para/>
<para>В процессе emerge world выдаётся очень много сообщений, причём важные комментарии перемешаны с командами компиляции, и отследить их при сборке нескольких пакетов одновременно не возможно. </para>
<para>Но все эти сообщения можно получить из log-файлов после окончания установки emerge world. Для этого нужно использовать либо enotice, либо portlog-info.</para>
<para/></sect4></sect3></sect2><sect2><title>Сборка на другом компьютере</title>
<para/>
<para>Существует много методов добиться этого, но мы используем самый удобный - тот, что работает с портежами. </para>
<para>Другие методы могут быть более подходящими для других ситуаций, когда главная проблема не только медленный процессор и долгое время сборки, например, если надо перенести Gentoo на систему, которая не может загружаться с CD или сети. </para>
<para>Скомпилировать Gentoo для старых систем x86 (например, Pentium Pro 200MHz с небольшим количеством RAM) можно на x86_64-системе с работающей Gentoo. Обратный трюк, собрать 64-битную систему на 32-битном компьютере, невозможен. </para>
<para/>
<para>Я собирал систему в chroot-окружении согласно Gentoo-handbook, используя мою 64bit-Gentoo вместо "живого" CD: </para>
<para># mkdir /your/new/gentoo</para>
<para># tar xjvpf stage3-x86-*.tar.bz2 -C /your/new/gentoo</para>
<para/>
<para>Отредактируйте переменные CHOST и CFLAGS, соответствующие вашей целевой системе (не изменяйте CHOST, если используете стадию 2 или 3 - возмите стадию для соответствующей платформы). У меня было: </para>
<para># CHOST="i686-pc-linux-gnu"</para>
<para># CFLAGS="-march=pentiumpro -Os -momit-frame-pointer -pipe" </para>
<para># CXXFLAGS="$CFLAGS"</para>
<para/>
<para>Далее переходим в chroot-окружение и выполняем все шаги, описанные в <link linkend="">Руководстве Gentoo по установке</link>. </para>
<para/>
<para>Чтобы собрать ядро для i386 на x86_64-машине добавьте ARCH=i386 при конфигурации и компиляции ядра. </para>
<para># make menuconfig ARCH=i386</para>
<para># make clean dep modules modules_install bzImage ARCH=i386</para>
<para># cp arch/i386/boot/bzImage /boot/vmlinuz</para>
<para/>
<para>Размечать диск и создавать файловые системы на старом компьютере вам придется с помощью "живого" CD или другой системы Linux. </para>
<para/>
<para>Переносим готовую систему на старый компьютер: </para>
<para># cd /your/new/gentoo</para>
<para># echo "/sys/*" &gt;&gt; tar_exclusions</para>
<para># echo "/var/run/*" &gt;&gt; tar_exclusions</para>
<para># echo "/tmp/*" &gt;&gt; tar_exclusions</para>
<para># echo "/proc/*" &gt;&gt; tar_exclusions</para>
<para>#</para>
<para># tar -C /your/new/gentoo -X tar_exclusions --preserve -cf ../gentoo.tar .</para>
<para>## можете добавить -v для подробного вывода или -j / -z для компрессии</para>
<para># scp [-P ssh_port]  ../gentoo.tar user@dest_pc:</para>
<para/>
<para>На старой машине подготавливаем диски и распаковываем систему: </para>
<para># tar -C /your/new/system --preserve -xf ~user/gentoo.tar </para>
<para/>
<para>Теперь вы можете войти в chroot-окружение. Сконфигурируйте системный загрузчик и перегрузитесь. Теперь вы находитесь в новой, с иголочки, Gentoo. </para>
<para>Система теперь должна работать, но я заметил проблему - я не могу ничего скомпилировать. Похоже, что не работает ни C-препроцессор, ни gcc (обычно configure говорит, что /lib/cpp fails sanity check). Не знаю почему, но копирование /usr/include из chroot-каталога с исходной машины на старый компьютер эту проблему решило. </para>
<para/>
<para>Удачи! </para>
<para/>
<para>Оригинал на http://gentoo-wiki.com/HOWTO_Compile_on_another_computer </para>
<para>Перевод Poor Fred</para>
<para/></sect2><sect2><title>Прочее</title>
<para/><sect3><title>Разделы MS Windows по-русски</title><sect4><title>Введение</title>
<para/>
<para>Достаточно часто возникает необходимость подмонтировать раздел с установленным M$ Windows. </para></sect4><sect4><title>Ядро </title>
<para/>
<para>Для того, чтобы система могла работать с разделами FAT или NTFS, необходимо включить их поддержку в ядре.</para>
<para> Linux Kernel Configuration: Filesystems </para>
<para>File systems -&gt; </para>
<para>  DOS/FAT/NT Filesystems -&gt;</para>
<para>    (M) DOS FAT fs support</para>
<para>    (M)   MSDOS fs support</para>
<para>    (M)   VFAT (Windows-95) fs support</para>
<para>    (M) NTFS file system support</para>
<para/>
<para>Также надо включить поддержку следующих кодировок: </para>
<para>Linux Kernel Configuration: Native Language Support </para>
<para>File systems -&gt; </para>
<para>  Native Language Support -&gt;</para>
<para>    &lt;M&gt; Windows CP1251 (Bulgarian, Belarusian)</para>
<para>    &lt;M&gt; Codepage 866 (Cyrillic/Russian)</para>
<para/></sect4><sect4><title>Монтирование </title>
<para/>
<para>Теперь можно примонтировать любой windows-раздел программой mount. mount -t file_system /dev/device /mnt/dir В нашем случае в качестве file_system необходимо указывать vfat или ntfs, в зависимости от файловой системы раздела с windows. </para>
<para/>
<para>Монтирование FAT</para>
<para/>
<para>Для монтирования разделов FAT нужно использовать следующую команду: </para>
<para>mount -t vfat -o codepage=866,iocharset=koi8-r,quiet,umask=000 /dev/hdd2 /mnt/win1</para>
<para/>
<para>Для украинских символов: </para>
<para>mount -t vfat -o codepage=866,iocharset=koi8-u,quiet,umask=000 /dev/hdd2 /mnt/win1 </para>
<para/>
<para>Мы использовали дополнительные опции iocharset, codepage, quiet и umask. </para>
<para>Рассмотрим их внимательнее: </para>
<orderedlist>
<listitem>
<para>codepage - это кодовая страница используемая на монтируемой ФС. Так как мы из России,то нужно писать codepage=866. Эта опция нужна для перекодировки имен файлов. </para>
</listitem>
<listitem>
<para>iocharset - указывает какую кодировку использовать для ввода/вывода.Нужно указать свою системную локаль. Локаль можно узнать командой locale. (Здесь под вводом/выводом понимается ввод с и вывод на терминал. Иммено поэтому нужно указывать кодировку локали, т.е. кодировку которую используют программы запущенные в терминале.) </para>
</listitem>
<listitem>
<para>quiet - при копировании на файловую систему FAT программа попытается записать права доступа, владельца и т.д., но на FAT их сохранить нельзя и будет выведено сообщение об ошибке ( хотя файл скопируется ). Чтобы ошибки не появлялись мы просим смонтировать в "молчаливом" режиме </para>
</listitem>
<listitem>
<para>umask - в некоторых случаях у простого пользователя может не хватить прав на чтение или запись файлов из-за неправильно установленных прав на файлы и директории. Поскольку у файловой системы FAT нет прав доступа, они выставляются операционной системой ( в данном случае Linux ) на лету в соответствии с указанным значением umask. Про umask смотрите в umask(2) </para>
</listitem>
</orderedlist>
<para/>
<para>Параметры codepage и iocharset можно задать прямо в ядре. Тогда не нужно будет писать их каждый раз:</para>
<para>Linux Kernel Configuration: FAT </para>
<para>File systems -&gt; </para>
<para>  DOS/FAT/NT Filesystems -&gt;</para>
<para>    (utf8) Default iocharset for FAT</para>
<para>    (866) Default codepage for FAT</para>
<para/>
<para>То есть вместо </para>
<para>mount -t vfat -o codepage=866,iocharset=utf8,quiet,umask=000 /dev/hdd2 /mnt/win1 можно писать </para>
<para>mount -t vfat -o quiet,umask=000 /dev/hdd2 /mnt/win1 </para>
<para/>
<para>Монтирование NTFS</para>
<para/>
<para>Для монтирования NTFS разделов опции mount немного изменяться. Делаем это так: </para>
<para>mount -t ntfs -o nls=koi8-r,umask=0,ro /dev/hdd2 /mnt/win1 </para>
<para>Для украинских символов:</para>
<para>mount -t ntfs -o nls=koi8-u,umask=0,ro /dev/hdd2 /mnt/win1 </para>
<para>Вот что они значат: </para>
<para>nls - указывает на вашу системную локаль. Отсутствие опций codepage и iocharset связано с тем,что NTFS разделы используют юникод для хранения имен файла. </para>
<para>umask - указывает на то что читать файлы с этого раздела могут все. А вот писать не разрешает опция ro. Мы рекомендуем ее поставить,так как функция записи на разделы NTFS еще не отлажена. </para>
<para>В случае если вы в качестве системной кодировки используете utf-8, то опции mount должны быть следующими: mount -t ntfs -o utf8,umask=0,ro /dev/hdd2 /mnt/win1 </para>
<para>utf8 - использовать UTF-8 для перекодировки имён файлов. </para>
<para/></sect4><sect4><title>Автомонтирование</title>
<para>Если у вас все еще есть разделы ОС Windows на харде,то можно добавить монтирование этих разделов при загрузке.Для этого необходимо отредактировать файл /etc/fstab. Файл: /etc/fstab </para>
<para>...</para>
<para>/dev/hda9 /mnt/win1 vfat auto,codepage=866,iocharset=koi8-r,quiet,umask=000 0 0 </para>
<para>#/dev/hda9 /mnt/win1 vfat auto,codepage=866,iocharset=koi8-u,quiet,umask=000 0 0 </para>
<para>/dev/hda3 /mnt/win2 ntfs auto,nls=koi8-r,umask=0,user 0 0 </para>
<para/>
<para>еще к опциям можно добавить showexec, чтобы все файлы не выглядели исполняемыми, в случае с FAT32</para>
<para/></sect4></sect3><sect3><title>Udev</title><sect4><title>Настройка системы </title>
<para/>
<para>Установка необходимых программ </para>
<para>emerge udev hotplug coldplug </para></sect4><sect4><title>Конфигурация ядра </title>
<para/>
<para>Для активизации udev нам необходимо ядро 2.6. Лично у меня 2.6.12-mm1. </para>
<para>General setup ---&gt;</para>
<para> [*] Support for hot-pluggable devices</para>
<para>File systems ---&gt;</para>
<para> Pseudo filesystems ---&gt;</para>
<para>  [ ] /dev file system support (OBSOLETE)</para>
<para>  [ ]   Automatically mount at boot (NEW)</para>
<para>  [*] Virtual memory file system support (former shm fs)</para>
<para/>
<para>Примечание: devfs Может быть включен, но автоматическое монтирование обязано быть выключено. А с учетом того, что из 2.6.13 его вообще собираются убрать... ну смотрите сами. </para>
<para>Примечание: Во всяком случае, из 2.6.14 убрали </para>
<para/></sect4><sect4><title>Ядро собираем и устанавливаем. </title>
<para/>
<para>Конфигурация системы </para>
<para/>
<para>Не буду рассматривать как udev работает из таррбола, рассматриваю вариант чистого udev. </para>
<para/>
<para>/etc/conf.d/rc: </para>
<para>...</para>
<para>RC_DEVICE_TARBALL="no"</para>
<para>...</para>
<para>RC_DEVFSD_STARTUP="yes"</para>
<para>...</para>
<para/>
<para>Примечание: Последнюю опцию можно поставить в "no", когда мы убедимся в нормальной работоспособности udev </para>
<para/>
<para>rc-update add coldplug boot rc-update add hotplug default </para>
<para/>
<para>Конфигурация процесса загрузки </para>
<para/>
<para>GrUB </para>
<para/>
<para>К строке kernel от старого ядра необходимо дописать: </para>
<para>kernel /boot/kernel-2.6.9-r4 root=/dev/hda3 gentoo=noudev</para>
<para/>
<para>А в строке kernel для нового ядра прописать: </para>
<para>kernel /boot/kernel-2.6.10-r6 root=/dev/hda3 gentoo=nodevfs</para>
<para/></sect4><sect4><title>Troubleshuting </title>
<para/>
<para>Попытка номер раз </para>
<para/>
<para>В принципе можно перегружаться, но нас ждет одно неприятное сообщение. Вот примерно такое: </para>
<para>WARNING: Unable to open an initial console </para>
<para/>
<para>Для того чтобы все было хорошо, нам необходимо загрузиться с другого носителя (например любой LiveCD) подмонтировать наш корневой раздел, и в каталоге /dev (каталог по идее должен оказаться абсолютно пустым) проделать следующее: Code: </para>
<para># mknod -m 660 console c 5 1</para>
<para># mknod -m 660 null c 1 3</para>
<para/>
<para>POMAH007: Зачем же так жестоко - заставлять грузиться с компакта? Согласно udev guide с www.gentoo.org (http://www.gentoo.org/doc/en/udev-guide.xml), доступ к девственному /dev можно получить альтернативно: Code: Code Listing 3.1: Listing device nodes available at boot </para>
<para># mkdir test</para>
<para># mount --bind / test</para>
<para># cd test/dev</para>
<para># ls</para>
<para/>
<para/>
<para>Попытка номер два </para>
<para/>
<para>С консолью вроде все в порядке, а вот иксы не хотят... грузимся в шелл и в файле конфигурации Xorg прописываем в разделе мыши: </para>
<para/>
<para>Option "Device" "/dev/input/mice" </para>
<para/>
<para>PS </para>
<para>Ну теперь вроде все так как было раньше. и старая конфигурация тоже работает. Если старая конфигурация не нужна, то убираем все из загрузчика, ставим в /etc/conf.d/rc - "no" и живем спокойно под udev. </para>
<para/>
<para>PPS </para>
<para>Кстати тарболл может потребоваться пользователям нестандартных устройств, а так же некоторых сторонних модулей ядра</para>
<para/>
<para/></sect4></sect3><sect3><title>Использование CFLAGS для оптимизации собранных программ</title>
<para/><sect4><title>Для чего все это надо?</title>
<para/>
<para>Стремление выжать из своего компьютера максимум производительности есть в каждом, ну почти в каждом ;-). Особенно его много в русских линуксоидах Gentoo'шниках ;) Мы попытаемся путем изменения флагов оптимизации ускорить работу приложений нашей системы. </para>
<para>ВНИМАНИЕ: Некоторые флаги могут сделать приложения нестабильными, так что нужно быть аккуратным. </para>
<para/></sect4><sect4><title>Оптимизация</title>
<para/>
<para>Переменная окружения CFLAGS</para>
<para>Для указания параметров оптимизации компилятору GCC, используется переменная окружения CFLAGS. Эта переменная определена в /etc/make.conf, её можно изменить двумя способами: </para>
<para>Отредактировать эту переменную в /etc/make.conf; </para>
<para>Экспортировать ее в окружение (emerge будет использовать эти параметры, но каждый раз выполнять export неудобно): </para>
<para/>
<para>export CFLAGS='параметры оптимизации' </para>
<para/>
<para>Уровни оптимизации</para>
<para/>
<para>Для gcc версий 3.x и выше существует только 5 уровней оптимизации: -O0 (без оптимизации), -O1, -O2 и -O3 (O3 - самый высокий уровень), а так же -Os. </para>
<para>Примечание: Если вы используете несколько -O опций, то только последняя объявленная будет оказывать влияние на процесс компиляции. </para>
<para/>
<para>-O0 </para>
<para>Отключает оптимизацию. Только переменные, объявленные register, сохраняются в регистрах. </para>
<para/>
<para>-O(-O1) </para>
<para>Включает оптимизацию. Пытается уменьшить размер кода и ускорить работу программы. Соответственно увеличивается время компиляции. При указании -O активируются следующие флаги: -fthread-jumps, -fdefer-pop. </para>
<para>На машинах, у которых есть слоты задержки, включается опция -fdelayed-branch. </para>
<para>На тех машинах, которые способны поддерживать отладку даже без указателя на стек функции, также включается опция -fomit-frame-pointer. </para>
<para>На других машинах могут быть включены и другие флаги. </para>
<para/>
<para>-O2 </para>
<para>Оптимизирует еще больше. GCC выполняет почти все поддерживаемые оптимизации, которые не включают уменьшение времени исполнения за счет увеличения длины кода. Компилятор не выполняет раскрутку циклов или подстановку функций, когда вы указываете -O2. По сравнения с -O, эта опция увеличивает как время компиляции, так и эффективность сгенерированного кода. </para>
<para>-O2 включает все флаги оптимизации наследованные от -O. Также включает следущие флаги оптимизации: </para>
<para>          -fforce-mem -foptimize-sibling-calls</para>
<para>          -fstrength-reduce -fcse-follow-jumps  -fcse-skip-blocks</para>
<para>          -frerun-cse-after-loop  -frerun-loop-opt -fgcse  -fgcse-lm</para>
<para>          -fgcse-sm -fgcse-las -fdelete-null-pointer-checks -fexpensive-optimizations</para>
<para>          -fregmove -fschedule-insns  -fschedule-insns2 -fsched-interblock</para>
<para>          -fsched-spec -fcaller-saves -fpeephole2 -freorder-blocks</para>
<para>          -fre-order-functions -fstrict-aliasing -funit-at-a-time -falign-functions</para>
<para>          -falign-jumps -falign-loops  -falign-labels -fcrossjumping</para>
<para/>
<para>-O3 </para>
<para>Оптимизирует еще немного. Включает все оптимизации -O2 и также включает флаг -finline-functions и -fweb. </para>
<para/>
<para>-Os </para>
<para>Включает оптимизацию по размеру. -Os флаг активирует все флаги оптимизации из -O2, в основном те, которые не увиличивают размер выходного файла. В дальнейшем выполняются оптимизации по уменьшению размера кода. </para>
<para>-Os выключает следущие флаги оптимизации: -falign-functions, -falign-jumps, -falign-loop, -falign-labels, -freorder-blocks, -fprefetch-loop-arrays. </para>
<para/>
<para>Примечание: Более полное описание флагов -Ox, -fflag смотрите в man gcc </para>
<para/>
<para>Оптимизация под тип процессора</para>
<para/>
<para>Не все процессоры одинаковы,поэтому давайте укажем компилятору на наш тип процессора. Для этого есть опции -mtune и -march.Отличие в том,что с опцией -mtune компилятор сделает код,который будет совместим с более младшими моделями процессора,в то время как с -march этого не происходит.Вот список возможных значений для данных опций: </para>
<para>i386 </para>
<para>i486 </para>
<para>i586 </para>
<para>i686 </para>
<para>pentium </para>
<para>pentium-mmx </para>
<para>pentiumpro </para>
<para>pentium2 </para>
<para>pentium3 </para>
<para>pentium4 </para>
<para>pentium-m </para>
<para>prescott </para>
<para>nocona </para>
<para>k6 </para>
<para>k8 </para>
<para>k6-2 (не рекомендуется ставить, из-за багов в компиляторе, заменять на i686) </para>
<para>k6-3 </para>
<para>athlon </para>
<para>athlon-tbird </para>
<para>athlon-4 </para>
<para>athlon-xp </para>
<para>athlon-mp </para>
<para>athlon64 </para>
<para>opteron </para>
<para>winchip-c6 </para>
<para>winchip2 </para>
<para>c3. </para>
<para/>
<para>Внимание! pentium-m - это аналог для pentium3. Если процессор в вашем ноутбуке Mobile Intel Pentium 4 - M, то нужно ставить опцию pentium4 или pentium4m (они равнозначны) </para>
<para/>
<para>Примечание(JohnBat26) (обновлено в 1.5): Если Вы используете компилятор версии 4.2.0 и выше, то вместо указания специфичного типа процессора, можно указывать одно из двух (в параметрах: -march и -mtune):</para>
<orderedlist>
<listitem>
<para>generic: если Вы хотите, чтобы Ваш скомпилированный код запускался на всех процессорах, архитектуры x86;</para>
</listitem>
<listitem>
<para>native: если Вы хотите оптимизировать код только для Вашего процессора. В этом случае компилятор будет брать сведения о процессоре путем вызова cpuid ! .</para>
</listitem>
</orderedlist>
<para/>
<para/>
<para>Выбор оптимальных параметров </para>
<para/>
<para>Для этого есть очень интересная утилита. emerge acovea </para>
<para/>
<para>Правда существующие профили рассчитаны только на pentium 3/4, и на gcc 3.3/3.4, Но в принципе добавить свою конфигурацию тоже не составляет труда. Также рекомендуется добавить в конфигурацию опции -ftracer и -mfpmath=sse. В некоторых случаях они дают значительный прирост производительности сгенерированного кода. </para>
<para/>
<para>После чего вызываем утилиту runacovea -config gcc33_pentium3.acovea -bench evobench.c Ждем несколько часов и получаем оптимальные флаги компиляции. </para>
<para/>
<para>Возможны различные тесты, которые хранятся в каталоге /usr/share/acovea/benchmarks, И различные конфигурации платформы /usr/share/acovea/config, к которым при желании можно добавить свою.</para>
<para/></sect4></sect3><sect3><title>Редактор nano</title>
<para/>
<para>nano - Nano's ANOther editor</para>
<para/>
<para>Nano - достаточно простой и удобный текстовый редактор, клон редактора pico </para>
<para/><sect4><title>Установка</title>
<para/>
<para>emerge nano </para>
<para/>
<para>Конфигурация</para>
<para>Файл: /etc/nanorc </para>
<para/></sect4><sect4><title>Запуск</title>
<para/>
<para>Запуск редактора </para>
<para>nano -w somefile </para>
<para/>
<para>Параметр -w здесь означает запрет переноса строк.</para>
<para/>
<para/></sect4></sect3><sect3><title>Udev и автомонтирование носителей</title><sect4><title>Введение </title>
<para/>
<para>В данной статье речь пойдет о том, как настроить udev для автоматического монтирования и отмонтирования usb-носителей. Ведь согласитесь, неудобно каждый раз монтировать флэшки из консоли. А когда вам нужно быстро что-то скинуть с одной флэшки на другую? Здесь я привожу одно из возможных решений. </para>
<para/></sect4><sect4><title>Требования </title>
<para/>
<para>У меня установлена следующая версия udev: </para>
<para>sys-fs/udev-069 </para>
<para/>
<para>Я умышленно не ставлю более новые версии, т.к. с ними возникают проблемы при загрузке firmware на моем компьютере. Возможно в более новых версиях что-то работает по-другому, но суть одна и та же. </para>
<para/></sect4><sect4><title>Настраиваем udev </title>
<para/>
<para>Создаем правила для flash-носителей </para>
<para>Правила udev, в соответствии с которыми устройствам назначаются имена, а также выполняются специфические действия, расположены в /etc/udev/rules.d/*. В этой директории уже есть файлы, содержащие правила, у меня их было 2: </para>
<para># ls /etc/udev/rules.d</para>
<para>05-udev-early.rules</para>
<para>50-udev.rules</para>
<para/>
<para>Такие названия им были даны неспроста. Дело в том, что udev обрабатывает файлы в этой директории в алфавитном порядке по возрастанию. Вообще, при написании правил udev следует помнить 2 главные вещи: </para>
<para>Udev считывает файлы из /etc/udev/rules.d в алфавитном порядке. </para>
<para>Найдя первое подходящее правило для устройства, udev прекращает дальнейший поиск. </para>
<para>Давайте добавим свой файл с правилами так, чтобы он обрабатывался раньше, чем файл с правилами по умолчанию (50-udev.rules). Назовем его 10-udev-my.rules. Содержимое нового файла будет следующим: </para>
<para>Файл: /etc/udev/rules.d/10-udev-my.rules </para>
<para/>
<para># First rule</para>
<para>SUBSYSTEM=="block", KERNEL=="sd*", ACTION=="add", NAME="%k", GROUP="disk", RUN+="/etc/udev/scripts/udev-flash-mount add %k"</para>
<para>#Second rule</para>
<para>SUBSYSTEM=="block", KERNEL=="sd*", ACTION=="remove", RUN+="/etc/udev/scripts/udev-flash-mount remove %k"</para>
<para/>
<para>Теперь разберемся в том, что написали. </para>
<para>Первое правило (добавление устройства) </para>
<para>SUBSYSTEM=="block" При добавлении нового устройства в систему возникает множество событий разных классов. block - это класс для блочных устройств, который нам больше всего подходит для составления правила. Для просмотра значений всех переменных, возникающих событий используйте udevmonitor --env Т.о. здесь мы реагируем только на событие, в окружении которого есть переменная SUBSYSTEM со значением block . </para>
<para>KERNEL=="sd*" Эта часть правила сравнивает имя устройства, которое было дано по умолчанию ядром, с шаблоном. В данном случае нам нужны такие имена как: sda, sda1, sdb, sdb1 и т.д. </para>
<para>ACTION=="add" Реагируем на событие добавления устройства. Например, usb флэшка была вставлена в разьем. </para>
<para>NAME="%k" Обратите внимание на то, что здесь стоит один знак равенства, а не два, как в предыдущих частях правила. Это говорит о присваивании, а не сравнении. Здесь мы присваиваем вставленному устройству имя, которое соответствует тому, что было дано по умолчанию ядром. %k это одна из переменных окружения. Подробнее о них можно прочитать в man udev. </para>
<para>GROUP="disk" Причисляем устройство к группе дисковых. </para>
<para>RUN+="/etc/udev/scripts/udev-flash-mount add %k" Это самая интересная часть скрипта. Здесь мы добавляем ("+=") одно из действий, которое произойдет после обработки правила. В данном случае мы запускаем скрипт (он будет рассмотрен далее) /etc/udev/scripts/udev-flash-mount и передаем ему 2 параметра. Первый указывает на то что нужно выполнить действия по добавлению и инициализации нового устройства, а второй содержит имя устройства, с которым нужно выполнять действия. </para>
<para>Второе правило (удаление устройства) </para>
<para>ACTION=="remove" Реагируем на удаление устройства. </para>
<para>RUN+="/etc/udev/scripts/udev-flash-mount remove %k" Здесь мы запускаем скрипт, использовавшийся в первом правиле, но уже для выполнения действий после удаления устройства из системы. Этот скрипт будет выполнен как только ядро заметит, что устройство было удалено из системы. Это не самое лучшее решение, т.к. данные могут быть утеряны, но об этом в следующем разделе. </para>
<para/></sect4><sect4><title>Пишем скрипт </title>
<para/>
<para>Теперь напишем скрипт, который будет выполняться после добавления устройства и после его удаления. Допустим он будет размещен в /usr/bin/. Итак, от пользователя root: </para>
<para># su</para>
<para/>
<para>Создадим файл: </para>
<para># touch /etc/udev/scripts/udev-flash-mount</para>
<para/>
<para>Сделаем его исполняемым: </para>
<para># chmod u+x /etc/udev/scripts/udev-flash-mount</para>
<para/>
<para>Напишем в нем следующее: Файл: /etc/udev/scripts/udev-flash-mount </para>
<para>#!/bin/bash</para>
<para/>
<para>LOG="/var/log/udev"</para>
<para> </para>
<para>sleep 3</para>
<para>  </para>
<para>DEV=`echo $2 | sed -n '/^sd[a-z][1-9]\?/p'`</para>
<para>if [ "$1" = "add" ]; then</para>
<para>  if [ "$DEV" != "" ]; then</para>
<para>    echo "--- `date` ---" &gt;&gt; $LOG</para>
<para>    echo "Mounting /dev/$DEV" &gt;&gt; $LOG</para>
<para>    mkdir /mnt/$DEV &gt;&gt; $LOG 2&gt;&amp;1</para>
<para>    chmod a+rwx /mnt/$DEV &gt;&gt; $LOG 2&gt;&amp;1</para>
<para>    mount /dev/$DEV /mnt/$DEV -o sync,umask=0000,iocharset=cp1251 &gt;&gt; $LOG 2&gt;&amp;1</para>
<para>  fi</para>
<para>elif [ "$1" = "remove" ]; then</para>
<para>  if [ "$DEV" != "" ]; then</para>
<para>    echo "--- `date` ---" &gt;&gt; $LOG</para>
<para>    echo "Unmounting /dev/$DEV" &gt;&gt; $LOG</para>
<para>    umount /dev/$DEV &gt;&gt; $LOG 2&gt;&amp;1</para>
<para>    rm -rf /mnt/$DEV &gt;&gt; $LOG 2&gt;&amp;1</para>
<para>  fi</para>
<para>fi</para>
<para/>
<para/>
<para>Задержка в 3 или более секунд необходима для того, чтобы ядро успело выполнить свои действия по инициализации устройства. Если не лень, то поэкспериментируйте с задержкой. Если скрипту был передан параметр add, то он создает папку с именем устройства, затем пытается примонтировать устройство в эту папку. Весь вывод, в том числе и ошибки, выводятся в файл лога. Соответственно, при вызове скрипта с параметром remove, он пытается отмонтировать устройство и удалить ранее созданную папку. Предупреждение: Опция sync в параметрах mount является необходимой, т.к. форсирует мгновенную запись на устройство. Если ее не будет, то когда вы удалите устройство из системы, данные не будут записаны на него. Поэтому, чтобы избежать проблем такого рода, дождитесь пока индикатор на носителе перестанет мигать и после этого извлеките устройство. НО для файловой системы fat c версии ядра linux 2.6.13 sync ставить нельзя т.к. функционирование данной опции сильно изменилось и максимальная скорость записи на usb2.0 это 200 клибойт в секунду а для usb1.0 это где то 10 - 20 килобайт в секунду. Кроме того, опция sync в параметрах mount убьет Вашу флешку с гарантией за 6 месяцев использования. См. http://bugs.debian.org/309625 </para>
<para>Предупреждение: Внимание! Если какая-либо запущенная программа просматривает содержимое папки, в которую смонтировано устройство, то скрипт не сможет отмонтировать его и удалить папку. Поэтому сначала убедитесь в том, что ни одна из программ не использует эту папку. </para>
<para/></sect4><sect4><title>Заключение </title>
<para/>
<para>Последний скрипт можно немного модернизировать. Предположим, если вы монтируете свою камеру, чтобы просмотреть фотографии, то можно передать скрипту еще один параметр из udev правила, например, с производителем устройства. Либо можно проанализировать содержимое каталога и на основе этого выполнить какие-либо действия. Все в ваших руках, дерзайте</para>
<para/></sect4></sect3><sect3><title> Оптимизация glibc</title>
<para/><sect4><title>Введение </title>
<para/>
<para>Glibc - свободная библиотека, предоставляющая системные вызовы и другие основные операторы для основных систем GNU/Linux. Если C является наиболее распространённым языком, используемым для программирования в Linux, такая же судьба постигла и glibc - она является продуманной частью ядра системы. Glibc может быть оптимизирована на вашей системе для ускорения операций различными способами. Оптимизация, естественно, зависит от вашей системы и её использования. Это также зависит от установки флагов USE, доступных при выполнении emerge. До применения рекомендаций рекомендуется узнать о назначении и использовании флагов USE. Есть неплохая инструкция здесь. </para>
<para/></sect4><sect4><title>Оптимизация компиляции Glibc </title>
<para/>
<para>Эффект CFLAGS </para>
<para/>
<para>Компиляция Glibc с возможностями GCC используется в основном коде glibc. Glibc идентифицирует GCC как компилятор и использует установленный флаги CFLAGS.Подробней здесь. Используя правильные флаги CFLAGS для вашей системы, вы можете хорошо оптимизировать glibc. </para>
<para/>
<para>Улучшение оптимизации </para>
<para/>
<para>Если вы использовали -fomit-frame-pointer, вы можете также поместить glibc-omitfp во флаги USE. Повторно пересоберите glibc. Code: Remerging glibc </para>
<para>emerge --newuse -v world</para>
<para/>
<para>При этом соберутся Glibc и её зависимости. При компиляции glibc этот флаг активизирует флаг -enable-omitfp, который, в свою очередь, указывает glibc на использование --fomit-frame-pointer. В результате более безопасно устанавливается указатель кадра. Этот флаг устанавливает максимальную оптимизацию glibc и предоставляет два типа библиотек - 'оптимизированная' и 'стандартная'. То есть, по умолчанию будут использоваться оптимизированные библиотеки, но при необходимости можно будет использовать 'стандартную' версию. Это увеличит размер glibc и приведет к обычному поведению при установленном --fomit-frame-pointer, т.е. сделает невозможным отладку (debug) программ, так что не используйте этот флаг если вы планируете заниматься разработкой программ. Теоретически этот флаг может вызвать некоторые ошибки компилятора, хотя на практике он достаточно безопасен, тем не менее вы были предупреждены. </para>
<para/>
<para>Модели потоков </para>
<para/>
<para>glibc поддерживает 2 различных модели потоков - старую linuxthreads и новую nptl. По умолчанию, если не был указан флаг nptlonly, кроме nptl собирается и версия с linuxthreads. В случае, если у вас нет устаревшего программного обеспечения, вы можете указать флаг nptl. Если у вас современная система без сторонних бинарных пакетов, будет лучше указать nptlonly, чтобы избежать сборки glibc дважды (с поддежкой linuxthreads и без неё). </para>
<para/></sect4><sect4><title>Локализация </title>
<para/>
<para>В основном это основано на еженедельном новостном бюллетене Gentoo от 8 ноября 2004 года, который можно найти здесь (en:TIP Specifying only needed locales). Вы можете выбрать, какие локали (включая раскладки и установки клавиатуры, времени и т.д.) будут собраны при установке. Если вы не ограничите локали, используемые в вашей системе, будут собраны все имеющиеся локали, начиная с aa_DJ (локаль Афар для Джибути) через en_GB (английская локаль для Великобритании) и заканчивая zu_ZA.utf8 (локаль Зулу для Южной Африки). При ограничении сборки локалей вы можете сохранить до 90% места, необходимого для Glibc в вашей системе, сохранить время, необходимое на сборку ненужных вам локале и, как следствие, уменьшить общее время компиляции. Если вы действительно не нуждаетесь в них всех (а трудно представить, кому это могло бы понадобиться), вы можете ограничить их необходимым минимумом. </para>
<para/>
<para>Используйте флаг USE userlocales для сборки только тех локалей, которые указаны в /etc/locales.build. </para>
<para/>
<para>Отредактируйте /etc/make.conf в вашем любимом редакторе и поместите userlocales где-нибудь между "" в строке USE="". </para>
<para/>
<para>Другой способ - изменить /etc/portage/package.use используя данную команду: Code: Activating the userlocales USE flag for glibc </para>
<para>echo "sys-libs/glibc userlocales" &gt;&gt; /etc/portage/package.use</para>
<para/>
<para/>
<para>После этого вы можете указать локали, которые хотите использовать: </para>
<para>Файл: nano -w /etc/locales.build </para>
<para>#Читайте комментарии в начале файла для большей информации!</para>
<para>en_US/ISO-8859-1</para>
<para>en_US.UTF-8/UTF-8</para>
<para>#en_GB/ISO-8859-1</para>
<para>#en_GB.UTF-8/UTF-8</para>
<para>de_DE/ISO-8859-1</para>
<para>de_DE@euro/ISO-8859-15</para>
<para>ru_RU.UTF-8/UTF-8</para>
<para/>
<para>В glibc-2.3.6-r4 или glibc-2.4-r2, был удалён флаг userlocales. Вы должны править файл /etc/locale.gen и удалить /etc/locales.build. </para>
<para/>
<para>Вы можете воспользоваться для этого следующими командами: Code: Convert locales.build to locale.gen </para>
<para>cd /etc</para>
<para>grep '^[^#].*' locales.build | sed 's:/: :' &gt; locale.gen</para>
<para>rm locales.build</para>
<para>nano -w locale.gen</para>
<para>Файл: nano -w /etc/locale.gen </para>
<para>#Читайте комментарии в начале файла для большей информации!</para>
<para>en_US.UTF-8 UTF-8</para>
<para>en_US ISO-8859-1</para>
<para>ru_RU.UTF-8 UTF-8</para>
<para>de_DE ISO-8859-1</para>
<para>de_DE@euro ISO-8859-15</para>
<para/>
<para/>
<para>Вы можете найти правильные значения локалей в файле /usr/share/i18n/SUPPORTED. </para>
<para/>
<para>Помогите! Я не знаю, какими должны быть настройки моей локали! </para>
<para/>
<para>Не волнуйтесь, это просто. Записи в этом файле должны быть в формате &lt;locale&gt;/&lt;charmap&gt;. &lt;locale&gt; это локаль из каталога /usr/share/i18n/locales, а &lt;charmap&gt; -- это имя одного из файлов каталога /usr/share/i18n/charmaps/. Нужно только понимать два момента: первое, локаль с новой валютой, такой как евро, требует изменения @euro, описанного в примере выше. Второе, локали UTF-8 требуют от вас добавления .UTF-8 в конец определения локали (нет, я не знаю, зачем, но иначе оно не работает). </para>
<para/>
<para>Если вы В САМОМ ДЕЛЕ хотите минимизировать ваши локали, вам всего лишь нужно перевести вашу систему на Юникод. Вообще-то пока есть причины этого не делать, но это уже становится стандартом de facto, так как несёт множество преимуществ перед старыми форматами ISO, ASCII и другими. Больше об этом можно прочесть здесь и здесь, а также непосредственно в соответствующем руководстве с сайта Gentoo. </para>
<para/>
<para>Вам просто нужно определить следующее: Файл: nano -w /etc/locales.build </para>
<para>#Как раньше!</para>
<para>en_US.UTF-8/UTF-8</para>
<para>ru_RU.UTF-8/UTF-8</para>
<para/>
<para/>
<para>Обратите внимание, я оставил строку US UTF-8. Её лучше не убирать, так как некоторые программы не соберутся без неё. </para>
<para/>
<para>Сделайте это до установки Gentoo </para>
<para/>
<para>Вы можете выполнить эти настройки до началасборки системы с нуля. Просто следуйте инструкциям из Gentoo Handbook. Это позволит меньше волноваться о возможных недоделках программ после сборки и наслаждаться быстрой сборкой. </para>
<para/>
<para>Сделайте это после установки Gentoo </para>
<para/>
<para>Если glibc уже установлена, вам потребуется пересобрать glibc:</para>
<para>Code: Пересборка glibc </para>
<para>emerge glibc</para>
<para/>
<para>Вы также можете пересобрать world, если пакеты были скомпилированы с поддержкой множества локалей, но полученное ускорение работы пакетов и сэкономленное дисковое пространство не стоят затрат времени. Придётся затратить очень много времени на пересборку всей системы. </para>
<para>Возможно, вам стоит обратить внимание на пакет localepurge, который может очистить систему от любых установленных man страниц или info-файлов на языках не используемых в вашей системе. Вначале прочитайте man к localepurge, что бы определить локали, которые необходимо пропустить в /etc/locale.nopurge. </para>
<para>Для большей инфомации об управлении локалями читайте: </para>
<para>
<ulink url="http://www.gentoo.org/doc/ru/guide-localization.xml">Gentoo Linux Localization Guide</ulink>. </para>
<para>Или на русском языке <link linkend="">Руководство по русской локализации Gentoo Linux</link>. </para>
<para>Эта оптимизация полностью безопасна (Кроме случаев, если вы не можете читать на языке, который установили!). </para></sect4><sect4><title>Безопасность </title>
<para/>
<para>Как безопасность относится к оптимизации? Итак, это оптимизация безопасности, поскольку ранее было сказано, как оптимизация зависит от вашей системы и как всё это работает. Если это сервер, вы, к примеру, можете пожертвовать оптимизацией в угоду безопасности, или выполнить обе оптимизации. </para>
<para/>
<para>Стабилизация Glibc </para>
<para/>
<para>Это предполагает (как вы, возможно, догадывались...) использование флага USE hardened. Это сделает вашу систему более устойчивой к нападениям разного вида. </para>
<para/>
<para>Усиление стека </para>
<para/>
<para>Используйте флаг erandom если вам необходимо использование модуля случайных чисел, установленного в вашем ядре.</para>
<para/></sect4></sect3><sect3><title>Подключение USB-flash</title>
<para/><sect4><title>Подключение USB-flash к компьютеру</title>
<para/>
<para>Введение</para>
<para>В Linux я пользователь новый и с этим вопросом никогда не сталкивался, и более того - ядро по жизни собирал без поддержки USB устройств, т.к. ничего такого у меня просто нет :), но вот, как говорится - пришлось и срочно. И как оказалось - это довольно несложно. </para>
<para>Итак, по прочтении парочки-тройки вопросов связанных с USB, и небольшого количества теории - я без проблем подмонтировал USB флешку. Примечание: Что такое флешка и USB описывать не буду, т.к. если читатель этого не знает - то имхо ему следует сначала прочесть несколько других статей. </para>
<para/>
<para>Итак, начнем </para>
<para/>
<para>Конфигурация ядра</para>
<para>USB флешки видны в Linux как scsi устройства,ибо поддержка usb устройств в ядре Linux реализуется именно посредством эмуляции скази, т.е. типа /dev/sda1(2,3) и т.д, смотря сколько партиций. </para>
<para>Следовательно, чтобы была возможность подключения флешки, сначала необходимо добавить поддержку scsi в ядро </para>
<para>Linux Kernel Configuration: Включаем поддержку SCSI </para>
<para>Device Drivers ---&gt; </para>
<para> SCSI device support</para>
<para>  &lt;*&gt;legacy /proc/scsi/ support</para>
<para>  --- SCSI support type (disk, tape, CD-ROM)</para>
<para>  &lt;*&gt; SCSI disk support</para>
<para>  &lt;*&gt; SCSI generic support</para>
<para>  --- Some SCSI devices (e.g. CD jukebox) support multiple LUNs</para>
<para>  &lt;*&gt; Probe all LUNs on each SCSI device</para>
<para/>
<para>Далее добавляем непосредственно поддержку USB (я не говорю о клавиатурах или других устройствах USB, а говорю только о флешке) </para>
<para>Linux Kernel Configuration: Поддержка USB </para>
<para>Device Drivers ---&gt;</para>
<para> USB support</para>
<para>  &lt;*&gt; Support for Host-side USB</para>
<para>  &lt;*&gt; USB device filesystem</para>
<para>  &lt;*&gt; EHCI HCD (USB 2.0) support</para>
<para>  &lt; &gt; OHCI HCD support</para>
<para>  &lt;*&gt; UHCI HCD (most Intel and VIA) support</para>
<para>  &lt;*&gt; USB Mass Storage support</para>
<para>Примечание: В разделе USB Mass Storage support есть куча других устройств - я там не отмечал ничего, у меня заработало и так. Подозреваю, что для специфических устройств (всмысле каких то навороченных флешок) нужно будет что нибудь еще там отметить. </para>
<para/>
<para>Кроме того, для этих всяких сложных флешок скорее всего придется добавить MTD в ядро</para>
<para>Linux Kernel Configuration: MTD </para>
<para>Device Drivers ---&gt;</para>
<para> Memory Technology Devices (MTD) ---&gt;</para>
<para/>
<para>ну и там смотрим, что нужно. Примечание: Для большинства современных флэшек, USB носителей и цифровых фотоаппаратов поддержка MTD не требуется. </para>
<para/>
<para>Монтирование</para>
<para>После загрузки с новым ядром, нажимаем Alt+F12 и вставляем флешку - если с ядром все ок- то сразу появятся сообщения, что мол есть устройство USB , потом пишется, что есть /dev/uba ну и т.п. </para>
<para>Если этого не происходит, делаем </para>
<para>dmesg | grep usb </para>
<para>Если и здесь ничего нет, то советую перегрузиться и посмотреть включены ли USB контроллеры в BIOS :) как это не смешно звучит, но я сам себе это отрубил, когда ядро собирал, а потом включить забыл, и минут 15 гадал - чего же оно не работает :) </para>
<para>Если dmesg | grep usb выдает результат, а когда вставляем флешку - никакой реакции, то нужно проверить еще раз - все ли отмечено в ядре. </para>
<para>Вобщем - надеемся , что все заработало и теперь нужно смонтировать флешку. </para>
<para>Добавляем в /etc/fstab строку </para>
<para>Файл: /etc/fstab </para>
<para>/dev/uba1 /mnt/usbdir auto user,noauto,rw 0 0 </para>
<para/>
<para>и можно монтировать! но есть одно но, в опциях я не указал кодировки, т.к. кодировка по умолчанию указанна в разделе Native Languages конфигурации ядра. </para>
<para>Не будет лишним напомнить отмонтировать флешку перед тем как вытаскивать ее! </para>
<para>Если такой вариант вас не устраивает, то вы можете установить пакет submount и монтировать флэшку вот так: </para>
<para>Файл: /etc/fstab </para>
<para> /dev/uba1 /mnt/usb  subfs  fs=vfat,auto,umask=0,quiet,sync 0 0 </para>
<para/>
<para>Параметр sync необходим чтобы отключить отложенную запись и избежать потерю данных при копировании файлов на флэшку. </para>
<para>Вроде бы все. Удачи всем! </para>
<para>И естественно- за любые комментарии, дополнения, уточнения и исправления ошибок – буду только благодарен :) </para>
<para/>
<para>надеюсь, кому-то помог tradakad </para>
<para>исправил касательно монтирования при помощи submount (dernik) </para>
<para/></sect4><sect4><title>Монтирование под kde</title></sect4><sect4><title/>
<para>Установите пакеты: hal, dbus, and hotplug </para>
<para/>
<para>Добавьте флаг hal в /etc/make.conf </para>
<para>emerge -avt kdebase-kioslaves </para>
<para/>
<para>Убедитесь, что hal используется всеми пакетами: </para>
<para>emerge -DNu world</para>
<para>rc-update add dbus default</para>
<para>/etc/init.d/dbus start</para>
<para>rc-update add hald default</para>
<para>/etc/init.d/hald start</para>
<para/>
<para>так же можно монтировать устройства без изменения /etc/fstab с помощью </para>
<para>emerge -av pmount</para>
<para/>
<para>Добавьте себя в групп plugdev </para>
<para>gpasswd -a USER plugdev</para>
<para/>
<para>Включите "Storage media" ("Устройства хранения данных" в русском варианте) в systray (на панель). Наслаждайтесь :) </para>
<para/></sect4><sect4><title>Автоматическое монтирование </title>
<para/>
<para>Если лень замарачиваться каждый раз при втыкании флэшки или сидюка, а хочется, чтоб как в одной другой ОС, добавьте параметр managed в /etc/fstab к требуемому устройству, например </para>
<para>Файл: /etc/fstab </para>
<para> /dev/cdrw    /mnt/cdrom    iso9660    user,noauto,ro,managed          0 0</para>
<para> /dev/sda     /mnt/flash    vfat       exec,user,noauto,sync,managed    0 0</para>
<para/>
<para>Типа, все, теперь при появлении флэшки в системе будет появляться иконка на рабочем столе. </para>
<para>ps. распишите эту статью подробнее. Добавьте gpasswd в статью:</para>
<para> <ulink url="http://gentoo-wiki.com/HOWTO_D-BUS,_HAL,_KDE_media:/">http://gentoo-wiki.com/HOWTO_D-BUS,_HAL,_KDE_media:/</ulink>
</para>
<para/></sect4></sect3><sect3><title>Чтение-запись NTFS с использованием драйвера ntfs-3g</title>
<para/><sect4><title>Введение</title>
<para/>
<para>"Драйвер ntfs-3g является открытым, лицензированным по GPL, драйвером NTFS для Linux, созданным в рамках проекта Linux-NTFS. Он предоставляет полный доступ к разделам NTFS (чтение-запись), кроме работы с зашифрованными файлами и записи сжатых файлов. Так же не поддерживается смена владельца файла и его прав доступа. Технически он является сильно усовершенствованным драйвером ntfsmount. Улучшена функциональность, качество и добавлены дополнительные возможности." (Szakacsits Szabolcs, автор ntfs-3g) </para>
<para/>
<para>Автор создал драйвер, который гораздо лучше пригоден для использования, чем другие драйвера NTFS для Linux, и при этом не менее быстрый, чем драйвера родных файловых систем Linux - временами в два раза быстрее чем родной модуль файловой системы EXT3 в ядре. </para>
<para/>
<para>Для получения более подробной информации посетите: [1]</para>
<para>Предупреждение: Драйвер имеет статус BETA, имеются некоторые не решённые вопросы, возможна потеря данных и/или зависания при попытке примонтировать раздел. Он НЕ работает на архитектурах, отличных от x86 и amd64. </para>
<para/>
<para>СДЕЛАЙТЕ РЕЗЕРВНУЮ КОПИЮ ДАННЫХ ПЕРЕД ЛЮБЫМИ ПОПЫТКАМИ ИСПОЛЬЗОВАНИЯ !!! В ЛЮБОМ СЛУЧАЕ - ВЫ ПРЕДУПРЕЖДЕНЫ !!! </para>
<para/></sect4><sect4><title>Установка</title>
<para/>
<para>ebuild драйвера зависит от sys-fs/fuse (portage установит его автоматически). </para>
<para/>
<para>Поскольку это программное обеспечение находится на стадии бета-тестирования, вы должны размаскировать его: </para>
<para># echo "sys-fs/ntfs3g ~x86" &gt;&gt; /etc/portage/package.keywords</para>
<para/>
<para>И установить его: </para>
<para># emerge sys-fs/ntfs3g</para>
<para/>
<para>Модуль ядра fuse должен быть загружен перед использованием драйвера </para>
<para># modules-update</para>
<para># modprobe fuse</para>
<para/>
<para>Примеры использования</para>
<para/>
<para>Монтирование раздела: </para>
<para># ntfs-3g /dev/hda1 /mnt/windows</para>
<para/>
<para>Полный доступ для всех пользователей, без ограничений прав доступа, и поддержкой заданной локали (В примере используется ru_RU.utf8, однако у вас она может отличаться): </para>
<para># ntfs-3g /dev/hda1 /mnt/windows -o silent,umask=0,locale=ru_RU.utf8 </para>
<para/>
<para>Размонтирование </para>
<para># fusermount -u /mnt/windows</para>
<para/>
<para>Прочтите страницу руководства по ntfs-3g для получения более подробной информации. </para>
<para>$ man ntfs-3g</para>
<para/>
<para>Монтирование при загрузке:</para>
<para/>
<para>Для автоматической загрузки модуля fuse при старте системы выполните: </para>
<para># echo "fuse" &gt;&gt; /etc/modules.autoload.d/kernel-2.6</para>
<para/>
<para>Отредактируйте /etc/fstab: </para>
<para># echo "/dev/hda1 /mnt/windows ntfs-3g silent,umask=0,locale=ru_RU.utf8 0 0" &gt;&gt; /etc/fstab</para>
<para/></sect4><sect4><title>Вопрос обновления ядра</title>
<para/>
<para>Если после обновления ядра драйвер перестал работать, сделайте следующее: </para>
<para># emerge sys-fs/fuse</para>
<para># modules-update</para>
<para># modprobe fuse</para>
<para/></sect4><sect4><title>Отказ от гарантий</title>
<para/>
<para>Автор этого документа не отвечает за какие либо последтсвия, связанные с использованием этого драйвера. Всё что вы делаете - вы делаете на свой страх и риск.</para>
<para/></sect4></sect3></sect2><sect2><title>Сетевые сервисы</title><sect3><title>Установка Apache2</title><sect4><title>Установка </title>
<para/>
<para>Apache2 сейчас работает на большинстве системах без проблем, если у вас возникли проблемы прочтите раздел Common Problems это может помочь. </para>
<para>Начнем установку apache2: добавьте "apache2" к вашим USE флагу в файле /etc/make.conf и выполните: </para>
<para>emerge apache</para></sect4><sect4><title>Запуск Apache </title>
<para/>
<para>Запустите Apache2: </para>
<para>/etc/init.d/apache2 start</para>
<para/>
<para>Если вы хотите запускать apache2 при запуске системы выполните комманду: </para>
<para>rc-update add apache2 default</para>
<para/>
<para>Посмотрите init scripts section для дополнительной информации. </para>
<para>Теперь у вас есть работующий веб сервер Apache2. Перейдите в вашем браузере на страницу http://localhost/ и вы должны увидеть страницу приветствия. </para>
<para>Вы найдете в /var/www/localhost/htdocs/index.html HTML код страницы приветствия которую вы видите на http://localhost/. Замечаем что Apache отображает htdocs/index.html когда вы пытаетесь открыть htdocs/ . Это особенность протокола HTTP. Apache не может передать директорию но может показать содержимое. Список (index) файлов в директории может быть передан. Apache ищет страницу со специальным именем index либо генерирует список файлов в директории. Если у вас есть страница с именем 'index' то будет отображена она; в этом случае вы не сможете посмотреть список файлов в директории. </para>
<para/></sect4><sect4><title>Модули </title>
<para/>
<para>Apache очень гибок. Он может сёрфить файлы используя HTTP либо серфить файлы и помощью FTP. Он может передать файл с жесткого диска, либо вывод PHP скрипта. Для реализации этого Apache использует модули. Другие приложения используют для этого плагины. При добавлении модули добавляют функциональность. Их также можно инсталлировать, удалять, пересобирать (перекомпилировать). </para>
<para>Модули Apache обычно называются mod_something. Некоторые уже включены в Апачь а некоторые нужно добавлять отдельно. В портежах содержатся множество модулей. Процесс установки выглядит примерно так: </para>
<orderedlist>
<listitem>
<para>emerge module ;</para>
</listitem>
<listitem>
<para>отредактируйте /etc/conf.d/apache2 для активации добавьте -D MOD ;</para>
</listitem>
<listitem>
<para>опционально /etc/apache2/modules.d/xy_module  ;</para>
</listitem>
<listitem>
<para>добавьте директивы конфигурации в httpd.conf либо .htaccess  ;</para>
</listitem>
</orderedlist>
<para>        emerge mod_perl </para>
<para>        nano /etc/conf.d/apache2</para>
<para>        # change APACHE_OPTS="" to APACHE_OPTS="-D PERL"</para>
<para/>
<para>Документацию по конкретным модулям вы найдете Apache Index in this wiki. Вы также можете почитать the documentation для дополнительной информации о модулях Apache. </para>
<para/></sect4><sect4><title>Конфигурация </title>
<para/>
<para>В файле httpd.conf, (/etc/apache2/httpd.conf,) который поставляется с Gentoo хранятся большинство настроек Apache. However, it probably does both more and less than you need it to. Apache configuration files have a consistent syntax. </para>
<para/>
<para>Любые строки начинающиеся с # игнорируются </para>
<para># Apache не анализирует написанное здесь</para>
<para># это комментарии</para>
<para/>
<para>Некоторые строки начинаются с директивы и могут иметь один или несколько аргументов. </para>
<para/>
<para>Директивы могут быть объединены в секции. Разделы обычно заключены в угловые скобки. </para>
<para>&lt;Section&gt;</para>
<para>  # Will only apply when the section matches</para>
<para>  AnotherDirective</para>
<para>&lt;/Section&gt;</para>
<para/>
<para>В разделе могут быть подразделы. Вот часть файла httpd.conf: </para>
<para># If mod_alias is loaded</para>
<para>&lt;IfModule mod_alias.c&gt;</para>
<para>    # Alias is a directive and it only applies if mod_alias is loaded</para>
<para>    Alias /icons/ "/usr/share/httpd/icons/"</para>
<para>    # If the file is in the directory</para>
<para>    &lt;Directory "/usr/share/httpd/icons"&gt;</para>
<para>        # Options will only apply if:</para>
<para>        #   mod_alias is loaded AND</para>
<para>        #   the file is in the directory</para>
<para>        Options Indexes MultiViews</para>
<para>    &lt;/Directory&gt;</para>
<para>&lt;/IfModule&gt;</para>
<para/>
<para>Вы можете прочитать подробнее configuration files и sections в оффициальная документация Apache. </para>
<para/></sect4><sect4><title>Common Problems </title>
<para/>
<para>SSI Not Working </para>
<para/>
<para>When configuring for SSI (Server Side Includes), an error may occur: </para>
<para>mod_include: Options +Includes (or IncludesNoExec) wasn't set, INCLUDES filter removed</para>
<para>The problem is that setting Options +Includes in either .htaccess or httpd.conf is overwritten by the additional configuration file as defined at the end of httpd.conf. </para>
<para>Include /etc/apache2/vhosts.d/*.conf</para>
<para/>
<para>You need to edit this additional configuration file such that </para>
<para>AllowOverride None</para>
<para/>
<para>Is replaced by </para>
<para>AllowOverride Options</para>
<para/>
<para>Could Not Open Error Log </para>
<para/>
<para>While starting Apache, it prints: </para>
<para>Error while starting apache: (2)No such file or directory: apache2: could not open error log file /usr/lib/apache2/logs/error_log.</para>
<para/>
<para>/usr/lib/apache2/logs should be a symlink pointing to /var/log/apache2 . Check it using: </para>
<para>ls -la /usr/lib/apache2/logs</para>
<para/>
<para>(note the lack of a slash on the end). If /var/log/apache2 is missing, create it and make sure you give apache ownership: </para>
<para>mkdir /var/log/apache2</para>
<para>chown apache:apache /var/log/apache2</para>
<para/>
<para>If the symlink /usr/lib/apache2/logs is missing, you can create it: </para>
<para>ln -s /var/log/apache2 /usr/lib/apache2/logs</para>
<para/>
<para>You don't need to set permissions on the symlink. </para>
<para/>
<para>Check the Logs </para>
<para/>
<para>See /var/log/apache2/error_log for errors, especially towards the end of the file. You may find tail useful because it displays only the last few lines of a file: </para>
<para>tail /var/log/apache2/error_log</para>
<para/>
<para>If you wish to keep an eye one the log the -f option for tail may be useful: </para>
<para> tail -f /var/log/apache2/error_log</para>
<para/>
<para>Here's one error you might see: </para>
<para>Error: [alert] (EAI 2)Name or service not known: mod_unique_id: unable to find IPv4 address of ""</para>
<para/>
<para>With the base installation "mod_unique_id" is turned on, this can cause problems, notably the server not starting. Simply comment out this module in /etc/apache2/httpd.conf and the problem will be solved. </para>
<para/>
<para>(Your config file might be /etc/apache2/conf/apache2.conf) </para>
<para/>
<para>Forbidden User Directories </para>
<para/>
<para>If the server is returning "403 Forbidden" while accessing http://server/~username/ Make sure Apache (usually user apache and group apache) has read access to username's home directory and public_html (or equivalent). You can grant everyone read access using: </para>
<para>chmod 755 ~username/ ~username/public_html/</para>
<para/>
<para>Not Enough Entropy </para>
<para/>
<para>If Apache2 </para>
<para>accepts connections </para>
<para>does not respond to clients </para>
<para>creates exactly one process </para>
<para>is not stopped by </para>
<para>/etc/init.d/apache2 stop</para>
<para/>
<para>Check to see how much entropy is available using: </para>
<para>cat /proc/sys/kernel/random/entropy_avail</para>
<para/>
<para>If little entropy (less than 100) is available, Apache2 is probably waiting for more so it can generate the secret for digest authentication (mod_auth_digest). To generate more entropy, just do something else for a little while. Grepping the kernel or emerging a package usually works well. </para>
<para/>
<para>The video-entropyd and audio-entropyd supply /dev/random with entropy gathered from your video and audio devices, respectively. If you have a hardware random number generator (RNG), you can emerge rng-tools and run rngd. </para>
<para/>
<para>If there's still a shortage of entropy, you can enable the urandom USE flag and re-emerge APR and Apache2. This makes APR use /dev/urandom, which falls back to a pseudorandom number generator when there isn't enough entropy. The program gets a number immediately, but it is cryptographically weaker. This is okay for some things (e.g. solitaire), but completely unacceptable for others (like PGP key generation). </para>
<para/>
<para>Confusing config files </para>
<para/>
<para>If you start the Apache2 server with the startup script /etc/init.d/apache2 check to see if the line </para>
<para/>
<para>local myconf="/etc/apache2/httpd.conf" </para>
<para/>
<para>from /etc/init.d/apache2 points to your configuration script. If it points to apache.conf and you use httpd.conf, make the necessary adjustments. </para>
<para/>
<para/>
<para/>
<para/></sect4><sect4><title>See Also </title>
<para/>
<para>Configure LAMP (Linux, Apache, MySQL, and Python/PHP/Perl) - A popular web server combination </para>
<para>Apache Installation &amp; Configuration </para>
<para>How to install mod_security for Apache</para>
<para/></sect4></sect3><sect3><title>Настройка iptables для начинающих</title><sect4><title>Введение </title>
<para>В сети мало документации по <ulink url="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</ulink> рассчитанной на новичков. Мы же попытаемся восполнить этот пробел. Рассмотрим основы составления правил, а также некоторые дополнительные модули которые помогут сделать жизнь легче. </para>
<para>Прежде чем двигаться дальше - убедитесь, что ... </para>
<orderedlist>
<listitem>
<para>Всё ваше аппаратное обеспечение работоспособно. То есть Вы подключили все оборудование, модули грузятся, устройства видны в системе. Полезно в начале проверить, что соединение с интернетом возможно и без всяких там <ulink url="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</ulink>. Нет ничего хуже, чем в течении многих часов возиться с упрямой программой, ругая её почём зря, а потом понять, что сетевая карта не работает или модем сконфигурирован неправильно. </para>
</listitem>
<listitem>
<para>Вы имеете представление о сетевых технологиях и Вы знакомы с администрированием Linux и Gentoo Linux в частности. То есть необходимы навыки работы с такими базовыми вещами как <ulink url="http://ru.gentoo-wiki.com/index.php?title=Man_ifconfig&amp;action=edit">ifconfig</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=Man_rc-update&amp;action=edit">rc-update</ulink>, /etc/conf.d/net, и так далее. Если для Вас это пока пустые звуки, то, пожалуйста предварительно изучите <link linkend="">Настольную книгу Gentoo</link> и <ulink url="http://www.linuxhelp.ca/guides/networkbasics/">Linux Help's Networking Basics 101</ulink> </para>
</listitem>
</orderedlist></sect4><sect4><title>Конфигурация ядра ОС Linux </title>
<para>Все что вам нужно - это включить поддержку <ulink url="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</ulink>. </para>
<para>Networking ---&gt;</para>
<para>  Networking Options----&gt;</para>
<para>   Network Packet Filtering (replace Ipchains)---&gt;</para>
<para>    Netfilter Configuration</para>
<para>Включим все опции как модули (хотя с точки зрения безопасности модули следует вообще отключить, монолитное ядро надежнее, хотя и медленнее). </para></sect4><sect4><title>Установка iptables </title>
<para>Далее вы должны установить пакет <ulink url="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</ulink>: emerge iptables </para></sect4><sect4><title>Проверка сети </title>
<para>Предположим, что у нас есть 2 сетевых интерфейса: eth0 - локальная сеть и ppp0 - интернет соединение. </para>
<para>Проверим работоспособность сети командой <ulink url="http://ru.gentoo-wiki.com/index.php?title=Man_ping&amp;action=edit">ping</ulink>: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ping </para>
</entry>
</row>
<row>
<entry>
<para>ping www.google.com</para>
<para>ping 192.168.1.78 </para>
<para>ping 192.168.2.77</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>Запуск iptables </title>
<para>Запустим <ulink url="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</ulink>: /etc/init.d/iptables start </para>
<para>Эта команда загрузит основные модули и создаст цепочки в ядре Linux. Теперь добавим <ulink url="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</ulink> в автозагрузку: rc-update add iptables default </para></sect4><sect4><title>Использование /etc/init.d/iptables </title>
<para>Скрипт /etc/init.d/iptables понимает несколько команд (/etc/init.d/iptables &lt;команда&gt;), некоторые из них: </para>
<orderedlist>
<listitem>
<para>start - запуск <ulink url="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</ulink>. Восстанавливает все правила (правила хранятся в /var/lib/iptables/rules-save); </para>
</listitem>
<listitem>
<para>stop - сброс всех цепочек; </para>
</listitem>
<listitem>
<para>save - сохранение всех правил. </para>
</listitem>
</orderedlist></sect4><sect4><title>Создание правил </title>
<para>Практически все правила можно привести к виду: iptables -A ЦЕПОЧКА ПАРАМЕТРЫ_ПАКЕТА -j ДЕЙСТВИЕ </para>
<para>Цепочки </para>
<para>Все изменения будем проводить над таблицей filter, именно она отвечает за фильтрацию пакетов. В таблице filter существует 3 цепочки: INPUT, OUTPUT и FORWARD. В каждой цепочки свой "тип" пакетов: </para>
<orderedlist>
<listitem>
<para>INPUT - пакеты пришедшие к Вам. То есть входящий трафик. </para>
</listitem>
<listitem>
<para>FORWARD - пакеты которые предназначены для другого узла, то есть транзитный трафик. </para>
</listitem>
<listitem>
<para>OUTPUT - пакеты, которые уходят от нас, или исходящий трафик. </para>
</listitem>
</orderedlist>
<para>Работают с цепочками так: iptables &lt;опция&gt; &lt;цепочка&gt; </para>
<para>Для работы с цепочками предусмотрены следующие опции: </para>
<orderedlist>
<listitem>
<para>-A - добавление нового правила в цепочку. Правило будет добавлено в конец цепочки. </para>
</listitem>
<listitem>
<para>-I - добавление правила не в конец,а туда куда вы укажите. Например команда: </para>
</listitem>
</orderedlist>
<para>iptables -I INPUT 2 bla-bla-bla - сделает наше правило вторым. </para>
<orderedlist>
<listitem>
<para>-D - удаление правила. Например для удаления пятого правила введите: </para>
</listitem>
</orderedlist>
<para>iptables -D INPUT 5 </para>
<orderedlist>
<listitem>
<para>-F - сброс всех правил цепочки. Нужно, например,при удалении ненужной цепочки. </para>
</listitem>
<listitem>
<para>-N - создание пользовательской цепочки. Если не хотите создавать кашу в каждой цепочке, то создайте несколько дополнительных цепочек. Синтаксис такой: iptables -N ЦЕПОЧКА. Только русские буквы, конечно, использовать нельзя. </para>
</listitem>
<listitem>
<para>-X - удаление пользовательской цепочки. </para>
</listitem>
</orderedlist>
<para>ПРИМЕЧАНИЕ: Удалить цепочки INPUT, OUTPUT и FORWARD нельзя. </para>
<orderedlist>
<listitem>
<para>-P - установка политики для цепочки. Например: </para>
</listitem>
</orderedlist>
<para>iptables -P ЦЕПОЧКА ПОЛИТИКА </para></sect4><sect4><title>Параметры пакетов </title>
<para>Итак по каким параметрам можно фильтровать пакеты? Рассмотрим самые основные. </para>
<para>Источник пакета </para>
<para>Для фильтрации по источнику используется опция -s. Например запретим все входящие пакеты с узла 192.168.133.133: iptables -A INPUT -s 192.168.133.133 -j DROP </para>
<para>Можно использовать доменное имя для указания адреса хоста. То есть: iptables -A INPUT -s test.host.jp -j DROP </para>
<para>Также можно указать целую подсеть: iptables -A INPUT -s 192.168.133.0/24 -j DROP </para>
<para>Также вы можете использовать отрицание (знак !). Например так - все пакеты с хостов отличных от 192.168.133.156 будут уничтожаться: iptables -A INPUT -s ! 192.168.133.156 -j DROP </para>
<para/>
<para>Адрес назначения </para>
<para>Для этого нужно использовать опцию -d. Например запретим все исходящие пакеты на хост 192.168.156.156: iptables -A OUTPUT -d 192.168.156.156 -j DROP </para>
<para>Как и в случае с источником пакета можно использовать адреса подсети и доменные имена. Отрицание также работает. </para>
<para/>
<para>Протокол </para>
<para>Опция -p указывает на протокол. Можно использовать all, icmp, tcp, udp. </para>
<para/>
<para>Порт источника </para>
<para>Указывает на порт с которого был прислан пакет. Вот синтаксис: iptables -A INPUT -p tcp --sport 80 -j ACCEPT </para>
<para>Для указания порта необходимо указать протокол (tcp или udp). Можно использовать отрицание. </para>
<para/>
<para>Порт назначения </para>
<para>Порт назначения. Синтаксис: iptables -A INPUT -p tcp --dport 80 -j ACCEPT </para>
<para>Как и в случае с портом источника нужно указать протокол. Можно использовать отрицание. </para></sect4><sect4><title>Действия над пакетами </title>
<para>Проку от того,что мы укажем параметры пакета нет.Нужно указать,что надо с ним делать. Для этого служит опция -j. Рассмотрим основные действия: </para>
<orderedlist>
<listitem>
<para>ACCEPT - разрешить пакет. </para>
</listitem>
<listitem>
<para>DROP - уничтожить пакет. </para>
</listitem>
<listitem>
<para>REJECT - будет отправлено ICMP сообщение, что порт недоступен. </para>
</listitem>
<listitem>
<para>LOG - информация об этом пакете будет добавлена в системный журнал (<ulink url="http://ru.gentoo-wiki.com/index.php?title=Man_syslog&amp;action=edit">syslog</ulink>). </para>
</listitem>
</orderedlist>
<para>В качестве действия можно указать и имя пользовательской цепочки. Например перекинем все пакеты с локальной сети в цепочку, где будет производиться дополнительная проверка: iptables -A INPUT -s 192.168.200.0/24 -j LOCAL_NET </para></sect4><sect4><title>Пример правил </title>
<para>В больши�стве случаев пользователю достаточно выполнить такую последовательность комманд: iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT iptables -A INPUT -i lo -j ACCEPT iptables -P INPUT DROP </para>
<para>Вот собственно и вся настройка. На первый взгляд непонятно, что мы тут вообще сделали. Поэтому ознакомимся с основами составления правил. </para></sect4><sect4><title>Модули </title>
<para>Может сложиться впечатление, что возможностей у <ulink url="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</ulink> маловато. Однако с использованием модулей <ulink url="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</ulink> получит просто безграничные возможности. Для указания модуля используется опция -m. Например: iptables -A INPUT -m модуль bla-bla </para>
<para>-m owner </para>
<para>Добавляет следующие опции (опции только для цепочки OUTPUT): </para>
<orderedlist>
<listitem>
<para>--uid-owner UID - UID программы пославшей пакет. </para>
</listitem>
<listitem>
<para>--gid-owner GID - GID прораммы пославшей пакет. </para>
</listitem>
</orderedlist>
<para>Следующие опции доступны только в версиях ядра ниже 2.6.14: </para>
<orderedlist>
<listitem>
<para>--pid-owner PID - PID программы пославшей пакет. </para>
</listitem>
<listitem>
<para>--sid-owner SID - SID (идентификатор сессии) производится проверка SID пакета, значение SID наследуются дочерними процессами от "родителя". </para>
</listitem>
<listitem>
<para>--cmd-owner NAME - имя программы пославшей пакет. </para>
</listitem>
</orderedlist>
<para/>
<para>-m multiport </para>
<para>Позволяет указывать не по одному порту, а сразу несколько: </para>
<orderedlist>
<listitem>
<para>--source-ports порт1,порт2 - список портов, с которых пришел пакет; </para>
</listitem>
<listitem>
<para>--sports порт1,порт2 - укороченый аналог --source-ports; </para>
</listitem>
<listitem>
<para>--destination-ports порт1,порт2 - список портов назначения; </para>
</listitem>
<listitem>
<para>--dports порт1,порт2 - укороченый аналог --destination-ports; </para>
</listitem>
<listitem>
<para>--ports порт1,порт2 - проверяет как исходящий так и входящий порт пакета. </para>
</listitem>
</orderedlist>
<para/>
<para>-m state </para>
<para>Предназначен для указания состояния пакета с помощью опции --state. Доступны следующие типы пакетов: </para>
<orderedlist>
<listitem>
<para>NEW - пакет устанавливающий новое соединение. </para>
</listitem>
<listitem>
<para>ESTABLISHED - пакет от уже установленного соединения. </para>
</listitem>
<listitem>
<para>RELATED - новый пакет уже установленном соединении. </para>
</listitem>
</orderedlist>
<para/>
<para>-m mac </para>
<para>Проверяет соответствие MAC-адреса в пакете с помощью опции --mac-source, например: </para>
<para>iptables -A INPUT -s 192.168.0.1 -m mac --mac-source 00:65:3F:ED:12:98 -j DROP</para>
<para>Получено с <ulink url="http://ru.gentoo-wiki.com/Настройка_iptables_для_начинающих">http://ru.gentoo-wiki.com/Настройка_iptables_для_начинающих</ulink>
</para>
<para/></sect4></sect3><sect3><title>Подробная настройка iptables</title>
<para/><sect4><title>Введение</title>
<para>Документация по iptables в сети не рассчитана на новичков. В этой статье будет сжато и быстро описаны команды, затем, возможно, будут правки и добавления для расширенного объяснения. Так что это будет минимальная установка которую мы в дальнейшем расширим и упрочим с помощью правил. </para>
<para>Так же примите во внимание, что будет использовано pppoe соединение и 2.6.x ядро. Для настройки сетевой карты надо будет заменить ppp0 на eth0 (или подходящий по смыслу ваш сетевой интерфейс глядящий в интернет) </para>
<para> Прежде чем двигаться дальше - убедитесь, что ...</para>
<orderedlist>
<listitem>
<para>1.Всё ваше аппаратное обеспечение работоспособно. То есть вы все подключили, модули грузятся, устройства видны в системе. Полезно вначале проверить, что соединение с интернетом возможно и без всяких там iptables. Нет ничего хуже, чем в течение многих часов возиться с упрямой программой, ругая её почём зря, а потом понять, что сетевая плата не работает или модем сконфигурирован неправильно. </para>
</listitem>
<listitem>
<para>2.Вы читали маны по теме. Предполагается, что, пока вы изучаете это руководство, man iptables постоянно открыт в соседнем терминале для точного понимания и уточнения, что же та или иная команда означает на самом деле. </para>
</listitem>
<listitem>
<para>3.Вы имеете представление о сетевых технологиях и Вы знакомы с администрированием Linux и Gentoo Linux в частности. То есть необходимы навыки работы с такими базовыми вещами как <ulink url="http://ru.gentoo-wiki.com/index.php?title=Ifconfig&amp;action=edit">ifconfig</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=Rc-update&amp;action=edit">rc-update</ulink>, /etc/conf.d/net, и так далее. Если для вас это пока пустые звуки, то, пожалуйста предварительно изучите <ulink url="http://www.gentoo.org/doc/en/handbook/index.xml">The Gentoo Handbook</ulink> и <ulink url="http://www.linuxhelp.ca/guides/networkbasics/">Linux Help's Networking Basics 101</ulink> </para>
</listitem>
</orderedlist></sect4><sect4><title>Конфигурация ядра</title>
<para>Все что вам нужно - это включить поддержку iptables. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Linux Kernel Configuration: Включение IPTables </para>
</entry>
</row>
<row>
<entry>
<para>Device Drivers---&gt;</para>
<para> Networking Support---&gt;</para>
<para>  Networking Options----&gt;</para>
<para>   Network Packet Filtering (replace Ipchains)---&gt;</para>
<para>    Netfilter Configuration</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Я включил все опции как модули (с тем рассчетом, что я захочу попробовать другие опции позже) и добавил ip_tables в modules.autoload. Это загрузит еще несколько модулей в качестве зависимостей. Модуль ip_conntrack необходим для "statefull" фильтрования, то есть для отслеживания соединений. Для запуска скриптов выполните команду : </para>
<para># modprobe ip_tables </para></sect4><sect4><title/></sect4><sect4><title>Необходимые утилиты</title>
<para>Далее вы должны установить пакет iptables: </para>
<para># emerge iptables </para></sect4><sect4><title>Конфигурация интерфейсов</title>
<para>
<ulink url="http://ru.gentoo-wiki.com/Сетевые_протоколы_индекс">Сетевые протоколы</ulink> </para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>
<ulink url="http://ru.gentoo-wiki.com/Сетевые_протоколы_индекс#.D0.9F.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.8B_.D1.83.D1.80.D0.BE.D0.B2.D0.BD.D1.8F_.D0.BF.D1.80.D0.B8.D0.BB.D0.BE.D0.B6.D0.B5.D0.BD.D0.B8.D1.8F">Прикладной уровень</ulink>
</para>
</entry>
<entry>
<para>
<ulink url="http://ru.gentoo-wiki.com/index.php?title=HTTP&amp;action=edit">HTTP</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=SMTP&amp;action=edit">SMTP</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=SSH&amp;action=edit">SSH</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=SNMP&amp;action=edit">SNMP</ulink>, <ulink url="http://ru.gentoo-wiki.com/FTP">FTP</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=NNTP&amp;action=edit">NNTP</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=NTP&amp;action=edit">NTP</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=LDAP&amp;action=edit">LDAP</ulink>, ...</para>
</entry>
</row>
<row>
<entry>
<para>
<ulink url="http://ru.gentoo-wiki.com/Сетевые_протоколы_индекс#.D0.9F.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.8B_.D1.81.D0.B5.D0.B0.D0.BD.D1.81.D0.BE.D0.B2.D0.BE.D0.B3.D0.BE_.D1.83.D1.80.D0.BE.D0.B2.D0.BD.D1.8F">Сеансовый уровень</ulink>
</para>
</entry>
<entry>
<para>
<ulink url="http://ru.gentoo-wiki.com/index.php?title=TLS&amp;action=edit">TLS</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=SSL&amp;action=edit">SSL</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=RPC&amp;action=edit">RPC</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=WSP&amp;action=edit">WSP</ulink>...</para>
</entry>
</row>
<row>
<entry>
<para>
<ulink url="http://ru.gentoo-wiki.com/Сетевые_протоколы_индекс#.D0.9F.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.8B_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D0.BD.D0.BE.D0.B3.D0.BE_.D1.83.D1.80.D0.BE.D0.B2.D0.BD.D1.8F">Транспортный уровень</ulink>
</para>
</entry>
<entry>
<para>
<ulink url="http://ru.gentoo-wiki.com/index.php?title=TCP&amp;action=edit">TCP</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=UDP&amp;action=edit">UDP</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=SCTP&amp;action=edit">SCTP</ulink>, <ulink url="http://ru.gentoo-wiki.com/ICMP">ICMP</ulink>, <ulink url="http://ru.gentoo-wiki.com/OSPF">OSPF</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=RSVP&amp;action=edit">RSVP</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=VRRP&amp;action=edit">VRRP</ulink>, <ulink url="http://ru.gentoo-wiki.com/RTP">RTP</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=DCCP&amp;action=edit">DCCP</ulink> ...</para>
</entry>
</row>
<row>
<entry>
<para>
<ulink url="http://ru.gentoo-wiki.com/Сетевые_протоколы_индекс#.D0.9F.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.8B_.D1.81.D0.B5.D1.82.D0.B5.D0.B2.D0.BE.D0.B3.D0.BE_.D1.83.D1.80.D0.BE.D0.B2.D0.BD.D1.8F">Сетевой уровень</ulink>
</para>
</entry>
<entry>
<para>
<ulink url="http://ru.gentoo-wiki.com/IP">IPv4</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=IPv6&amp;action=edit">IPv6</ulink>, <ulink url="http://ru.gentoo-wiki.com/ARP">ARP</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=RARP&amp;action=edit">RARP</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=MPLS&amp;action=edit">MPLS</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=IPX&amp;action=edit">IPX</ulink> ...</para>
</entry>
</row>
<row>
<entry>
<para>
<ulink url="http://ru.gentoo-wiki.com/Сетевые_протоколы_индекс#.D0.9F.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.8B_.D0.BA.D0.B0.D0.BD.D0.B0.D0.BB.D1.8C.D0.BD.D0.BE.D0.B3.D0.BE_.D1.83.D1.80.D0.BE.D0.B2.D0.BD.D1.8F">Канальный уровень</ulink>
</para>
</entry>
<entry>
<para>
<ulink url="http://ru.gentoo-wiki.com/index.php?title=Ethernet&amp;action=edit">Ethernet</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=IEEE_802&amp;action=edit">802.11</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=DSL&amp;action=edit">xDSL</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=Fibre_Channel&amp;action=edit">Fibre Channel</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=FDDI&amp;action=edit">FDDI</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=ATM&amp;action=edit">ATM</ulink>, <ulink url="http://ru.gentoo-wiki.com/index.php?title=ISDN&amp;action=edit">ISDN</ulink> ...</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>В моем случае имеется 3 сетевых адаптера. Один подключен к <ulink url="http://ru.gentoo-wiki.com/WAN">WAN</ulink> через pppoe. Другие два - к моей внутренней сети. Для того, чтобы не было проблем с iptables и маскардингом (<ulink url="http://ru.gentoo-wiki.com/NAT">NAT</ulink>'ом), они должны быть сконфигурированы для различных подсетей. Для примера, 2 сетевых адаптера подключены к моим внутренним компьютерам (внутренние сетевые интерфейсы). Им присвоены IP-адреса: 192.168.1.1 и 192.168.2.1. </para>
<para>Следует заметить, что будет лучше если подключать эти внутренние адаптеры в любое сетевое устройство, такие как свитч и хаб. Для pppoe подключений мы должны убедиться, что сетевой адаптер подключен к внешнему миру, то есть внешним интерфейсам не присвоены никакие IP-адреса. Его запись в /etc/conf.d/net должна оставаться пустой. Это делается потому, что pppoe выступает в качестве виртуального устройства, которое включается вслед за сетевым интерфейсом. Мы также должны присвоить правильные сетевые маски и широковещательные адреса для этих интерфейсов. Ваш conf.d/ должна выглядеть примерно так: </para>
<para>Сервер</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/conf.d/net </para>
</entry>
</row>
<row>
<entry>
<para> # Для pppoe подключений вы не должны указывать значения для [[eth0]], </para>
<para> # просто добавьте net.ppp0 или rc-pppoe в default уровень загрузки.</para>
<para> iface_eth0="192.168.1.1 broadcast 192.168.1.255 netmask 255.255.255.0"</para>
<para> iface_eth1="192.168.2.1 broadcast 192.168.2.255 netmask 255.255.255.0"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Заметьте, что не было указано никаких шлюзов. </para>
<para>Клиент1</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/conf.d/net </para>
</entry>
</row>
<row>
<entry>
<para> iface_eth0="192.168.1.77 broadcast 192.168.1.255 netmask 255.255.255.0"</para>
<para> gateway="eth0/192.168.1.1"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Клиент2</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/conf.d/net </para>
</entry>
</row>
<row>
<entry>
<para> iface_eth0="192.168.2.77 broadcast 192.168.2.255 netmask 255.255.255.0"</para>
<para> gateway="eth0/192.168.2.1"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Шлюз для клиентов установлен на внутренний IP сетевого интерфейса сервера, что и логично. Теперь добавьте все интерфейсы в default уровень загрузки и перезапустите подключения: </para>
<para># rc-update add net.eth1 default &amp;&amp; rc-update add net.eth2 default &amp;&amp; rc-update add net.ppp0 default </para>
<para>и </para>
<para># /etc/init.d/net.eth1 start &amp;&amp; /etc/init.d/net.eth2 start &amp;&amp; /etc/init.d/net.ppp0 start </para>
<orderedlist>
<listitem>
<para>Для клиентов: </para>
</listitem>
</orderedlist>
<para># /etc/init.d/net.eth0 restart </para></sect4><sect4><title>Проверка настроек</title>
<para>Теперь убедитесь в том, что ваш сервер подключен к интернету, а также все интерфейсы могут пинговать друг друга. Для сервера: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ping </para>
</entry>
</row>
<row>
<entry>
<para>ping www.google.com; </para>
<para>ping 192.168.1.78 </para>
<para>ping 192.168.2.78</para>
<para>ping 192.168.1.77</para>
<para>ping 192.168.2.77</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Убедитесь что у клиентов правильно указаны <ulink url="http://ru.gentoo-wiki.com/DNS">DNS</ulink>-сервера в /etc/resolv.conf </para></sect4><sect4><title>Scripting</title>
<para>Теперь интересная часть... iptables и NAT(трансляция адресов). Для начала сделаем простое перенаправление адресов с минимальными правилами, чтобы убедиться что можем выходить в сеть. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: Если вы параноик, то это не самое секретное, что можно сделать... мы открываемся в сеть с мизерной защитой. Однако будем считать, что сеть настраиваем для дома или для игрового класса. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /var/lib/iptables/rules-save </para>
</entry>
</row>
<row>
<entry>
<para>#!/bin/bash</para>
<para/>
<para>IPTABLES='/sbin/iptables'</para>
<para/>
<para># Определяем интерфейсы</para>
<para>EXTIF='ppp0'</para>
<para>INTIF1='eth1'</para>
<para>INTIF2='eth2'</para>
<para/>
<para># Включаем форвардинг ip в ядре.</para>
<para>/bin/echo 1 &gt; /proc/sys/net/ipv4/ip_forward</para>
<para/>
<para># Сбросить правила и удалить цепочки </para>
<para>$IPTABLES -F</para>
<para>$IPTABLES -t nat -F</para>
<para>$IPTABLES -t mangle -F</para>
<para>$IPTABLES -X</para>
<para>$IPTABLES -t nat -X</para>
<para>$IPTABLES -t mangle -X</para>
<para/>
<para># Включаем маскарадинг для разрешения доступа в интернет</para>
<para>$IPTABLES -t nat -A POSTROUTING -o $EXTIF -j MASQUERADE</para>
<para/>
<para># Форвардить сетевой трафик с $INTIF1 на интернетовский интерфейс $EXTIF</para>
<para>$IPTABLES -A FORWARD -i $INTIF1 -o $EXTIF -m state --state NEW,ESTABLISHED -j ACCEPT</para>
<para/>
<para># Форвардить сетевой трафик с $INTIF2 на интернетовский интерфейс $EXTIF</para>
<para>$IPTABLES -A FORWARD -i $INTIF2 -o $EXTIF -m state --state NEW,ESTABLISHED -j ACCEPT</para>
<para/>
<para>#echo -e "       - Разрешаем доступ к SSH серверу"</para>
<para>$IPTABLES -A INPUT --protocol tcp --dport 22 -j ACCEPT</para>
<para>#echo -e "       - Разрешаем доступ к HTTP серверу"</para>
<para>$IPTABLES -A INPUT --protocol tcp --dport 80 -j ACCEPT</para>
<para># Блокируем все прочие попытки доступа на $EXTIF</para>
<para>$IPTABLES -A INPUT -i $EXTIF -m state --state NEW,INVALID -j DROP</para>
<para>$IPTABLES -A FORWARD -i $EXTIF -m state --state NEW,INVALID -j DROP</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>Проверка на работоспособность</title>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Этот скрипт написан кем-то в сетевом форуме... Адрес автора утерян, имя... В общем, спасибо ему, пусть и без имени. (Надеюсь, он не обидется). </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь проверяем могут ли наши пользователи выйти в интернет или подключиться к серверу по ssh. Если все нормально, то можно переходить ниже по тексту. Если нет - проверьте синтаксические ошибки и прочее... Удостоверьтесь, что IP-адреса и маски клиентов и сервера введены правильно... Ну или... </para>
<para>Если все работает, как задумали, сохраняем конфигурацию: </para>
<para># /etc/init.d/iptables save </para>
<para>И бэкапим вашу рабочую конфигурацию для возможного восстановления "как было": </para>
<para># cp /var/lib/iptables/rules-save /var/lib/iptables/rules.working </para>
<para>Проверим iptables start-up скрипт перед тем как добавить iptables в default runlevel: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Проверка скрипта </para>
</entry>
</row>
<row>
<entry>
<orderedlist>
<listitem>
<para>/etc/init.d/iptables start </para>
</listitem>
<listitem>
<para>/etc/init.d/iptables stop </para>
</listitem>
<listitem>
<para>/etc/init.d/iptables start </para>
</listitem>
</orderedlist>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Смысл в запуске-остановке-запуске в том, что у нас нет скрипта запуска iptables... поэтому нужно “инициализировать” статус перед остановкой. Остановка, по существу, обнуляет настройки и возвращает все к исходному. Перезапуск покажет нам работает ли наша сеть после перезагрузки. Если все в порядке, то добавляем iptables в default runlevel: </para>
<para>rc-update add iptables default </para>
<para>Не забудем также установить в /etc/sysctl.conf: </para>
<para>net.ipv4.ip_forward = 1 </para></sect4><sect4><title>Оборона Firewall</title>
<para>Далее мы сделаем наш, уже работающий файрвол безопасным, т.е. защищающим нашу систему от проникновений извне. На самом деле нам придется настроить файрвол таким образом, чтобы он не только защищал нас, но и защищал внешнюю сеть от нас. :) Защита такого рода является обязательной, она нужна для того, чтобы, в том случае, если наша система все-таки была взломана, взломщик не смог воспользоваться нашими ресурсами для дальнейшей атаки любого рода. Этот аспект является важнейшим в сетях класса SOHO, т.е. небольших офисах. Обыкновенно вирусы не оказывают никакого влияния на малые сети и заражение ими редко приводит к потере данных. Для нас, пользователей *nix, этой проблемы практически не существует. В любом случае, т.к. небольшие сети, как правило, защищены гораздо хуже больших, кракеры стараются использовать их в качестве “опорной базы” для DoS атак, или другой своей вредоносной активности. </para>
<para>В последующем я опишу всю конфигурацию по кусочкам, дабы мы смогли бы проверить пошагово каждый фрагмент. Каждый шаг может потребовать от вас вставки чего-либо до, после или в середину указываемого скрипта. Все действия производятся так, чтобы (я надеюсь) ваша сеть не работала только лишь короткий промежуток времени во время настройки. Это сделано мною потому как я предположил что у многих из вас (таких как я) выделен сервер под Firewall. И так как я предпочитаю настраивать свой сервер через SSH, отключение сети может иметь пренеприятные последствия, такие как ползания под столами или хуже того. Если же вы смелы, то вы можете скопировать скрипт в конце этого документа и запустить его на своей машине. Этот скрипт должен быть работоспособен на все сто, но тестировал я его только на своей машине, так что <ulink url="http://lingvo.yandex.ru/en?text=YMMV">ymmv</ulink>. </para>
<para/></sect4><sect4><title>Установка переменных окружения</title>
<para>Вы можете установить необходимые переменные окружения следующим скриптом: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ' </para>
</entry>
</row>
<row>
<entry>
<para>#!/bin/sh</para>
<para>#</para>
<para># Внешний интерфейс</para>
<para>EXTIF="ppp0"</para>
<para/>
<para># Внутренний интерфейс</para>
<para>INTIF="eth1"</para>
<para/>
<para># Loop device/localhost</para>
<para>LPDIF="lo"</para>
<para>LPDIP="127.0.0.1"</para>
<para>LPDMSK="255.0.0.0"</para>
<para>LPDNET="$LPDIP/$LPDMSK"</para>
<para/>
<para># Необходимые утилиты</para>
<para>IPT="/sbin/iptables"</para>
<para>IFC="/sbin/ifconfig"</para>
<para>G="/bin/grep"</para>
<para>SED="/bin/sed"</para>
<para>AWK="/usr/bin/awk"</para>
<para>ECHO="/bin/echo"</para>
<para/>
<para># Последующие команды могут работать некорректно при локализации.</para>
<para/>
<para># Установка переменных окружения внешнего интерфейса</para>
<para>EXTIP="`$IFC $EXTIF | $AWK /$EXTIF/'{next}//{split($0,a,":");split(a[2],a," ");print a[1];exit}'`"</para>
<para>EXTBC="255.255.255.255" </para>
<para>#EXTMSK="`$IFC $EXTIF | $G Mask:|$SED 's/.*Mask:\([^ ]*\)/\1/'`"</para>
<para>EXTMSK="`$IFC $EXTIF | $AWK /$EXTIF/'{next}//{split($0,a,":");split(a[4],a," ");print a[1];exit}'`"</para>
<para>EXTNET="$EXTIP/$EXTMSK"</para>
<para>$ECHO "EXTIP=$EXTIP EXTBC=$EXTBC EXTMSK=$EXTMSK EXTNET=$EXTNET"</para>
<para/>
<para># Due to absence of EXTBC I manually set it to 255.255.255.255</para>
<para># this (hopefully) will serve the same purpose</para>
<para/>
<para># Установка переменных окружения внутреннего интерфейса</para>
<para>INTIP="`$IFC $INTIF | $AWK /$INTIF/'{next}//{split($0,a,":");split(a[2],a," ");print a[1];exit}'`"</para>
<para>INTBC="`$IFC $INTIF | $AWK /$INTIF/'{next}//{split($0,a,":");split(a[3],a," ");print a[1];exit}'`"</para>
<para>INTMSK="`$IFC $INTIF | $AWK /$INTIF/'{next}//{split($0,a,":");split(a[4],a," ");print a[1];exit}'`"</para>
<para>INTNET="$INTIP/$INTMSK"</para>
<para>$ECHO "INTIP=$INTIP INTBC=$INTBC INTMSK=$INTMSK INTNET=$INTNET"</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>iptables ACCEPTS</title>
<para>Теперь мы должны установить ACCEPTы, так, чтобы мы могли соединяться с нашим сервером. На самом деле это очень больной вопрос. Правила для надежного маршрутизатора должны по умолчанию запрещать нежели разрешать. Однако, если вы сделаете это, то потеряете все соединения. Продолжайте тестирование пока не будете уверены что ваши ACCEPTы работают как надо. Однако думаю, что сперва мы введем следующее и это будет предпоследним правилом в окончательном скрипте. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ' </para>
</entry>
</row>
<row>
<entry>
<para>$IPT -t nat -A PREROUTING -j ACCEPT</para>
<para># $IPT -t nat -A POSTROUTING -o $EXTIF -s $INTNET -j SNAT --to $EXTIP</para>
<para/>
<para># Закомментируйте последующие строки (которые содержат "MASQUERADE") </para>
<para># для сетей без трансляции адресов (NAT)</para>
<para>$IPT -t nat -A POSTROUTING -o $EXTIF -s $INTNET1 -j MASQUERADE</para>
<para>$IPT -t nat -A POSTROUTING -o $EXTIF -s $INTNET2 -j MASQUERADE</para>
<para>$IPT -t nat -A POSTROUTING                       -j ACCEPT</para>
<para>$IPT -t nat -A OUTPUT                            -j ACCEPT</para>
<para>$IPT -A INPUT   -p tcp --dport auth --syn -m state --state NEW -j ACCEPT</para>
<para>$IPT -A INPUT   -m state --state ESTABLISHED,RELATED -j ACCEPT</para>
<para>$IPT -A OUTPUT  -m state --state ESTABLISHED,RELATED -j ACCEPT</para>
<para>$IPT -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>iptables DROP &amp; REJECT</title>
<para>Теперь мы определим пару цепочек (chains) которые будут фиксировать события DROP и REJECT. Таким образом нам не придется вводить отдельные строки для каждой введенной команды. Сообщения о событиях будут отправлены сервису syslog, (обычно они фиксируются в /var/log/messages). Позже я (переводчик не имеет к этому никакого отношения) собираюсь написать скрипт на sed/grep по разбору событий для облегченного просмотра и установлю его как ежедневную работу для сервиса cron. </para>
<para>Эти строки следует вставить сразу после текста выше, в тот же скрипт. Когда вы это сделаете, запустите скрипт снова. Это не окажет влияния на вашу сеть, вы пока просто устанавливаете правила. Но это поможет убедиться что мы не сделали ошибок на данном этапе. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ' </para>
</entry>
</row>
<row>
<entry>
<para># ********** Цепочки журналирования событий **********</para>
<para>#</para>
<para># Теперь мы определяем несколько цепочек которые служат для записи </para>
<para># событий о сбрасываемых пакетах. Это позволит нам избежать ввода </para>
<para># команд для каждого правила. Сперва мы фиксируем DROP, а потом REJECT.</para>
<para># Не жалуйтесь, если цепочки уже существуют (однако это не приведет к ошибкам???)</para>
<para>$IPT -N DROPl   2&gt; /dev/null</para>
<para>$IPT -A DROPl -m limit --limit 3/minute --limit-burst 10 -j LOG --log-prefix 'FIREWALL DROP BLOCKED:'</para>
<para>$IPT -A DROPl   -j DROP</para>
<para>$IPT -N REJECTl 2&gt; /dev/null</para>
<para>$IPT -A REJECTl -m limit --limit 3/minute --limit-burst 10 -j LOG --log-prefix 'FIREWALL REJECT BLOCKED:'</para>
<para>$IPT -A REJECTl -j REJECT</para>
<para>$IPT -N DROP2   2&gt; /dev/null</para>
<para>$IPT -A DROP2 -m limit --limit 3/second --limit-burst 10 -j LOG --log-prefix 'FIREWALL DROP UNKNOWN:'</para>
<para>$IPT -A DROP2   -j DROP</para>
<para>$IPT -N REJECT2 2&gt; /dev/null</para>
<para>$IPT -A REJECT2 -m limit --limit 3/second --limit-burst 10 -j LOG --log-prefix 'FIREWALL REJECT UNKNOWN:'</para>
<para>$IPT -A REJECT2 -j REJECT</para>
<para/>
<para># Для тестирования фиксируем события ACCEPT</para>
<para>$IPT -N ACCEPTl   2&gt; /dev/null</para>
<para>$IPT -A ACCEPTl -m limit --limit 10/second --limit-burst 50 -j LOG --log-prefix 'FIREWALL ACCEPT:'</para>
<para>$IPT -A ACCEPTl   -j ACCEPT</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>Сброс правил</title>
<para>Теперь, когда мы видим наши устройства, правильно определенные, вставляем команду сброса правил. Однако все уже назначенные правила будут сброшены. Эти строки должны быть вставлены после определения утилит, которые заканчиваются строкой: ECHO='/bin/echo' </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ' </para>
</entry>
</row>
<row>
<entry>
<para># Сброс всех существующих и очистка персональных цепочек.</para>
<para>CHAINS=`cat /proc/net/ip_tables_names 2&gt;/dev/null`</para>
<para/>
<para>for i in $CHAINS</para>
<para>do</para>
<para>    $IPT -t $i -F</para>
<para>done</para>
<para/>
<para>for i in $CHAINS</para>
<para>do</para>
<para>    $IPT -t $i -X</para>
<para>done</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title/></sect4><sect4><title>Локальные интерфейсы</title>
<para>Теперь мы готовы для того, чтобы описать некоторые правила. Для начала мы разрешим все пакеты с loopback интерфейса, имеющие в качестве адреса назначения один из адресов наших интерфейсов. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ' </para>
</entry>
</row>
<row>
<entry>
<para>$IPT -A INPUT   -i $LPDIF -s   $LPDIP  -j ACCEPT</para>
<para>$IPT -A INPUT   -i $LPDIF -s   $EXTIP  -j ACCEPT</para>
<para>$IPT -A INPUT   -i $LPDIF -s   $INTIP1  -j ACCEPT</para>
<para>$IPT -A INPUT   -i $LPDIF -s   $INTIP2  -j ACCEPT</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>Блокировка широковещательных пакетов</title>
<para>Теперь мы должны заблокировать все входящие и исходящие широковещательные пакеты. Это предотвратит DoS атаки против нас, и не позволит нашим клиентам проводить DoS атаки против кого либо другого. Если бы все системные администраторы следовали этим правилам, тогда много суровых и дорогих DoS атак не состоялись или были максимально ограниченными. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Блокировка широковещательных пакетов </para>
</entry>
</row>
<row>
<entry>
<para>$IPT -A INPUT   -i $EXTIF -d   $EXTBC  -j DROPl</para>
<para>$IPT -A INPUT   -i $INTIF1 -d  $INTBC1  -j DROPl</para>
<para>$IPT -A INPUT   -i $INTIF2 -d  $INTBC2  -j DROPl</para>
<para>$IPT -A OUTPUT  -o $EXTIF -d   $EXTBC  -j DROPl</para>
<para>$IPT -A OUTPUT  -o $INTIF1 -d  $INTBC1  -j DROPl</para>
<para>$IPT -A OUTPUT  -o $INTIF2 -d  $INTBC2  -j DROPl</para>
<para>$IPT -A FORWARD -o $EXTIF -d   $EXTBC  -j DROPl</para>
<para>$IPT -A FORWARD -o $INTIF1 -d  $INTBC1  -j DROPl</para>
<para>$IPT -A FORWARD -o $INTIF2 -d  $INTBC2  -j DROPl</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь проверим скрипт еще раз, чтобы убедиться в том, что мы не наделали синтаксических ошибок. Также отмечу, что мы используем определенные нами DROP1 цепочки (chains). Это означает, что отбрасываемые пакеты будут отмечены в журнале событий (log file). </para></sect4><sect4><title>Блокировка доступа в локальную сеть из глобальной</title>
<para>Теперь мы блокируем доступ из глобальной сети в нашу локальную сеть, если мы не хотим что бы интернет провайдер назначал IP адреса для нашей внутренней сети. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ' </para>
</entry>
</row>
<row>
<entry>
<para># Блокировать внешний доступ к локальной сети</para>
<para># Это позволит остановить боевых кракеров от использования </para>
<para># нашей сети как стартовой точки для других атак.</para>
<para>#</para>
<para># Нижеприведенная строчка на человеческом языке будет выглядеть как</para>
<para># "если входящий пакет, пришедший на наш внешний интерфейс,</para>
<para># имеет адрес назначения, отличный от адреса нашего внешнего интерфейса,</para>
<para># то этот пакет не будет пропущен."</para>
<para>$IPT -A INPUT   -i $EXTIF -d ! $EXTIP  -j DROPl</para>
</entry>
</row></tbody></tgroup>
</informaltable></sect4><sect4><title>Изолирование локальных сетей</title>
<para>Теперь мы предпримем некоторые действия для наших локальных сетей. Другими словами - все пакеты не относящиеся к локальным сетям должны быть блокированы. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ' </para>
</entry>
</row>
<row>
<entry>
<para># Теперь мы должны заблокировать все пакеты не относящиеся к </para>
<para># адресному пространству наших локальных сетей.</para>
<para># Запомните, если вы подключите свой ноутбук к другому разъему, </para>
<para># вам надо убедиться, что ваш сетевой адрес соответствует адресам этой сети.</para>
<para>#</para>
<para># Первая локальная сеть</para>
<para>$IPT -A INPUT   -i $INTIF1 -s ! $INTNET1 -j DROPl</para>
<para>$IPT -A OUTPUT  -o $INTIF1 -d ! $INTNET1 -j DROPl</para>
<para>$IPT -A FORWARD -i $INTIF1 -s ! $INTNET1 -j DROPl</para>
<para>$IPT -A FORWARD -o $INTIF1 -d ! $INTNET1 -j DROPl</para>
<para># Вторая локальная сеть</para>
<para>$IPT -A INPUT   -i $INTIF2 -s ! $INTNET2 -j DROPl</para>
<para>$IPT -A OUTPUT  -o $INTIF2 -d ! $INTNET2 -j DROPl</para>
<para>$IPT -A FORWARD -i $INTIF2 -s ! $INTNET2 -j DROPl</para>
<para>$IPT -A FORWARD -o $INTIF2 -d ! $INTNET2 -j DROPl</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Дальше мы сделаем некоторые дополнительные проверки исходящих пакетов и остановим все icmp пакеты кроме ping. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ' </para>
</entry>
</row>
<row>
<entry>
<para># Дополнительная проверка</para>
<para>$IPT -A OUTPUT  -o $EXTIF -s ! $EXTNET -j DROPl</para>
<para># Блокируем исходящие ICMP (кроме PING)</para>
<para>$IPT -A OUTPUT  -o $EXTIF -p icmp --icmp-type ! 8 -j DROPl</para>
<para>$IPT -A FORWARD -o $EXTIF -p icmp --icmp-type ! 8 -j DROPl</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Замечательно. Двигаемся дальше и проверяем скрипт на ошибки. </para></sect4><sect4><title>Ports</title>
<para>Предполагая что у нас все сработало мы заткнем еще несколько портов, доступ по которым может представлять для нас серьезную опасность: </para>
<para># COMmon ports:</para>
<para># 0 is tcpmux; SGI had vulnerability, 1 is common attack</para>
<para># 13 is daytime</para>
<para># 98 is Linuxconf</para>
<para># 111 is sunrpc (portmap)</para>
<para># 137:139, 445 is Microsoft</para>
<para># SNMP: 161,2</para>
<para># Squid flotilla: 3128, 8000, 8008, 8080</para>
<para># 1214 is Morpheus or KaZaA</para>
<para># 2049 is NFS</para>
<para># 3049 is very virulent Linux Trojan, mistakable for NFS</para>
<para># Common attacks: 1999, 4329, 6346</para>
<para># Common Trojans 12345 65535</para>
<para> COMBLOCK="0:1 13 98 111 137:139 161:162 445 1214 1999 2049 3049 4329 6346 3128 8000 8008 8080 12345 65535"</para>
<para># TCP ports:</para>
<para># 98 is Linuxconf</para>
<para># 512-5!5 is rexec, rlogin, rsh, printer(lpd)</para>
<para>#   [very serious vulnerabilities; attacks continue daily]</para>
<para># 1080 is Socks proxy server</para>
<para># 6000 is X (NOTE X over SSH is secure and runs on TCP 22)</para>
<para># Block 6112 (Sun's/HP's CDE)</para>
<para> TCPBLOCK="$COMBLOCK 98 512:515 1080 6000:6009 6112"</para>
<para/>
<para># UDP ports:</para>
<para># 161:162 is SNMP</para>
<para># 520=RIP, 9000 is Sangoma</para>
<para># 517:518 are talk and ntalk (more annoying than anything)</para>
<para> UDPBLOCK="$COMBLOCK 161:162 520 123 517:518 1427 9000 9 6346 3128 8000 8008 8080 12345 65535"</para>
<para>После определения переменных окружения нам останется только пробежаться по ним циклом: </para>
<para>echo -n "FW: Blocking attacks to TCP port"</para>
<para>for i in $TCPBLOCK;</para>
<para>do</para>
<para> echo -n "$i "</para>
<para>  $IPT -A INPUT   -p tcp --dport $i  -j DROPl</para>
<para>  $IPT -A OUTPUT  -p tcp --dport $i  -j DROPl</para>
<para>  $IPT -A FORWARD -p tcp --dport $i  -j DROPl</para>
<para>done</para>
<para>echo ""</para>
<para>echo -n "FW: Blocking attacks to UDP port "</para>
<para>for i in $UDPBLOCK;</para>
<para>do</para>
<para> echo -n "$i "</para>
<para>   $IPT -A INPUT   -p udp --dport $i  -j DROPl</para>
<para>   $IPT -A OUTPUT  -p udp --dport $i  -j DROPl</para>
<para>   $IPT -A FORWARD -p udp --dport $i  -j DROPl</para>
<para>done</para>
<para>echo ""</para>
<para>Ну что ж, теперь каждый раз, когда мы запускаем скрипт, эти строчки просто добавляются к уже существующим... что создаёт небольшой бардак. По этой причине мы собираемся перепрыгнуть в начало скрипта... сразу после переменных окружения для sed и grep, но перед переменными для EXTIP и EXTBC - там мы добавляем цикл, который производит очистку. Так мы будем уверены, что работаем в чистой среде. Нам не приходилось задумываться об этом ранее, потому что мы не имели возможности оттестить скрипт без обрыва соединения либо закрытия файрвола. Этот скрипт сначала выставляет всю политику в DROP, после чего очищает и удаляет наши цепочки. Чтобы убедиться, что мы по-прежнему можем залогиниться по ssh на наш сервер после того, как скрипт перезапуститься, мы добавим цепочку INPUT для ssh. Пока что поставим её в конец скрипта. Это делается для того чтобы избежать открытия дыры в момент установки новых правил, что является довольно распространённой ошибкой: </para>
<para># Отказываем, потом принимаем: это уберёт дыру в момент,</para>
<para># когда мы закрываем порты</para>
<para> $IPT        -P INPUT       DROP</para>
<para> $IPT        -P OUTPUT      DROP</para>
<para> $IPT        -P FORWARD     DROP</para>
<para># Очищаем все существуещие цепочки и стираем дополнительные</para>
<para> CHAINS=`cat /proc/net/ip_tables_names 2&gt;/dev/null`</para>
<para> for i in $CHAINS;</para>
<para> do</para>
<para>   $IPT -t $i -F</para>
<para> done</para>
<para> for i in $CHAINS;</para>
<para> do</para>
<para>   $IPT -t $i -X</para>
<para> done</para>
<para> $IPT -A INPUT   -i $INTIF1 -p tcp --dport 22 --syn -m state --state NEW -j ACCEPT</para></sect4><sect4><title>Sysctl'ы</title>
<para>Сразу после этого мы запустим sysctl'ы для tcp_syncookies, icmp_echo_ignore_broadcasts, rp_filter и accept_source_routе. До этого момента многие правила, которые мы "проверяли", фактически не выполнялись. По сути, мы просто делали проверку синтаксических ошибок. Теперь наши правила будут выполняться в полной мере: </para>
<para>echo 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</para>
<para>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</para>
<para># Проверка адреса источника</para>
<para>for f in /proc/sys/net/ipv4/conf/*/rp_filter;</para>
<para>do</para>
<para> echo 1 &gt; $f</para>
<para>done</para>
<para># Отключаем роутинг источника IP и ICMP-редиректы</para>
<para>for f in /proc/sys/net/ipv4/conf/*/accept_source_route;</para>
<para>do</para>
<para> echo 0 &gt; $f</para>
<para>done</para>
<para>for f in /proc/sys/net/ipv4/conf/*/accept_redirects;</para>
<para>do</para>
<para> echo 0 &gt; $f</para>
<para>done</para>
<para>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</para>
<para>Теперь мы собираемся добавить трекинг ftp-соединения, так что нам не доведётся наблюдать ошибки PASV при установке паков: </para>
<para># Запускаем трекинг ftp-соединения</para>
<para>MODULES="ip_nat_ftp ip_conntrack_ftp"</para>
<para>for i in $MODULES;</para>
<para>do</para>
<para> echo "Добавляем модуль $i"</para>
<para> modprobe $i</para>
<para>done</para></sect4><sect4><title>Базовая конфигурация NAT</title>
<para>А сейчас возвратимся к концу нашего скрипта, поскольку мы собираемся открыть сервисы для хостов, находящихся за файерволом. Я включил следующие сервисы: IRC, MSN, ICQ, and NFS, FTP, domain,time и некоторые другие. Самое главное здесь то, что эти сервисы могут использоваться ТОЛЬКО ЗА файерволом.Таким образом никто не сможет их использовать по ftp внутри Вашей локальной сетки: </para>
<para>IRC='ircd'</para>
<para>MSN=1863</para>
<para>ICQ=5190</para>
<para>NFS='sunrpc'</para>
<para># Мы пользуемся sync!!</para>
<para>PORTAGE='rsync'</para>
<para>OpenPGP_HTTP_Keyserver=11371</para>
<para># Все порты сервисов считываются из /etc/services</para>
<para>TCPSERV="domain ssh http https ftp ftp-data mail pop3 pop3s imap3 imaps imap2 time $PORTAGE $IRC $MSN $ICQ $OpenPGP_HTTP_Keyserver"</para>
<para>UDPSERV="domain time"</para>
<para>echo -n "FW: Allowing inside systems to use service:"</para>
<para>for i in $TCPSERV;</para>
<para>do</para>
<para> echo -n "$i "</para>
<para> $IPT -A OUTPUT  -o $EXTIF -p tcp -s $EXTIP --dport $i --syn -m state --state NEW -j ACCEPT</para>
<para> $IPT -A FORWARD -i $INTIF1 -p tcp -s $INTNET1 --dport $i --syn -m state --state NEW -j ACCEPT</para>
<para> $IPT -A FORWARD -i $INTIF2 -p tcp -s $INTNET2 --dport $i --syn -m state --state NEW -j ACCEPT</para>
<para>done</para>
<para>echo ""</para>
<para>echo -n "FW: Allowing inside systems to use service:"</para>
<para>for i in $UDPSERV;</para>
<para>do</para>
<para> echo -n "$i "</para>
<para> $IPT -A OUTPUT  -o $EXTIF -p udp -s $EXTIP --dport $i -m state --state NEW -j ACCEPT</para>
<para>   $IPT -A FORWARD -i $INTIF1 -p udp -s $INTNET1 --dport $i -m state --state NEW -j ACCEPT</para>
<para>   $IPT -A FORWARD -i $INTIF2 -p udp -s $INTNET2 --dport $i -m state --state NEW -j ACCEPT</para>
<para>done</para>
<para>echo ""</para>
<para>Теперь сделаем так, чтобы файервол позволил нам пинговать внешний мир. Для этого разрешим прохождение icmp-пакетов через внешний интерфейс: </para>
<para># Разрешаем внешнее пингование</para>
<para>$IPT -A OUTPUT  -o $EXTIF -p icmp -s $EXTIP --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para>$IPT -A FORWARD -i $INTIF1 -p icmp -s $INTNET1 --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para>$IPT -A FORWARD -i $INTIF2 -p icmp -s $INTNET2 --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para>                                                                              </para>
<para># Разрешим файерволу пинговать наши внутренние сетки:</para>
<para>$IPT -A OUTPUT  -o $INTIF1 -p icmp -s $INTNET1 --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para>$IPT -A OUTPUT  -o $INTIF2 -p icmp -s $INTNET2 --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para>Теперь мы по умолчанию будем записывать в журнал все прочие запросы, но никак не будем на них реагировать. Все что нам надо было принять мы описали в начале наших правил. Так что заканчиваем правила блокировкой всего, что специально не разрешено: </para>
<para># Заблокируем все, что осталось:</para>
<para> $IPT -A INPUT             -j DROPl</para>
<para> $IPT -A OUTPUT            -j REJECTl</para>
<para> $IPT -A FORWARD           -j DROPl</para>
<para>Итак, все сделано. я имею дружественные nmap и nessus для моих соединений с вышеописанным набором правил и ничего не препятствует использованию IRC, MSN, ICQ, и emerge sync. </para></sect4><sect4><title>The full script</title>
<para>А сейчас, полноценный скрипт во всей своей красе (Заодно я поместил форвардинг ssh в более подходящее для него место): </para>
<para># Внешний интерфейс</para>
<para> EXTIF=ppp0</para>
<para># Внутренний интерфейс</para>
<para> INTIF1=eth1</para>
<para> INTIF2=eth2</para>
<para># Loop-устройство/localhost</para>
<para> LPDIF=lo</para>
<para> LPDIP=127.0.0.1</para>
<para> LPDMSK=255.0.0.0</para>
<para> LPDNET="$LPDIP/$LPDMSK"</para>
<para># Переменные текстовых инструментов</para>
<para> IPT='/sbin/iptables'</para>
<para> IFC='/sbin/ifconfig'</para>
<para> G='/bin/grep'</para>
<para> SED='/bin/sed'</para>
<para># Последнее (но немаловажное) - пользователи</para>
<para> JAMES=192.168.1.77</para>
<para> TERESA=192.168.2.77</para>
<para># Deny вместо accept: предотвращает открытие "дыр"</para>
<para># в то время, как мы закрываем порты и все такое</para>
<para> $IPT        -P INPUT       DROP</para>
<para> $IPT        -P OUTPUT      DROP</para>
<para> $IPT        -P FORWARD     DROP</para>
<para># Сброс всех существующих цепочек и стирание персональных цепочек</para>
<para> CHAINS=`cat /proc/net/ip_tables_names 2&gt;/dev/null`</para>
<para> for i in $CHAINS</para>
<para> do</para>
<para>  $IPT -t $i -F</para>
<para>  $IPT -t $i -X</para>
<para> done</para>
<para> echo 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</para>
<para> echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</para>
<para># Проверка адреса источника</para>
<para> for f in /proc/sys/net/ipv4/conf/*/rp_filter;</para>
<para> do</para>
<para>  echo 1 &gt; $f</para>
<para> done</para>
<para># Запрет маршрутизации IP от источника и редиректов ICMP</para>
<para> for f in /proc/sys/net/ipv4/conf/*/accept_source_route;</para>
<para> do</para>
<para>  echo 0 &gt; $f</para>
<para> done</para>
<para> for f in /proc/sys/net/ipv4/conf/*/accept_redirects;</para>
<para> do</para>
<para>  echo 0 &gt; $f</para>
<para> done</para>
<para> echo 1 &gt; /proc/sys/net/ipv4/ip_forward</para>
<para># Установка переменных среды для внешнего интерфейса</para>
<para> EXTIP="`$IFC $EXTIF|$G addr:|$SED 's/.*addr:\([^ ]*\) .*/\1/'`"</para>
<para> #EXTBC="`$IFC $EXTIF|$G Bcast:|$SED 's/.*Bcast:\([^ ]*\) .*/\1/'`"</para>
<para> EXTBC="255.255.255.255"</para>
<para> EXTMSK="`$IFC $EXTIF|$G Mask:|$SED 's/.*Mask:\([^ ]*\)/\1/'`"</para>
<para> EXTNET="$EXTIP/$EXTMSK"</para>
<para> #echo "EXTIP=$EXTIP EXTBC=$EXTBC EXTMSK=$EXTMSK EXTNET=$EXTNET"</para>
<para> echo "EXTIP=$EXTIP EXTBC=$EXTBC EXTMSK=$EXTMSK EXTNET=$EXTNET"</para>
<para># Так как EXTBC отсутствует, я устанавливаю ее вручную как it to 255.255.255.255</para>
<para># Это (надеюсь) послужит тем же целям</para>
<para># Устанвка переменных среды для первого внутреннего интерфейса</para>
<para> INTIP1="`$IFC $INTIF1|$G addr:|$SED 's/.*addr:\([^ ]*\) .*/\1/'`"</para>
<para> INTBC1="`$IFC $INTIF1|$G Bcast:|$SED 's/.*Bcast:\([^ ]*\) .*/\1/'`"</para>
<para> INTMSK1="`$IFC $INTIF1|$G Mask:|$SED 's/.*Mask:\([^ ]*\)/\1/'`"</para>
<para> INTNET1="$INTIP1/$INTMSK1"</para>
<para> echo "INTIP1=$INTIP1 INTBC1=$INTBC1 INTMSK1=$INTMSK1 INTNET1=$INTNET1"</para>
<para># Установка переменных среды для второго внутреннего интерфейса</para>
<para> INTIP2="`$IFC $INTIF2|$G addr:|$SED 's/.*addr:\([^ ]*\) .*/\1/'`"</para>
<para> INTBC2="`$IFC $INTIF2|$G Bcast:|$SED 's/.*Bcast:\([^ ]*\) .*/\1/'`"</para>
<para> INTMSK2="`$IFC $INTIF2|$G Mask:|$SED 's/.*Mask:\([^ ]*\)/\1/'`"</para>
<para> INTNET2="$INTIP2/$INTMSK2"</para>
<para> echo "INTIP2=$INTIP2 INTBC2=$INTBC2 INTMSK2=$INTMSK2 INTNET2=$INTNET2"</para>
<para># Сейчас мы собираемся создать несколько собственных цепочек, результатом работы </para>
<para># которых будет логгинг отброшенных пакетов. Это поможет нам избежать необходимости</para>
<para># вводить команду log перед каждым отбрасыванием пакета, что мы хотим запротоколировать.</para>
<para># Первыми идут лог отброшенных пакетов и собственно отброс, затем лог пакетов с отказами</para>
<para># и собственно отказы.</para>
<para># Отключаем сообщения о том, что цепочки уже существуют (чтобы перезапуск был без мусора)</para>
<para> $IPT -N DROPl   2&gt; /dev/null</para>
<para> $IPT -A DROPl   -j LOG --log-prefix 'DROPl:'</para>
<para> $IPT -A DROPl   -j DROP</para>
<para> $IPT -N REJECTl 2&gt; /dev/null</para>
<para> $IPT -A REJECTl -j LOG --log-prefix 'REJECTl:'</para>
<para> $IPT -A REJECTl -j REJECT</para>
<para># Весь траффик от устройства loopback принимается</para>
<para># если IP совпадает с любым из наших интерфейсов.</para>
<para> $IPT -A INPUT   -i $LPDIF -s   $LPDIP  -j ACCEPT</para>
<para> $IPT -A INPUT   -i $LPDIF -s   $EXTIP  -j ACCEPT</para>
<para> $IPT -A INPUT   -i $LPDIF -s   $INTIP1  -j ACCEPT</para>
<para> $IPT -A INPUT   -i $LPDIF -s   $INTIP2  -j ACCEPT</para>
<para># Широковещательные пакеты блокируем</para>
<para> $IPT -A INPUT   -i $EXTIF -d   $EXTBC  -j DROPl</para>
<para> $IPT -A INPUT   -i $INTIF1 -d   $INTBC1  -j DROPl</para>
<para> $IPT -A INPUT   -i $INTIF2 -d   $INTBC2  -j DROPl</para>
<para> $IPT -A OUTPUT  -o $EXTIF -d   $EXTBC  -j DROPl</para>
<para> $IPT -A OUTPUT  -o $INTIF1 -d   $INTBC1  -j DROPl</para>
<para> $IPT -A OUTPUT  -o $INTIF2 -d   $INTBC2  -j DROPl</para>
<para> $IPT -A FORWARD -o $EXTIF -d   $EXTBC  -j DROPl</para>
<para> $IPT -A FORWARD -o $INTIF1 -d   $INTBC1  -j DROPl</para>
<para> $IPT -A FORWARD -o $INTIF2 -d   $INTBC2  -j DROPl</para>
<para># Блокируем доступ к внутренней сети из WAN</para>
<para># Это также призвано не дать нечестивым крякерам использовать нашу сетку </para>
<para># в качестве отправной точки для атак на других людей</para>
<para># Перевод с языка iptables:</para>
<para># "если пришедшие на наружный интерфейс пакеты были отправлены не с выданного</para>
<para># nefarious адреса, выкинуть их как горячую картошку"</para>
<para> $IPT -A INPUT   -i $EXTIF -d ! $EXTIP  -j DROPl</para>
<para># А сейчас мы блокируем внутренние адреса, кроме двух, присвоенных нашим двум</para>
<para># внутренним интерфейсам.....только помните, что если вы воткнете свой лэптоп или</para>
<para># какой другой pc в напрямую в одну из этих сетевых карт, то нужно удостовериться,</para>
<para># что они имеют именно эти IP-адреса или добавить соответствующий адрес отдельно.               </para>
<para># Первый интерфейс/первая внутренняя сеть</para>
<para> $IPT -A INPUT   -i $INTIF1 -s ! $INTNET1 -j DROPl</para>
<para> $IPT -A OUTPUT  -o $INTIF1 -d ! $INTNET1 -j DROPl</para>
<para> $IPT -A FORWARD -i $INTIF1 -s ! $INTNET1 -j DROPl</para>
<para> $IPT -A FORWARD -o $INTIF1 -d ! $INTNET1 -j DROPl</para>
<para># Второй интерфейс/вторая внутренняя сеть</para>
<para> $IPT -A INPUT   -i $INTIF2 -s ! $INTNET2 -j DROPl</para>
<para> $IPT -A OUTPUT  -o $INTIF2 -d ! $INTNET2 -j DROPl</para>
<para> $IPT -A FORWARD -i $INTIF2 -s ! $INTNET2 -j DROPl</para>
<para> $IPT -A FORWARD -o $INTIF2 -d ! $INTNET2 -j DROPl</para>
<para># Дополнительная Egress-проверка</para>
<para> $IPT -A OUTPUT  -o $EXTIF -s ! $EXTNET -j DROPl</para>
<para># Блокируем исходящиие пакеты ICMP (за исключением PING)</para>
<para> $IPT -A OUTPUT  -o $EXTIF -p icmp --icmp-type ! 8 -j DROPl</para>
<para> $IPT -A FORWARD -o $EXTIF -p icmp --icmp-type ! 8 -j DROPl</para>
<para># печально известные порты:</para>
<para># 0 - tcpmux; у SGI есть уязвимость, через которую можно атаковать</para>
<para># 13 - daytime</para>
<para># 98 - Linuxconf</para>
<para># 111 - sunrpc (portmap)</para>
<para># 137:139, 445 - Microsoft</para>
<para># SNMP: 161,2</para>
<para># Флотилия Squid: 3128, 8000, 8008, 8080</para>
<para># 1214 - Morpheus или KaZaA</para>
<para># 2049 - NFS</para>
<para># 3049 - очень заразный троян для Linux, часто путаемый с NFS</para>
<para># Часто атакуемые: 1999, 4329, 6346</para>
<para># Частые трояны 12345 65535</para>
<para> COMBLOCK="0:1 13 98 111 137:139 161:162 445 1214 1999 2049 3049 4329 6346 3128 8000 8008 8080 12345 65535"</para>
<para># Порты TCP:</para>
<para># 98 - Linuxconf</para>
<para># 512-5!5 - rexec, rlogin, rsh, printer(lpd)</para>
<para>#   [очень серьезеные уязвимости; продолжаются ежедневные атаки]</para>
<para># 1080 - прокси-серверы Socks</para>
<para># 6000 - X (ЗАМЕЧАНИЕ. X через SSH - безопасен, и работает на порту TCP 22)</para>
<para># Блокировка 6112 (CDE у Sun и HP)</para>
<para> TCPBLOCK="$COMBLOCK 98 512:515 1080 6000:6009 6112"</para>
<para># Порты UDP:</para>
<para># 161:162 - SNMP</para>
<para># 520=RIP, 9000 - Sangoma</para>
<para># 517:518 - talk и ntalk (самые надоедливые)</para>
<para> UDPBLOCK="$COMBLOCK 161:162 520 123 517:518 1427 9000"</para>
<para>echo -n "FW: Blocking attacks to TCP port"</para>
<para>for i in $TCPBLOCK;</para>
<para>do</para>
<para> echo -n "$i "</para>
<para>  $IPT -A INPUT   -p tcp --dport $i  -j DROPl</para>
<para>  $IPT -A OUTPUT  -p tcp --dport $i  -j DROPl</para>
<para>  $IPT -A FORWARD -p tcp --dport $i  -j DROPl</para>
<para>done</para>
<para>echo ""</para>
<para>echo -n "FW: Blocking attacks to UDP port "</para>
<para>for i in $UDPBLOCK;</para>
<para>do</para>
<para> echo -n "$i "</para>
<para>  $IPT -A INPUT   -p udp --dport $i  -j DROPl</para>
<para>  $IPT -A OUTPUT  -p udp --dport $i  -j DROPl</para>
<para>  $IPT -A FORWARD -p udp --dport $i  -j DROPl</para>
<para>done</para>
<para>echo ""</para>
<para># Открываем отлеживание соединений по ftp</para>
<para> MODULES="ip_nat_ftp ip_conntrack_ftp"</para>
<para> for i in $MODULES;</para>
<para> do</para>
<para>  echo "Inserting module $i"</para>
<para>  modprobe $i</para>
<para> done</para>
<para># Защищаем некоторые распространенные клиенты для чата.</para>
<para># Уберите из списка допустимых для пущей безопасности.</para>
<para> IRC='ircd'</para>
<para> MSN=1863</para>
<para> ICQ=5190</para>
<para> NFS='sunrpc'</para>
<para># Нам нужно синхронизировать данные!!</para>
<para> PORTAGE='rsync'</para>
<para> OpenPGP_HTTP_Keyserver=11371</para>
<para># Все порты сервисов читаются из /etc/services</para>
<para> TCPSERV="domain ssh http https ftp ftp-data mail pop3 pop3s imap3 imaps imap2 time $PORTAGE $IRC $MSN $ICQ  $OpenPGP_HTTP_Keyserver" UDPSERV="domain time"</para>
<para>echo -n "FW: Allowing inside systems to use service:"</para>
<para>for i in $TCPSERV;</para>
<para>do</para>
<para> echo -n "$i "</para>
<para>  $IPT -A OUTPUT  -o $EXTIF -p tcp -s $EXTIP --dport $i --syn -m state --state NEW -j ACCEPT</para>
<para>  $IPT -A FORWARD -i $INTIF1 -p tcp -s $INTNET1 --dport $i --syn -m state --state NEW -j ACCEPT</para>
<para>  $IPT -A FORWARD -i $INTIF2 -p tcp -s $INTNET2 --dport $i --syn -m state --state NEW -j ACCEPT</para>
<para>done</para>
<para>echo ""</para>
<para>echo -n "FW: Allowing inside systems to use service:"</para>
<para>for i in $UDPSERV;</para>
<para>do</para>
<para> echo -n "$i "</para>
<para>  $IPT -A OUTPUT  -o $EXTIF -p udp -s $EXTIP --dport $i -m state --state NEW -j ACCEPT</para>
<para>  $IPT -A FORWARD -i $INTIF1 -p udp -s $INTNET1 --dport $i -m state --state NEW -j ACCEPT</para>
<para>  $IPT -A FORWARD -i $INTIF2 -p udp -s $INTNET2 --dport $i -m state --state NEW -j ACCEPT</para>
<para>done</para>
<para>echo ""</para>
<para># Разрешается ping наружу</para>
<para>$IPT -A OUTPUT  -o $EXTIF -p icmp -s $EXTIP --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para>$IPT -A FORWARD -i $INTIF1 -p icmp -s $INTNET1 --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para>$IPT -A FORWARD -i $INTIF2 -p icmp -s $INTNET2 --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para># Файерволу разрешается ping внутренних систем</para>
<para>$IPT -A OUTPUT  -o $INTIF1 -p icmp -s $INTNET1 --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para>$IPT -A OUTPUT  -o $INTIF2 -p icmp -s $INTNET2 --icmp-type 8 -m state --state NEW -j ACCEPT                                                                                                                                                             </para>
<para>$IPT -A INPUT   -i $INTIF1 -p tcp --dport 22 --syn -m state --state NEW -j ACCEPT</para>
<para>$IPT -t nat -A PREROUTING -j ACCEPT</para>
<para>$IPT -t nat -A POSTROUTING -o $EXTIF -s $INTNET1 -j MASQUERADE</para>
<para>$IPT -t nat -A POSTROUTING -o $EXTIF -s $INTNET2 -j MASQUERADE</para>
<para>$IPT -t nat -A POSTROUTING -j ACCEPT</para>
<para>$IPT -t nat -A OUTPUT -j ACCEPT</para>
<para>$IPT -A INPUT -p tcp --dport auth --syn -m state --state NEW -j ACCEPT</para>
<para>$IPT -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</para>
<para>$IPT -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</para>
<para>$IPT -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT</para>
<para># Заблокировать и запротоколировать все, что мы могли забыть.</para>
<para>$IPT -A INPUT -j DROPl</para>
<para>$IPT -A OUTPUT -j REJECTl</para>
<para>$IPT -A FORWARD -j DROPl</para>
<para/>
<para/>
<para/></sect4></sect3><sect3><title>Установка почтовой системы</title>
<para/>
<para/>
<para>Установка почтовой системы на Gentoo linux для небольшой конторы </para>
<para/>
<para>Используется postfix + cyrus-imap, авторизация пользователей через cyrus-sasl без прикручивания какой-либо БД (подходит для контор с несколькими десятками почтовых ящиков - хранить что-либо в mysql или postgress в данном случае нет смысла). Пользователи хранятся в базе sasldb, поэтому нет нужды заводить в системе реальных пользователей. </para>
<para>Возможно при установке указанных пакетов понадобится установить все зависимости, которые они за собой тянут. Предоставим системе самой разобраться, что же ей не хватает - она с этим вполне успешно справляется. </para>
<para>Предпочитаю использовать для /var reiserfs, но это сугубо личные предпочтения. </para>
<para/>
<para/>
<para>emerge -pv cyrus-sasl</para>
<para>[ebuild   N   ] dev-libs/cyrus-sasl-2.1.20  -authdaemond +berkdb -debug +gdbm +java -kerberos -ldap +mysql  +pam -postgres +ssl -static 0 kB</para>
<para/>
<para>На всякий случай проверяем флаги - все ОК </para>
<para>emerge cyrus-sasl</para>
<para/>
<para>Этот пакет поставили, едем дальше </para>
<para>emerge -pv postfix</para>
<para>These are the packages that I would merge, in order:</para>
<para> Calculating dependencies ...done!</para>
<para>[ebuild   N   ] mail-mta/postfix-2.1.5-r1  +ipv6 -ldap -mailwrapper -mbox +mysql +pam -postgres -sasl*(-selinux) +ssl -vda 0 kB</para>
<para/>
<para>Здесь нам может пригодиться флаг sasl, хотя в моем случае пока нет нужды авторизоваться на smtp, возможно в дальнейшем здесь будет описана авторизация через cyrus-sasl на smtp - вообщем выставляйте флаги по вкусу кому что надо </para>
<para>USE="sasl" emerge postfix</para>
<para/>
<para>Постфикс собрался </para>
<para>emerge -pv cyrus-imapd</para>
<para>These are the packages that I would merge, in order:</para>
<para>Calculating dependencies ...done!</para>
<para>[ebuild   N   ] net-mail/cyrus-imapd-2.2.10  -afs -drac -idled -kerberos +pam -snmp +ssl +tcpd 0 kB</para>
<para/>
<para>После проверки и установки нужных нам флагов пересобираем openssl и imap-сервер </para>
<para>emerge cyrus-imapd</para>
<para/>
<para>Программа для администрирования имаповских ящиков </para>
<para>emerge cyrus-imap-admin</para>
<para/>
<para>После того как все нужные нам пакеты поставлены, можно приступать к настройке </para>
<para/>
<para>сначала cyrus-sasl </para>
<para>passwd cyrus</para>
<para>pwconv</para>
<para>chown -R cyrus:mail /etc/sasl2 - доступ cyrus к базе /etc/sasl2/sasldb2</para>
<para>saslpasswd2 cyrus - заводим в sasldb2 </para>
<para>sasldblistusers2 - для проверки</para><sect4><title>Разбираемся с postfix </title>
<para/>
<para>Cодержимое /etc/postfix/main.cf, ниже приведена примерная конфигурация почтового сервера подключенного напрямую к инету (не через relayhost), естественно для этого случая должна быть MX-запись в ДНС. Подчеркиваю, что умышленно опускаю многие параметры в main.cf, чтобы не раздувать описание. Добавьте все остальное руководствуясь документацией postfix. </para>
<para/>
<para>queue_directory = /var/spool/postfix</para>
<para>command_directory = /usr/sbin</para>
<para>daemon_directory = /usr/lib/postfix</para>
<para>mail_owner = postfix</para>
<para>myhostname = mail.domain.tld</para>
<para>mydomain = mail.domain.tld</para>
<para>myorigin = $mydomain</para>
<para>inet_interfaces = all</para>
<para>mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain</para>
<para>local_recipient_maps =</para>
<para>unknown_local_recipient_reject_code = 550</para>
<para>mynetworks_style = subnet</para>
<para>mynetworks = 192.168.1.0/24, 127.0.0.0/8</para>
<para>relay_domains = $mydestination</para>
<para>НА ЭТУ СТРОЧКУ ОБРАТИТЕ ВНИМАНИЕ!!! </para>
<para>mailbox_transport = lmtp:unix:/var/imap/socket/lmtp</para>
<para>Если надо подключить procmail то вместо нее пишем</para>
<para>mailbox_transport = procmail</para>
<para/>
<para>Когда добавили все, что нужно в main.cf, идем в /etc/postfix/master.cf </para>
<para/>
<para>Ищем такую строку </para>
<para> # Also specify in main.cf: cyrus_destination_recipient_limit=1</para>
<para>cyrus     unix  -       n       n       -       -       pipe</para>
<para> user=cyrus argv=/cyrus/bin/deliver -e -r ${sender} -m ${extension} ${user}</para>
<para> </para>
<para>И заменяем путь на </para>
<para> # Also specify in main.cf: cyrus_destination_recipient_limit=1</para>
<para>cyrus     unix  -       n       n       -       -       pipe</para>
<para> user=cyrus argv=/cyrus/deliver -e -r ${sender} -m ${extension} ${user}</para>
<para/>
<para>При использовании procmail, добавляем </para>
<para>procmail unix  -       n      n       -        -       pipe</para>
<para> flags=R user=cyrus argv=/usr/bin/procmail -p /etc/procmailrc  USER=${user}</para>
<para/>
<para>Где файл /etc/procmailrc : </para>
<para>DELIVERMAIL=/usr/lib/cyrus/deliver</para>
<para>LOGFILE=/var/log/procmaillog</para>
<para>IMAP="$DELIVERMAIL -e -a $USER -m user.$USER"</para>
<para>(если надо подключить spamassassin)</para>
<para>:0fw : spamassassin.lock</para>
<para>* &lt; 90000</para>
<para>| /usr/bin/spamassassin</para>
<para>и далее обязательно</para>
<para>:0</para>
<para>| $IMAP</para>
<para>:0w</para>
<para>{</para>
<para>EXITCODE=$?</para>
<para>HOST</para>
<para>}  </para>
<para/>
<para>Все, с постфиксом разобрались, теперь cyrus-imapd </para>
<para/>
<para>Редактируем /etc/cyrus.conf </para>
<para># $Header: /var/cvsroot/gentoo-x86/net-mail/cyrus-imapd/files/cyrus.conf,v 1.4 2004/07/18 04:02:23 dragonheart  Exp $</para>
<para># Standard standalone server configuration.</para>
<para>START {</para>
<para> # Do not delete this entry!</para>
<para> recover        cmd="ctl_cyrusdb -r"</para>
<para> # This is only necessary if using idled for IMAP IDLE.</para>
<para> #idled                cmd="idled"</para>
<para>}</para>
<para># UNIX sockets start with a slash and are put into /var/imap/socket.</para>
<para>SERVICES {</para>
<para>  # Add or remove based on preferences.</para>
<para>  imap                cmd="imapd" listen="imap2" prefork=0</para>
<para>  pop3                cmd="pop3d" listen="pop-3" prefork=0</para>
<para>   # Don't forget to generate the needed keys for SSL or TLS</para>
<para>  # (see doc/html/install-configure.html).</para>
<para>  imaps                cmd="imapd -s" listen="imaps" prefork=0</para>
<para>  pop3s                cmd="pop3d -s" listen="pop3s" prefork=0</para>
<para>  sieve                cmd="timsieved" listen="sieve" prefork=0</para>
<para>  # at least one LMTP is required for delivery</para>
<para>  #lmtp                cmd="lmtpd" listen="lmtp" prefork=0</para>
<para>   ##ОБРАТИТЕ ВНИМАНИЕ НА ЭТУ СТРОКУ</para>
<para>  lmtpunix        cmd="lmtpd" listen="/var/imap/socket/lmtp" prefork=0</para>
<para>     # this is only necessary if using notifications</para>
<para>  #notify        cmd="notifyd" listen="/var/imap/socket/notify" proto="udp" prefork=1</para>
<para>}</para>
<para>EVENTS {</para>
<para>  # This is required.</para>
<para>  checkpoint        cmd="ctl_cyrusdb -c" period=30</para>
<para>  # This is only necessary if using duplicate delivery suppression.</para>
<para>  delprune        cmd="ctl_deliver -E 3" period=1440</para>
<para>  # This is only necessary if caching TLS sessions.</para>
<para>  tlsprune        cmd="tls_prune" period=1440</para>
<para>}</para>
<para/>
<para>Вот так делаем сертификаты </para>
<para>openssl req -new -nodes -out req.pem -keyout key.pem  </para>
<para>openssl rsa -in key.pem -out new.key.pem</para>
<para>openssl x509 -in req.pem -out ca-cert -req \</para>
<para>-signkey new.key.pem -days 999 </para>
<para>cp new.key.pem /etc/ssl/cyrus/server.pem</para>
<para>rm new.key.pem</para>
<para>cat ca-cert &gt;&gt; /etc/ssl/cyrus/server.pem</para>
<para>chown cyrus:mail /etc/ssl/cyrus/server.pem</para>
<para>chmod 600 /etc/ssl/cyrus/server.pem # Your key should be protected</para>
<para/>
<para>Проверяем все-ли директории созданы </para>
<para>/var/imap</para>
<para>cd /var</para>
<para>mkdir imap</para>
<para>chown cyrus:mail imap</para>
<para>chmod 750 imap</para>
<para>/var/spool/imap </para>
<para>cd /var/spool</para>
<para>mkdir imap</para>
<para>chown cyrus:mail imap</para>
<para>chmod 750 imap</para>
<para>/usr/sieve</para>
<para>cd /usr</para>
<para>mkdir sieve</para>
<para>chown cyrus:mail sieve</para>
<para>chmod 750 sieve</para>
<para/>
<para>Далее редактируем /etc/imapd.conf </para>
<para>configdirectory:        /var/imap</para>
<para>partition-default:        /var/spool/imap</para>
<para>auto_transition:        yes</para>
<para>tls_ca_path:           /etc/ssl/cyrus</para>
<para>tls_cert_file:                /etc/ssl/cyrus/server.pem</para>
<para>tls_key_file:                /etc/ssl/cyrus/server.pem</para>
<para>admins:                        cyrus</para>
<para>hashimapspool:                yes</para>
<para>allowanonymouslogin:        no</para>
<para>allowplaintext:                yes</para>
<para>sasl_pwcheck_method:        auxprop</para>
<para>sasl_auxprop_plugin:        sasldb</para>
<para>sasldb_path:                /etc/sasl2/sasldb2</para>
<para>sasl_mech_list:                LOGIN PLAIN </para>
<para/>
<para>Авторизация через базу sasldb, механизмы авторизации LOGIN,PLAIN Если мы будем использовать обычные открытые пароли, без шифрования (например внутри организации) то изменим в /etc/imapd.conf </para>
<para>allowanonymouslogin: yes</para>
<para/>
<para>вроде бы с настройкой cyrus покончено </para>
<para/>
<para>Теперь займемся почтовыми ящиками юзеров, для этого используем программу cyradm </para>
<para>/etc/init.d/cyrus start</para>
<para>cyradm -user cyrus -server localhost</para>
<para>localhost&gt; cm user.testuser</para>
<para>localhost&gt; help - выводит все команды для руления юзерскими ящиками</para>
<para>localhost&gt; exit</para>
<para/>
<para>Не забудьте забить в sasldb2 нового юзера: </para>
<para>saslpasswd2 testuser </para>
<para/>
<para>Поднимаем сервисы </para>
<para>/etc/init.d/postfix start</para>
<para>/etc/init.d/cyrus start</para>
<para/>
<para>Настраиваем почтового клиента (проверено с thunderbird 1.0 и с KMail 1.7.1, с Outlook Express тоже не должно быть проблем). </para>
<para/>
<para>Пробуем отправить письмо, если что-то не работает - смотрим логи, прежде всего проверьте права на доступ в /var/imap/socket/lmtp для пользователей postfix и cyrus, чаще всего проблемы связаны именно с этим. Также проверьте права на доступ к /etc/sasl2/sasldb2 для пользователя cyrus, который должен быть в группе mail. </para>
<para/>
<para>Желательно поставить антивирус например clamav используем для этого связку clamav + clamsmtp хотя возможны и другие варианты например amavisd-new. Установка прекрасно описана здесь http://www.nixp.ru/articles/clamav_postfix, необходимо руководствоваться ей,естественно с адаптацией под реалии Gentoo </para>
<para>emerge clamav</para>
<para>ACCEPT_KEYWORDS="~x86" emerge clamsmtp (пока замаскирован в портаджах)</para>
<para/>
<para>Затем в файле /etc/conf.d/clamd START_CLAMD = yes (для версии старше 0.85 уже не актуально - все настройки только в clamd.conf и clamsmtpd.conf) </para>
<para/>
<para>Редактируем файлы /etc/clamd.conf и /etc/clamsmtpd.conf в соответствии с рекомендациями приведенными выше по ссылке Обратите внимание на параметры LocalSocket: /var/run/clamav/clamd.sock в /etc/clamav.conf и ClamAddress: /var/run/clamav/clamd.sock в /etc/clamsmtpd.conf - путь и имя файла должен одинаковым для обоих конфигов </para>
<para/>
<para>В файл main.cf необходимо добавить две строчки: </para>
<para>content_filter = scan:127.0.0.1:10025</para>
<para>receive_override_options = no_address_mappings</para>
<para/>
<para>Первая говорит postfix'у о том, что необходимо пересылать всю почту через сервис (фильтр) 'scan' на 10025-ый порт, который, как раз, открыт clamsmtpd. Вторая строчка говорит о том, чтобы postfix не делал никаких манипуляций с адресами до того, как они дойдут до content_filter. Так что получается, что фильтр работает с реальными почтовыми адресами, а не с результатами перевода в виртуальные псевдонимы, маскарадингом и т.п. </para>
<para/>
<para>В файл master.cf необходимо добавить следующие строки: </para>
<para># AV scan filter (used by content_filter)</para>
<para>scan      unix  -       -       n       -       16      smtp</para>
<para>       -o smtp_send_xforward_command=yes</para>
<para># For injecting mail back into postfix from the filter</para>
<para>127.0.0.1:10026 inet  n -       n       -       16      smtpd</para>
<para>       -o content_filter=</para>
<para>       -o receive_override_options=no_unknown_recipient_checks,no_header_body_checks</para>
<para>       -o smtpd_helo_restrictions=</para>
<para>        -o smtpd_client_restrictions=</para>
<para>       -o smtpd_sender_restrictions=</para>
<para>       -o smtpd_recipient_restrictions=permit_mynetworks,reject</para>
<para>       -o mynetworks_style=host</para>
<para>       -o smtpd_authorized_xforward_hosts=127.0.0.0/8</para>
<para/>
<para>Примечание: вокруг знака '=' пробелы не ставить. Значение 127.0.0.1:10026 открывает 10026-порт для возвращения почты обратно от clamsmtpd. </para>
<para>rc-update add clamd default</para>
<para>rc-update add clamsmtpd default</para>
<para>/etc/init.d/postfix reload</para>
<para/>
<para>все - антивирус должен проверять всю почту проходящую через Ваш почтовик </para>
<para/>
<para>P.S. Все вышеописанное проверялось на моей рабочей машине и на серваке небольшой конторы. Автор (или авторы) не несут ответственности за безграмотное и необдуманное применение данного руководства. Ваша безопасность в ваших руках и в голове! Данное описание не претендует на полное и развернутое и не является единственно возможным вариантом конфигурации. Также выражаю признательность разработчикам вышеописанных замечательных программ за прекрасное исполнение и хорошую документацию. Практически все вышенаписанное подчерпнуто из документации к самим пакетам, а также некоторые мысли родились из отрывочных данных, блуждающих в рунете - большое спасибо за это их авторам. </para>
<para/>
<para>PS. Некоторая путаница возникает с переадресацией почты - самый простой вариант использование файла aliases - но до его использования в отличие от sendmail, ящик который должен быть переадресован должен быть все-таки создан в системе через cyradm -user cyrus -auth login -server localhost команда cm и не забыть что etc/postfix/main.cf </para>
<para>alias_maps = hash:/usr/local/etc/postfix/aliases</para>
<para>alias_database = hash:/usr/local/etc/postfix/aliases</para>
<para/></sect4></sect3><sect3><title>Настройка vsftpd</title><sect4><title>Введение </title>
<para/>
<para>Это перевод статьи en:HOWTO vsftpd. Кое-что изменено и добавлено от себя для более понятного, как мне кажется, изложения </para>
<para>Взято из en:HOWTO Plan, setup and run a high school Gentoo Club и модифицировано. </para>
<para>Это руководство описывает процесс установки VSFTP и настройки его для анонимного доступа с правами только для чтения. FTP (File Transfer Protocol) - старый, но надежный протокол, используемый для быстрой передачи файлов в сети. </para>
<para/></sect4><sect4><title>Установка VSFTPD </title>
<para/>
<para>Зайдите в систему под пользователем root и введите комманду: Code: Установка </para>
<para> emerge vsftpd</para>
<para/>
<para>Настройка </para>
<para/>
<para>Это очень легко. Откройте файл /etc/vsftpd/vsftpd.conf вашим любимым текстовым редактором и внесите в него вот эти изменения: </para>
<para/>
<para>Общие настройки </para>
<para>Файл: /etc/vsftpd/vsftpd.conf </para>
<para> dirmessage_enable=YES</para>
<para> # banner_file=/etc/vsftpd/vsftpd.banner # edit banner first</para>
<para> chown_uploads=NO</para>
<para> xferlog_enable=YES</para>
<para> idle_session_timeout=600</para>
<para> data_connection_timeout=120</para>
<para> ascii_upload_enable=NO</para>
<para> ascii_download_enable=NO</para>
<para> chroot_list_enable=YES</para>
<para> background=YES</para>
<para> listen=YES</para>
<para> ls_recurse_enable=NO</para>
<para/>
<para/>
<para>Анонимный пользователь (Anonymous), только для чтения</para>
<para>Файл: /etc/vsftpd/vsftpd.conf </para>
<para> anonymous_enable=YES</para>
<para> anon_upload_enable=NO</para>
<para> anon_mkdir_write_enable=NO</para></sect4><sect4><title>Отключаем локальных пользователей </title>
<para/>
<para>Это плохая идея разрешать локальным пользователям доступ через ftp (проще sftp/ssh), потому мы отключаем им доступ. Файл: /etc/vsftpd/vsftpd.conf </para>
<para> local_enable=NO</para>
<para> write_enable=NO</para></sect4><sect4><title>Запуск службы </title>
<para/>
<para>Gentoo предоставляет централизированное место для служб, которые называються init scripts или скрипты инициализации. Эти скрипты находяться в каталоге /etc/init.d/ и имеют имя сервиса, который они стартуют. Инит скрипты используються для управления сервисами. Для запуска VSFTPD сервера наберите Code: Запуск vsftpd как службы </para>
<para> /etc/init.d/vsftpd start</para>
<para/>
<para>Вы можете узнать больше о том что вы можете сделать этим скриптом инициализации набрав "/etc/init.d/vsftpd" без аргументов ("start" это аргумент, еще есть "stop" и "restart") ) </para>
<para/></sect4><sect4><title>Настройка скриптов конфигурации </title>
<para/>
<para>Вы не хотите набирать /etc/init.d/vsftpd start каждый раз когда вы включаете свой компьютер? Gentoo предоставляет простой путь запуска скриптов инициализации при включении вашего компьютера. Чтобы настроить VSFTPD для запуска при каждой загрузке, наберите: Code: запуск vsftpd как службы загрузке </para>
<para> rc-update add vsftpd default</para>
<para/>
<para>Если вы хотите узнать больше о rc-update наберите "man rc-update". </para>
<para/>
<para>Также можно и через chkconfig: Code: запуск vsftpd как службы загрузке </para>
<para> chkconfig vsftpd on</para></sect4><sect4><title>Где размещать файлы </title>
<para/>
<para>Файлы анонимного пользователя находятся в домашнем каталоге специального пользоватьля ftp (пользователя в системе). По умолчанию это - /home/ftp. Если вы хотите сменить его например на /var/ftp, вам нужно сделать следущие действия: /var/ftp Code: Смена размещения </para>
<para> rmdir /home/ftp</para>
<para> mkdir /var/ftp</para>
<para> chown ftp:ftp /var/ftp</para>
<para> ln -s /var/ftp /home/</para>
<para/>
<para/>
<para>Теперь можно что-то разместить в этом каталоге. Например, если вы хотите сделать доступными для других каталоги disfiles и packages, можно сделать следущие действия: Code: ' </para>
<para> mv /usr/portage/disfiles /var/ftp/</para>
<para> ln -s /var/ftp/disfiles /usr/portage/</para>
<para> mv /usr/portage/packages /var/ftp/</para>
<para> ln -s  /var/ftp/packages /usr/portage/</para>
<para/>
<para/>
<para>Примечание: VSFTPD автоматически запусается в chroot окружении, поэтому символические ссылки не работают. Именно для этого пришлось перенести каталоги /usr/portage/disfiles и usr/portage/packages и создать символические ссылки в тех местах где они должны находится. </para>
<para/>
<para>Но можно например монтировать нужные каталоги в .../ftp при помощи fstab. Для этого нужно создать каталоги: /var/ftp/distfiles и /var/ftp/packages Code: ' </para>
<para> mkdir /var/ftp/distfiles</para>
<para> mkdir /var/ftp/packages</para>
<para/>
<para/>
<para>После чего пропишите в /etc/fstab следущее: Code: ' </para>
<para> /usr/portage/distfiles /var/ftp/distfiles none ro,bind 0 0</para>
<para> /usr/portage/packages /var/ftp/packages none ro,bind 0 0</para></sect4><sect4><title>Клиенты </title>
<para/>
<para>Есть множеcтво программ, которые позволяют получать доступ к ftp серверу. Вот некоторые из них: </para>
<para>ftp </para>
<para>lftp - лучшый консольный клиент </para>
<para>mozilla-firefox </para>
<para>nautilus </para>
<para>gftp</para></sect4></sect3><sect3><title>Jabber Server</title><sect4><title>Введение</title>
<para/>
<para>Jabber - это открытый протокол, использующий XML, для быстрого обмена сообщениями и информацией о присутствии между любыми двумя абонентами в интернете. Благодаря своей уникальной расширяемости и гибкости, jabber способен поддерживать множество протоколов - ICQ, IRQ, MSN, RSS, Yahoo и др. </para></sect4><sect4><title>Установка пакетов</title>
<para>В качестве платформы для развертывания протокола jabber возьмем пакет jabberd. Он поддерживает множество возможностей - основные IM-протоколы ICQ, MSN, Yahoo, поддержку SSL-соединений и даже IPv6.</para>
<para>Сначала посмотрим, какие USE-флаги требует jabber: Code: Зависимости </para>
<para/>
<para># emerge -pv jabberd</para>
<para>These are the packages that I would merge, in order:</para>
<para>Calculating dependencies ...done!</para>
<para>[ebuild N ] net-im/jabberd-1.4.3-r5 -icq -ipv6 -ldap -msn -oscar -ssl -yahoo 0 kB </para>
<para>Total size of downloads: 0 kB </para>
<para/>
<para>Включаем соответсвующие флаги в установку (неважно, через переменную USE или через файл make.conf) и собираем: USE="icq ssl" emerge jabberd В качестве зависимости вытянется пакет jit - Jabber ICQ Transport, необходимый для поддержки протокола ICQ. </para>
<para/></sect4><sect4><title>Конфигурация</title>
<para/>
<para>Сначала добавьте пользователей, ответсвенных за администрирование сервера jabber, в группу jabber: </para>
<para>gpasswd -a имя_пользователя jabber </para>
<para>Все конфигурационные файлы, связанные с jabber, имеют формат XML и находятся в каталоге /etc/jabber. </para>
<para>Обязательно надо прописать имя хоста и РАЗРЕШИТЬ регистрации. </para></sect4><sect4><title>Запуск демона</title>
<para/>
<para>Добавляем запуск сервера при старте системы: </para>
<para>rc-update add jabber default </para>
<para>Стартуем наш сервер: /etc/init.d/jabber start </para>
<para>Все должно работать :)</para>
<para/></sect4></sect3><sect3><title>Выделенный сервер Counter-Strike</title>
<para/>
<para>Рано или поздно у большинства админов локальных сетей возникает необходимость настраивать игровые сервера для пользователей. Одной из самых популярных сетевых игр на сегодняшний день является Counter-Strike.CS:Source. Которая, к сожалению пока не приобрела достаточной популярности у нас в России. Мы рассмотриму установку сервера для игры CS 1.6. Более популярной в среде российских геймеров. </para>
<para/><sect4><title>Необходимое программное обеспечение</title>
<para>Для установки CS-сервера нам понадобится только одна программа:halflife-steam Code: emerge -pv halflife-steam </para>
<para/>
<para>Calculating dependencies ...done! </para>
<para>[ebuild N ] games-server/halflife-steam-2.0 3,431 kB </para>
<para>Total size of downloads: 3,431 kB </para>
<para/>
<para/>
<para>Steam - это утилита от Valve,позволяющая обновлять любую их игру через steam-network. </para></sect4><sect4><title>Установка и настройка</title>
<para/>
<para>Ставим steam</para>
<para>Установка сводится к простому emerge halflife-steam. </para>
<para/>
<para>Настройка установка hl</para>
<para/>
<para>Steam установится в каталог /opt/halflife </para>
<para/>
<para>ВАЖНО: в ноябре 2006 года в пакете была бага. Что характерно для всех продуктов получаемых через стим, они иногда забывают unix специфику. Непостредственно у меня, на steam не стоял бит исполняемости. И в cs было имя типа xxx.WAD (нужно wad, различаеться регистр) Code: команды </para>
<para/>
<para>cd /opt/halflife </para>
<para>chmod +x stream </para>
<para/>
<para>Code: команды </para>
<para>./steam -command update -game cstrike -dir ./ </para>
<para/>
<para>Наблюдаем лог. Если никаких слов типа error нет - значит сервер установился. Code: output </para>
<para/>
<para>HLDS installation up to date </para>
<para/>
<para/>
<para>Предупреждение: Этот сервер работает только в LAN (класс С) и только со steam клиентами. Все остальное Варез</para>
<para/></sect4></sect3><sect3><title>Файл сервер Samba в домене Win2k</title>
<para>Задача: </para>
<para>Организация файлового сервера </para>
<para>Авторизация пользователей через домен контроллер </para>
<para/>
<para>Дано: </para>
<para>Red Hat 9.0 </para>
<para>Samba 3.0.13 </para>
<para>DC win 2003 server </para>
<para/><sect4><title>Вступление </title>Вступление<para>Взяться за написание данной статьи меня побудило то, что когда возникла задача о которой написано выше , то статьи описывающей решение данной проблемы полностью я не нашел вот и решил написать такую статью в которой было бы готовое решение. </para>
<para/></sect4><sect4><title>Основная часть </title>
<para>Первым делом устанавливаем самбу. Решено было использовать последнюю версию 3.0.13. Установлено все это было из стандартного RPM пакета. Думаю с этим сложностей ни у кого не возникает, док по данному вопросу полно и потому начнем сразу править конфиг самбы. Ниже приведен окончательный работающий конфиг, может там и есть что лишнее, но после того как все заработало я убирать оттуда ничего не стал. </para>
<para> [global]</para>
<para>   realm = bryusov.iasnet.ru</para>
<para> # Workgroup = имя NT-домена (или рабочей группы): </para>
<para>   workgroup = DOMAIN  </para>
<para/>
<para> # NetBIOS-имя, под которым будет виден сервер остальным машинам сети.</para>
<para>   netbios name = NAU</para>
<para/>
<para> # Комментарий, появляющийся рядом с именем машины в "Сетевом окружении" Windows.</para>
<para>   server string = Samba Server</para>
<para/>
<para> # Следующий параметр влияет на безопасность. Hosts allow разрешает машинам с </para>
<para> # указанными IP-адресами присоединяться к Samba-серверу. </para>
<para>   hosts allow = 172.18. 172.17.  127.</para>
<para/>
<para> # если подставить %m то для каждой машины  подключенной к Samba-серверу будет </para>
<para> # использоваться свой log-файл. </para>
<para>   log file = /var/log/samba/log.smbd   </para>
<para/>
<para> # это кому скока не жалко             </para>
<para>   max log size = 500    </para>
<para/>
<para> # определяет, каким образом будет осуществляться проверка пароля (нам надо через DC)                                          </para>
<para>   security = domain</para>
<para/>
<para> # Параметр Password server используется только совместно с опцией security = domain</para>
<para>   password server =  &lt;IP домен контролера&gt;</para>
<para/>
<para> # для репликации всех доменов входящих в траст с вашим доменом</para>
<para>   allow trusted domains = yes                </para>
<para/>
<para> # включаем  поддержку шифрованных паролей. </para>
<para>   encrypt passwords = yes</para>
<para/>
<para> # Используя следующий параметр можно создать отдельную конфигурацию для каждой машины домена. </para>
<para> # Вместо пары символов %m при входе подставляется NetBIOS-имя машины. </para>
<para> # Я Такого не делал хотя поэксперементровать можно.</para>
<para> # include = /usr/local/samba/lib/smb.conf.%m</para>
<para/>
<para> # данные строчки можно не включать в работающий конфиг они определяют место</para>
<para> # хранения , порядок обновления Unix паролей и какой программой все это производится</para>
<para>   smb passwd file = /etc/samba/smbpasswd</para>
<para>   unix password sync = Yes</para>
<para>   passwd program = /usr/bin/passwd %u</para>
<para>   passwd chat = *New*UNIX*password* %n\n *ReType*new*UNIX*password* %n\n *passwd:*all*authentication*tokens*updated*successfully*</para>
<para/>
<para> # В документации  говорится, что с помощью этого параметра</para>
<para> # можно повысить производительность Samba-сервера.</para>
<para>   socket options = TCP_NODELAY SO_RCVBUF=8192 SO_SNDBUF=8192</para>
<para/>
<para> # по дефолту слушаются все интерфейсы, здесь можно указать конкретно</para>
<para>   interfaces = &lt;ip или название интерфейса&gt;</para>
<para/>
<para> # строчки которых не было в стандартном конфиге и были добавлены руками для pепликации NT-юзеpов:</para>
<para/>
<para>  winbind uid = 10000-20000</para>
<para>  winbind gid = 10000-20000</para>
<para>  winbind enum groups = yes</para>
<para>  winbind enum users = yes</para>
<para/>
<para> # Если вам нужны русские буквы в именах файлов, то раскоментируйте </para>
<para> # следующие 3 строки (заменив KOI8-R на свою локаль)</para>
<para> # dos charset = CP866       </para>
<para> # unix charset = KOI8-R     </para>
<para> # display charset = KOI8-R  </para>
<para/>
<para/>
<para/>
<para> # описываем шары</para>
<para> [FILES]</para>
<para>   comment = share</para>
<para>   path = /share/FILES</para>
<para>   public = no</para>
<para>   writable = yes</para>
<para>   valid users = DOMAIN\users</para>
<para>   create mask = 0744</para>
<para/>
<para> # настройка кириллицы по желанию</para>
<para/>
<para>Все с конфигом самбы закончили, далее привожу конфиг /etc/krb5.conf </para>
<para> [logging]</para>
<para>  default = FILE:/var/log/krb5libs.log</para>
<para>  kdc = FILE:/var/log/krb5kdc.log</para>
<para>  admin_server = FILE:/var/log/kadmind.log</para>
<para/>
<para> [libdefaults]</para>
<para>  ticket_lifetime = 24000</para>
<para>  default_realm = PDC.DOMAIN.NAME.RU</para>
<para>  dns_lookup_realm = false</para>
<para>  dns_lookup_kdc = false</para>
<para/>
<para> [realms]</para>
<para>  DOMAIN.NAME.RU = {</para>
<para>   kdc = pdc.domain.name.ru:88</para>
<para>   admin_server = kerberos.domain.name.ru:749</para>
<para>   default_domain = domain.name.ru</para>
<para>  }</para>
<para/>
<para> [domain_realm]</para>
<para>  .domain.name.ru = DOMAIN.NAME.RU</para>
<para>  domain.name.ru = DOMAIN.NAME.RU</para>
<para/>
<para> [kdc]</para>
<para>  profile = /var/kerberos/krb5kdc/kdc.conf</para>
<para/>
<para> [appdefaults]</para>
<para>  pam = {</para>
<para>    debug = false</para>
<para>    ticket_lifetime = 36000</para>
<para>    renew_lifetime = 36000</para>
<para>    forwardable = true</para>
<para>    krb4_convert = false</para>
<para>  }</para>
<para/>
<para>Все остальное оставлено без изменений. </para>
<para/>
<para>Теперь заводим самба сервер в домен, делаем со стороны домен контролера двусторонние доверительные отношения, запускаем getent group и видим что все работает. </para>
<para/>
<para>Вот и все надеюсь полезной инфы достаточно для быстрой и эффективной настройки файл сервера. </para>
<para/>
<para>Огромное спасибо всем кто писал статьи про самбу почти все их прочитал и почерпнул много полезного , в том числе не только для решения своих задач.</para>
<para/></sect4></sect3><sect3><title>Руководство по настройке Samba в режиме PDC с использованием LDAP</title>
<para/><sect4><title>Устанавливаемые пакеты </title>
<para/>
<para>Установим нужные пакеты: </para>
<para/>
<para># USE="ldap acl ldapsam pam gdbm samba ssl tcpd winbind" emerge samba openldap acl nss_ldap pam_ldap </para>
<para/>
<para/>
<para/>
<para>ВАЖНО: Версия nss_ldap должна быть не ниже 250-r1 (&gt;=sys-auth/nss_ldap-250-r1) </para>
<para/></sect4><sect4><title>OpenLDAP</title>
<para/>
<para>Конфигурирование OpenLDAP</para>
<para/>
<para>Для примера используется домен amber.global.com который является дочерним доменом домена global.com, который работает под управлением Win2003 Server. </para>
<para/>
<para>Примечание: Не решенной задачей осталось создание доверительных отношений между доменами и включение домена amber в лес global.com </para>
<para>Файл: /etc/openldap/slapd.conf </para>
<para>include /etc/openldap/schema/core.schema</para>
<para> include /etc/openldap/schema/cosine.schema</para>
<para> include /etc/openldap/schema/inetorgperson.schema</para>
<para> include /etc/openldap/schema/misc.schema</para>
<para> include /etc/openldap/schema/nis.schema</para>
<para> include /etc/openldap/schema/openldap.schema</para>
<para> include /etc/openldap/schema/samba.schema</para>
<para> pidfile                        /var/run/openldap/slapd.pid</para>
<para> argsfile                /var/run/openldap/slapd.args</para>
<para/>
<para> access to dn.base=""</para>
<para>                by self write</para>
<para>                by * auth</para>
<para> access to attr=userPassword</para>
<para>                by self write</para>
<para>                by * auth</para>
<para> access to attr=shadowLastChange</para>
<para>                by self write</para>
<para>                by * read</para>
<para> access to *</para>
<para>                by * read</para>
<para>                by anonymous auth</para>
<para> #loglevel 1</para>
<para> database        ldbm</para>
<para> suffix          "dc=amber,dc=global,dc=com"</para>
<para> rootdn          "cn=Manager,dc=amber,dc=global,dc=com"</para>
<para> # Пароль rootpw лучше всего указывать в зашифрованном виде.</para>
<para> # Для генерации шифрованного пароля используйте утилиту slappasswd</para>
<para> # Например: slappasswd -h {MD5}</para>
<para> # rootpw = secret</para>
<para> rootpw                {MD5}Xr4ilOzQ4PCOq3aQ0qbuaQ==</para>
<para> directory        /var/lib/openldap-ldbm</para>
<para/>
<para> index objectClass           eq</para>
<para> index cn                    eq,subinitial</para>
<para> index sn                    eq,subinitial</para>
<para> index uid                   eq,subinitial</para>
<para> index displayName           eq,subinitial</para>
<para> index uidNumber             eq</para>
<para> index gidNumber             eq</para>
<para> index memberUID             eq</para>
<para> index sambaSID              eq</para>
<para> index sambaPrimaryGroupSID  eq</para>
<para> index sambaDomainName       eq</para>
<para>Файл: /etc/openldap/ldap.conf </para>
<para>HOST 127.0.0.1</para>
<para>BASE dc=sanaa,dc=global,dc=com</para>
<para/>
<para/>
<para/>
<para>Проверяем разрешения на каталоги /var/lib/openldap-*</para>
<para>ls -la /var/lib/ </para>
<para/>
<para>ВАЖНО: </para>
<para>drwx------   2 ldap     ldap      104 Июн  8 18:31 openldap-data</para>
<para>drwx------   2 ldap     ldap       72 Июн  8 18:31 openldap-ldbm</para>
<para>drwx------   2 ldap     ldap       72 Июн  8 18:31 openldap-slurp</para>
<para/></sect4><sect4><title>Запуск сервера OpenLDAP</title>
<para/>
<para>пока работаем без шифрования трафика, так как сервер LDAP и SAMBA работают на одном сервере, подправляем конфиг чтобы LDAP слушал 389 порт только на localhost. </para>
<para>Файл: /etc/conf.d/sldap </para>
<para># conf.d file for the openldap-2.1 series</para>
<para>#</para>
<para># To enable both the standard unciphered server and the ssl encrypted</para>
<para># one uncomment this line or set any other server starting options</para>
<para># you may desire.</para>
<para>#</para>
<para># OPTS="-h 'ldaps:// ldap:// ldapi://%2fvar%2frun%2fopenldap%2fslapd.sock'"</para>
<para>OPTS="-h 'ldap://127.0.0.1'"</para>
<para/>
<para>и запускаем OpenLDAP </para>
<para/>
<para>/etc/init.d/slapd start </para>
<para/></sect4><sect4><title>SAMBA</title>
<para/>
<para>Миграция OpenLDAP</para>
<para/>
<para>Существует 2 пути создания учетных записей пользователей: домен уже существует и создание нового домена. В первом случае самбу нужно настроить в режиме BDC, перенести все учетные записи, и потом изолировав PDC, перезапустить самбу в режиме PDC. Во втором случае все еще проще, самбу сразу запускаем в режиме PDC и создаем стандарные учетные записи при помощи замечательного пакета smbldap-tools. </para>
<para/>
<para/>
<para/>
<para>emerge smbldap-tools</para>
<para/>
<para>/etc/init.d/samba start</para>
<para/>
<para>Code: configure.pl </para>
<para>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-</para>
<para>       smbldap-tools script configuration</para>
<para>       -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</para>
<para>Before starting, check</para>
<para> . if your samba controller is up and running.</para>
<para> . if the domain SID is defined (you can get it with the 'net getlocalsid')</para>
<para/>
<para> . you can leave the configuration using the Crtl-c key combination</para>
<para> . empty value can be set with the "." character</para>
<para>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-</para>
<para>Looking for configuration files...</para>
<para/>
<para>Samba Configuration File Path [/etc/samba/smb.conf] &gt; </para>
<para>The default directory in which the smbldap configuration files are stored is shown.</para>
<para>If you need to change this, enter the full directory path, then press enter to continue.</para>
<para>Smbldap-tools Configuration Directory Path [/etc/smbldap-tools/] &gt; </para>
<para>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</para>
<para>Let's start configuring the smbldap-tools scripts ...</para>
<para/>
<para>. workgroup name: name of the domain Samba act as a PDC</para>
<para>  workgroup name [amber] &gt; </para>
<para>. netbios name: netbios name of the samba controler</para>
<para>  netbios name [neptun] &gt; </para>
<para>. logon drive: local path to which the home directory will be connected </para>
<para> (for NT Workstations). Ex: 'H:'</para>
<para>  logon drive [U:] &gt; </para>
<para>. logon home: home directory location (for Win95/98 or NT Workstation).</para>
<para>  (use %U as username) Ex:'\\neptun\%U'</para>
<para>  logon home (press the "." character if you don't want homeDirectory) [\\%L\users\%U] &gt; </para>
<para>. logon path: directory where roaming profiles are stored. Ex:'\\neptun\profiles\%U'</para>
<para>  logon path (press the "." character if you don't </para>
<para>  want roaming profile) [\\%L\Profiles\%a\%U] &gt; </para>
<para>. home directory prefix (use %U as username) [/home/%U] &gt; </para>
<para>. default users' homeDirectory mode [700] &gt; </para>
<para>. default user netlogon script (use %U as username) [] &gt;</para>
<para>   default password validation time (time in days) [45] &gt; 900</para>
<para>. ldap suffix [dc=amber,dc=global,dc=com] &gt; </para>
<para>. ldap group suffix [ou=Groups] &gt; </para>
<para>. ldap user suffix [ou=Users] &gt; </para>
<para>. ldap machine suffix [ou=Users] &gt; </para>
<para>. Idmap suffix [ou=Idmap] &gt; </para>
<para>. sambaUnixIdPooldn: object where you want to store the next uidNumber</para>
<para>  and gidNumber available for new users and groups</para>
<para>  sambaUnixIdPooldn object (relative to ${suffix}) [sambaDomainName=amber] &gt; </para>
<para>. ldap master server: IP adress or DNS name of the master (writable) ldap server</para>
<para>  ldap master server [127.0.0.1] &gt; </para>
<para>. ldap master port [389] &gt; </para>
<para>. ldap master bind dn [cn=Manager,dc=amber,dc=global,dc=com] &gt; </para>
<para>. ldap master bind password [] &gt;  </para>
<para>. ldap slave server: IP adress or DNS name of the slave ldap server: can also </para>
<para>  be the master one</para>
<para>  ldap slave server [127.0.0.1] &gt; </para>
<para>. ldap slave port [389] &gt; </para>
<para>. ldap slave bind dn [cn=Manager,dc=amber,dc=global,dc=com] &gt; </para>
<para>. ldap slave bind password [] &gt;  </para>
<para>. ldap tls support (1/0) [0] &gt; </para>
<para>. SID for domain amber: SID of the domain (can be obtained with 'net getlocalsid neptun')</para>
<para>  SID for domain amber [S-1-5-21-1918777035-593721947-2697221154] &gt; </para>
<para>. unix password encryption: encryption used for unix passwords</para>
<para>  unix password encryption (CRYPT, MD5, SMD5, SSHA, SHA) [SSHA] &gt; MD5</para>
<para>. default user gidNumber [513] &gt; </para>
<para>. default computer gidNumber [515] &gt; </para>
<para>. default login shell [/bin/bash] &gt; </para>
<para>. default skeleton directory [/etc/skel] &gt; </para>
<para>. default domain name to append to mail adress [] &gt; </para>
<para>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</para>
<para>backup old configuration files:</para>
<para>  /etc/smbldap-tools/smbldap.conf-&gt;/etc/smbldap-tools/smbldap.conf.old</para>
<para>  /etc/smbldap-tools/smbldap_bind.conf-&gt;/etc/smbldap-tools/smbldap_bind.conf.old</para>
<para>writing new configuration file:</para>
<para>  /etc/smbldap-tools/smbldap.conf done.</para>
<para>  /etc/smbldap-tools/smbldap_bind.conf done.</para>
<para/>
<para/>
<para/>
<para>Если мы не хотим, что бы у всех пользователей профили были перемещаемыми, то в файле /etc/smbldap-tools/smbldap.conf установим следующее значение: Файл: /etc/smbldap-tools/smbldap.conf </para>
<para> ...</para>
<para> userProfile=""</para>
<para> ...</para>
<para> </para>
<para>Инициализируем каталоги самбы в LDAP: </para>
<para/>
<para>smbldap-populate -a Administrator -k 0 -m 0</para>
<para/>
<para>Конфигурация SAMBA</para>
<para>Файл: /etc/samba/smb.conf </para>
<para>[global]</para>
<para>        workgroup = amber</para>
<para>        netbios name = neptun</para>
<para>        realm = amber.global.com</para>
<para>        nt acl support = yes</para>
<para>        acl compatibility = win2k</para>
<para>        map acl inherit = yes</para>
<para>        server string = Samba Server %v</para>
<para>        interfaces = eth0</para>
<para>        bind interfaces only = yes</para>
<para>        hosts allow = 192.168.7. 127.</para>
<para>        log file = /var/log/samba/log.%m</para>
<para>        debug level = 9</para>
<para>        max log size = 500</para>
<para>        socket options = TCP_NODELAY SO_SNDBUF=8192 SO_RCVBUF=8192</para>
<para>        security = user</para>
<para>        os level = 250</para>
<para>        passdb backend = ldapsam:"ldap://127.0.0.1/"</para>
<para>        enable privileges = yes</para>
<para>        </para>
<para>        passwd program = /usr/sbin/smbldap-passwd "%u"</para>
<para>        passwd chat = *new*password* %n\n *new*password* %n\n *successfully*</para>
<para>        passdb expand explicit = no</para>
<para>        unix password sync = no</para>
<para>        ldap passwd sync = no</para>
<para>        </para>
<para>        ldap suffix = dc=amber,dc=global,dc=com</para>
<para>        ldap admin dn = cn=Manager,dc=amber,dc=global,dc=com</para>
<para>        ldap user suffix = ou=Users</para>
<para>        ldap group suffix = ou=Groups</para>
<para># Т.к. для самбы компьютеры и пользователи - одно и то же,</para>
<para># и искать она в дальнейшем записи компьютеров будет в пользователях,</para>
<para># то для избежания дальнейших проблем при добавлении рабочих станций</para>
<para># к домену мы вместо следующей строки</para>
<para>#</para>
<para>#        ldap machine suffix = ou=Computers</para>
<para>#</para>
<para># напишем другую:</para>
<para>        ldap machine suffix = ou=Users</para>
<para>        ldap idmap suffix = ou=Idmap</para>
<para>        idmap backend = ldapsam:ldap://127.0.0.1/</para>
<para>        idmap uid = 10000-20000</para>
<para>        idmap gid = 10000-20000</para>
<para>        </para>
<para>        ldap delete dn = Yes</para>
<para>        ldap ssl = no</para>
<para>        </para>
<para>        </para>
<para>        add user script = /usr/sbin/smbldap-useradd -n -a "%u"</para>
<para>        delete user script = /usr/sbin/smbldap-userdel "%u"</para>
<para>        </para>
<para>        add group script = /usr/sbin/smbldap-groupadd -p "%g"</para>
<para>        delete group script = /usr/sbin/smbldap-userdel "%g"</para>
<para>        </para>
<para>        add user to group script = /usr/sbin/smbldap-groupmod -m "%u" "%g"</para>
<para>        delete user from group script = /usr/sbin/smbldap-groupmod -x "%u" "%g"</para>
<para>        set primary group script = /usr/sbin/smbldap-usermod -g "%g" "%u"</para>
<para>        </para>
<para>        </para>
<para>        add machine script = /usr/sbin/smbldap-useradd -w "%u"</para>
<para>        </para>
<para>        #PDC</para>
<para>        domain master = yes</para>
<para>        preferred master = yes</para>
<para>        #BDC</para>
<para>#        domain master = no</para>
<para>#        preferred master = no</para>
<para>        domain logons = Yes</para>
<para>        </para>
<para/>
<para>        logon script = </para>
<para># Если хотите, что бы профили всех пользователей были перемещаемыми</para>
<para># и хранились на сервере (со всеми гигабайтами фильмов и личных фотографий)</para>
<para># то укажите такое значение следующего параметра:</para>
<para>#</para>
<para>#        logon path = \\%L\Profiles\%a\%U</para>
<para>#</para>
<para># Если вы не хотите гонять профили по сети, оставьте значение пустым, </para>
<para># (но ни в коем случае не комментируйте эту строку, она просто получит </para>
<para># значение по умолчанию), вот так:</para>
<para>        logon path =</para>
<para>        logon drive = U: </para>
<para>        logon home = \\%L\users\%U</para>
<para>        </para>
<para>        </para>
<para>#============================ Share Definitions ==============================</para>
<para>[netlogon]</para>
<para>    comment = Network Logon Service</para>
<para>    path = /var/lib/samba/netlogon</para>
<para>    browseable = yes</para>
<para>    guest ok = yes</para>
<para>    writable = no</para>
<para>    share modes = no</para>
<para/>
<para>[Profiles]</para>
<para>    admin users = admin</para>
<para>    create mode = 600</para>
<para>    directory mode = 700</para>
<para>    path = /var/lib/samba/profiles</para>
<para>    browseable = yes</para>
<para>    guest ok = yes</para>
<para>    writable = yes</para>
<para/>
<para>[homes]</para>
<para>  comment = Home Directories</para>
<para>  browseable = no</para>
<para>  read only = no</para>
<para/>
<para>[public]</para>
<para>  path = /pub</para>
<para>  guest ok = yes</para>
<para>  read only = no</para>
<para/>
<para>[users]</para>
<para>  path = /home/users</para>
<para>  writable = yes</para>
<para>  printable = no</para>
<para> </para>
<para/>
<para/>
<para>Добавим запуск winbind с самбой (если нужно): Файл: /etc/conf.d/samba </para>
<para> ...</para>
<para> daemon_list="smbd nmbd winbind"</para>
<para> ...</para>
<para> </para>
<para>Введём пароль рабочей станции: </para>
<para/>
<para>smbpasswd -w secret </para>
<para/>
<para>Введём контроллёр домена, собственно в домен </para>
<para/>
<para>net rpc join -S neptun -U Administrator </para>
<para/></sect4><sect4><title>Настройка системы на авторизацию в LDAP</title>
<para/>
<para>--ladserg 14:05, 28 июля 2006 (UTC) У меня честно говоря не получилось сделать авторизацию пользователей samba через LDAP без настройки поддержки авторизации системных пользователей в LDAP, пришлось настраивать и это. </para>
<para/>
<para>Сначала поправим файл /etc/ldap.conf, приведя его примерно к следующему виду: </para>
<para/>
<para>Файл: /etc/ldap.conf </para>
<para> host 127.0.0.1</para>
<para> base dc=amber,dc=global,dc=com</para>
<para> ldap_version 3</para>
<para> rootbinddn cn=Manager,dc=amber,dc=global,dc=com</para>
<para> bind_timelimit 10</para>
<para> bind_policy soft</para>
<para> pam_filter objectClass=posixAccount</para>
<para> pam_password exop</para>
<para> nss_base_passwd         ou=Users,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_shadow         ou=Users,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_group          ou=Groups,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_hosts          ou=Hosts,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_services       ou=Services,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_networks       ou=Networks,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_protocols      ou=Protocols,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_rpc            ou=Rpc,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_ethers         ou=Ethers,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_netmasks       ou=Networks,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_bootparams     ou=Ethers,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_aliases        ou=Aliases,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_netgroup       ou=Netgroup,dc=tty,dc=perm,dc=ru?one</para>
<para> ssl off</para>
<para> nss_reconnect_tries 4</para>
<para> nss_reconnect_sleeptime 1</para>
<para> nss_reconnect_maxsleeptime 16</para>
<para> nss_reconnect_maxconntries 2</para>
<para> </para>
<para>Сим мы скажем nss_ldap где и как искать зписи пользователей и групп. </para>
<para/>
<para>Теперь сзодадим файл /etc/ldap.secret и при помощи лбого текстого редактора в plain/text виде занесём туда пароль пользователя, который выше у нас указан в опции rootbinddn, нпример пароль secret: </para>
<para>Файл: /etc/ldap.secret </para>
<para>secret </para>
<para/>
<para>Затем непременно установим на него нужные права:</para>
<para>Code: Установка прав на файл /etc/ldap.secret </para>
<para> #chmod 600 /etc/ldap.secret</para>
<para> #chown root:root /etc/ldap.secret</para>
<para/>
<para>Далее приведём файл /etc/pam.d/system-auth к следующему виду: </para>
<para>Файл: /etc/pam.d/system-auth </para>
<para> auth       required     pam_env.so</para>
<para> auth       sufficient   pam_unix.so likeauth nullok</para>
<para> auth       sufficient   pam_ldap.so use_first_pass</para>
<para> auth       required     pam_deny.so</para>
<para/>
<para> account    sufficient   pam_ldap.so</para>
<para> account    required     pam_unix.so</para>
<para/>
<para> password   required     pam_cracklib.so difok=2 minlen=8 dcredit=2 ocredit=2 retry=3</para>
<para> password   sufficient   pam_unix.so nullok md5 shadow use_authtok</para>
<para> password   sufficient   pam_ldap.so use_authtok</para>
<para> password   required     pam_deny.so</para>
<para/>
<para> session    required     pam_limits.so</para>
<para> session    required     pam_unix.so</para>
<para> session    required     pam_mkhomedir.so skel=/etc/skel/ umask=077</para>
<para> session    optional     pam_ldap.so</para>
<para> </para>
<para>Обратите внимание на строку: </para>
<para/>
<para>session required pam_mkhomedir.so skel=/etc/skel/ umask=077 </para>
<para/>
<para>Она заставляет систему создавать домашние каталоги для тех пользоватей у которых они ещё не созданы, при этом в новый каталог помещается содержимое директории /etc/skel/ и задаётся маска каталога 0x700 </para>
<para/>
<para>После чего правим файл /etc/nsswitch.conf, приводя его к следующему виду: </para>
<para>Файл: /etc/nsswitch.conf </para>
<para> passwd:      files ldap</para>
<para> shadow:      files ldap</para>
<para> group:       files ldap</para>
<para/>
<para> hosts:       files dns</para>
<para> networks:    files dns</para>
<para/>
<para> services:    db files</para>
<para> protocols:   db files</para>
<para> rpc:         ldap [NOTFOUND=return] db files</para>
<para> ethers:      ldap [NOTFOUND=return] db files</para>
<para> netmasks:    files</para>
<para> netgroup:    ldap [NOTFOUND=return] files</para>
<para> bootparams:  files</para>
<para/>
<para> automount:   files</para>
<para> aliases:     files </para>
<para/>
<para>Предупреждение: Ни в коем случае не добавляйте значение ldap к следующим базам: hosts, networks, protocols, services. Иначе вы рискуете не дождаться следующей загрузки системы. </para>
<para/>
<para>Всё, теперь мы указали системе брать пользователей как из системных файлов, так и из LDAP. </para>
<para/>
<para>Перезагрузим наш компьютер, дабы убедиться что система грузится нормально. Если система останавливается на загрузке udev, то смотрите ошибки в файле /etc/nsswitch.conf, может вы указали использовать ldap не в той базе. </para>
<para/></sect4><sect4><title>Управление пользователями</title>
<para/>
<para>Ранее мы установили пакет smbldap-tools, теперь рассмотрим возможность управления пользователями с его помощью. </para>
<para/>
<para>Создание пользователя</para>
<para/>
<para>smbldap-useradd [-o] [-a] [-b] [-w] [-i] [-u uid] [-g gid ] [-G groups,,,] </para>
<para> [-n] [-d home] [-s shell] [-c gecos] [-m [-k]] [-t] [-P] [-A 0|1] [-B 0|1] </para>
<para> [-C sambaHomePath] [-D sambaHomeDrive] [-E sambaLogonScript] [-F sambaProfilePath] </para>
<para> [-H sambaAcctFlags] [-N surname] [-S family name] [-M local mailAddress,,,] </para>
<para> [-T mailToAddress] [-?] user</para>
<para/>
<para>Где: </para>
<para> user - системное имя создаваемого пользователя</para>
<para> -o   - add the user in the organizational unit (relative to the user suffix)</para>
<para> -a   - is a Windows User (otherwise, Posix stuff only)</para>
<para> -b   - is a AIX User</para>
<para> -w   - is a Windows Workstation (otherwise, Posix stuff only)</para>
<para> -i   - is a trust account (Windows Workstation)</para>
<para> -u   - uid</para>
<para> -g   - gid</para>
<para> -G   - список групп пользователя, разделённых запятой.</para>
<para> -n   - do not create a group</para>
<para> -d   - домашний каталог пользователя (по умолчанию /home/имя_пользователя)</para>
<para> -s   - оболочка пользователя (по умолчанию /bin/false)</para>
<para> -c   - отображаемое в Windows имя пользователя</para>
<para> -m   - создать домашний каталог и скопировать в него файлы из /etc/skel</para>
<para> -k   - указать иной каталог, из которого будут копироваться файлы при </para>
<para>        создании домашнего каталога пользователя (используется с ключём -m)</para>
<para> -t   - time. Wait 'time' seconds before exiting (when adding Windows Workstation)</para>
<para> -P   - ends by invoking smbldap-passwd</para>
<para> -A   - возможность менять пароль пользователем, значение 0 если нет, 1 если да</para>
<para> -B   - пользователь должен поменять пароль, значение 0 если нет, 1 если да</para>
<para> -C   - домашний каталог samba (например '\\PDC-SRV\homes')</para>
<para> -D   - буква диска для монтирования домашнего каталога samba (например 'H:')</para>
<para> -E   - скрипт, выполняемый при входе в систему</para>
<para> -F   - каталог профиля пользователя (например '\\PDC-SRV\profiles\foo')</para>
<para> -H   - sambaAcctFlags (samba account control bits like '[NDHTUMWSLKI]')</para>
<para> -N   - настоящее имя пользователя (для русских ещё и отчество)</para>
<para> -S   - фамилия пользователя</para>
<para> -M   - local mailAddress (comma seperated)</para>
<para> -T   - mailToAddress (forward address) (comma seperated)</para>
<para> -?   - отобразить помощь</para>
<para/>
<para>Например создание пользователя ladserg: </para>
<para/>
<para>smbldap-useradd -a -c 'Serg Alex Lad' -N 'Serg Alex' -S 'Lad' -s /bin/bash ladserg </para>
<para/>
<para>К сожалению подружить smbldap-tools с русским мне не удалось, даже при использовании кодировки UTF-8. </para>
<para>Итак, в приведённом выше примере будет создан пользователь с системным именем ladserg, фамилией Lad, именем Serg Alex, оболочкой /bin/bash, домашним каталогом /home/ladserg. Флаг -a укажет, что пользователь также будет являться пользователем домена. </para>
<para/>
<para>Изменение пароля</para>
<para>smbldap-passwd [-s] [-u] [-h] username</para>
<para/>
<para>Где: </para>
<para> username       - имя пользователя</para>
<para> -h, -?, --help - показать помощь</para>
<para> -s             - обновить только samba пароль</para>
<para> -u             - обновить только UNIX пароль</para>
<para/>
<para/>
<para>Например: </para>
<para/>
<para>smbldap-passwd ladserg </para>
<para/>
<para>После чего дважды будет запрошен пароль. </para>
<para/>
<para>Теперь можно попробовать зайти в систему под учётной записью только что созданного пользователя. </para>
<para/>
<para>Модификация пользователя</para>
<para>smbldap-usermod [-a] [-c comment] [-d home_dir] [-e expiration_date] </para>
<para> [-g initial_group] [-r new_login_name] [-p passwd] [-s shell] [-u uid [ -o]] [-x] </para>
<para> [-A canchange] [-B mustchange] [-C smbhome] [-D homedrive] [-E scriptpath] </para>
<para> [-F profilepath] [-G group[,...]] [-H acct‐flags] [-N canonical_name] </para>
<para> [-S surname] [-P] login</para>
<para/>
<para>Где: </para>
<para> -c    - Полное имя</para>
<para> -d    - Домашний каталог</para>
<para> -r    - новое имя пользователя (cn, sn и dn будут обновлены)</para>
<para> -u    - uid</para>
<para> -o    - uid может быть не уникальным</para>
<para> -g    - gid</para>
<para> -G    - список групп пользователя, разделённых запятой.</para>
<para> -s    - оболочка</para>
<para> -N    - настоящее имя пользователя (для русских ещё и отчество)</para>
<para> -S    - фамилия пользователя</para>
<para> -P    - ends by invoking smbldap-passwd</para>
<para>For samba users:</para>
<para> -a    - add sambaSAMAccount objectclass</para>
<para> -e    - expire date ("YYYY-MM-DD HH:MM:SS")</para>
<para> -A    - возможность менять пароль пользователем, значение 0 если нет, 1 если да</para>
<para> -B    - пользователь должен поменять пароль, значение 0 если нет, 1 если да</para>
<para> -C    - домашний каталог samba (например '\\PDC-SRV\homes')</para>
<para> -D    - буква диска для монтирования домашнего каталога samba (например 'H:')</para>
<para> -E    - скрипт, выполняемый при входе в систему</para>
<para> -F    - каталог профиля пользователя (например '\\PDC-SRV\profiles\foo')</para>
<para> -H    - sambaAcctFlags (samba account control bits like '[NDHTUMWSLKI]')</para>
<para> -I    - disable an user. Can't be used with -H or -J</para>
<para> -J    - enable an user. Can't be used with -H or -I</para>
<para> -M    - mailAddresses (comma seperated)</para>
<para> -T    - mailToAddress (forward address) (comma seperated)</para>
<para> -?|-h - отобразить помощь</para>
<para/>
<para/>
<para>Например команда: </para>
<para>smbldap-usermod -A 1 ladserg</para>
<para/>
<para>Позволит пользователю ladserg менять пароль. А команда: </para>
<para>smbldap-usermod -a slad-adm</para>
<para/>
<para>Добавит к учётной записи пользователя slad-adm класс sambaSAMAccount, что сделает его пользователем samba. </para>
<para/>
<para>Удаление пользователя</para>
<para>smbldap-userdel [-r|-R|-?] username</para>
<para/>
<para>Где: </para>
<para> -r    удалить домашний каталог</para>
<para> -R    удалить домашний каталог с запросом на удаление каждого файла</para>
<para> -?    отобразить помощь</para>
<para/>
<para>Например команда: </para>
<para>smbldap-userdel -r slad-adm </para>
<para/>
<para>удалит пользователя slad-adm, и его домашний каталог. </para>
<para/>
<para>Управление пользователями в оффтопике</para>
<para/>
<para>Если вы вводите в домен компьютеры под управлением Windows, то вам пригодятся пара утилит, архив которых можно скачать отсюда: </para>
<para/>
<para>
<ulink url="ftp://ftp.microsoft.com/Softlib/MSLFILES/SRVTOOLS.EXE">ftp://ftp.microsoft.com/Softlib/MSLFILES/SRVTOOLS.EXE</ulink>
</para>
<para/></sect4></sect3><sect3><title>Мониторинг работы системы</title>
<para/><sect4><title>Введение</title>
<para/>
<para>В данной статье описывается, как осуществить мониторинг разных системных и физических параметров компьютеров, работающих под GNU/Linux или другими UNIX. </para>
<para/>
<para/>
<para/>
<para>Постановка задачи</para>
<para/>
<para>Нужно осуществлять постоянный мониторинг основных параметров работы компьютеров (физических и системных) через сеть, собирать и выдавать эту информацию в удобной форме.</para>
<para/>
<para>Для примера см: http://monitoring.sourceforge.net/example.html</para>
<para/>
<para>К основным системным параметрам относят: загрузка процессоров (пользователями, системой, привилегированными программами, свободное процессорное время), использования оперативной памяти (и многие другие, всего больше 100), дисков, сетевого трафика. Для получения необходимых нам значений параметров работы системы используем программы df, sar и iptables или ipfw.</para>
<para/>
<para>К физическим параметрам относят: температуру процессора и материнской платы, скорость вращения вентиляторов, напряжения питания. Для получения показателей датчиков материнских плат используется модуль ядра I2C и программа lm_sensors.</para>
<para/>
<para>Для передачи информации через сеть используем клент-серверную модель и программу Net-Telnet. Базу данных строим пакетом rrdtool, информацию предоставляем через сервер apache и/или по почте. С помощью скриптов постараемся максимально упростить и автоматизировать поставленную задачу, это избавит вас от рутинной работы.</para>
<para/>
<para>Программа работает по клиент-серверной технологии. На компьютерах, которые нужно мониторить, размещается часть программы, которая снимает различные показатели работы компьютера и выдает их по запросу через сеть. На одном административном компьютере осуществляется периодический опрос всех компьютеров, за которыми ведется наблюдение, данные записываются в специально созданную базу, и на её основе формируется html страница, которая экспортируется через apache для просмотра обычным браузером.</para>
<para/>
<para>Теперь подробно о том, что нам нужно сделать:</para>
<para>Загружаем последнюю версию программы для мониторинга с сайта http://monitoring.sourceforge.net/ Файл monitoring-*.tar.bz2 размещаем в доступном месте, например в папке локального ftp: /var/ftp/pub/linux. </para></sect4><sect4><title>"Серверная" сторона</title>
<para/>
<para>Разархивируйте monitoring-*.tar.bz2.</para>
<para/>
<para>У Gentoo есть ебилд, для установки программы monitoring со всеми зависимостями. С сайта необходимо скачать monitoring-*.ebuild.tar.bz2 и распаковать его в /usr/local. Далее выполните: </para>
<para># emerge -pv monitoring</para>
<para>[ebuild N ] net-analyzer/monitoring-0.11 USE="-admin -apache2 -lm_sensors -server"</para>
<para/>
<para>Для серверной стороны необходимо добавить USE="server", а для поддержки мониторинга датчиков USE="lm_sensors" </para>
<para># export "USE=lm_sensors server"</para>
<para># emerge monitoring</para>
<para/>
<para>Компиляция и установка lm_sensors, sysstat, iptables, coreutils, xinetd в случае использования Gentoo можно пропустить, потому что эти пакеты уже установлены как зависимости, и перейти сразу к их настройке. </para></sect4><sect4><title>Мониторинг физических параметров</title>
<para/>
<para>Определяем на базе какого чипсета сделаны платы: материнская, видеокарта (некоторые имеют датчики) и прочие, заходим на страницы: http://secure.netroedge.com/~lm78/supported.html и http://www.lm-sensors.nu/~lm78/newdrivers.html и ищем, есть ли драйверы для мониторинга этих плат под Линуксом. Если определили, что ваши чипсеты поддерживаются и драйвер стабильный, можете продолжить выполнение этого пункта.</para>
<para/>
<para>Внимание, если версия ядра меньше за 2.4.9, нужно обновить ядро или воспользоваться старой версией программы! смотрите: i2c. Если ядро версии 2.4.*, вам дополнительно нужен СООТВЕТСТВУЮЩИЙ! модуль i2c-*.*.*.tar.gz, родной Линуксовый не подходит. В версии ядра 2.6.* все хорошо - отлично работает родной модуль ядра i2c. </para>
<para/></sect4><sect4><title>Компиляция ядра</title>
<para/>
<para>Подробную инструкцию по сборке нового ядра можно прочесть по ссылке "Ставим ядро 2.6, или Ядерная физика для домохозяйки. Версия 2.0"</para>
<para>Обратите особое внимание на пункты, которые добавляют к ядру GNU/Linux поддержку сенсоров:</para>
<para>Для поддержания ACPI: </para>
<para>Power management options (ACPI, APM) ---&gt; ACPI (Advanced Configuration and Power Interface) Support ---&gt;</para>
<para/>
<para>Для поддержки IPMI стандарта управления сенсорами. </para>
<para>Device Drivers ---&gt; Character devices ---&gt; IPMI ---&gt;</para>
<para/>
<para>Включаем поддержку сенсоров в ядре </para>
<para>Device Drivers ---&gt; I2C support ---&gt;</para>
<para/>
<para>Выбираем алгоритмы, использующие ваши чипы </para>
<para>Device Drivers ---&gt; I2C support ---&gt; I2C Algorithms ---&gt;</para>
<para/>
<para>Выбираем ваш чипсет (внимание, здесь нужно указать чипсет именно вашей системной платы, или видеокарты, см. ниже): </para>
<para>Device Drivers ---&gt; I2C support ---&gt; I2C Hardware Bus support ---&gt;</para>
<para>Device Drivers ---&gt; I2C support ---&gt; Miscellaneous I2C Chip support ---&gt;</para>
<para/>
<para>Выбираем драйверы ко всем вашим сенсорам (внимание, именно тех, соответствующих вашим чипам, предыдущим пунктам): </para>
<para>Device Drivers ---&gt; Hardware Monitoring support ---&gt;</para>
<para/>
<para>Можно собрать необходимые драйверы как модули, хотя это несколько добавит работы при настройке (нужно будет запустить программу sensors-detect). Для мониторинга сети можно использовать netfilter (iptables) и прочие опции... </para>
<para/>
<para>Если Ваше аппаратное обеспечения поддерживается, установите lm_sensors</para>
<para/>
<para>Загружаем с: lm_sensors, свеженькую версию lm_sensors-*.*.*.tar.gz. Разархивируем lm_sensors-*.*.*.tar.gz Заходим в директорию, какая создалась и выполняем: </para>
<para># make user</para>
<para># make user_install</para>
<para># depmod -a</para>
<para/>
<para>Проверяем, есть ли строка /usr/local/lib в файле /etc/ld.so.conf, если нет, добавляем и выполняем команду: </para>
<para># ldconfig</para>
<para/>
<para/>
<para>Настройка lm_sensors</para>
<para/>
<para>Выполняем команду </para>
<para># prog/mkdev/mkdev.sh</para>
<para/>
<para>Чтобы правильно определить ваше оборудование и знать, какие модули нужно загрузить, выполним: </para>
<para># prog/detect/sensors-detect</para>
<para/>
<para>именно этот скрипт и указывает, какие у вас чипсеты, и какие в них сенсоры!</para>
<para>Добавляем строки, созданные программой для modules.conf в /etc/modules.conf</para>
<para>Копируем prog/init/lm_sensors.init в каталог /etc/rc.d/init.d/lm_sensors (назначить права для исполнения).</para>
<para>Добавляем строки, которые создала программа prog/detect/sensors-detect с modprobe и sensors -s например, в конец файла /etc/conf.d/local.start - чтобы они загружались при старте системы</para>
<para>или можно запускать как сервис:</para>
<para>для Gentoo выполняем: </para>
<para># rc-update -a lm_sensors default</para>
<para/>
<para>Только для клонов RedHat выполняем: </para>
<para># chkconfig --add lm_sensors</para>
<para/>
<para>копируем prog/init/lm_sensors.sysconfig в /etc/sysconfig/lm_sensors</para>
<para>копируем etc/sensors.conf.eg в /etc/sensors.conf</para>
<para>копируем prog/sensors/sensors в каталог /usr/bin/sensors (предоставить права на выполнение) </para>
<para/>
<para>Все теперь выполняют modprobe с параметрами, которые указала программа sensors-detect для загрузки модулей, потом выполняем: </para>
<para># sensors -s</para>
<para/>
<para>Корректируем /etc/sensors.conf таким образом, чтобы названия напряжений, скорости вентиляторов и температур, именно Ваших чипов содержали соответственно: "Volt", "Fan", "Temp". При этом, названия меток допускают только малые и большие латинские буквы, цифры, знак "_", и не должны содержать знаков „.”, ”/” или ”+”! Выполнение этих условий обязательно!!!</para>
<para>Пример /etc/sensors.conf можно найти в server/etc/sensors.conf</para>
<para>Например, для lm85*: </para>
<para># cat /etc/sensors.conf</para>
<para>...</para>
<para># Voltage inputs</para>
<para>  label in0   "VoltA1_5"      # AGP on Intel S845WD1-E</para>
<para>  label in1   "Volt1_5"</para>
<para>  label in2   "Volt3_3"</para>
<para>  label in3   "Volt5"</para>
<para>  label in4   "Volt12"</para>
<para># Temperature inputs</para>
<para>  label temp1  "TempCPU"</para>
<para>  label temp2  "TempMB1"</para>
<para>  label temp3  "TempMB2"</para>
<para># Fan inputs</para>
<para>  label fan1   "FanCPU"</para>
<para>  label fan2   "FanSys1"</para>
<para>  label fan3   "FanSys2"</para>
<para>  label fan4   "FanSys3"</para>
<para># PWM Outputs</para>
<para>  label pwm1   "CPUF_PWM"</para>
<para>  label pwm2   "SysF1_PWM"</para>
<para>  label pwm3   "SysF2_PWM"</para>
<para>...</para>
<para/>
<para>Теперь выполним команду sensors, и если у нас все получилось, то увидим примерно следующее: </para>
<para># sensors</para>
<para>lm85b-i2c-0-2e </para>
<para>Adapter: SMBus I801 adapter at c800 </para>
<para>VoltA1_5:   +1.48 V  (min =  +1.42 V, max =  +1.58 V)</para>
<para>Volt1_5:    +1.50 V  (min =  +1.45 V, max =  +1.60 V)</para>
<para>Volt3_3:    +3.33 V  (min =  +3.13 V, max =  +3.47 V)</para>
<para>Volt5:     +5.10 V  (min =  +4.74 V, max =  +5.26 V)</para>
<para>Volt12:   +12.31 V  (min = +11.38 V, max = +12.62 V)</para>
<para>FanCPU:    3360 RPM  (min = 3000 RPM)</para>
<para>TempCPU:     +36C  (low  =   +10C, high =   +60C)</para>
<para>TempMB1:     +33C  (low  =   +10C, high =   +45C)</para>
<para>TempMB2:     +33C  (low  =   +10C, high =   +45C)</para>
<para>CPUF_PWM:  255</para>
<para>SysF1_PWM: 255</para>
<para>SysF2_PWM:  77</para>
<para>vid:      +1.525 V    (VRM Version  9.1)</para>
<para/>
<para>Если у вас названия напряжений, скорости вентиляторов и температуры не содержат соответственно: "Volt", "Fan", "Temp" - обязательно отредактируйте файл /etc/sensors.conf как показано выше. </para>
<para/></sect4><sect4><title>Мониторинг системных параметров</title>
<para/>
<para>Установка sysstat</para>
<para/>
<para>Загружаем последнюю версию пакета sysstat с сайта http://perso.wanadoo.fr/sebastien.godard/ или ftp://ibiblio.org/pub/Linux/system/status/ </para>
<para>Розархивируем файл sysstat-*.*.*.tar.bz2 в /usr/src </para>
<para>Заходим в созданный каталог и выполняем: </para>
<para># make config                 #Отвечаем на вопросы только 'y' или 'n'</para>
<para># make</para>
<para># make install</para>
<para/>
<para>Теперь из командной строки пробуем: </para>
<para># sar -A 1 1 |grep Average: </para>
<para>Average:       proc/s </para>
<para>Average:         0.00 </para>
<para>Average:      cswch/s </para>
<para>Average:       258.00 </para>
<para>Average:          CPU     %user     %nice   %system   %iowait     %idle </para>
<para>Average:          all      1.90      0.00      0.40      0.00     97.70 </para>
<para>........................................................................</para>
<para>Average:      runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15 </para>
<para>Average:            0        83      0.06      0.15      0.16 </para>
<para/>
<para>Проверка df</para>
<para># df</para>
<para>Filesystem           1K-blocks      Used Available Use% Mounted on</para>
<para>/dev/sda3              2007996    411772   1596224  71% /</para>
<para>/dev/sda1               132206     10981    114399  43% /boot</para>
<para>/dev/sda5               248895      4256    231789   2% /tmp</para>
<para>/dev/sda6              5863496   2556028   3307468  64% /var</para>
<para>/dev/sda7              6843432   5128048   1715384  75% /usr</para>
<para>/dev/sda8              1976492   1048740    827348  56% /home</para>
<para>/dev/sda9              5863496   4479752   1383744  77% /usr/portage/distfiles</para>
<para>none                    254752         0    254752   0% /dev/shm</para>
<para>/usr/portage/distfiles 5863496   4479752   1383744  77% /var/ftp/pub/linux/distfiles</para>
<para>/usr/portage/packages  6843432   5128048   1715384  75% /var/ftp/pub/linux/packages</para>
<para/>
<para>Если Вам выдало: </para>
<para>bash: df: command not found</para>
<para>установите df из пакета coreutils. </para>
<para/></sect4><sect4><title>Мониторинг сети</title>
<para/>
<para>Мониторинг сети основывается на подсчете байт, попадающих в правила сетевых экранов - iptables или ipfw, и поэтому они достаточно гибкие, но является зависимым от конфигурации сетевого экрана.</para>
<para>Если Вы хотите осуществлять мониторинг сети: просмотрите server/etc/show_network.conf (/etc/monitoring/show_network.conf) – это список графиков, которые Вы получите. Он должен отвечать названиям графиков в admin/etc/network (/etc/monitoring/network). </para>
<para/></sect4><sect4><title>Linux iptables</title>
<para/>
<para>Нужно откорректировать server/etc/show_iptables_acc.conf (/etc/monitoring/show_network.conf)</para>
<para>1 колонка – название графика (должна отвечать show_network.conf, но с “in_*.N” или “out_*.N”, где N – некоторый идентификатор, например число)</para>
<para>2 колонка – название таблицы</para>
<para>3 колонка – название цепочки с таблицы</para>
<para>4 колонка – порядковый номер правила с цепочки</para>
<para>Это всё должно отвечать Вашим правилам!</para>
<para>Простые примеры экранов находятся в server/firewall/* и если подходит Вам, можете использовать их.</para>
<para>Проверьте работу /usr/bin/show_iptables.sh. Результат найдёте в /home/monitoring </para>
<para/></sect4><sect4><title>FreeBSD ipfw</title>
<para/>
<para>Для BSD, надо откорректировать server/bin/show_ipf_acc.conf:</para>
<para>1 колонка – название графика</para>
<para>2 колонка – номер правила</para>
<para>3 колонка – порядковый номер правила в ipfw show</para>
<para>Это должно отвечать Вашим правилам!</para>
<para>Проверьте работу /usr/bin/show_ipfw.sh Результат в /home/monitoring </para>
<para/>
<para>Некоторые важные системные настройки</para>
<para/>
<para>Если нет xinetd – установите его. Загляньте в </para>
<para>server/etc/host.allow (/etc/host.allow): </para>
<para># BEGIN allow services for monitoring</para>
<para>show_hdisk.sh:127.0.0.1 # IP ком п'ютера что мониторит</para>
<para>show_sensors.sh:127.0.0.1 # IP ком п'ютера что мониторит</para>
<para>show_info.sh:127.0.0.1 # IP ком п'ютера что мониторит</para>
<para>show_system.sh:127.0.0.1 # IP ком п'ютера что мониторит</para>
<para>show_network.sh:127.0.0.1 # IP ком п'ютера что мониторит</para>
<para># END allow services for monitoring</para>
<para/>
<para>Также некоторые из них вы можете изменить в server/bin/show_* и строки "only_from", "bind" и "disable" в server/xinetd.d/show_* </para>
<para>$ cat server/xinetd.d/show_hdisk</para>
<para># default: on</para>
<para># description: The showdisk server show disk useg on the server.</para>
<para>#       It dont uses authentication !!!!!!!!!!!!!!!.</para>
<para>service df</para>
<para>{</para>
<para>       socket_type             = stream</para>
<para>       wait                    = no</para>
<para>       user                    = monitoring</para>
<para>       bind                    = 127.0.0.1               # IP сетевого интерфейса, на котором мониторят</para>
<para>       server                  = /usr/bin/show_hdisk.sh</para>
<para>       only_from               = 127.0.0.1               # IP комп'ютера, который мониторит</para>
<para>       disable                 = no                      # Вкл./Выкл.</para>
<para>}</para>
<para/>
<para>Откройте доступ к следующим портам: 9045/tcp 9046/tcp 9047/tcp 9048/tcp 9049/tcp с административного компьютера в случае наличия сетевых экранов. Если Вы хотите осуществить установку вручную, пропустите следующий пункт. </para>
<para/>
<para>Автоматическая инсталляция</para>
<para/>
<para>Для автоматической установки отредактируйте следующие строки в monitoringinstall.sh (/usr/sbin/monitoringinstall.sh): </para>
<para># Edit this first:</para>
<para># all command will execute user:</para>
<para>runuser=monitoring</para>
<para>rungroup=monitoring</para>
<para># cron cfg directory</para>
<para>cronpath=/etc/cron.d</para>
<para># init script locations:</para>
<para>crond=/etc/init.d/crond</para>
<para># Edit only for server side:</para>
<para># init script location:</para>
<para>xinetd=/etc/init.d/xinetd</para>
<para># program location:</para>
<para>dfpath=/bin/df</para>
<para>sarpath=/usr/bin/sar</para>
<para>sensorspath=/usr/bin/sensors</para>
<para/>
<para>Теперь с правами суперпользователя выполните: </para>
<para># ./monitoringinstall.sh --server</para>
<para/>
<para>В Gentoo просто: </para>
<para># monitoringinstall.sh --server</para>
<para/>
<para>Вы можете пропустить пункт следующий пункт и перейти к „административной” части системы. </para>
<para/></sect4><sect4><title>Ручная установка</title>
<para/>
<para>Копируем следующие файлы: </para>
<para>cp server/etc/show_iptables_acc.conf /etc/monitoring        #for GNU/Linux</para>
<para>cp server/etc/show_ipfw_acc.conf /etc/monitoring        #for BSD</para>
<para>cp server/etc/show_network.conf /etc/monitoring</para>
<para>cp server/xinetd.d/show_hdisk /etc/xinetd.d/</para>
<para>cp server/xinetd.d/show_network /etc/xinetd.d/</para>
<para>cp server/xinetd.d/show_sensors /etc/xinetd.d/</para>
<para>cp server/xinetd.d/show_system /etc/xinetd.d/</para>
<para>cp server/bin/show_hdisk.sh /usr/bin</para>
<para>cp server/bin/show_iptables.sh /usr/bin                #for GNU/Linux</para>
<para>cp server/bin/show_ipfw.sh /usr/bin                        #for BSD</para>
<para>cp server/bin/show_network.sh /usr/bin</para>
<para>cp server/bin/show_sar.sh /usr/bin</para>
<para>cp server/bin/show_sensors.sh /usr/bin</para>
<para>cp server/bin/show_system.sh /usr/bin</para>
<para/>
<para>Добавим следующие строки к /etc/service: </para>
<para>network                9045/tcp                        # show network info</para>
<para>info                9046/tcp                        # show server info</para>
<para>df                9047/tcp                        # show disk info</para>
<para>sys                9048/tcp                        # show system info</para>
<para>sensors                9049/tcp                        # show sensors info</para>
<para/>
<para>Создадим специального пользователя: </para>
<para>groupadd monitoring</para>
<para>useradd -g monitoring -d /home/monitoring -s /bin/bash -c monitoring monitoring</para>
<para>mkdir /home/monitoring</para>
<para>chmod 700 /home/monitoring</para>
<para>chown -R monitoring:monitoring /home/monitoring</para>
<para/>
<para>В случае использования политик SELinux необходимо также добавить: </para>
<para># cat /etc/security/selinux/src/policy/users</para>
<para>...</para>
<para># BEGIN monitoring selinux:</para>
<para>user monitoring roles user_r;</para>
<para># END monitoring selinux.</para>
<para/>
<para>и дополнительно выполнить: </para>
<para># cd /etc/security/selinux/src/policy</para>
<para># make load</para>
<para/>
<para>Перегрузим xinetd: </para>
<para># /etc/init.d/xinetd restart</para>
<para/>
<para>и добавьте строки в crontab: </para>
<para>*/10 * * * * monitoring /usr/bin/show_iptables.sh        # для GNU/Linux</para>
<para>*/10 * * * * monitoring /usr/bin/show_ipfw.sh                # для BSD</para>
<para>*/1 * * * * monitoring /usr/bin/show_sar.sh</para>
<para/>
<para>Перегрузим crond: </para>
<para># /etc/init.d/crond restart</para>
<para/>
<para>Все вышесказанное нужно сделать на КАЖДОМ сервере, который вы хотите мониторить... </para>
<para/></sect4><sect4><title>"Административная" сторона</title>
<para/>
<para>Для начала убедитесь что все хорошо со стороны серверов</para>
<para/>
<para>Для каждого сервера проверяем доступность необходимых сервисов: </para>
<para># telnet server_name 9045</para>
<para>Trying serverIP...</para>
<para>Connected to serverIP.</para>
<para>Escape character is '^]'.</para>
<para>in_ftp                    0</para>
<para>out_ftp                   0</para>
<para>in_http                    0</para>
<para>out_http                   0</para>
<para>in_other                    249</para>
<para>out_other                   27</para>
<para>Connection closed by foreign host.</para>
<para/>
<para># telnet server_name 9046</para>
<para>Trying serverIP...</para>
<para>Connected to server_name.</para>
<para>Escape character is '^]'.</para>
<para>  Intel(R) Celeron(R) CPU 2.40GHz | 504 Mb</para>
<para>Connection closed by foreign host.</para>
<para/>
<para># telnet server_name 9047</para>
<para>Trying serverIP...</para>
<para>Connected to server_name.</para>
<para>Escape character is '^]'.</para>
<para>/dev/sda3              2007996    411772   1596224  71% /</para>
<para>/dev/sda1               132206     10981    114399  43% /boot</para>
<para>/dev/sda5               248895      4256    231789   2% /tmp</para>
<para>/dev/sda6              5863496   2556028   3307468  64% /var</para>
<para>/dev/sda7              6843432   5128048   1715384  75% /usr</para>
<para>/dev/sda8              1976492   1048740    827348  56% /home</para>
<para>/dev/sda9              5863496   4479752   1383744  77% /usr/portage/distfiles</para>
<para>Connection closed by foreign host.</para>
<para/>
<para># telnet server_name 9048</para>
<para>Trying serverIP...</para>
<para>Connected to server_name.</para>
<para>Escape character is '^]'.</para>
<para>Average:       proc/s</para>
<para>Average:         3.98</para>
<para>Average:      cswch/s</para>
<para>Average:       308.00</para>
<para>Average:          CPU     %user     %nice   %system   %iowait     %idle</para>
<para>Average:          all      1.76      0.00      0.47      0.00     97.76</para>
<para>.............................................................</para>
<para>Average:      runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15</para>
<para>Average:            1        88      0.05      0.21      0.21</para>
<para>Connection closed by foreign host.</para>
<para/>
<para># telnet server_name 9049</para>
<para>Trying serverIP...</para>
<para>Connected to server_name.</para>
<para>Escape character is '^]'.</para>
<para>lm85b-i2c-0-2e</para>
<para>Adapter: SMBus I801 adapter at c800</para>
<para/>
<para>Volt1_5:    +1.48 V  (min =  +1.42 V, max =  +1.58 V)</para>
<para>VoltCore:   +1.50 V  (min =  +1.45 V, max =  +1.60 V)</para>
<para>Volt3_3:    +3.33 V  (min =  +3.13 V, max =  +3.47 V)</para>
<para>Volt5:     +5.10 V  (min =  +4.74 V, max =  +5.26 V)</para>
<para>Volt12:   +12.25 V  (min = +11.38 V, max = +12.62 V)</para>
<para>CPU_Fan:   3377 RPM  (min = 3000 RPM)</para>
<para>fan2:         0 RPM  (min =    0 RPM)</para>
<para>fan3:         0 RPM  (min =    0 RPM)</para>
<para>fan4:         0 RPM  (min =    0 RPM)</para>
<para>TempCPU:     +32 C  (low  =   +10 C, high =   +50 C)</para>
<para>TempBoard:   +30 C  (low  =   +10 C, high =   +45 C)</para>
<para>TempRemot:   +30 C  (low  =   +10 C, high =   +40 C)</para>
<para>CPU_PWM:   255</para>
<para>Fan2_PWM:  255</para>
<para>Fan3_PWM:   77</para>
<para>vid:      +1.525 V  (VRM Version 9.0)</para>
<para/>
<para>Connection closed by foreign host.</para>
<para/>
<para/>
<para/></sect4><sect4><title>Установление необходимых программ</title>
<para/>
<para>Разархивируйте monitoring-*.tar.bz2.</para>
<para/>
<para>Для Gentoo есть ебилд, для установления программы monitoring со всеми зависимостями с сайта стоит брать monitoring-*.ebuild.tar.bz2 и распаковать его в /usr/local дальше выполните: </para>
<para># emerge -pv monitoring</para>
<para>[ebuild N ] net-analyzer/monitoring-0.11 USE="-admin -apache2 -lm_sensors -server"</para>
<para/>
<para>Для административной стороны необходимо добавить USE=admin, а для поддержки apache-2* USE=apache2 </para>
<para># export "USE=admin apache2"</para>
<para># emerge monitoring</para>
<para/>
<para>Компиляцию и установление rrdtool, apache, Net-Telnet в случае использования Gentoo можно пропускать, потому что эти пакеты уже будут установлены как зависимости, а переходить сразу к их настройке. </para>
<para/></sect4><sect4><title>Инсталляция rrdtool</title>
<para/>
<para>Базой данных, для хранения информации и инструмент генерации графиков, используется пакет rrdtool (round robin database tool). Зкачать пакет можно отсюда: http://rrdtool.eu.org или http://people.ee.ethz.ch/~oetiker/webtools/rrdtool/ Подробно ознакомиться с этим пакетом можно здесь: http://www.bog.pp.ru/work/rrdtool.html (Российская). В принципе, программа самостоятельно создаст необходимые базы так, что дополнительных знаний не нужно и следующий пункт Пример расчёта настройки базы RRD можно пропустить. </para>
<para/>
<para>Пример расчёта настройки базы RRD</para>
<para/>
<para>Расчёт настроек создания базы RRD файлы /etc/monitoring/*.rrd.cf Количество "слов" в файле будет соотведствовать количеству графиков в разных маштабах времени. например для расчёта подобия MRTG: 5-ти минутный - даные за последние 2 дня: х-доля=0.5 количество отсчётов на ячейку=1 количество ячеек=2*24*12=576 +min+max+avg+cur ~ 650 </para>
<para>0.5:1:650</para>
<para/>
<para>30-ти минутный - дание за последние две недели: х-доля=0.5 количество отсчётов на ячейку=30/5=6 количество ячеек=2*7*24*2=672 +min+max+avg+cur ~ 750 </para>
<para>0.5:6:750</para>
<para/>
<para>2-ух часовой - даные за последние два месяца: х-доля=0.5 количество отсчётов на ячейку=60*2/5=24 количество ячеек=2*31*24/2=744 +min+max+avg+cur ~ 850 </para>
<para>0.5:24:850</para>
<para/>
<para>1-но дневный - даные за последние два года: х-доля=0.5 количество отсчётов на ячейку=60*24/5=288 количество ячеек=2*366=732 +min+max+avg+cur ~ 900 </para>
<para>0.5:288:900</para>
<para/>
<para>Таким образом имеем: </para>
<para># cat /etc/monitoring/5min.rrd.cf</para>
<para>0.5:1:650        0.5:6:750        0.5:24:850        0.5:288:900</para>
<para/></sect4><sect4><title>Инсталляция Net-Telnet</title>
<para/>
<para>Данная версия программы для работы через сеть требует Net-Telnet perl модуль (можно при желании использовать и netcat): из-за этого нужно установить perl (что пожалуй уже сделано). Дальше Net-Telnet perl модуль берем и устанавливаем отсюда: http://cpan.perl.org/modules/by-module/Net/ название файлу Net-Telnet-*.tar.gz </para>
<para/></sect4><sect4><title>Инсталляция Apache</title>
<para/>
<para>Нужно установить и настроить apache сервер, дополнительно можете добавить (admin/etc/apache/monitoring.conf): </para>
<para># cat /etc/apache2/vhosts.d/monitoring.conf</para>
<para>### /etc/apache2/vhosts.d/monitoring.conf</para>
<para>### $Id: monitoring.conf,v 0.11 2006/09/28 16:27:12 hse Exp $</para>
<para>###</para>
<para>### For Monitoring *.shtml</para>
<para>AddType text/html .shtml</para>
<para>AddOutputFilter INCLUDES .shtml</para>
<para>### For authentication:</para>
<para>&lt;Directory "/var/www/localhost/htdocs/administration/monitoring"&gt;</para>
<para>   AllowOverride All</para>
<para>   Options Includes</para>
<para>   &lt;IfModule mod_access.c&gt;</para>
<para>### For password authentication:</para>
<para>#       AuthUserFile /var/www/localhost/htdocs/administration/passwd_file</para>
<para>#       AuthGroupFile /dev/null</para>
<para>#       AuthName Administrative-information</para>
<para>#       AuthType Basic</para>
<para>#       Require valid-user</para>
<para>### For host/network authentication:</para>
<para>        Order deny,allow</para>
<para>        Deny from all</para>
<para>        Allow from 127.0.0.1</para>
<para>#        Allow from .cluster.linux</para>
<para>    &lt;/IfModule&gt;</para>
<para>&lt;/Directory&gt;</para>
<para/>
<para>Добавляем пользователя для просмотра веб страницы: </para>
<para># htpasswd -bcm /var/www/localhost/htdocs/administration/passwd_file username password</para>
<para/>
<para>Если все хорошо идем дальше. </para>
<para/></sect4><sect4><title>Установка программ для мониторинга</title>
<para/>
<para>В файл admin/etc/host (/etc/monitoring/host) вносим перечень серверов, которые нужно мониторить (имена должны разрешаться в IP адреса). Коректируем под свои потребности файл admin/etc/monitoring.conf (/etc/monitoring/monitoring.conf) </para>
<para>путь по которому установлено скрипт:</para>
<para>installpath=/usr/</para>
<para>путь к веб страницы:</para>
<para>apachehtmldir=/var/www/html</para>
<para>webdirpath=/administration/monitoring</para>
<para>путь к файлу с перечнем серверов для мониторинга:</para>
<para>confpath=$installpath/etc/host</para>
<para>путь к временных файлов:</para>
<para>diskinfopath=/tmp/monitoring/disk.tmp</para>
<para>sarinfopath=/tmp/monitoring/sar.tmp</para>
<para>sensorsinfopath=/tmp/monitoring/sensors.tmp</para>
<para>путь где установлен пакет rrdtool:</para>
<para>rrdtoolpath=/usr/bin/rrdtool</para>
<para>почтовый адресов:</para>
<para>emailvalue=root@localhost</para>
<para>По желанию (или за потребностью) правим другие файлы с каталога etc/ (/etc/monitoring/):</para>
<para/>
<para>diskusage memusage quantity cpu memory systemload - содержимое файлов должно отвечать тем параметрам которые Вы хотите мониторить. Все параметры должны выводиться командой sar -A 1 1 |grep Average: Названия файлов отвечают названиям графиков и баз которые создадутся и должны быть записаны в файле system. Значение параметров принадлежащих одном файлу должны быть одного типа!</para>
<para/>
<para>system - первая колонка определяет какие графики получите и каждый ее элемент отвечать файлу из этого же каталога (см. выше). Вторая указывает через какие периоды времени база rrdtool будет принимать данные. Третья и четвертая колонка определяет минимальное и максимальное значение параметра которое еще может быть записано в базу. Пятая колонка определяет легенду (размерность).</para>
<para/>
<para>сolors - файл с номерами цветов в 16-ричной системе.</para>
<para> </para>
<para>config - содержит имена конфигурационных файлов из этого же каталога отвечающие веб страницам что создаються (можно добавлять свои, но тогда их должны создать!).</para>
<para/>
<para>disk - содержит названия графиков, периоды времени через которые база rrdtool будет принимать данные, минимальные и максимальные значение параметров которые мониторите, легенду (размерность).</para>
<para/>
<para>network - содержит названия графиков, периоды времени через которые база rrdtool будет принимать данные, минимальные и максимальные значение параметров которые мониторите, легенду (размерность).</para>
<para/>
<para>sensors - содержит названия графиков, периоды времени через которые база rrdtool будет принимать данные, минимальные и максимальные значение параметров которые мониторите, легенду (размерность).</para>
<para/>
<para>disk.rrd.cf network.rrd.cf sensors.rrd.cf system.rrd.cf - описывают структуру базы данных.</para>
<para/>
<para>disk.msg network.msg sensors.msg system.msg - содержит информацию которую получите почтой в критических ситуациях.</para>
<para/>
<para>Если хотите осуществить установку вручную, пропустите следующий пункт. </para>
<para/></sect4><sect4><title>Автоматическая установка программ</title>
<para/>
<para>Теперь можете воспользоваться скриптом для инсталляции. Для этого нужно откорректировать следующие строки в файле monitoringinstall.sh (/usr/sbin/monitoringinstall.sh) или пропустить этот пункт и следовать дальнейшей инструкции для установки в ручную. </para>
<para>имя пользователя и группы:</para>
<para>runuser=monitoring</para>
<para>rungroup=monitoring</para>
<para>директория где расположены cron настройки:</para>
<para>cronpath=/etc/cron.d</para>
<para>путь к инициализационному скрипту</para>
<para>crond crond=/etc/init.d/crond</para>
<para>директория где находятся настройки apache</para>
<para>apachconfdir=/etc/apache/conf</para>
<para>файл конфигурации apache:</para>
<para>apachconffile=apache.conf</para>
<para>путь к инициализационному скрипту apache</para>
<para>apached=/etc/init.d/apache</para>
<para/>
<para>Теперь с правами рута выполните (нужно подождать 1 минуту, если не установили мониторинг сети, и 10 минут после установки мониторынга сети на последнем сервере, прежде чем выполнять следующую команду): </para>
<para># ./monitoringinstall.sh --admin</para>
<para/>
<para>В Gentoo просто </para>
<para># monitoringinstall.sh --admin</para>
<para/>
<para>Если видите ошибки, наверное надо:</para>
<para>1 поправить файлы конфигурации в admin/etc/ (/etc/monitoring)</para>
<para>2 посмотреть в /home/monitoring/hostname/err/...</para>
<para>3 удалить файлы с /home/monitoring/hostname/ и перезапустити скрипт</para>
<para>4 удалить базы данных с /var/db/monitoring/... и перезапустити скрипт</para>
<para>5 bin/net_telnet.pl читает только 500 строк входа. Если в Вас больше, отредактируйте його:</para>
<para>line 32: while [$и ne 500]</para>
<para/>
<para>Тогда попробуйте еще, но добавьте имена сервисов, под рутом выполните: </para>
<para># ./monitoringinstall.sh --admin=disk</para>
<para># ./monitoringinstall.sh --admin=sensors</para>
<para># ./monitoringinstall.sh --admin=system</para>
<para># ./monitoringinstall.sh --admin=network</para>
<para/>
<para>Если где-то допустили ошибку, можно просто выполнить monitoringuninstall.sh и попытаться еще раз. Можете пропустить следующий пункт. </para>
<para/></sect4><sect4><title>Ручная установка программ</title>
<para/>
<para>Устанавливаем скрипти для мониторинга, генерации базы данных и веб страницы скопировав с каталога monitoring/admin в каталог: /usr/ ($INSTALL_PATH), используя опцию –p для сохранения прав. Выполняем: </para>
<para># cp -p admin/bin/* $INSTALL_PATH/bin/</para>
<para># mkdir /etc/monitoring</para>
<para># cp -p admin/etc/* /etc/monitoring/</para>
<para># mkdir $INSTALL_PATH/share/monitoring</para>
<para># cp -p admin/share/* $INSTALL_PATH/share/monitoring/</para>
<para/>
<para># mkdir -p /var/www/localhost/htdocs/administration/monitoring</para>
<para># chmod 755 /var/www/localhost/htdocs/administration/monitoring/</para>
<para># groupadd -g 1111 monitoring</para>
<para># useradd -u 1111 -g monitoring -d /home/monitoring -s /bin/bash -c monitoring monitoring</para>
<para># chmod -R 700 /home/monitoring</para>
<para># chown -R monitoring:monitoring /home/monitoring</para>
<para># chown -R monitoring:monitoring /var/www/localhost/htdocs/administration/monitoring/</para>
<para/>
<para>И тогда выполняйте (подождите 1 минуту, если не устанавливали мониторинг сети, и 10 минут после установки мониторынга сети на последнем сервере, прежде чем выполнять следующую команду): </para>
<para># su monitoring</para>
<para>$ $INSTALL_PATH/bin/net.vert.1.sh</para>
<para>$ $INSTALL_PATH/bin/net.vert.10.sh</para>
<para/>
<para>создаются базы данных в каталоге /var/db/monitoring/имя_сервера/ для всех серверов с файлу /etc/monitoring/host и дополнительная конфигурация в /home/monitoring</para>
<para>Выполняем: </para>
<para>$ $INSTALL_PATH/bin/png_graph.sh disk -1week 30min</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh disk -1month 2hour</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh disk -1year 1day</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh network -1week 30min</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh network -1month 2hour</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh network -1year 1day</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh sensors -2day 5min</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh sensors -1week 30min</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh sensors -1month 2hour</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh sensors -1year 1day</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh system -2day 5min</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh system -1week 30min</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh system -1month 2hour</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh system -1year 1day</para>
<para/>
<para>Если видите ошибки, наверное нужно:</para>
<para>1 поправить файлы конфигурации в /etc/monitoring</para>
<para>2 посмотреть в /home/monitoring/hostname/err/...</para>
<para>3 удалить файлы с /home/monitoring/hostname/ и перезапустить скрипт</para>
<para>4 удалить базы данных с /var/db/monitoring/... и перезапустить скрипт</para>
<para>5 bin/net_telnet.pl читает только 500 строк входа. Если в Вас больше, отредактируйте его:</para>
<para>line 32: while [$и ne 500]</para>
<para/>
<para>Тогда попробуйте еще раз.</para>
<para/>
<para>В каталоге /var/www/localhost/htdocs/administration/monitoring создаются начальная страница и каталоги с веб страницами для каждого сервера.</para>
<para/>
<para>Если не возникло больше ошибок, используйте следующий файл для автоматизации всей работы с crond: </para>
<para>$ exit</para>
<para># cat /etc/cron.d/monitoring</para>
<para/>
<para>SHELL=/bin/bash</para>
<para>PATH=/bin:/usr/bin</para>
<para>MAILTO=root</para>
<para>HOME=/home/monitoring</para>
<para>LANG=POSIX</para>
<para/>
<para># Begin server part (may be you wont monitoring "admin" computer too)</para>
<para>*/1 * * * * monitoring /usr/bin/show_sar.sh</para>
<para>*/10 * * * * monitoring /usr/bin/show_iptables.sh        #GNU/Linux</para>
<para>#*/10 * * * * monitoring /usr/bin/show_ipfw.sh                #BSD</para>
<para># End server part</para>
<para/>
<para># Begin disk admin part</para>
<para>*/30 * * * * monitoring /usr/bin/png_graph.sh hdisk -1week 30min</para>
<para>0 */2 * * * monitoring /usr/bin/png_graph.sh hdisk -1month 2hour</para>
<para>0 0 * * * monitoring /usr/bin/png_graph.sh hdisk -1year 1day</para>
<para># End  disk admin part</para>
<para/>
<para># Begin network admin part</para>
<para>*/30 * * * * monitoring /usr/bin/png_graph.sh network -1week 30min</para>
<para>0 */2 * * * monitoring /usr/bin/png_graph.sh network -1month 2hour</para>
<para>0 0 * * * monitoring /usr/bin/png_graph.sh network -1year 1day</para>
<para># End  network admin part</para>
<para/>
<para># Begin system admin part</para>
<para>*/5 * * * * monitoring /usr/bin/png_graph.sh system -2day 5min</para>
<para>*/30 * * * * monitoring /usr/bin/png_graph.sh system -1week 30min</para>
<para>0 */2 * * * monitoring /usr/bin/png_graph.sh system -1month 2hour</para>
<para>0 0 * * * monitoring /usr/bin/png_graph.sh system -1year 1day</para>
<para># End system admin part</para>
<para/>
<para># Begin sensors admin part</para>
<para>*/5 * * * * monitoring /usr/bin/png_graph.sh sensors -2day 5min</para>
<para>*/30 * * * * monitoring /usr/bin/png_graph.sh sensors -1week 30min</para>
<para>0 */2 * * * monitoring /usr/bin/png_graph.sh sensors -1month 2hour</para>
<para>0 0 * * * monitoring /usr/bin/png_graph.sh sensors -1year 1day</para>
<para># End sensors admin part</para>
<para/>
<para># Begin vert admin part</para>
<para>*/1 * * * * monitoring /usr/bin/net.vert.1.sh</para>
<para>*/10 * * * * monitoring /usr/bin/net.vert.10.sh</para>
<para># End  vert admin part</para>
<para/>
<para>Выполняем: </para>
<para># /etc/init.d/crond restart</para>
<para/>
<para/>
<para/>
<para>Если все хорошо</para>
<para/>
<para>Теперь заходим Вашим любимым браузером на страницу http://servername/administration/monitoring/index.html. Здесь уже можем выбрать ссылки на сервер, который вас интересует :) </para>
<para/></sect4><sect4><title>Добавление новых серверов</title>
<para/>
<para>Если Вам когда-то придется добавить новый сервер, достаточно будет сделать следующее:</para>
<para>1. Выполнить для него пункт 2 („Серверная” сторона)</para>
<para>2. Добавить его имя в файл /etc/monitoring/host</para>
<para>Всё остальное создастся само !!! Наслаждайтесь :))) </para>
<para/></sect4><sect4><title>Альтернативы</title>
<para/>
<para>Если Вы недовольны реализацией мониторинга таким образом (по моему мнению достаточно неплохое решение ;)) подберите себе лучшую. Вот некоторый перечень альтернатив или дополнений :=) </para>
<para>Angel Network Monitor http://www.paganini.net/angel/ </para>
<para>Autostatus http://www.angio.net/consult/autostatus/ </para>
<para>Cacti http://cacti.net </para>
<para>HiWAyS http://www.hiways.org/ </para>
<para>MARS http://www.altara.org/mars.html </para>
<para>Mon http://www.kernel.org/software/mon/ </para>
<para>Monit http://www.tildeslash.com/monit/ </para>
<para>Nagios http://www.nagios.org </para>
<para>Netup (French) http://www.pasteur.fr/units/sis/netup/ </para>
<para>NocMonitor http://www2.discpro.org/nocmon/ </para>
<para>NodeWatch http://www.skendric.com/nodewatch/ </para>
<para>Penemo http://www.communityprojects.org/apps/penemo/ </para>
<para>PIKT http://pikt.org/ </para>
<para>RITW http://www.terravista.pt/Ancora/1883/ritw_e.html </para>
<para>RRDWorld http://oss.oetiker.ch/rrdtool/rrdworld/index.en.html </para>
<para>Scotty http://wwwhome.cs.utwente.nl/~schoenw/scotty/ </para>
<para>Spong http://spong.sourceforge.net/ </para>
<para>Sysmon http://www.sysmon.org/ </para>
<para>ZABBIX http://www.zabbix.com </para>
<para>ZEUS http://www.zeus.com/ </para>
<para/></sect4></sect3></sect2><sect2><title>Настройка X</title>
<para/><sect3><title>Настройка русских шрифтов в X</title>
<para/><sect4><title>Введение </title>
<para/>
<para>Введение временное </para>
<para/>
<para>Ну вот и начался этот проект, призванный восполнить достаточно широкий пробел в документации по настройке шрифтов в Иксах. Надеюсь многочисленные русские пользователи проявят некую сознательность и отпишут сюда пару строчек. </para>
<para/>
<para>Кто принимает участие </para>
<para>Macil - линуксоид из Ярославля. Обитает на yar.lancktelecom.ru/talk, forum.median.ru, а также Macil [at] jabber.ru </para>
<para>Wanderer - пользователь Linux из Москвы. Всерьез занимаюсь изучением и использоваением Linux последние 4 года, до этого просто приглядывался ;-). На Gentoo пересел почти год назад и ничуть не жалею и даже наоборот, очень этим доволен. Связаться со мной можно посредством e-mail (wanderer_mg [at] mail.ru) или jabber (wanderer [at] jabber.ru). </para>
<para/></sect4><sect4><title>Две системы рисования шрифтов </title></sect4><sect4><title/>
<para>Исторически в X Window System существует 2 системы рисования шрифтов. Родная (core) и Xft. </para>
<para>Родная система – прямой потомок системы рисования шрифтов, введенной в X11R1, выпущенной в 1987 году. Изначально она могла рисовать только монохромные растровые шрифты, но на протяжении всех этих лет предпринимались более-менее успешные попытки заставить ее работать с векторными шрифтами. </para>
<para>Xft не является неотъемлемой частью X, хотя возможно будет ей в будущем. Это значит, что она распространяется не со всеми реализациями X. Она проектировалась для работы с векторными шрифтами, и делает это достаточно эффективно. В отличие от родной системы рисования, Xft поддерживает anti-aliasing и sub-pixel rasterisation. Кроме того, она позволяет приложениям полностью контролировать то, как будут рисоваться шрифты, обеспечивая возможность создания WYSIWYG приложений. </para>
<para/>
<para>Нужно ли уточнять что эти две подсистемы совершенно не совместимы на уровне API? Из-за достаточно анархичного развития X в последнее время, возникла большая путаница в определениях и версиях используемых библиотек. </para>
<para/>
<para>//Источник: вольный перевод файла README.fonts </para>
<para/></sect4><sect4><title>Хft </title>
<para/>
<para>Введение в Xft </para>
<para/>
<para>Xft это библиотека, которая предоставляет клиентский API для рисования шрифтов. В настоящее время версия Xft 2.0 использует библиотеки fontconfig и freetype для выбора шрифтов и их рисования, соответственно. Xft 1.0 использовала внутренний механизм конфигурации, что было не очень хорошей идеей так как KDE и Pango "заимствовали" механизм конфигурации шрифтов и создали еще большую путаницу. Подробности можно посмотреть [здесь]. </para>
<para/>
<para>Нужно запомнить 3 вещи: </para>
<para>fontconfig - для конфигурации </para>
<para>freetype - для рисования </para>
<para>XFT - связывает все во едино </para>
<para/>
<para>Freetype - библиотека рисования шрифтов </para>
<para/>
<para>[Freetype] - совершенно независимый от кого-либо проект по созданию библиотеки рисования шрифтов. Библиотека предоставляет достаточно простой API, но поскольку обычные приложения заинтересованы в более высокоуровневых сервисах, в чистом виде не используется. Вместе с X идет модифицированная freetype, предназначенная для поддержки векторных шрифтов родной системой рисования. Я не вижу смысла даже пытаться ее компилировать (она компилируется в модуль freetype), так как большинство приложений перешли на использование Xft и путанице со шрифтами приходит конец. Рендеринг векторных шрифтов очень сложный процесс, и к сожалению, freetype не может его выполнять до конца и в некоторых шрифтах появляются не очень приятные артефакты. Но ничего лучшего (открытого и бесплатного) пока нет... Как обычно, существует 2 версии freetype: freetype1 и freetype2. Отличия их в том, что freetype1 может рисовать тоько шрифты формата TrueType. Сложно найти современный дистрибутив, где отсутствует freetype2. </para>
<para/></sect4><sect4><title>Теория рендеринга векторных шрифтов </title>
<para/>
<para>Что такое hinting </para>
<para/>
<para>На английском много информации о hinting можно найти тут http://www.myfonts.com/activity/hinting/ </para>
<para/>
<para>Не уверен, однако, что можно тут публиковать такие ссылки. </para>
<para>Это — незавершённая статья. Вы можете помочь проекту, исправив и дополнив материал.</para>
<para/>
<para>Что такое anti-aliasing </para>
<para/>
<para>Это методы избавления от артефактов, возникающих при отрисовке векторного изображения в растовое. Когда вектороное изображение (не дискретное, к примеру, формула y=2*x) отрисовывается в растовое, то в результате погрешностей и того, что цвет каждого пискселя строго зависит от формулы, возникают артефакты. То есть наклонную линию мы будем видеть ступенчато, а не плавно. Методы anti-aliasing, в основном, базируются на отрисовке изображения в большее разрешение и приведение к обычному путём билинейной фильтрации, т.е. цвет пикселя будет строиться из цветов нескольких пикселей большого изображения. Шрифты после применения anti-aliasing выглядят более гладко, т.к. более точно соответствуют "векторной формуле". </para>
<para>Это — незавершённая статья. Вы можете помочь проекту, исправив и дополнив материал.</para>
<para/>
<para>Шрифты из Microsoft Windows </para>
<para/>
<para/>
<para>Установка шрифтов Microsoft Windows имея доступ в интернет </para>
<para/>
<para>Если есть доступ к интернету, то можно просто установить пакет corefonts: emerge corefonts </para>
<para/></sect4><sect4><title>Настройка родной подсистемы </title>
<para/>
<para>Настройка Xft </para>
<para/>
<para>Все настройки Xft хранятся в файлах /etc/fonts/fonts.conf и /etc/fonts/local.conf. Все изменения нужно производить в файле /etc/fonts/local.conf. Изменение файла /etc/fonts/fonts.conf не рекомендуется, т.к. при обновлении пакета fontconfig он будет перезаписан и все настройки потеряны. </para>
<para/>
<para>Отключение сглаживания для шрифтов меньше определенного размера </para>
<para/>
<para>По умолчанию сглаживание действует для всех шрифтов, но для шрифтов маленького размера его лучше отключить, т.к. смотрится это почти всегда плохо. </para>
<para/>
<para>Ниже приведен пример конфига /etc/fonts/local.conf, в котором указана отмена сглаживания для шрифтов, размер которых меньше 14. Code: /etc/fonts/local.conf </para>
<para>&lt;?xml version="1.0"?&gt;</para>
<para>&lt;!DOCTYPE fontconfig SYSTEM "fonts.dtd"&gt;</para>
<para>&lt;!-- /etc/fonts/local.conf file for local customizations --&gt;</para>
<para>&lt;fontconfig&gt;</para>
<para/>
<para>&lt;!--  Enable sub-pixel rendering  --&gt;</para>
<para/>
<para>        &lt;match target="font"&gt;</para>
<para>                &lt;edit name="rgba" mode="assign"&gt;&lt;const&gt;rgb&lt;/const&gt;&lt;/edit&gt;</para>
<para>        &lt;/match&gt;</para>
<para>        &lt;match target="font"&gt;</para>
<para>            &lt;test name="size" compare="less_eq"&gt;</para>
<para>                &lt;double&gt;14&lt;/double&gt;</para>
<para>            &lt;/test&gt;</para>
<para>            &lt;edit name="antialias" mode="assign"&gt;</para>
<para>                &lt;bool&gt;false&lt;/bool&gt;</para>
<para>            &lt;/edit&gt;</para>
<para>        &lt;/match&gt;</para>
<para>        &lt;match target="font"&gt;</para>
<para>            &lt;test name="pixelsize" compare="less_eq"&gt;</para>
<para>                &lt;double&gt;14&lt;/double&gt;</para>
<para>            &lt;/test&gt;</para>
<para>            &lt;edit name="antialias" mode="assign"&gt;</para>
<para>                &lt;bool&gt;false&lt;/bool&gt;</para>
<para>            &lt;/edit&gt;</para>
<para>        &lt;/match&gt;</para>
<para/>
<para>&lt;/fontconfig&gt;</para>
<para/></sect4><sect4><title>Настройка Qt и Gtk </title>
<para/>
<para>Для Qt</para>
<para>emerge qt qtconfig </para>
<para/>
<para>Для Gtk</para>
<para>emerge gtk-theme-switch switch2 </para>
<para/>
<para/></sect4></sect3><sect3><title>Настройка размера шрифтов в X</title>
<para/><sect4><title>Введение </title>
<para>Столкнулся с проблемой (и не я один) размера шрифтов. </para>
<para/>
<para>Процесс сталкивания выглядел так: </para>
<para>~ $ emerge xorg-x11</para>
<para>...</para>
<para>~ $ emerge kde</para>
<para>...</para>
<para>startx</para>
<para/>
<para>Попал я, естессна сразу в KDE. И увидел очень мелкие шрифты, очень мелкие, похожие на точечки. Примерно такие:</para>
<para>Естессна, первое, что я сделал - полез в центр управления и установил размер, соответствующий моему зрению. Им оказался 40. Немало. Тогда я понял, что что-то неправильно. Порылся в инете, не нашел ничего. Смирился. Однако вскоре узнал, что та же проблема у меня и в KDM, только там изменить размер немного сложнее. Изменил. Но проблему это не решило, потому что нашлись еще всякие шибко умные проги, которые пользовались собственными настройками шрифтов. Их (настройки) искать оказалось очень сложно и пришлось брать быка за рога. Итак, </para></sect4><sect4><title>Суть проблемы </title>
<para/>
<para>Она состоит в том, что шрифты ориентированы на определенное физическое разрешение экрана - dpi (точек на дюйм). В винде по дефолту оно идет равным 96. X11 решил, что это слишком сложно не знаю для кого и, как выяснилось позже, выставил себе аж целых 25 dots per inch. В переводе в метрическую систему это около 1 точки на миллиметр. Соответсвенно, экран разрешением 1024х768 должен быть шириной в метр, высотой 77 см, чтоб читалось все как надо. Ну а поскольку реально экран у нас меньше, мы видели то, что мы видели. </para>
<para/></sect4><sect4><title>Неправильный ход мысли </title>
<para/>
<para>но полезный совет. Увеличть размер шрифта для KDM можно в этом файле: </para>
<para>/usr/kde/3.5/share/config/kdm/kdmrc</para>
<para>Но это не выход, как я уже говорил. Кстати, GDM настраивается в другом файле, его я не знаю, потому что пришел к следующему пункту: </para>
<para/></sect4><sect4><title>Правильный ход мысли </title>
<para>Надо изменить разрешение, те самые dpi. Где? Как? </para>
<para/>
<para>Меняем dpi </para>
<para/>
<para>Тут, кстати, возможны варианты. Если Вы запускаете иксы из консоли по мере необходимости командой startx, то Вам сюда. Если иксы стартуют сами при загрузке системы - то сюда. В идеале стоит проделать оба варианта. </para>
<para/>
<para>Для команды startx </para>
<para/>
<para>Лезем туда, где этот стартикс лежит и правим его </para>
<para>~ $ find /usr -name startx</para>
<para/>
<para>У меня он оказался в /usr/bin, и с вероятностью 99,(9)% там же он будет и у Вас. </para>
<para>Вписать в него надо всего ничего параметр -dpi 96 в ключ defaultserverargs </para>
<para>defaultserverargs="-dpi 96"</para>
<para/>
<para>Те параметры, которые там есть не удаляйте, у них свое назначение, этот просто допишите к ним.</para>
<para>В принципе, на этом все. Можно </para>
<para>~ $ startx</para>
<para/>
<para>Жизнь удалась. </para>
<para/>
<para>Для пользователей KDM, XDM и тому подобного </para>
<para/>
<para>Вооружитесь калькулятором. В файле xorg.conf Вам надо изменить параметр DisplaySize. По умолчанию, он устанавливается равным разрешению (помните, я говорил в начале статьи), но ваш-то монитор меньше. Можно померять линейкой, можно посчитать, какие значения ему присвоить: </para>
<para>X = x * 25,4 / dpi</para>
<para>Y = y * 25,4 / dpi</para>
<para>где X, Y - значения, которые надо присвоить DisplaySize </para>
<para>x, y - разрешение монитора (x - ширина, y - высота) </para>
<para>dpi - то физическое разрешение, которое должно получиться </para>
<para/>
<para>У меня при разрешении 1024x768 получилось так: </para>
<para>~ $ vi /etc/X11/xorg.conf</para>
<para/>
<para>Section "Monitor"</para>
<para>       Identifier   "Monitor0"</para>
<para>       VendorName   "HSD"</para>
<para>       ModelName    "HSD150PX17-A"</para>
<para>       DisplaySize  270.9 203.2 # mm</para>
<para>EndSection</para>
<para/>
<para>Вывод </para>
<para>Ерунда какая, ничего сложного, если сразу заглянуть в xorg.conf и почитать комментарии, то этого можно избежать. Но я не избежал и, кстати, долго с этим мучился. </para>
<para/>
<para>Вывод-то в чем: будьте внимательнее! </para>
<para/>
<para>P.S. </para>
<para>В Gnome есть такая настроечка, как dpi, сам не видел, но знающие люди говорят, что есть и рекомендуют ее тоже выставить на 96 или то, которое принято везде.</para>
<para/>
<para/></sect4></sect3><sect3><title>Xorg X11 и прозрачность</title>
<para/><sect4><title>Введение</title>
<para/>
<para>Это руководство поможет в установке X.org на Linux/Gentoo машине, хотя общие настройки должны работать и на любом другом дистрибутиве. </para>
<para/>
<para>Шаг за шагом</para>
<para/></sect4><sect4><title>Установка X.org</title>
<para/>
<para>Установите последнюю версию X.org с помощью команды emerge xorg-x11 </para>
<para/>
<para>После компиляции необходимо настроить X.org путем редактирования /etc/X11/xorg.conf </para>
<para>Если у вас было установленно XFree86 то рабочий /etc/X11/XF86Config будет автоматически использоватся для работы X.org. Для обеспечения целостности рекомендуется переименовать /etc/X11/XF86Config в /etc/X11/xorg.conf. </para>
<para/>
<para>Для загрузки X.org выполните команду startx </para>
<para/></sect4><sect4><title>Установка X Composite Extension</title>
<para/>
<para>Откройте /etc/X11/xorg.conf для редактирования nano -w /etc/X11/xorg.conf пользуйте ваш любимый редактор ;) </para>
<para/>
<para>Добавьте следующие строки в любом месте конфиг файла Файл: /etc/X11/xorg.conf </para>
<para>Section "Extensions"</para>
<para>    Option "Composite" "Enable"</para>
<para>    Option "RENDER" "Enable"</para>
<para>EndSection</para>
<para/>
<para>При следующей перезагрузке X.org у вас будет включен Composite Extension. Это расширение включает предварительную отрисовку вне экрана, чтобы на экран выводилось уже законченное изображение. Это позволяет использовать различные эффекты (например прозарчность и тени). </para>
<para/>
<para>Для достоверности можно проверить лог файл grep COMPOSITE /var/log/Xorg.0.log </para>
<para>(II) Initializing built-in extension COMPOSITE</para>
<para/>
<para>Включение теней и настоящей прозрачности</para>
<para/></sect4><sect4><title>KDE 3.4 или более поздняя</title>
<para/>
<para>Начиная с версии 3.4 KDE поддерживает прозрачность через Xorg. На заголовке любого окна щелкните правой кнопкой мыши, выбирите "настройка поведения окна" и в списке слева надите пункт полупрозрачность. Поставьте флажок "использовать прозрачность/тени", после чего станут доступны множество настроек прозрачности (активного,неактивного окна, окна при перетаскивании, плавные переходы прозрачности и т.д.) и теней. </para>
<para/>
<para>xcompmgr и transset</para>
<para/>
<para>Многие WM еще не обладают поддержкой новых функций X.org, так что нам придется использовать дополнительные инструменты для наших эффектов. </para>
<para>Вначале нам надо установить xcompmgr </para>
<para/>
<para>echo "x11-misc/xcompmgr ~x86" &gt;&gt; /etc/portage/package.keywords </para>
<para/>
<para>emerge xcompmgr </para>
<para>Затем установим transset </para>
<para/>
<para>echo "x11-misc/transset ~x86" &gt;&gt; /etc/portage/package.keywords </para>
<para/>
<para>emerge transset </para>
<para/>
<para>Теперь у нас есть все необходимое, чтобы включить тени, затенение и настоящую прозрачность. Запустите из Xterm xcompmgr xcompmgr -c Эта команда позволит вам увидеть эффекты от запущенного xcompmgr, если они вам не понравятся, то CTRL+C в консоли позволит вам убить процесс, а если они вам нравятся, то надо убить процесс и запустить его в фоновом режиме (сзади консоли): xcompmgr -c &amp; Примечание: символ &amp; позволяет запустить xcompmgr в фоновом режиме, но при этом если убить сам терминал - процесс тоже сдохнет, чтобы этого не произошло можно использовать утилиту nohup: nohup xcompmgr -c &amp; При этом весь вывод будет направлен в nohup.out </para>
<para/>
<para>Таким образом xcompmgr включит "мягкие" тени. Если будет использован флаг -s то будут "грубые" тени. </para>
<para/>
<para>Рабочий пример для xcompmgr с тенью и затенением xcompmgr -cCfF -r7 -o.65 -l-10 -t-8 -D7 &amp; </para>
<para/>
<para>Теперь о прозрачности. Выполните в консоли transset Теперь ваш курсор изменился, вы можете кликнуть на окне которое хотите сделать прозрачным. Если запустить transset с цифровым значением от 0 до 1 то это укажет насколько прозрачным должно быть окно </para>
<para>0 - полностью прозрачно </para>
<para>1 - не прозрачно </para>
<para/>
<para>Попробуйте выполнить transset 0.2 </para>
<para/>
<para>Для возвращения окна назад просто выполните transset и кликните по прозрачному окну. </para>
<para/>
<para>Как это выглядит</para>
<para/>
<para>Изображение взято на http://www.grebowiec.net/archives/xorg4.html </para>
<para/>
<para> </para>
<para/>
<para>Выключение эффектов</para>
<para/>
<para>Для выключения всех эффектов выполните killall xcompmgr </para>
<para/>
<para>Примечание</para>
<para/>
<para>NVIDIA</para>
<para/>
<para>При использовании NVIDIA видео карточек рекомендуется добавить в /etc/X11/xorg.conf нижеприведенные строки для того, чтобы можно было использовать расширение "Composite" и увеличить производительность при его использовании. Файл: /etc/X11/xorg.conf </para>
<para/>
<para>Section "Device"</para>
<para>...</para>
<para>Option "RenderAccel" "true"</para>
<para>Option "AllowGLXWithComposite" "true"</para>
<para>...</para>
<para>EndSection </para>
<para/>
<para>ВАЖНО: При использовании RenderAccel у вас могут возникнуть проблемы со стабильностью, так как эта опция экспериментальная и использовать ее вам предлагается на свой страх и риск.</para>
<para>При использовании AllowGLXWithComposite у вас могут возникнуть проблемы с opengl приложениями. Могут появляться артефакты, так как glx и composite не рекомендуется использовать одновременно. </para>
<para/>
<para>ATI </para>
<para/>
<para>При использовании ATI видео карточек совместно с ATI драйверами, дополните /etc/X11/xorg.conf опцией backingstore, для включения поддержки backing store, механизма с помощью которого пиксельные данные закрытого окна запоминаются Х сервером и снимает необходимость посылки сообщений к Х клиенту когда надо обновить изображение Файл: /etc/X11/xorg.conf </para>
<para/>
<para>Section "Device"</para>
<para>...</para>
<para>Option "backingstore" "true"</para>
<para>...</para>
<para>EndSection </para>
<para/>
<para/></sect4><sect4><title>Заключение</title>
<para/>
<para>Эти разработки находятся в самой начальной стадии и мы можем использовать их уже в X.org версии 6.8. По мере развития WM и приложений будет возможность воспользоваться новым функционалом X.org в полную меру без установки дополнительных приложений. Некоторые программы, kwin к примеру, уже портируются.</para>
<para/></sect4></sect3><sect3><title>Xorg. Переключение раскладок</title>
<para>Переключение USA/RUS + Scroll Lock Led </para>
<para/>
<para>В секции InputDevice для клавиатуры надо дописать следующее: </para>
<para>Section "InputDevice"</para>
<para>   Identifier        "Keyboard1"</para>
<para>   Driver        "kbd"</para>
<para>   Option        "AutoRepeat"        "500 30"</para>
<para>   Option "XkbModel"        "pc105"</para>
<para>   Option "XkbLayout"        "us,ru(winkeys)"</para>
<para>   Option "XkbOptions"        "grp:alt_shift_toggle, grp_led:scroll"</para>
<para>EndSection</para>
<para/>
<para>Раскладки будут переключаться по Alt+Shift, с индикацией на Scroll Lock Led </para>
<para/>
<para>Если, конечно, не забыть, что в Section "ServerLayout" должно быть прописано InputDevice "Keyboard1". По умолчанию там как раз Keyboard0, так что будьте внимательны. </para>
<para/>
<para>а если вы захотите что-бы CTRL-C CTRL-V работали во всех раскладках так-же четко как в микрософт виндовс - то этого увы вам никто не расскажет :) - надо править запутанные конфиги xkb </para>
<para/>
<para>Возможно, вариант русской раскладки winkeys у вас не заработает. Тогда измените следующую строку: </para>
<para>   Option "XkbLayout" "us,ru"</para>
<para/>
<para>и добавьте </para>
<para>   Option "XkbVariant" ",winkeys"</para>
<para/>
<para>Обратите внимание на запятую, она указывает на то, что вариант "winkeys" применяется именно к русской раскладке!</para>
<para/></sect3><sect3><title>Установка Xgl</title><sect4><title>Введение</title>
<para/>
<para>Проект Xgl позволяет ускорять посредством подсистемы OpenGL вывод примитивов X сервера, а также обеспечивать ускорение composite и render. На данный момент мы можем получить быструю работу с прозрачностью, тенью и отрисовкой окон. </para>
<para/>
<para>Более подробное руководство на английском языке рамещено по адресу en:HOWTO XGL </para>
<para/></sect4><sect4><title>Инсталяция</title>
<para/>
<para>Xorg</para>
<para/>
<para>Нам понадобится последняя версия Xorg. Необходимо размаскировать нужные пакеты и установить Xorg-7.0emerge xorg-x11 Примечание: Дополнительно можно почитать статью Настройка Portage </para>
<para/>
<para/>
<para>glitz</para>
<para/>
<para>Так же необходимо скачать из CVS последнюю версию glitz. cvs -d:pserver:anoncvs@cvs.freedesktop.org:/cvs/cairo co glitz Установить ее.autogen.sh &amp;&amp; ./configure --prefix=/usr/ &amp;&amp; make &amp;&amp; make install </para>
<para/>
<para>glxcompmgr</para>
<para/>
<para>Для работы с расширением composite скачаем утилиту glxcompmgr cvs -d :pserver:anoncvs@cvs.freedesktop.org:/cvs/xorg co app/glxcompmgr Скомпилируем и установимautogen.sh &amp;&amp; ./configure --prefix=/usr/ &amp;&amp; make &amp;&amp; make install </para>
<para/>
<para>metacity</para>
<para/>
<para>Так уж сложилось, что пока glxcompmgr может себя показать во всей красе только с оконным менеджером metacity, да, он способен работать и с kwin, но при этом запуск kdesktop вызовет прекращение нормальной работы glxcompmgr. metacity </para>
<para/>
<para>MesaLib</para>
<para/>
<para>Если мы хотим использовать composite, необходимо собрать библиотеку libGL.so.1.2 из пакета MesaLib-6.4.1 с патчем mesa-glx-x11-render-texture-3.diff, который лежит в каталоге glxcompmgr.patch -p0 &lt;mesa-glx-x11-render-texture-3.diff &amp;&amp; ./configure --prefix=/usr/ &amp;&amp; make Нет необходимости переустанавливать весь пакет т.к. нас интересует только файл ./lib/libGL.so.1.2. Заменим старый файл.cp ./lib/libGL.so.1.2 /usr/lib/opengl/xorg-x11/lib/ </para>
<para/>
<para>Xgl</para>
<para/>
<para>Теперь скачаем. cvs -d:pserver:anoncvs@cvs.freedesktop.org:/cvs/xorg login </para>
<para>CVS password: нажмите Enter </para>
<para>cvs -d:pserver:anoncvs@cvs.freedesktop.org:/cvs/xorg co -r xgl-0-0-1 xserver </para>
<para>Код находится в ./hw/xql </para>
<para>И установим сам Xgl сервер. ./configure --prefix=/usr/ --enable-xglserver --enable-glx --enable-xkb &amp;&amp; make &amp;&amp; make install </para>
<para/></sect4><sect4><title>Запуск сервера для видеокарт nvidia</title>
<para/>
<para>"Голый" сервер</para>
<para/>
<para>Убедимся, что мы используем libGL.so.1.2 от nvidiaeselect opengl set nvidia Для запуска сервера в отдельном окне откройте свой любимый терминал и выполните командуXgl :1 -ac -accel xv -accel glx:pbuffer -screen 800x600 &amp; Если сервер не запускается, то, возможно, необходимо отключить расширение xkb, добавив опцию -kb Xgl :1 -kb -ac -accel xv -accel glx:pbuffer -screen 800x600 &amp; Также могут возникнуть проблемы с шрифтами, тогда путь к ним надо указать вручную Xgl :1 -kb -ac -accel xv -accel glx:pbuffer -fp /usr/share/fonts/misc/ -screen 800x600 &amp; Для запуска сервера в полноэкранном режиме можно использовать опцию -fullscreenXgl :1 -kb -ac -accel xv -accel glx:pbuffer -fp /usr/share/fonts/misc/ -fullscreen &amp; </para>
<para/>
<para>Для запуска на ATI картах с установленными драйверами fglrx необходимо вместо ... -accel xv... Использовать ... -accel xv:pbuffer... </para>
<para/>
<para>Запускаем glxcompmgr</para>
<para/>
<para>Сначала для примера запустим xterm и metacity из терминала. export DISPLAY=:1xterm &amp;metacity &amp; После этого необходимо переключиться на использование библиотеки libGL.so.1.2 из пакета MesaLibeselect opengl set xorg-x11 После этого можно запускать glxcompmgr.glxcompmgr shadow wobbly &amp; После этого уже должен быть виден интересный эффект на запущеном xterm'е. </para>
<para/>
<para>KDE, GNOME</para>
<para/>
<para>Для запуска kde или Gnome необходимо запустить сначало metacity затем kde(Gnome) и в последнюю очередь glxcompmgr. </para>
<para/>
<para>Возможные проблемы</para>
<para/>
<para>Возможно у вас не получится запустить сервер т.к. файл /usr/lib/libGL.so.1 будет указывать не на /usr/lib/opengl/nvidia/lib/libGL.so.1.2, а на /usr/lib/libnvidia-tls.so.1. Поменяйте симлинк и сервер запустится.</para>
<para>Для переключения раскладки подойдет программа xruskb.</para>
<para/></sect4></sect3><sect3><title>XGL</title><sect4><title>Введение </title>
<para/>
<para>Xgl это X сервер, который использует OpenGL для прорисовки обьектов. Вместе с композитным оконным менеджерами Compiz или новой версией Metacity позволяет получить превосходное качество 3D и 2D эффектов рабочего стола. Xgl базируется на расширении Mesa, GLX_EXT_texture_from_pixmap, который представлен только в версиях Mesa 6.5 и старше. </para>
<para/>
<para>На the XOrg mailing list предлагается написать спецификацию GLX_EXT_texture_from_pixmap расширения совместно с NVIDIA. Бета версия драйверов уже выпущеных NVIDIA, версия 9625, поддерживают это расширение, это означает что Xgl уже не нуждается в использовании Compiz на NVIDIA картах, кроме этого использование данной конфигурации приветствуется. Для информации об этом методе использования Xgl, пожалуйста ознакомтесь на en:HOWTO nVidia GL Desktop Effects </para>
<para/>
<para>Кроме того, Compiz тесно связан с GNOME-компонентами, Xgl и Compiz работают прекрасно во всех окружениях рабочих столов (KDE/GNOME/Xfce/*box). Если Вы всё же не используете GNOME, будте готовы к установке необходимых библиотек и утилит. </para>
<para>Предупреждение: Данное программное обеспечение ещё не является стабильным, и хотя оно почти всегда работает, всё же используйте его с осторожностью. </para>
<para/></sect4><sect4><title>Системные требования</title>
<para/>
<para>см. the article on video card support under Xgl. </para>
<para/>
<para>Установка Xgl Примечание: Установка должна быть произвадена на системе с работающей X сессией используя эмулятор терминала типа konsole или gterm, выполнение этого условия необходимо для запуска gconf-editor или gset-compiz для конфигурации Compiz в конце установки. </para></sect4><sect4><title>Требования к програмному обеспечению</title>
<para/>
<para>Обновите Ваше локальное дерево портажей. </para>
<para/>
<para>emerge --sync </para>
<para/>
<para>Вам необходима модульная версия XOrg (версия 7.x). Для установки модульной версии XOrg ознакомтесь с официальной Gentoo документацией или соответствующей статьёй wiki. </para>
<para>en:HOWTO Modular Xorg </para>
<para/></sect4><sect4><title>Официальное руководство </title>
<para/>
<para>Модульный XOrg (версия 7.x) был опубликован в стабильнй ветке дерева портажей, поэтому Вы можете пропустить эту главу если Ваш Gentoo полностью обновлен. </para>
<para/>
<para>Compiz использует рабочую оболочку GNOME GConf для конфигурации, и некоторые из опций конфигурации будут приведены здесь. Наиболее легким и популярным способом конфигурации является программа gconf-editor, одна из приложений GNOME. Конечно, и менее известная KDE программа KConfigEditor также может использоваться для конфигурации. Правда для этой программы пока не существует ebuild файла, но Вы можете загрузить исходный код этой программы с extragear.kde.org. Пожалуй самый нежелательный из способов это редактирование gconf конфигурационных файлов вручную, что является скучным и неблагодарным занятием. </para>
<para/>
<para>Если Вы хотите использовать gconf-editor, то его необходимо установить. </para>
<para/>
<para>emerge -nav gconf-editor </para>
<para/>
<para>Также Вам необходимо установить Subversion с включенной поддержкой webdav. Вы должны отключить флаг nowebdav. Добавте добавте при необходимости следующую строку в /etc/portage/package.use: Примечание: Тут используется двойное отрицание в использовании USE флага. </para>
<para/>
<para>echo "dev-util/subversion -nowebdav" &gt;&gt; /etc/portage/package.use </para>
<para>затем, </para>
<para>emerge -nav subversion </para>
<para/></sect4><sect4><title>Загрузка Portage оверлея</title>
<para/>
<para>Существуют два метода для создания требуемого оверлея; оверлей можно загрузить используя svn утилиту или использовать layman утилиту которая будет управлять оверлеями вместо Вас. Используя layman производить обновление системы проще, так что решать Вам. Вне зависимости, что Вы будете использовать результат будет одним и темже. </para>
<para/>
<para>Метод по умолчанию: использование Layman утилиты</para>
<para/>
<para>Если вы ещё не установили Layman, сделайте это сейчас. </para>
<para/>
<para>emerge -nav layman </para>
<para/>
<para>Также Вам необходимо добавить следующую строку в Ваш make.conf. </para>
<para/>
<para>echo "source /usr/portage/local/layman/make.conf" &gt;&gt;/etc/make.conf </para>
<para/>
<para>Если Вы используете Eix Caching System, удостовертесь что Вы используете самую новую версию; старые версии не поддерживают чтение внешних файлов make.conf. </para>
<para/>
<para>Измените "nocheck" переменную на значение "yes" в конфигурационном файле утилиты layman. (/etc/layman/layman.cfg) </para>
<para/>
<para>Затем добавте оверлей с помощью Layman утилиты: </para>
<para/>
<para>layman -f</para>
<para>layman -a xeffects </para>
<para/>
<para>если вы используете layman версии 1.0.7 или позже, то оверлеи с неправильными атрибутами будут проигнорированы. Используйте опцию -k для обхода этой ситуации. </para>
<para/>
<para>layman -k -a xeffects </para>
<para/></sect4><sect4><title>Альтернативный метод: Создание оверлея вручную</title>
<para/>
<para>Если Вы хотите обслуживать Вашь оверлей самостоятельно, то сделайте следующее. Иначе (если используется lanman), вы можете перейти к главе Размаскирование необходимых пакетов. Примечание: Лучше всего не смешивать оверлеи и использовать их отдельно друг от друга. </para>
<para/>
<para>Перейдите в Вашу директорию оверлеев </para>
<para/>
<para>cd /usr/local/overlays </para>
<para/>
<para>Загрузите последнюю версию из CoffeeBuzz's Subversion репозитория в директорию 'xgl-coffee' </para>
<para/>
<para>svn co http://svn.xgl-coffee.org/xgl-coffee/trunk xgl-coffee </para>
<para/>
<para>Теперь Вы создали оверлей дерева портежей в /usr/local/overlays/xgl-coffee. </para>
<para/>
<para>Добавьте следующий путь в переменную PORTDIR_OVERLAY в /etc/make.conf. </para>
<para>Файл: /etc/make.conf </para>
<para>PORTDIR_OVERLAY="${PORTDIR_OVERLAY} /usr/local/overlays/xgl-coffee"</para>
<para/>
<para/></sect4><sect4><title>Размаскирование необходимых пакетов</title>
<para/>
<para>Много пакетов маркированы как нестабильные и должны быть размаскированы чтобы их можно было установить из дерева портажей Добавте следующие строки к файлу /etc/portage/package.keywords или /etc/portage/package.unmask </para>
<para>Файл: /etc/portage/package.keywords </para>
<para># Зависимости</para>
<para>dev-util/git</para>
<para>media-libs/glitz</para>
<para>media-libs/mesa</para>
<para>x11-apps/mesa-progs</para>
<para>sys-apps/man</para>
<para>x11-libs/cairo</para>
<para>dev-python/pycairo</para>
<para>x11-libs/qt</para>
<para>x11-misc/util-macros</para>
<para>x11-proto/glproto</para>
<para>x11-apps/xvinfo</para>
<para>x11-apps/xlsclients</para>
<para>x11-libs/libwnck</para>
<para>x11-misc/xwinwrap</para>
<para>virtual/xft</para>
<para>gnome-base/gconf</para>
<para>gnome-base/libgnomeui</para>
<para>x11-libs/gtk+</para>
<para>dev-libs/glib</para>
<para>x11-libs/libdrm</para>
<para/>
<para>#XGL пакет</para>
<para>x11-base/xgl</para>
<para/>
<para># старые версии Compiz</para>
<para>x11-wm/compiz-quinnstorm</para>
<para>x11-misc/compiz-quinnstorm-plugins</para>
<para>x11-wm/compiz</para>
<para>x11-wm/cgwd</para>
<para>x11-misc/csm</para>
<para>x11-misc/cgwd-themes</para>
<para>x11-misc/cgwd-themes-extra</para>
<para>x11-misc/gset-compiz</para>
<para>x11-misc/compiz-manager</para>
<para/>
<para># новая ветка Beryl для Compiz</para>
<para>x11-wm/beryl-core</para>
<para>x11-plugins/beryl-plugins</para>
<para>x11-misc/beryl-manager</para>
<para>x11-misc/beryl-settings</para>
<para>x11-wm/emerald</para>
<para>x11-misc/emerald-themes</para>
<para/>
<para/>
<para>Удостоверьтесь что флаги glitz, pdf и png включены в переменную USE для Cairo. Возможно Вам понадобится добавить следующую строку к файлу package.use: </para>
<para>Файл: /etc/portage/package.use </para>
<para>x11-libs/cairo glitz pdf png</para>
<para/></sect4><sect4><title>Установка Xgl</title>
<para/>
<para>Новые бета драйверы с закрытым исходным кодом от nVidia (версия 1.0.9625) уже включают в себя поддержку XGL. Поэтому не нужно более никаких установок. Если вы не хотите использовать новейшие бета драйвера, то следуйте к главе "не-nVidia пользователи". Данный способ работает на nVidia картах при этом установка и использование новых nVidia драйверов намного проще. Если Вы хотите использовать новейшие бета драйвера тогда Вы должны перейти к главе "nVidia Пользователи". </para>
<para/>
<para>Не-nVidia пользователи</para>
<para/>
<para>Во-первых Вы должны установить Cairo. Используй опуцию --oneshot чтобы не записывать этот пакет в список world (не захламляй свой world список). </para>
<para/>
<para># emerge --oneshot --ask --verbose cairo </para>
<para/>
<para>Переинсталируй pango и gtk+ с использованием новоустановленного Cairo пакета. </para>
<para/>
<para># emerge --oneshot --ask --verbose pango gtk+ </para>
<para/>
<para/>
<para>Далее у Вас есть выбор между beryl и compiz ветками: </para>
<para>compiz это оригинальное приложение написанное Давидом Равеманом (David Reveman) из Новел (Novell). Это приложение уже включено в дерево портажей. </para>
<para>beryl это снимок Quinnstorm's Ubuntu кодовой базы с некоторыми экспериментальными плагинами. Формально эта ветка известна под названием compiz-quinnstorm. Использует emerald как window decorator. это отдельный пакет не включенный в дерево портежей. </para>
<para/>
<para>Проверьте что флаги dbus и svg включены в переменную USE для Compiz. Возможно Вам потребуется добавить следующую строку в package.use: Файл: /etc/portage/package.use </para>
<para>x11-wm/compiz dbus svg</para>
<para/>
<para>Проверьте что пакеты glproto и libdrm установлены. Установите их если это требуется: </para>
<para/>
<para># emerge --ask --verbose --oneshot --noreplace glproto libdrm </para>
<para/>
<para>В конечном итоге Вы должны будете установить Xgl и Mesa, которые автоматичеси скомпилируют и установят Compiz а также все его плагины и Xgl сервер. </para>
<para/>
<para># emerge --ask --verbose --oneshot --noreplace mesa </para>
<para/>
<para>Опция 1: Для использования vanilla compiz: </para>
<para/>
<para># emerge --ask --verbose xgl compiz </para>
<para/>
<para>Опция 2: Для использования beryl мета пакета: </para>
<para/>
<para># emerge --ask --verbose xgl beryl-core </para>
<para/>
<para>Примечание: Установка beryl также устанавливает декоратор окон emerald и его темы. Таким образом emerald не надо устанавливать отдельно. </para>
<para>Примечание: NVIDIA пользователи пожалуйста переустановите nvidia-drivers после установки Xgl </para>
<para>Примечание: Если неудается скомпилировать xgl, проверте заплатку на </para>
<para>http://forums.xgl-coffee.org/viewtopic.php?t=178 </para>
<para>Примечание: Если неудается скомпилировать beryl из за dbus, попробуйте обновить пакет dbus </para>
<para>Примечание: Если неудается скомпилировать xgl и компиляция обрывается на fbmmx.c или fbedge.c, попробуйте удалить флаг "-fforce-addr" из переменной CFLAGS. Также ознакомтесь с документацией на форуме </para>
<para/>
<para>Если всё прошло удачно, то Cairo должен присутствовать в системе как зависимость. Примечание: Для следующей проверки необходим установленый пакет gentoolkit. </para>
<para/>
<para>Проверите с помощью следующей команды </para>
<para/>
<para># equery d -o -p cairo </para>
<para/>
<para>Предупреждение: Если команда не возвращает никаких пакетов, то значит чтото прошло не правильно! </para>
<para/>
<para>После произведенных действий Вы должны получить функционирующую установку Xgl. Пожалуйста ознакомтесь с Глава работающий Xgl. </para>
<para/>
<para>nVidia пользователи</para>
<para/>
<para>nVidia драйвер версии 9625 BETA и старше содержат XGL и AIGLX-подобные расширения и могут быть использованы совмесно с другими композитными менеджерами окон. см. en:HOWTO nVidia GL Desktop Effects для более детальной информации. </para>
<para/></sect4><sect4><title>Обновление Xgl </title>
<para/>
<para>Из-за быстрой разработки Xgl и Compiz, оверлей обновляется как минимум один раз в неделю. Используйте один из приведённых методов для обновления оверлея. </para>
<para/>
<para>Обновление с помощью Layman утилиты</para>
<para/>
<para>Обновление оверлея с помощью Layman утилиты очень просто: </para>
<para/>
<para>layman -s xeffects </para>
<para/>
<para>Обновление вручную</para>
<para/>
<para>Для обновления оверлея вручную, перейдите в директорию оверлея и введите ./svnup.sh. этот скрипт также выведет список изменений. </para>
<para>cd /usr/local/overlays/xgl-coffee/</para>
<para>./svnup.sh</para>
<para/></sect4><sect4><title>Запуск Xgl </title>
<para/>
<para>Конфигурация Compiz </para>
<para/>
<para>Для начала надо сконфигурировать Compiz и его плагинов. Если никакие плагины не указаны, тогда окна останутся без декораций! (не будет кнопок minimize/maximize/close, невозможно будет изменять размеры окна, ничего вообще толком не будет.) </para>
<para/>
<para>Существуют два пути указания плагинов. Вы можете указать плагины в командной строке или использовать оконный редактор конфигурации например с помощью программ gconf-editor или gset-compiz. Но вы не можете использовать оба способа одновременно! Если gconf указан в командной строке, тогда Compiz проигнорирует все другие плагины указанные в командной сторке и возьмёт список плагинов из вашей конфигурации gconf. </para>
<para/>
<para>Таким образом если Вы впервые запускаете Xgl и Вы хотите конфигурировать в оконном редакторе, наступило время сделать это, до того как Вы выйдете из Вашей X сессии. </para>
<para/>
<para>Способ "По умолчанию": Использование gconf-editor </para>
<para># gconf-editor</para>
<para/>
<para>Перейдите в apps --&gt; compiz --&gt; general --&gt; allscreens --&gt; options и отредактируйте узел active_plugins находящийся справа. Примечание: Если в gconf-editor нет вкладок Сompiz, тогда это можно исправить таким образом: </para>
<para> # export GCONF_CONFIG_SOURCE="xml:merged:/etc/gconf/gconf.xml.defaults"</para>
<para> # gconftool-2 --makefile-install-rule /etc/gconf/schemas/compiz.schemas</para>
<para/>
<para>Способ "По умлочанию" для compiz-quinnstorm: Использование csm</para>
<para># csm</para>
<para/>
<para>Плагины могут быть активированы кликая в checkbox после имени. Индивидуальная конфигурация плагинов осуществляется после щелчка мышью на имени плагина. Примечание: Compiz-quinnstorm поставляется вместе с Compiz Manager (compiz-manager). Это оконное приложение находящееся в системной панели и включает в себя Compiz Settings Manager (csm) и Compiz Theme Manager (gcompizthemer). Запустив на выполнение эти две утилиты (управляйте compiz и темами), перестартуйте оконный менеджер или декоратор из системной панели и установите запасной оконный менеджер который будет использоваться в случае неудачного старта. </para>
<para/>
<para># compiz-manager</para>
<para> or (if any dbus problem) :</para>
<para># dbus-launch compiz-manager</para>
<para/>
<para>Альтернативный способ: Испльзование gconftool-2</para>
<para># gconftool-2 -s /apps/compiz/general/allscreens/options/active_plugins "[gconf,decoration,wobbly,fade,minimize,cube,switcher,move,resize,place,rotate,zoom,scale]" -t list --list-type=string</para>
<para/>
<para>Укажите активные плагины внутри квадратных скобок. </para>
<para/>
<para>Альтернативный способ: Использование gset-compiz Предупреждение: </para>
<para/>
<para>gset-compiz больше не пытается использовать все возможности Compiz. Используйте лучше gconf-editor или более новые программы для возможностей которыми не располагает gset-compiz. </para>
<para/>
<para># gset-compiz</para>
<para/>
<para>Плагин можно активировать поставив галочку сразу возле его имени. Конфигурация индивидуальных настроек плагина доступна после нажатия кнопки Plugins находящейся сразу под меню. </para>
<para/>
<para>Как минимум, потребуются пакеты gconf и decoration. Также, если Вы хотите включить все доступные эффекты, надо также добавить wobbly, fade, switcher, move, resize, place, minimize, cube, rotate, zoom, и scale. Из имени пакета Вы сами можете догадаться, что выполняет каждый из плагинов, так что не торопитесь включать их все. Это как предпочтения "сладостей для глаз", установите плагины move и resize - у Вас появится возможность работать с их функциями. </para>
<para/>
<para>Using Quinnstorm's compiz &amp; cgwd </para>
<para/>
<para>Quinnstorm's new compiz doesn't use gconf plugin anymore (so settings). To use it, replace any instance of compiz --replace gconf found in this document with dbus-launch compiz --replace dbus csm. And set it by csm or dbus-launch csm. </para>
<para/>
<para>Quinnstorm's new window decorator must be called instead of gnome-window-decorator in order to function. If you chose to emerge cgwd, just replace any instance of gnome-window-decorator found in this document with dbus-launch cgwd. </para>
<para/>
<para>Оконный режим </para>
<para/>
<para>Запустив Xgl таким способом мы создадим новое окно с включенным Xgl сервером. Это отличный способ протестировать правильность установки прежде чем запускать XGL в полноэкранном режиме. </para>
<para/>
<para>Чтобы попробовать его работу в оконном режиме при уже запущенном X сервере: Code: Для ati пользователей </para>
<para>Xgl :1 -ac -accel glx:pbuffer -accel xv:pbuffer -fp /usr/share/fonts/misc,/usr/share/fonts/other_fonts</para>
<para>Code: Для nVidia пользователей </para>
<para>Xgl :1 -ac -accel glx:pbuffer -accel xv -fp /usr/share/fonts/misc,/usr/share/fonts/other_fonts</para>
<para/>
<para>Примечание: Обсуждение использования pbuffer или fbo как аргументов accel, можно почитать здесь http://forums.gentoo.org/viewtopic-t-455153-highlight-.html </para>
<para>Примечание: Xgl не будет считывать значение FontPath из xorg.conf, по-этому, лучше в конце строки после опции -fp прописать пути к шрифтам разделяя их запятой. Используйте этот скрипт для получения путей к шрифтам прописанным в файле xorg.conf: </para>
<para/>
<para> grep -i fontpath /etc/X11/xorg.conf | egrep -v "[:space:]*#" | sed "s/.\+\"\(.\+\)\"/\1,/g" | xargs echo | sed "s/\ //g" | sed "s/,\$//"</para>
<para/>
<para>Протестируйте Вашу конфигурацию: </para>
<para/>
<para>Запустите композитный оконный менеджер (compiz or compiz-quinnstorm), запустите декоратор окон (gnome-window-decorator or cgwd) и запустите приложение (xterm). Code: Для большинства: Если Вы используете compiz совмесно с gnome-window-decorator </para>
<para/>
<para>Учтите что название gnome-window-decorator изменилось на gtk-window-decorator 22 Сентября 2006 года. </para>
<para>LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ \</para>
<para>DISPLAY=:1 compiz gconf</para>
<para>DISPLAY=:1 gnome-window-decorator</para>
<para>DISPLAY=:1 xterm</para>
<para>Code: Альтернатива 1: если Вы используете compiz-quinnstorm совмесно с gnome-window-decorator </para>
<para>LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ \</para>
<para>DISPLAY=:1 dbus-launch compiz dbus csm</para>
<para>DISPLAY=:1 gnome-window-decorator</para>
<para>DISPLAY=:1 xterm</para>
<para>Code: Альтернатива 2: Если вы используете compiz-quinnstorm с cgwd </para>
<para>LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ \</para>
<para>DISPLAY=:1 dbus-launch compiz dbus csm</para>
<para>DISPLAY=:1 dbus-launch cgwd</para>
<para>DISPLAY=:1 xterm</para>
<para/>
<para/>
<para>Если всё прошло успешно, мы можем начать конфигурировать Вашу систему для запуска Xgl с Вашим графическим менеджером аутентификации. Следуйте инструкциям которые помогут Вам настр�ить менеджер аутентификации. Это последний шаг необходим для удобного использования Xgl. </para>
<para/>
<para>startx (Для пользователей startx) </para>
<para/>
<para>Если вы обычно загружаетесь в консоль и Xorg сервер запускается через startx, а .xinitrc загружает ваш менеджер окон на DISPLAY:0, то вам нужно: написать скрипт startxgl для запуска сервера Xgl, а так же файл .xglinitrc для загрузки менеджера окон на DISPLAY:1. Эти действия не изменят вашей текущей конфигурации и вы сможете в любой момент вернутся в нормальный Xorg сервер. </para>
<para/>
<para>1) Скопируйте startx (cp /usr/bin/startx /usr/local/bin/startxgl) и отредактируйте 2 строки: Файл: /usr/local/bin/startxgl </para>
<para> ## userclientrc=$HOME/.xinitrc</para>
<para> userclientrc=$HOME/.xglinitrc</para>
<para/>
<para> ## xinit $clientargs -- $serverargs -deferglyphs 16 &amp;</para>
<para> # ATI</para>
<para> xinit $clientargs -- /usr/bin/Xgl :1 $serverargs -ac -accel xv -accel glx:pbuffer -deferglyphs 16 &amp;</para>
<para> # NVIDIA</para>
<para> xinit $clientargs -- /usr/bin/Xgl :1 $serverargs -ac -accel xv -accel glx:fbo -deferglyphs 16 &amp;</para>
<para/>
<para/>
<para>2) создайте файл ~/.xglinitrc (vi ~/.xglinitrc) Файл: ~/.xglinitrc </para>
<para> sleep 2 # give Xgl some extra time to start</para>
<para> DISPLAY=:1 KDEWM=compiz-decorator startkde</para>
<para>Примечание: Пользователи Gnome должны вписать gnome-session вместо startkde и WINDOW_MANAGER вместо KDEWM. Пользователи других DM вписывают соответствующие им команды запуска. Для уточнения проверте ваш ~/.xinitrc. </para>
<para/>
<para/>
<para>3) создайте файл compiz-decorator (vi /usr/local/bin/compiz-decorator) Файл: /usr/local/bin/compiz-decorator </para>
<para>## Start compiz or compiz-quinnstorm</para>
<para>## compiz --replace gconf &amp;</para>
<para>## dbus-launch compiz --replace dbus csm &amp;</para>
<para>compiz --replace gconf &amp;</para>
<para/>
<para>sleep 2</para>
<para/>
<para>## Start gnome-window-decorator or cgwd</para>
<para>## gnome-window-decorator &amp;</para>
<para>## dbus-launch cgwd &amp;</para>
<para>gnome-window-decorator &amp;</para>
<para>Примечание: Команды для запуска и использования compiz-quinnstorm и cgwd в скрипте закоментированны. Если вы хотите пользоваться ими то незабудте закоментировать текущие </para>
<para/>
<para>Смените права доступа на /usr/local/bin/compiz-decorator что бы сделать его исполняемым: </para>
<para># chmod +x /usr/local/bin/compiz-decorator</para>
<para/>
<para>4) Для запуска вашего оконного менеджера в XOrg используйте startx, для запуска в Xgl используйте startxgl. </para>
<para/>
<para>Скрипты тестировались на связке ATI и KDE. --Ash 17:48, 11 Сентября 2006 (UTC) </para>
<para/>
<para>XDM (Базовая графическая система аутентификации) </para>
<para/>
<para>Измените ссылку на X сервер: Файл: /etc/X11/xdm/Xservers </para>
<para>:0 local /usr/bin/Xgl vt7</para>
<para/>
<para/>
<para>KDM (для пользователей KDM) </para>
<para/>
<para>Замените строку с ServerCmd в kdmrc на одну из следующих:</para>
<para>Файл: /usr/kde/&lt;your version&gt;/share/config/kdm/kdmrc </para>
<para># NVidia Command</para>
<para>ServerCmd=/usr/bin/Xgl -br -ac -accel glx:pbuffer -accel xv</para>
<para># ATI Command</para>
<para>ServerCmd=/usr/bin/Xgl -br -ac -accel glx:pbuffer -accel xv:pbuffer</para>
<para/>
<para>Вы также должны поменять занчение ServerTimeout так как Xgl запускается немного дольше, чем нормальный Х сервер: </para>
<para>Файл: /usr/kde/&lt;your version&gt;/share/config/kdm/kdmrc </para>
<para>ServerTimeout=30</para>
<para>Если kdm не смог загрузится, измените значение ServerTimeout на 600. Учтите, что в этом случае время загрузки Xgl значительно увеличится. </para>
<para>Не используйте скрипт /usr/kde/3.5/share/config/kdm/Xstartup для запуска Compiz. Для его выполнения нужны права пользователя root. </para>
<para/>
<para>Скопируйте скрипт в другое место, например сюда: Файл: /usr/local/bin/compiz-decorator </para>
<para>## Start compiz or compiz-quinnstorm</para>
<para>## compiz --replace gconf &amp;</para>
<para>## dbus-launch compiz --replace dbus csm &amp;</para>
<para>compiz --replace gconf &amp;</para>
<para/>
<para>sleep 2</para>
<para/>
<para>## Start gnome-window-decorator or cgwd</para>
<para>## gnome-window-decorator &amp;</para>
<para>## dbus-launch cgwd --replace &amp;</para>
<para>gnome-window-decorator --replace &amp;</para>
<para/>
<para>Примечание: Команды для запуска и использования compiz-quinnstorm и cgwd в скрипте закоментированны. Если вы хотите пользоваться ими то незабудте закоментировать текущие. </para>
<para/>
<para>Сделайте вновь созданный скрипт /usr/local/bin/compiz-decorator исполняемым: </para>
<para># chmod +x /usr/local/bin/compiz-decorator</para>
<para/>
<para/>
<para>Далее измените: </para>
<para>Файл: /etc/env.d/99kde-env </para>
<para>KDEWM=compiz-decorator</para>
<para/>
<para>И наконец, выполните команду: </para>
<para># env-update</para>
<para/>
<para>Теперь после перезагрузки или выполнения комманды /etc/init.d/xdm start вы запустите полнофункциональный Xgl со всеми эффектами без пользовательского вмешательства и аутентификацией с помощью KDM. </para>
<para/>
<para>GDM (для пользователей GNOME) </para>
<para/>
<para>Вы должны сделать 3 вещи, чтобы заставить Xgl работать с GDM и использовать Compiz для автоматической загрузке при авторизации пользователя. </para>
<para>Сконфигурируйте GDM для Xgl с отложенным запуском, чтобы при запуске нельзя было сказать, что она не работает </para>
<para>Сконфигурируйте GDM для использования с Xgl-сервером </para>
<para>Установите сессию GNOME для автоматического запуска из Compiz Примечание: Конфигурирование gdm для отложенного запуска Xgl доступно с gdm-2.14.1 и поздних версий. Если Вы используете раннюю версию, начинте с шага 2, но, возможно, Вам не удастся заставить gdm работать с Xgl. Также использование gdmsetup для конфигурирования gdm на испольльзоваине Xgl-сервера (Раздел 2a) может быть недоступно для версий gdm ранее 2.14.0. Если недоступны необходимые Вам функции, самостоятельно отредактируйте конфигурационный файл GDM (Раздел 2b). </para>
<para/>
<para/>
<para>Конфигурирование Gdm на отложенный запуск для запуска Xgl </para>
<para/>
<para>Gdm сконфигурирована по умолчанию на завершение (kill) X-сервера, если загрузка заняла более 10 секунд. К сожадению, новые версии Xgl могут загружаться дольше. Пользователи Xgl в Gentoo, могут сконфигурировать Gdm (пример по версии 2.14.1) на ожидание более 10 секунд. </para>
<para># emerge --ask --verbose &gt;=gdm-2.14.1</para>
<para>Добавьте/измените следующие команды секции [daemon] файла /etc/X11/gdm/custom.conf. Строка: Файл: /etc/X11/gdm/custom.conf </para>
<para>GdmXserverTimeout=30</para>
<para/>
<para>Если /etc/X11/gdm/custom.conf не существует, попробуйте /etc/X11/gdm/gdm.conf-custom или /etc/X11/gdm/gdm.conf. </para>
<para/>
<para>Конфигурирование Gdm для использования сервера Xgl </para>
<para/>
<para>Использование gdmsetup </para>
<para>Для начала сделайте резервную копию файла gdm.conf </para>
<para>cp /etc/X11/gdm/gdm.conf /etc/X11/gdm/gdm.conf.bak </para>
<para>Запустите gdmsetup </para>
<para>Выберите раздел Security </para>
<para>Щёлкните кнопку Configure X Server, расположенную снизу-справа раздела </para>
<para/>
<para>Для начала мы удалим значения для стандартного X-сервера </para>
<para>Нажмите по стандартному серверу, ктороы находится в списке Servers to Start </para>
<para>Нажмите Remove Button </para>
<para/>
<para>Сейчас мы создадим значения для сервера Xgl </para>
<para>Нажмите кнопку Add/Modify </para>
<para>Задайте использование нового сервера VT 1. Используйте Standard для Server опцию — она отображает, какой профиль использовать для сервера, в идеале мы должны создать новый "Xgl"-профиль, а в настоящее время при помощи gdmsetup это сделать невозможно, так что отредактируем настройки для профиля Standard. Не воодите здесь каких-либо опций. Нажмите Ok по завершении. </para>
<para>В Server Settings измените Server Name на "Xgl" </para>
<para>Введите команду Xgl в поле Command, например, для пользователей ATI: </para>
<para>/usr/bin/Xgl :1 -ac -accel glx:pbuffer -accel xv:pbuffer</para>
<para>NVIDIA users should use: </para>
<para>/usr/bin/Xgl -br -ac -accel glx:pbuffer -accel xv</para>
<para>Измените в выпадающем списке Launch значение на Greeter </para>
<para>Установите Logins are handled by this computer </para>
<para>Установите Flexible (on demand) </para>
<para>Save и Close </para>
<para>Перезапустите gdm </para>
<para/>
<para>Ручная настройка </para>
<para>Для начала сделайте резервную копию файла gdm.conf </para>
<para>cp /etc/X11/gdm/gdm.conf /etc/X11/gdm/gdm.conf.bak</para>
<para>Now open /etc/X11/gdm/gdm.conf in a text editor and search for the [servers] section. This should be near the end of the file. </para>
<para>Comment out 0=Standard and add a new line that reads 0=inactive and one that reads 1=Xgl. </para>
<para>Add the server information for the Xgl server, remember to substitute the correct Xgl server command! The one below is for ATI cards. </para>
<para/>
<para>The modified /etc/X11/gdm/gdm.conf: </para>
<para>[servers]</para>
<para>#0=Standard</para>
<para>1=Xgl</para>
<para/>
<para># Definition of the xgl X server.</para>
<para>[server-Xgl]</para>
<para>name=Xgl</para>
<para>command=/usr/bin/Xgl :1 -ac -accel xv:pbuffer -accel glx:pbuffer</para>
<para>flexible=true</para>
<para>chooser=false</para>
<para>handled=true</para>
<para>priority=0 </para>
<para>Restart gdm Примечание: For i810 users (not necessarly i915; this would kill my xorg sessions, I had to use the ATI command), the command for the above should be:</para>
<para>[server-xgl]</para>
<para>name=Xgl server</para>
<para>command=/usr/bin/Xgl -accel xv -accel glx:pbuffer -accel xv:pbuffer -ac -audit 0 -br -dpms -dpi 72</para>
<para>flexible=true</para>
<para/>
<para/>
<para>Via xsession </para>
<para/>
<para>You can add another session for Xgl on display :1 (leaving the standard server on :0). It is a 2 step setup and imho the best option, first create a file to start Xgl and second create a new xsession file. </para>
<para/>
<para>Create a new file startxgl.sh in /usr/bin which starts Xgl. </para>
<para>vim /usr/bin/startxgl.sh</para>
<para/>
<para>And add one of the four options below. </para>
<para>NVIDIA (using GNOME) </para>
<para>#!/bin/bash</para>
<para>Xgl -fullscreen :1 -audit 0 -ac -br -accel glx:pbuffer -accel xv:fbo &amp;</para>
<para>sleep 2 &amp;&amp; DISPLAY=:1 gnome-session</para>
<para>NVIDIA (using KDE) </para>
<para>#!/bin/bash</para>
<para>Xgl -fullscreen :1 -audit 0 -ac -br -accel glx:pbuffer -accel xv:fbo &amp;</para>
<para>sleep 2 &amp;&amp; DISPLAY=:1 startkde</para>
<para>ATI and Intel (using GNOME) </para>
<para>#!/bin/bash</para>
<para>Xgl -fullscreen :1 -audit 0 -ac -br -accel glx:pbuffer -accel xv:pbuffer &amp;</para>
<para>sleep 2 &amp;&amp; DISPLAY=:1 gnome-session</para>
<para>ATI and Intel (using KDE) </para>
<para>#!/bin/bash</para>
<para>Xgl -fullscreen :1 -audit 0 -ac -br -accel glx:pbuffer -accel xv:pbuffer &amp;</para>
<para>sleep 2 &amp;&amp; DISPLAY=:1 startkde</para>
<para/>
<para>Create a new xsession file: Файл: /usr/share/xsessions/xgl.desktop </para>
<para>[Desktop Entry]</para>
<para> Encoding=UTF-8</para>
<para> Name=Xgl</para>
<para> Comment=Start an Xgl Session</para>
<para> Exec=/usr/bin/startxgl.sh</para>
<para> Icon=</para>
<para> Type=Application</para>
<para/>
<para/>
<para>Now you will be able to select a new session via gdm's option menu. Options -&gt; Select Session </para>
<para/>
<para>The benefit is that it will not replace your normal XOrg server. So when you "break" your Xgl you can return to the normal XOrg server. </para>
<para/>
<para>Adding Compiz to your GNOME session (replacing Metacity) </para>
<para/>
<para>Here is a little startscript, which I've placed in /usr/bin/. Useful if you do not always run Xgl. Change or remove the setxkbmap line according to your keyboard layout. Файл: /usr/bin/compizrc </para>
<para>#!/bin/bash</para>
<para>#</para>
<para># Start compiz within gnome-session</para>
<para>#</para>
<para>if [ `ps -A -o comm | grep -c '^Xgl$'` == "1" ]; then</para>
<para>        DISPLAY=:1 LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ compiz --replace gconf &amp;</para>
<para>        DISPLAY=:1 gnome-window-decorator &amp;</para>
<para>#       DISPLAY=:1 setxkbmap -model pc105 -layout it -variant basic # Change according to your needs, and uncomment if needed</para>
<para/>
<para>#       Or like that, if you need to switch between layouts.</para>
<para>#       setxkbmap -model pc105 -layout "us,ru(winkeys)" -variant winkeys -option "grp:alt_shift_toggle,grp_led:scroll"</para>
<para>else echo "${0}: Error: Compiz and g-w-d not launched. Xgl not running?"</para>
<para>fi</para>
<para>Файл: /usr/bin/compizrc.modified </para>
<para>#!/bin/bash</para>
<para>#</para>
<para># Start compiz within gnome-session</para>
<para>#</para>
<para>if [ `ps -A -o comm | grep -c '^Xgl$'` == "1" ]; then</para>
<para># For old versions</para>
<para>#       DISPLAY=:0 LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ compiz --replace gconf &amp;</para>
<para># For Compiz-Quinnstorm with csm</para>
<para>        DISPLAY=:0 LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ compiz --replace dbus csm &amp;</para>
<para>        DISPLAY=:0 dbus-launch cgwd --replace &amp;</para>
<para>#       DISPLAY=:0 setxkbmap -model br-abnt2 -layout br -variant br</para>
<para>else echo "${0}: Error: Compiz and cgwd not launched. Xgl not running?"</para>
<para>fi</para>
<para>Code: Make the script executable </para>
<para/>
<para>chmod 755 /usr/bin/compizrc </para>
<para/>
<para/>
<para/>
<para>After logging into GNOME, start System-&gt;Settings-&gt;Sessions. Here you go to the 3rd tab Startup Programs and press the Add button. Enter the path to your Compiz startscript (e.g., /usr/bin/compizrc). </para>
<para>After logging out and back in Compiz will start, but you'll see no decorations and effects. Thats because the Compiz gconf tree for the current user has just been created - without any plugins! </para>
<para>So start your configuration editor and go to apps/compiz/general/allscreens/options and edit the active_plugins key. This should contain the following items in this order: gconf decoration wobbly fade minimize cube rotate zoom scale move resize place menu switcher </para>
<para>If the key is not there, make it with a type of List </para>
<para>After restarting your Xgl Server should be accessible with GDM &amp; gnome-session. </para>
<para/>
<para>Xsession (Modifying startx)Примечание: This is for NVIDIA users. </para>
<para>Предупреждение: This currently will not work for ATI users because of the display issues, requiring to be run on DISPLAY=:1. </para>
<para>Примечание: I use simmilar configuration (see startx section) on ATI. Consider /usr/bin/Xgl :1 instead of /usr/bin/Xgl and starting Gnome at :1 as well, if DISPLAY:0 is problematic. --Ash 17:57, 11 September 2006 (UTC) </para>
<para/>
<para/>
<para>Copy /usr/bin/startx to /usr/bin/startxgl and change the following line towards the end of the file: Файл: /usr/bin/startxgl </para>
<para>xinit $clientargs -- $serverargs -deferglyphs 16 &amp;</para>
<para/>
<para>to </para>
<para>xinit $clientargs -- /usr/bin/Xgl $serverargs -ac -accel xv -accel glx:pbuffer -deferglyphs 16 &amp;</para>
<para/>
<para/>
<para>This does not start Compiz so create a small start script and add it to the gnome-session manager (Once GNOME is up. The first time, you will have to open a terminal and call the script manually.) Файл: /usr/bin/compizrc </para>
<para>#!/bin/bash</para>
<para>#</para>
<para># Start compiz within gnome-session</para>
<para>#</para>
<para>if [ `ps -A | grep Xgl | wc -l` == "1" ]; then</para>
<para>        LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ compiz --replace gconf &amp;</para>
<para>        gnome-window-decorator &amp;</para>
<para>#       setxkbmap -model pc105 -layout it -variant basic # Change according to your needs, and uncomment if needed</para>
<para/>
<para>#       Or like that, if you need to switch between layouts.</para>
<para>#       setxkbmap -model pc105 -layout "us,ru(winkeys)" -variant winkeys -option "grp:alt_shift_toggle,grp_led:scroll"</para>
<para/>
<para>fi</para>
<para>Примечание: This should start the desktop environment configured via XSESSION in /etc/rc.conf </para>
<para/>
<para/>
<para>Xfce4 </para>
<para/>
<para>With xfce4-session</para>
<para/>
<para>xfce4-session is installed by default as part of the xfce4 meta-package. If you installed xfce4 this way, the following will work. </para>
<para/>
<para>First, it is necessary to create a script that will start Compiz and gnome-window-decorator with the correct libraries and switches. Файл: /usr/bin/compizrc </para>
<para>LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib compiz --replace gconf &amp;</para>
<para>gnome-window-decorator</para>
<para>Code: Make the script executable </para>
<para>chmod 755 /usr/bin/compizrc</para>
<para/>
<para/>
<para>Now, edit the xfce4-session settings to point to this rather than xfwm4. Файл: /etc/xdg/xfce4-session/xfce4-session.rc </para>
<para>[Failsafe Session]</para>
<para>Count=4</para>
<para>Client0_Command=compizrc</para>
<para>Client0_PerScreen=False</para>
<para>Client1_Command=xfce4-panel</para>
<para>Client1_PerScreen=True</para>
<para>Client2_Command=xftaskbar4</para>
<para>Client2_PerScreen=True</para>
<para>Client3_Command=xfdesktop</para>
<para>Client3_PerScreen=False</para>
<para>Примечание: Instead of editing system-wide file you may also add above section to ~/.config/xfce4-session/xfce4-session.rc file. Note also that you may need to delete content of the ~/.cache/sessions directory, if you still have xfwm4 rather than Compiz running. </para>
<para/>
<para/>
<para/>
<para>Finally, create a script to start Xgl with Xfce4. Файл: /usr/bin/startxgl for NVIDIA </para>
<para>#!/bin/bash</para>
<para>Xgl -ac -accel xv:fbo -accel glx:pbuffer &amp;</para>
<para>xfce4-session</para>
<para>Файл: /usr/bin/startxgl for ATi </para>
<para>#!/bin/bash</para>
<para>Xgl -ac -accel xv:pbuffer -accel glx:pbuffer &amp;</para>
<para>xfce4-session</para>
<para>Code: Make the script executable </para>
<para>chmod 755 /usr/bin/startxgl</para>
<para/>
<para/>
<para>You will notice that xfce4-panel is now transparent, just like if you were using xfwm4's compositor. The pager will be distorted, but otherwise everything works beautifuly. Windows even minimize to the correct spot on the taskbar. </para>
<para/>
<para>Without xfce4-session</para>
<para/>
<para>If you compiled a minimal Xfce (without xfce4-session, xffm4, etc.), then you can use this altered startxgl script from the gnome script above: </para>
<para>#!/bin/bash</para>
<para>echo "&gt;Starting XGL at Display: $1"</para>
<para>echo "========= XGL ============"</para>
<para>Xgl :$1 -ac -accel xv -accel glx:pbuffer &amp;</para>
<para>sleep 3</para>
<para>echo "======= COMPIZ ==========="</para>
<para>DISPLAY=:$1 LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ compiz --replace switcher decoration wobbly fade minimize cube rotate zoom scale move resize place &amp;</para>
<para>sleep 3</para>
<para>echo "======= XFCE ============"</para>
<para>DISPLAY=:$1 xfce-mcs-manager</para>
<para>DISPLAY=:$1 gnome-window-decorator &amp;</para>
<para>DISPLAY=:$1 xftaskbar4 &amp;</para>
<para>DISPLAY=:$1 xfdesktop &amp;</para>
<para>DISPLAY=:$1 exec xfce4-panel</para>
<para/>
<para>Again, xfce4-panel will be transparent as if you had the X.org composite extension turned on (but you don't) or if you use xfce4-svn, and the pager will be distorted. Everything else should be fine. </para>
<para/>
<para>With startxfce4</para>
<para/>
<para>To do it the old fashioned, or 'normal' way via startx/startxfce4 I did the following. First, startxfce4 shouldn't be called I don't think. just use an .xinitrc in your homedir and startx. Файл: ~/.xinitrc </para>
<para>#!/bin/sh</para>
<para>/usr/bin/startxfce4</para>
<para/>
<para/>
<para>Now as root, we create compizrc, like above. Note however that for me, it worked best/only without the DISPLAY variable. Файл: /usr/bin/compizrc </para>
<para>#!/bin/bash</para>
<para>LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ compiz --replace gconf &gt; ~/compiz.log 2&gt;&amp;1 &amp;</para>
<para>sleep 1;</para>
<para>gnome-window-decorator &gt; ~/gnome-window.log 2&gt;&amp;1 &amp;</para>
<para/>
<para/>
<para>Obviously the output redirections are optional (but handy for debugging). The sleep 1; might also be removed to speed things up. If things go TO fast however, you might get in trouble though. Don't forget to chmod 755 /usr/bin/compizrc </para>
<para/>
<para>Lastly we need to use this new compizrc instead of the default xfce4 window manager. </para>
<para/>
<para>Again, as root edit /etc/xdg/xfce4-session/xfce4-session.rc and replace xfwm4 with compizrc Файл: /etc/xdg/xfce4-session/xfce4-session.rc (old) </para>
<para>Client0_Command=xfwm4</para>
<para>Файл: /etc/xdg/xfce4-session/xfce4-session.rc (new) </para>
<para>Client0_Command=compizrc</para>
<para/>
<para/>
<para>Now only one thing is left, start Xgl. As above you can copy startx in /usr/bin/startx to /usr/bin/startxgl and make the following change: Файл: /usr/bin/startxgl (old) </para>
<para/>
<para>xinit $clientargs -- $serverargs -deferglyphs 16 &amp; </para>
<para>Файл: /usr/bin/startxgl (new) </para>
<para/>
<para>xinit $clientargs -- /usr/bin/Xgl -ac -accel xv -accel glx:pbuffer $serverargs -deferglyphs 16 &amp; </para>
<para/>
<para/>
<para>Примечание: Todo: Make Client0_Command depend on wether startx or startxgl is beeing used as 3D apps don't appear to work as they should and switching back to the 'old way' is required. </para>
<para/>
<para/>
<para>Edit: it seams that when using the startxfce4 script, the /etc/xdg/xfce4-session/xfce4-session.rc file (and the .xinitrc) get ignored thus starting a non Xgl desktop. Making 'switchin' not needed. startxfce4 for oldschool, startxgl for new style </para>
<para/>
<para>Entrance </para>
<para>Emerge latest entrance: </para>
<para>echo "=x11-misc/entrance-0.9.0.007 ~x86" &gt;&gt; /etc/portage/package.keywords</para>
<para>emerge -av entrance</para>
<para>Use the ecore_config utility to change the xserver string (choose according to your video card): </para>
<para># ATI</para>
<para>ecore_config -k "/entranced/xserver" -s "/usr/bin/Xgl -ac -accel xv:pbuffer -accel glx:pbuffer -nolisten tcp"  -c /etc/entrance_config.cfg</para>
<para># NVIDIA</para>
<para>ecore_config -k "/entranced/xserver" -s "/usr/bin/Xgl -ac -accel xv:fbo -accel glx:pbuffer -nolisten tcp"  -c /etc/entrance_config.cfg</para>
<para>Restart entrance.</para>
<para/>
<para>Qingy </para>
<para/>
<para>It is quite easy to change Qingy to start Xgl instead of a regular X server. All you need to do to make it start Xgl is change 2 lines in /etc/qingy/settings Файл: /etc/qingy/settings </para>
<para>...</para>
<para># x_server = "/usr/X11R6/bin/XFree86"</para>
<para>x_server = "/usr/bin/Xgl"</para>
<para># x_args = "-nolisten tcp"</para>
<para>x_args = "-ac -accel xv -accel glx:pbuffer -nolisten tcp"</para>
<para>...</para>
<para/>
<para/>
<para>Now Qingy should start Xgl instead of regular X. To make KDE and GNOME load Compiz you need to export a variable. KDEWM for KDE and WINDOW_MANAGER for GNOME. It is easiest to do this in /etc/X11/Sessions. </para>
<para/>
<para>You need to have followed the instructions for adding plugins to gconf-editor. Then make a /usr/bin/compizrc as shown and chmod +x it. Файл: /usr/bin/compizrc </para>
<para>#!/bin/bash</para>
<para>LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib compiz --replace gconf &amp;</para>
<para>sleep 2</para>
<para>gnome-window-decorator &amp;</para>
<para>setxkbmap -model itouch -layout gb &amp; ## Change/Remove as appropriate</para>
<para/>
<para/>
<para>Then edit the appropriate file (or both) in /etc/X11/Sessions</para>
<para>For KDE: Файл: /etc/X11/Sessions/kde-3.5 </para>
<para>#!/bin/sh</para>
<para>export KDEWM="/usr/bin/compizrc"</para>
<para>exec /usr/kde/3.5/bin/startkde</para>
<para/>
<para/>
<para>Or for GNOME add this to the top of the file : Файл: /etc/X11/Sessions/Gnome </para>
<para>#!/bin/sh</para>
<para/>
<para>export WINDOW_MANAGER="/usr/bin/compizrc"</para>
<para/>
<para>...</para>
<para/>
<para/>
<para>For Xfce4 edit /etc/xdg/xfce4-session/xfce4-session.rc as shown in a previous section.</para>
<para>Hopefully Qingy should now start Xgl and Compiz instead of X and some other WM. </para>
<para/>
<para>Generic startxgl script</para>
<para/>
<para>There is a generic startup script in the overlay. For usage instructions start it without arguments. </para>
<para>Currently it support Xfce, Xfce-svn, GNOME and KDE. </para>
<para>cd /usr/local/overlays/xgl-coffee</para>
<para>./startxgl</para></sect4></sect3><sect3><title>Автоматическое переключение раскладок</title>
<para>Для начала сделаем ebuild в portage overlay </para>
<para/>
<para>Создаём каталог:</para>
<para>mkdir -p /usr/local/portage/x11-misc/xneur cd /usr/local/portage/x11-misc/xneur </para>
<para/>
<para>Создаём ebuild:</para>
<para> nano -w xneur-0.1.0_1.ebuild Файл: /usr/local/portage/x11-isc/xneur/xneur-0.1.0_1.ebuild </para>
<para># Copyright 1999-2005 Gentoo Foundation</para>
<para># Distributed under the terms of the GNU General Public License v2</para>
<para/>
<para>DESCRIPTION="It's program like Punto Switcher, but has other final aim."</para>
<para>SRC_URI="http://www.xneur.ru/xneur/${P}.tar.gz"</para>
<para>HOMEPAGE="http://www.xneur.ru/"</para>
<para>DEPEND="virtual/x11"</para>
<para/>
<para>LICENSE="GPL-2"</para>
<para>SLOT="0"</para>
<para>KEYWORDS="~x86 ~amd64 ~sparc ~alpha ~ppc ~hppa ~ppc64"</para>
<para/>
<para>src_install () {</para>
<para>       make DESTDIR=${D} install || die</para>
<para>       #dodoc AUTHORS README COPYING INSTALL NEWS ChangeLog TODO .xneurrc</para>
<para>}</para>
<para/>
<para>pkg_postinst() {</para>
<para>      # einfo "Run:"</para>
<para>      # einfo "gzcat /usr/doc/${P}/.xneurrc.gz &gt; ~/.xneurrc"</para>
<para>}</para>
<para/>
<para/>
<para>Далее: ebuild xneur-0.1.0_1.ebuild digest Поскольку у нас бэта: echo "x11-misc/xneur ~x86" &gt;&gt; /etc/portage/package.keywords emerge xneur ;) </para>
<para/>
<para>А за подробностями на <ulink url="http://www.xneur.ru/">http://www.xneur.ru/</ulink>
</para>
<para/></sect3><sect3><title>Cedega 5.1</title><sect4><title>Введение</title>
<para/>
<para>Cedega - коммерческая версия ПО для реализации WinAPI на *nix-платформах WINE, разработанная Transgaming, ранее известная как Winex. Поддерживается большинство популярных игр. В последней версии добавилась официальная поддержка Sid Meier's Civilization® IV, FIFA® 06 и Need for Speed™: Most Wanted. </para>
<para/>
<para>Cedega 5.1 состоит из двух компонентов: </para>
<para>Point-to-play - графический интерфейс для простой установки игр, распространяется в виде .rpm/.deb/.tgz </para>
<para>Engine / engine update - модифицированный WINE, распространяется в виде файлов .cpkg - tar архивы, содержащие tgz архив и файл manifest с номером версии . </para>
<para/></sect4><sect4><title>Установка</title>
<para/>
<para>Установка самого эмулятора, без неудобного в использовании Point-to-play выглядит так: </para>
<para>Code: Установка Cedega </para>
<para>su</para>
<para>tar -zxf cedega-engine-5.1-local-update.i386.cpkg</para>
<para>tar -C /usr -zxf cedega_5.1-1.i386.p2p.tgz bin winex</para>
<para>mv /usr/share/share/doc/* /usr/share/doc</para>
<para>mv /usr/share/share/man/man1/* /usr/share/man1</para>
<para>mv /usr/bin/winex3 /usr/bin/cedega</para>
<para>mkdir /usr/lib/transgaming/cedega; mv /usr/winex /usr/lib/transgaming_cedega</para>
<para>exit</para>
<para/>
<para/>
<para>Первоначальная настройка</para>
<para>Code: Первоначальная настройка </para>
<para>tar -C $HOME -zxf cedega_5.1-1.i386.p2p.tgz .transgaming</para>
<para>nano ~/.transgaming/config</para>
<para/>
<para>Проверка</para>
<para/>
<para>cedega -version</para>
<para/></sect4></sect3></sect2><sect2><title>Секреты командной строки</title>
<para/><sect3><title/><sect4><title>Общие команды</title>
<para/>
<para>поиск команды Linux, ее описания и номера секции man страниц </para>
<para/>
<para>apropos word </para>
<para>закодировать файл file с помощью GnuPG </para>
<para/>
<para>gpg -c file </para>
<para>раскодировать файл file </para>
<para/>
<para>gpg file.gpg </para>
<para>быстрый поиск по словарю слов, начинающихся с word </para>
<para/>
<para>look word </para>
<para>подсветить слово word в файле /somefile </para>
<para/>
<para>grep --color word /somefile </para>
<para>запустить command с низким приоритетом </para>
<para/>
<para>nice command </para>
<para>назначить низший приоритет текущему шеллу (и всем потомкам). Может быть полезно, если вашу систему сильно замедляет установка нового пакета (emerge). Кстати, для автоматического понижения приоритета emerge используется переменная PORTAGE_NICENESS в файле /etc/make.conf </para>
<para/>
<para>renice 19 -p $$ </para>
<para>посмотреть код завершения предыдущей команды </para>
<para/>
<para>echo $? </para>
<para>скачать список новых страничек с нашего сайта в 01:00 в текущую директорию </para>
<para/>
<para>echo "wget http://ru.gentoo-wiki.com/Special:Newpages" | at 01:00 </para>
<para>в 17:45 послать пустое письмо с заголовком 'got the r00t?'на bugs@microsoft.com </para>
<para/>
<para>echo "mail -s 'got the r00t?' bugs@microsoft.com &lt; /dev/null" | at 17:45 </para>
<para>напечатать 1234 в соответствии с настройками локали (в России обычно 1.234) </para>
<para/>
<para>printf "%'d\n" 1234 </para>
<para>запускать просмотр прерываний каждую секунду </para>
<para/>
<para>watch -n1 "cat /proc/interrupts" </para>
<para>посмотреть, сколько времени занимает выполнение команды </para>
<para/>
<para>time command </para>
<para>удобный алиас для вывода дампа </para>
<para/>
<para>alias hd='od -Ax -tx1z -v' </para>
<para>полный путь к команде command </para>
<para/>
<para>which command </para>
<para>вывести в 9 колонок по ширине терминала </para>
<para/>
<para>ls | pr -T9 -W$COLUMNS </para>
<para>установить время изменения для файла file (в формате YYMMDDhhmm) </para>
<para/>
<para>touch -c -t 0304050607 file </para>
<para>показать иерархию запущенных процессов </para>
<para/>
<para>pstree -p </para>
<para>показать процессы, использующие файл /dir/file (чаще всего использую нечто вроде 'lsof /mnt/cdrom'). Не забудьте сделать 'emerge -n lsof' </para>
<para/>
<para>lsof /dir/file </para>
<para/></sect4></sect3><sect3><title/><sect4><title>Ввод-вывод</title>
<para>объединить stderr и stdout (вернее сказать перенаправить stderr в stdout) </para>
<para/>
<para>gcc file.c 2&gt;&amp;1 | less </para>
<para>Перенаправить stderr в файл errors.log а stdout в файл compile.log для дальнейшего анализа </para>
<para/>
<para>gcc file.c 2&gt;errors.log 1&gt;compile.log </para>
<para>Если нужно запретить вывод потока (например убрать в скрипте сообщения об ошибках) то достаточно перенаправить поток на устройство /dev/null, тогда сообщения уйдут в никуда: </para>
<para/>
<para>rm -r /var/tmp/portage 2&gt;&amp;1 &gt;/dev/null или rm -r /var/tmp/portage &amp;&gt; /dev/null </para>
<para>Порой нужно обьединить выходной поток сразу нескольких комманд, а поток одной изних отключить, тогда группу нужно объединить в скобки: </para>
<para/>
<para>( cat /etc/gentoo-release ; cat /etc/passwd &gt;/dev/null; cat /etc/group ) |less </para>
<para/>
<para>Навигация по директориям.</para>
<para>вернуться в предыдущую директорию (не путать с 'cd ..') </para>
<para/>
<para>cd - </para>
<para>вернуться в домашнюю директорию </para>
<para/>
<para>cd </para>
<para>перейти в директорию dir, запустить command и автоматически вернуться назад </para>
<para/>
<para>(cd dir; command) </para>
<para>добавить текущую директорию в стек, чтобы потом можно было сделать popd и вернуться к ней </para>
<para/>
<para>pushd . </para>
<para/></sect4></sect3><sect3><title/><sect4><title>Дисковое пространство</title>
<para>показать список файлов с информацией о каждом файле (-l), отсортировав список по убыванию размера (-S) и перевернуть список (-r). Получим сортировку по возрастанию. </para>
<para/>
<para>ls -lSr </para>
<para>показать, сколько места на диске занимает файл file и директория dir </para>
<para/>
<para>du -sh file dir </para>
<para>показать свободное место на примонтированных ресурсах </para>
<para/>
<para>df -h </para>
<para>то же самое но в инодах </para>
<para/>
<para>df -i </para>
<para>показать геометрию размещения разделов жесткого диска (нужны права root) </para>
<para/>
<para>fdisk -l </para>
<para/></sect4></sect3><sect3><title/><sect4><title>Работа с CD</title>
<para>создать iso-образ диска и заархивировать его </para>
<para/>
<para>dd bs=1M if=/dev/cdrom | gzip &gt; cdrom.iso.gz </para>
<para>создать iso-образ из директории dir </para>
<para/>
<para>mkisofs -r dir | gzip &gt; cdrom.iso.gz </para>
<para>смонтировать cdrom.iso в /mnt/dir (для просмотра и правки) </para>
<para/>
<para>mount -o loop cdrom.iso /mnt/dir </para>
<para>записать архивированный образ на диск </para>
<para/>
<para>gzip -dc cdrom.iso.gz | cdrecord dev=0,0,0 - </para>
<para>рипнуть дорожки с Audio-CD в текущую директорию (в формате .wav) </para>
<para/>
<para>cdparanoia -B </para>
<para>создать Audio-CD из всех .wav файлов в текущей директории </para>
<para/>
<para>cdrecord dev=0,0,0 -audio *.wav </para>
<para>конвертировать файл track.cdda.wav формат .ogg </para>
<para/>
<para>oggenc --tracknum="track" track.cdda.wav -o "track.ogg" </para>
<para/></sect4></sect3><sect3><title/><sect4><title>Работа с архивами</title>
<para>создать архив директории dir </para>
<para/>
<para>tar c dir/ | bzip2 &gt; dir.tar.bz2 </para>
<para/>
<para>tar -cjf dir.tar.bz2 dir </para>
<para>извлечь архив в директорию /to/dir (без '-C /to/dir' в текущую директорию) </para>
<para/>
<para>bzip2 -dc dir.tar.bz2 | tar x -С /to/dir </para>
<para/>
<para>tar -xjf dir.tar.bz2 -C /to/dir </para>
<para>создать архив всех .png файлов в директории dir/ </para>
<para/>
<para>find dir/ -name "*.png" | xargs tar rf dir.tar; bzip2 dir.tar </para>
<para>скопировать (с сохранением прав доступа!) директорию /dir/to/copy/ в /where/to/ </para>
<para/>
<para>( tar cf - /dir/to/copy ) | ( cd /where/to/ &amp;&amp; tar xf - ) </para>
<para>скопировать (с сохранением прав доступа!) содержимое директории /dir/to/copy в /where/to/ </para>
<para/>
<para>( cd /dir/to/copy &amp;&amp; tar cf - . ) | ( cd /where/to/ &amp;&amp; tar xf - ) </para>
<para>скопировать (с сохранением прав доступа!) директорию /dir/to/copy/ в директорию /where/to/ на удаленной машине </para>
<para/>
<para>( tar cf - /dir/to/copy ) | gzip | ssh user@remote 'cd /where/to/ &amp;&amp; gzip -dc | tar xf -' </para>
<para>создать и сохранить бэкап жесткого диска на удаленной машине </para>
<para/>
<para>dd bs=1M if=/dev/hda | gzip | ssh user@remote 'dd of=hda.gz' </para>
<para/></sect4></sect3><sect3><title/><sect4><title>Работа с файлами</title>
<para>удобный листинг по команде l </para>
<para/>
<para>alias l='ls -l --color=auto' </para>
<para>вывести листинг с упорядочиванием по дате </para>
<para/>
<para>ls -lrt </para>
<para>показать в папке dir файлы модифицированные раньше, чем 2 дня назад </para>
<para/>
<para>find dir -mtime +2 </para>
<para>удаляем в папке dir файлы старше 1 часа </para>
<para/>
<para>find dir -type f -mmin +60 -exec rm -f {} \; </para>
<para>удаляем в папке dir файлы старше 10 дней </para>
<para/>
<para>find dir -type f -mtime +10 -exec rm -f {} \; </para>
<para>найти в текущей директории (и ниже) .c и .h файлы содержащие строку "search string" </para>
<para/>
<para>find -name "*.[ch]" | xargs grep -E "search string" </para>
<para>искать строку "search string" только в обычных файлах </para>
<para/>
<para>find -type f | xargs grep -E "search string" </para>
<para>искать строку "search string" только в текущей директории (не спускаться ниже) </para>
<para/>
<para>find -type f -maxdepth 1 | xargs grep -E "search string" </para>
<para>в текущей директории найти все файлы с расширением sql содержащие USER1 и заменить в них USER1 на USER2 </para>
<para/>
<para>tmp="/tmp/$RANDOM$$.tmp"; f="USER1"; r="USER2"; </para>
<para/>
<para>find . -name '*.sql' -exec grep -l "$f" {} \; | </para>
<para/>
<para>xargs --replace="{}" bash -c "( sed 's/$f/$r/g' &lt; {} &gt; $tmp &amp;&amp; cat $tmp &gt; {} &amp;&amp; rm -f $tmp )" </para>
<para>найти файл в базе данных программы slocate. Замечание: данное регулярное выражение эквивалентно маске *file*.txt </para>
<para/>
<para>locate -r 'file[^/]*\.txt' </para>
<para/></sect4></sect3><sect3><title/><sect4><title>Работа с файловой системой</title>
<para>отформатировать флоппи-диск с FAT </para>
<para/>
<para>mkdosfs -c -f 16 -n "название тома" /dev/fd0 или mkfs -t fat16 /dev/fd0 </para>
<para>"правильная" кодировка и права файлов для сменных носителей (floppy, CD, flash) </para>
<para/>
<para>необходимо прописать в /etc/fstab!!! </para>
<para>для CDROM</para>
<para>/dev/cdrom /mnt/cdrom iso9660 ro,nosuid,noauto,exec,user,nodev 0 0 </para>
<para/>
<para>для "дискетки"</para>
<para>/dev/fd0 /mnt/floppy vfat iocharset=koi8-r,sync,nosuid,codepage=866,user,--,noauto,nodev,unhide 0 0 </para>
<para/>
<para>для раздела Windows</para>
<para>/dev/hda1 /mnt/win vfat user,exec,umask=0,codepage=866,iocharset=koi8-r 0 0 </para>
<para>для "флешки"</para>
<para/>
<para>/dev/sda1 /mnt/flash vfat user,exec,umask=0,sync,codepage=866,iocharset=koi8-r 0 0 </para>
<para>вышенаписанное справедливо для локали koi8-r, ваша может отличаться (см. locale), в этом случае все "koi8-r" необходимо исправить на свои, и помните, что это, лишь, пример </para>
<para/></sect4></sect3><sect3><title/><sect4><title>Работа с календарем</title>
<para>вывести на экран календарь на текущий, предыдущий и следующий месяцы </para>
<para/>
<para>cal -3 </para>
<para>на какой день недели выпал в этом году день рождения Linux? </para>
<para/>
<para>date --date='25 Aug' +%A </para>
<para>конвертировать в дату (в соответствии с локалью) - 130204800 секунд, прошедшие с начала эпохи Unix </para>
<para/>
<para>date --date '1970-01-01 UTC 130204800 seconds' </para>
<para>Сколько сейчас времени на западном побережьи США (используйте tzselect чтобы узнать параметр для TZ) </para>
<para/>
<para>TZ="America/Los_Angeles" date </para>
<para/></sect4></sect3><sect3><title/><sect4><title>Работа с сетью</title>
<para>(Предварительно сделать emerge на net-tools, sys-apps/iproute2, net-dns/bind-tools)</para>
<para>показать сетевые интерфейсы </para>
<para/>
<para>ip link show </para>
<para>показать статус сетевых интерфейсов </para>
<para/>
<para>ethtool interface или /sbin/ifconfig </para>
<para>переименовать eth0 в wan </para>
<para/>
<para>ip link set dev eth0 name wan </para>
<para>добавить ip 1.2.3.4 с маской 255.255.255.0 на eth0 </para>
<para/>
<para>ip addr add 1.2.3.4/24 brd + dev eth0 </para>
<para>поднять интерфейс </para>
<para/>
<para>ip link set dev interface up </para>
<para>опустить интерфейс </para>
<para/>
<para>ip link set dev interface down </para>
<para>сделать шлюзом по умолчанию 1.2.3.254 </para>
<para/>
<para>ip route add default via 1.2.3.254 </para>
<para>показать ip адрес для name </para>
<para/>
<para>host name </para>
<para>показать прослушиваемые порты в системе (и кто их слушает) </para>
<para/>
<para>netstat -lp --inet </para>
<para>показать активные соединения </para>
<para/>
<para>netstat -p --inet </para>
<para/></sect4></sect3><sect3><title/><sect4><title>Математика</title>
<para>простое вычисление </para>
<para/>
<para>echo "(321-123)/123" | bc -l </para>
<para>простое целочисленное вычисление с использование bash </para>
<para/>
<para>echo "$(( (51+123)/2 ))" </para>
<para>использование python для научных вычислений </para>
<para/>
<para>echo "print (10E3-123)/123" | python </para>
<para>приведение систем счисления (в данном случае, десятичной к шестнадцатеричной) </para>
<para/>
<para>echo "obase=16;ibase=10;123" | bc </para>
<para>Более сложное вычисление - максимальная скорость передачи (в пакетах в секунду) в Fast Ethernet сети (100Mb) </para>
<para/>
<para>echo "framing=20; minsize=64; (100*10^6)/((framing+minsize)*8)" | bc </para>
<para>А здесь мы строим график зависимости скорости передачи от размера пакета всё в той же 100-мегабитной сети. </para>
<para/>
<para>echo "framing=20; plot [64:1518] (100*10**6)/((framing+x)*8)" | gnuplot -persist </para>
<para/>
<para/></sect4></sect3></sect2><sect2><title>Тонкость работы ccache с emerge</title>
<para/>
<para>Вы пробовали оценить эффективность работы ccache при пересборке системы? Проделайте опыт: очистите кэш (ccache -C) и запустите пересборку (emerge --emptytree world). После пересборки десятка-другого пакетов прервите процесс и посмотрите статистику (ccache -s) Запустите пересборку по новой и опять прервитесь на старом месте. Что показывает статистика? Много ли совпадений? </para>
<para/>
<para>А теперь добавьте в /etc/make.conf строчки </para>
<para>CC=gcc </para>
<para>CXX=g++ </para>
<para/>
<para>очистите кэш и статистику и повторите эксперимент заново. Не правда ли, что после этого кэш только и заработал? </para>
<para/>
<para>Суть: по состоянию на апрель 2005 ccache опознает как компилятор только стандартные имена типа gcc, g++ и не опознает такие имена как i686-pc-linux-gnu-gcc. Однако именно такие имена и используют пакеты в качестве компилятора после работы скриптов кофигурации configure </para>
<para/></sect2><sect2><title>Keymap</title>
<para/>
<para>Варианты раскладок клавиатуры для прописывания в /etc/conf.d/keymaps (в старых версиях baselayout переменная находится в файле /etc/rc.conf) Файл: /etc/conf.d/keymaps </para>
<para>...</para>
<para>KEYMAP="-u ru4"</para>
<para>...</para>
<para>Доступные варианты: </para>
<para>ru -- кодировка KOI-8, переключение [Right-Ctrl], одиночный символ [Right-Alt] </para>
<para>ru1 -- кодировка KOI-8, переключение [Right-Alt] </para>
<para>ru2 -- альтернативная кодировка (IBM866), переключение [Right-Alt] </para>
<para>ru3 -- кодировка KOI-8, 102 кнопочная клавиатура, переключение [CapsLock], [Shift+CapsLock] -- фиксация регистра </para>
<para>ru4 -- кодировка KOI-8, 105 кнопочная клавиатура, переключение [CapsLock], [Shift+CapsLock] -- фиксация регистра </para>
<para>ru-cp1251 -- кодировка CP1251, переключение [Right-Ctrl], одиночный символ [Right-Alt] </para>
<para>ru-ms -- раскладка как в Microsoft Cyrillic keyboard layout, переключение [Right-Ctrl] </para>
<para>ru_win -- кодировка CP1251, переключение [Right-Ctrl], одиночный символ [Right-Alt] </para>
<para>ru-yawerty -- кодировка KOI-8, раскладка "ЯВЕРТЫ" (это бывает удобно при работе на клавиатуре без русских символов), переключение [Right-Alt] </para>
<para/>
<para>Вариант, которого нет в стандартной поставке, но весьма удобен ru-utf. Переключение [Right-Ctrl], одиночный символ [Right-Alt]. Брать тут: http://mlclm.narod.ru/ru-utf.map.gz, сохранить в каталог /usr/share/kbd/keymaps/i386/qwerty или в случае отсутствия этого, в каталог /usr/share/keymaps/i386/qwerty. </para>
<para/>
<para>Кроме того есть вариант ru-mab. Он даёт переключение по [Ctrl+Shift]. Взять можно тут: http://moose.ylsoftware.com/gentoo.ru/ru-mab.map.gz Code: /etc/conf.d/keymaps </para>
<para>...</para>
<para>KEYMAP="ru-utf"</para></sect2><sect2><title/></sect2><sect2><title/>
<para/>
<para/></sect2></sect1><sect1><title>Часто задаваемые вопросы</title>
<para/>
<para/><sect2><title>2. Введение</title>
<para/><sect3><title>Как произносится слово Gentoo, и что оно означает?</title>
<para/>
<para>Gentoo (Хинду) это вид маленького и быстрого пингвина, произносится по-английски как "gen-too" (джин-туу). Научное название пингвина - Pygoscelis papua. Имя Gentoo было дано пингвину жителями Фолклендских (Мальвинских) Островов (Islas Malvinas). По-русски прижилось произношение Gentoo как "генту". </para>
<para/></sect3><sect3><title>Что делает Gentoo особенным?</title>
<para/>
<para>Gentoo использует похожую на порты BSD систему, называемую Portage (англ.). Portage - это система управления пакетами, дающая огромную гибкость при установке и сопровождении программного обеспечения в системе Gentoo. Она предоставляет поддержку директив времени компиляции (с помощью USE-флагов), условные зависимости, сведения о пакете перед его установкой, безопасную установку (через "песочницу") и удаление ПО, системные профили, защиту конфигурационных файлов, а также многие другие возможности. </para>
<para/>
<para>С Gentoo вы можете построить всю свою систему из исходных кодов, используя необходимую вам оптимизацию. Вы полностью контролируете, какие пакеты устанавливать, а какие нет. Gentoo предоставляет множество вариантов установки, удовлетворяющие вашим запросам, поэтому его называют метадистрибутивом. </para>
<para/>
<para>Gentoo активно развивается. Поддерживается высокий темп разработки: заплатки быстро включаются в основное дерево проекта, документация обновляется ежедневно, часто добавляются новые функции в Portage, а официальные выпуски выходят дважды в год. </para>
<para/></sect3></sect2><sect2><title>3. Установка</title>
<para/><sect3><title>Все работает очень нестабильно, мои флаги оптимизации "-O9 -ffast-math -fomit-frame-pointer". В чем проблема? </title>
<para/>
<para>Не пробуйте использовать что-либо выше, чем -O3 т.к. это не поддерживается текущими версиями gcc. Очень агрессивная оптимизация иногда заставляет компилятор изменять ассемблерный код так, что он уже выполняет несколько другие действия, чем предполагалось. </para>
<para/>
<para>Попробуйте компилировать с флагами CFLAGS -O2 -march=&lt;your_arch&gt; прежде чем сообщать об ошибках. </para>
<para/></sect3><sect3><title>Как изменить пароль root (или любого другого пользователя)?</title>
<para/>
<para>Используйте passwd, чтобы сменить пароль пользователя, под именем которого вы вошли. Как root, вы можете сменить пароль любого пользователя в системе командой passwd username. Дополнительные параметры смотрите на странице: man passwd. </para>
<para/></sect3><sect3><title>Как добавить обычного пользователя?</title>
<para/>
<para>Команда adduser username добавит пользователя с именем "username". Однако, такой метод не даст пользователю некоторые права которые вы, возможно, хотите ему предоставить, поэтому предпочтительней использовать: </para>
<para/>
<para>Листинг 3.1: Использование useradd</para>
<para># useradd -m -G users,audio,wheel username</para>
<para/>
<para>В итоге в системе появится пользователь с именем "username". Параметр audio добавит его в группу audio и позволит пользователю работать со звуковыми платами. Параметр wheel добавит пользователя в группу wheel, которая позволит ему запускать команду su, чтобы получить привилегии суперпользователя. </para>
<para/></sect3><sect3><title>Почему пользователь не может получить права root командой su?</title>
<para/>
<para>В целях безопасности, пользователи могут выполнять команду su, только если они состоят в группе wheel. Чтобы добавить пользователя в группу wheel, выполните следующую команду из-под root: </para>
<para/>
<para>Листинг 3.2: Добавление пользователя в группу wheel</para>
<para># gpasswd -a username wheel</para>
<para/></sect3><sect3><title>Как отключить devfs?</title>
<para/>
<para>Gentoo может работать с devfs, udev, а так же поддерживает статический /dev. С появлением ядра 2.6, которое стабильно на большинстве архитектур, рекомендуется использовать udev. Информацию по настройке udev можно найти в Руководстве по udev. </para>
<para>Если вы хотите использовать статический /dev, установите параметр RC_DEVICES="static" в /etc/conf.d/rc. </para>
<para/></sect3><sect3><title>Могу ли я обновить Gentoo без переустановки? </title>
<para/>
<para>На самом деле, нет разницы между разными версиями после их установки. Gentoo 1.4 и старше основаны на glibc-2.3.x. Поэтому, выполнив emerge --sync &amp;&amp; emerge -uDN world, вы приведете свою систему в самое актуальное состояние (latest Gentoo). Различия между отдельными версиями Gentoo заключаются в установочных носителях и прекомпилированных пакетах. Подробнее о профилях и о их роли при обновлении смотрите в руководстве по обновлению Gentoo. </para>
<para/></sect3><sect3><title>Ядро не загружается (правильно), что мне теперь делать?</title>
<para/>
<para>Вы не обязаны повторять каждый шаг установки, но понимание ядра и связанных с ним этапов установки необходимо. Предположим, вы установили Gentoo на /dev/hda1 (точка монтирования /boot) и /dev/hda3 (точка монтирования /) с разделом подкачки /dev/hda2: </para>
<para/>
<para>Листинг 3.3: Конфигурация ядра</para>
<para>Загрузитесь с установочного CD и дождитесь приглашения </para>
<para>командной строки</para>
<para>Сначала примонтируем все разделы:</para>
<para># mount /dev/hda3 /mnt/gentoo</para>
<para># mount /dev/hda1 /mnt/gentoo/boot</para>
<para># swapon /dev/hda2</para>
<para># mount -t proc none /mnt/gentoo/proc</para>
<para>Затем перейдем в вашу систему командой chroot </para>
<para>и настроим ядро:</para>
<para># chroot /mnt/gentoo /bin/bash</para>
<para># env-update &amp;&amp; source /etc/profile</para>
<para># cd /usr/src/linux</para>
<para># make menuconfig</para>
<para>Отметьте/уберите все что по вашему вы отметили/убрали неправильно</para>
<para>в прошлый раз</para>
<para>Затем выходите и откомпилируйте ядро:</para>
<para># make &amp;&amp; make modules_install</para>
<para>Теперь замените bzImage новой его версией:</para>
<para># cp arch/i386/boot/bzImage /boot/&lt;kernel_name&gt;</para>
<para>Если используете LILO, выполните lilo; пользователи GRUB - пропустите этот шаг:</para>
<para># /sbin/lilo</para>
<para>Теперь выйдите из среды chroot и перезагрузитесь.</para>
<para># exit</para>
<para># umount /mnt/gentoo/proc /mnt/gentoo/boot /mnt/gentoo</para>
<para># reboot</para>
<para/>
<para/>
<para>С другой стороны, проблема может быть с вашим загрузчиком; тогда поступите так же, только вместо конфигурирования/компилирования ядра перенастройте свой загрузчик (его перекомпиляция не нужна). </para>
<para/></sect3><sect3><title>Мой прокси-сервер требует аутентификации, что делать?</title>
<para/>
<para>Чтобы Portage автоматически использовал реквизиты, определите их в /etc/make.conf: </para>
<para/>
<para>Листинг 3.4: /etc/make.conf</para>
<para>HTTP_PROXY="http://username:password@yourproxybox.org:portnumber"</para>
<para>FTP_PROXY="ftp://username:password@yourproxybox.org:portnumber"</para>
<para>RSYNC_PROXY="rsync://username:password@yourproxybox.server:portnumber"</para>
<para/></sect3><sect3><title>Как записать ISO файл на компакт-диск?</title>
<para/>
<para>Вам необходимо записать его в raw-режиме. Это означает что вам нужно НЕ просто поместить его на CD, а интерпретировать сам файл как CD. </para>
<para/>
<para>Существует множество утилит для записи CD; рассказывать о них всех будет сизифовым трудом. Однако описать несколько популярных никогда не повредит: </para>
<para>Используя EasyCD Creator, выберите File, Record CD from CD image. Затем поменяйте тип файла на ISO image file. Найдите ISO-файл и кликните Open. При нажатии на Start recording, ISO образ будет записан на диск. </para>
<para>Используя Nero Burning ROM, закройте мастер, автоматически появляющийся при запуске, нажмите Burn Image из меню File. Выберите необходимый образ и нажмите Open. Теперь нажмите кнопку Burn и наблюдайте за процессом прожига вашего нового CD. </para>
<para>Используя cdrecord, просто наберите cdrecord dev=/dev/hdc (заменив /dev/hdc именем своего CD-RW привода), а затем имя ISO образа :) </para>
<para>Используя K3B, выберите Tools &gt; CD &gt; Burn CD Image. Затем найдите ISO образ, используя окно 'Image to Burn'. Наконец, Нажмите Start. </para>
<para>В Mac OS X Panther, запуститеDisk Utility из Applications/Utilities, нажмите Open из меню Images, в главном окне выберите примонтированный образ диска и нажмите Burn в меню Images. </para>
<para>В Mac OS X Jaguar, запустите Disk Copy из Applications/Utilities, выберите Burn Image из меню File, найдите образ ISO и нажмите кнопку Burn. </para>
<para/></sect3><sect3><title>Какой диск/стадию надо использовать с моим процессором?</title>
<para/>
<para>Для начала надо узнать, что за процессор вы используете. Предположим, что это Pentium-M. Теперь необходимо найти, с какими инструкциями процессора он совместим. Вы можете проконсультироваться на сайте производителя, однако обычно достаточно погуглить :-). </para>
<para/>
<para>Если вы не уверены, выберите "меньший" файл CD/stage, например, от i686 или даже универсальный x86 (или эквивалентный в своей архитектуре). Так вы можете быть уверены, что ваша система точно заработает, но будет работать не так быстро, как если бы она была скомпилирована с использованием флагов оптимизации. </para>
<para/>
<para>Учтите, что существует намного больше параметров, чем те с которыми скомпилированы бинарные пакеты Gentoo. Чтобы правильно выставить -march, ознакомьтесь с gcc guide. </para>
<para/></sect3><sect3><title>Я не могу выйти в интернет после перезагрузки. В чем может быть дело? </title>
<para/>
<para>Для начала проверьте, правильно ли определилась ваша сетевая карта ядром. Выполните ifconfig -a, найдите eth0 или wlan0 (если у вас беспроводная карта). Возможно, потребуется загрузить специфичный модуль ядра, чтобы ядро правильно опознало вашу сетевую карту. Если так, то убедитесь, что эти модули ядра перечислены в /etc/modules.autoload.d/kernel-2.6 (или kernel-2.4, если вы до сих пор используете ядро 2.4). </para>
<para/>
<para>Если вы забыли включить поддержку вашей карты в ядро, придется его переконфигурировать (и пересобрать). </para>
<para/>
<para>Если ваша сетевая карта найдена ядром, но настроена на использование DHCP, то вы могли забыть установить dhcpd (emerge dhcpcd). Необходимо загрузиться с установочного CD, чтобы установить dhcpcd. </para>
<para/>
<para>О том, как восстановить вашу систему, используя установочный CD, смотрите здесь. </para>
<para/></sect3><sect3><title>Я хочу загрузить Windows из GRUB или LILO, но вижу только черный экран. Что делать? </title>
<para/>
<para>Это известная проблема. Windows отказывается грузиться и показывает черный/пустой экран, если установлен не на первый жесткий диск. Чтобы исправить ситуацию, надо, используя настройку загрузчика, "надурить" Windows, чтобы она "думала" что установлена на первый жесткий диск. Учтите, что в следующем примере Gentoo установлен на hda (первый диск), а Windows на hdb (второй). Подправьте ваш конфигурационный файл соответственно. </para>
<para/>
<para>Листинг 3.5: Пример двойной загрузки для Windows в grub.conf</para>
<para>title Windows XP</para>
<para>     map (hd1) (hd0)</para>
<para>     map (hd0) (hd1)</para>
<para>     rootnoverify (hd1,0)</para>
<para>     chainloader +1</para>
<para/>
<para/>
<para>Листинг 3.6: Пример двойной загрузки для Windows в lilo.conf</para>
<para>other=/dev/hdb1</para>
<para>     label=WindowsXP</para>
<para>     table=/dev/hdb</para>
<para>     map-drive = 0x80</para>
<para>     to = 0x81</para>
<para>     map-drive = 0x81</para>
<para>     to = 0x80</para>
<para/>
<para/>
<para>Это заставит Windows поверить, что она установлена на первый жесткий диск, и грузиться без проблем. Дополнительную информацию можно найти в разделе Документация GRUB и в man lilo.conf, смотря, какой загрузчик используете. </para>
<para/></sect3><sect3><title>Как установить Gentoo, используя файл Stage1 или Stage2?</title>
<para/>
<para>Настольная книга Gentoo только объясняет, как установить ОС, используя файл stage3. Однако, все еще осталась возможность установки из stage1 или stage2. Возможность оставлена для нужд разработчиков (команда Release Engineering начинает со stage1, чтобы получить stage3), но не обязательна к использования пользователями: файл stage3 тоже очень хорошо подходит для самогенерации системы. Вам потребуется соединение с Интернетом. </para>
<para/>
<para>Самогенерация (bootstrapping) - построение набора инструментов (библиотека Си и компилятор) для системы, после чего устанавливаются пакеты, входящие в ядро системы. Чтобы сгенерировать систему, выполните установку со stage3. Перед главой настройка ядра, отредактируйте сценарий bootstrap.sh под ваши нужды, а затем выполните его: </para>
<para/>
<para>Листинг 3.7: Самогенерация системы</para>
<para># cd /usr/portage/scripts</para>
<para># vi bootstrap.sh</para>
<para/>
<para># ./bootstrap.sh</para>
<para/>
<para/>
<para>Затем пересоберите все ключевые системные пакеты только что собранным набором (библиотека - компилятор). Нам необходимо пересобрать их т.к. в файле stage3 они уже есть: </para>
<para/>
<para>Листинг 3.8: Пересборка ключевых системных пакетов</para>
<para># emerge -e system</para>
<para/>
<para>Теперь можно переходить к настройке ядра. Прекомпилированные пакеты GRP больше использовать нельзя. </para>
<para/></sect3></sect2><sect2><title>4. Управление пакетами</title>
<para/><sect3><title>В каком формате хранятся пакеты?</title>
<para/>
<para>Пакеты не "хранятся". Вместо этого Gentoo предоставляет набор сценариев, которые могут разрешать зависимости, закачивать исходный код, и компилировать версию пакета именно под ваши нужды. В общем, мы собираем двоичные файлы только для выпусков (версий) и снимков (snapshots). Gentoo Ebuild HOWTO (англ.) рассказывает о содержимом сценариев ebuild в деталях. </para>
<para/>
<para>Для полных ISO-выпусков, мы создаем полный набор двоичных пакетов в расширенном .tbz2 формате, который совместим с .tar.bz2 и включает метаинформацию, присоединенную к концу файла. Они могут использоваться для быстрой и эффективной установки работающей (правда, не очень оптимизированной) версии пакета. </para>
<para/>
<para>Также возможно создать RPM (файлы Redhat package manager) средствами Gentoo, но на данный момент нельзя использовать уже готовые RPM для установки. </para>
<para/></sect3><sect3><title>Я хочу выполнить сценарий ./configure сам. Возможно ли это?</title>
<para/>
<para>Да, но это не так просто, и не рекомендуется. Т.к. вы все равно должны понимать, как работает Portage, то лучше сделайте заплатку для ebuld-файла, выполняющую то, что вы хотите, и положите ebuild-файл в оверлей Portage (для этого он и существует). Такой подход более подходит для поддержки, и обычно легче. Чтобы узнать больше, см. Ebuild HOWTO (англ.). </para>
<para/></sect3><sect3><title>Как использовать emerge, если я за межсетевым экраном?</title>
<para/>
<para>Смотрите вопросы о proxy, rsync, и Закачка исходных кодов вручную. </para>
<para/></sect3><sect3><title>Что делать, если rsync мне не подходит?</title>
<para/>
<para>Если вы за межсетевым экраном, который не пропускает rsync трафик, то вы можете использовать emerge-webrsync, который закачает и установит снимок дерева Portage через обычный HTTP. Обратите внимание на раздел proxy этого документа, чтобы выяснить, как закачивать исходные коды и снимки Portage через прокси-сервер. </para>
<para/></sect3><sect3><title>У меня дома лишь слабое модемное подключение. Могу ли я скачать исходные коды в другом месте, а затем добавить их в систему? </title>
<para/>
<para>Конечно. Выполните emerge --pretend package, чтобы понять, какие программы необходимо установить. Чтобы увидеть, какие исходные коды необходимо скачать и откуда, выполните emerge -fp package. Закачайте исходники, и принесите их на любом носителе домой. Скопируйте их в /usr/portage/distfiles/, затем просто наберите emerge package. Но имейте в виду: это нудное занятие. </para>
<para/></sect3><sect3><title>Исходные коды хранятся в /usr/portage/distfiles. Безопасно ли удалить их? </title>
<para/>
<para>Удаление этих файлов никак не повлияет на каждодневную производительность. Однако лучше оставить самые последние версии файлов; часто несколько файлов ebuild выпускаются с расчетом на одну и ту же версию исходных кодов. В таком случае, если вы удалили архивы с исходными текстами, а затем решили обновить ПО, потребуется заново скачать нужные исходники через Интернет. Существуют программы, разработанные пользователями, для удаления всех исходников, кроме самых последних версий. Заметьте, они хоть и работают, но официально не поддерживаются. Используйте их на свой страх и риск. </para>
<para/></sect3><sect3><title>Что находится в /var/tmp/portage? Можно ли удалить файлы и каталоги из /var/tmp/portage? </title>
<para/>
<para>Во время компиляции, Gentoo сохраняет исходники пакетов в /var/tmp/portage. Эти файлы и каталоги обычно удаляются после успешной установки, но не всегда. Можете спокойно очищать этот каталог, если emerge не запущен. Чтобы быть уверенным, всегда выполняйте pgrep emerge перед отчисткой каталога. </para>
<para/></sect3></sect2><sect2><title>5. Использование</title>
<para/><sect3><title>Как установить международную раскладку клавиатуры?</title>
<para/>
<para>Отредактируйте переменную KEYMAP в файле /etc/conf.d/keymaps. Чтобы консоль заработала правильно с расширенными знаками вашей раскладки, вам может также потребоваться настроить переменные CONSOLETRANSLATION и CONSOLEFONT у себя в /etc/conf.d/consolefont (за дальнейшими сведениями о локализации своей среды обращайтесь к нашему руководству по локализации (англ.). Затем выполните перезагрузку (reboot), или перезапустите сценарии keymaps и consolefont: </para>
<para/>
<para>Листинг 5.1: Перезагрузка keymaps</para>
<para># /etc/init.d/keymaps restart</para>
<para># /etc/init.d/consolefont restart</para>
<para/>
<para>Разрешение имен DNS работает только у суперпользователя.</para>
<para>У файла /etc/resolv.conf неправильно выставлены права; Выполните chmod, как описано ниже: </para>
<para>Листинг 5.2: Смена прав /etc/resolv.conf</para>
<para># chmod 0644 /etc/resolv.conf</para>
<para/>
<para/></sect3><sect3><title>Почему мой пользователь не может использовать свой файл crontab?</title>
<para/>
<para>Вы должны внести своего пользователя в группу cron. </para>
<para/></sect3><sect3><title>Как включить numlock при загрузке?</title>
<para/>
<para>Если вы работаете в командной строке, вам всего лишь необходимо выполнить </para>
<para>rc-update add numlock default &amp;&amp;/etc/init.d/numlock start. </para>
<para/>
<para>Каждый GUI предоставляет собственные средства для этого; смотрите раздел справки или руководство. </para>
<para/></sect3><sect3><title>Как сделать очистку терминала при выходе?</title>
<para/>
<para>Для этого добавьте clear в ваш сценарий ~/.bash_logout: </para>
<para/>
<para>Листинг 5.3: Очистка терминала при выходе</para>
<para>$ echo clear &gt;&gt; ~/.bash_logout</para>
<para/>
<para>Если вы хотите, чтобы у новых пользователей это работало автоматически, добавьте ту же строку в /etc/skel/.bash_logout: </para>
<para/>
<para>Листинг 5.4: Очистка экрана при выходе у новых пользователей</para>
<para># echo clear &gt;&gt; /etc/skel/.bash_logout</para>
<para/></sect3><sect3><title>Не удается запускать X приложения из-под root'а (после su)</title>
<para/>
<para>Похоже, что эта проблема появляется только при графическом входе. Пользователи, использующие startx, с ней не сталкиваются. Проблема в Gentoo's PAM, однако выход довольно прост: добавьте следующую строку в файл /etc/profile. </para>
<para>Листинг 5.5: Экспорт XAUTHORITY</para>
<para>export XAUTHORITY="${HOME}/.Xauthority"</para>
<para/>
<para/>
<para/>
<para/>
<para/></sect3></sect2><sect2><title>6. Сопровождение</title>
<para/><sect3><title>ReiserFS и порча файловых систем - как исправить, и т.п.</title>
<para/>
<para>Если раздел с ReiserFS испорчен, попытайтесь загрузится с установочного диска Gentoo и выполните reiserfsck --rebuild-tree на испорченной файловой системе. Эта команда предназначена для восстановления файловой системы, но все же из-за ее повреждения некоторые файлы или каталоги могут быть утеряны. </para>
<para/></sect3></sect2><sect2><title>7. Разработка</title>
<para/><sect3><title>Где оставлять сообщения об ошибках?</title>
<para/>
<para>Используйте нашу систему Bugzilla. Если вы не уверены в актуальности ошибки, можете зайти на канал #gentoo в сети IRC FreeNode </para>
<para/></sect3><sect3><title>Как часто появляются новые стабильные выпуски?</title>
<para/>
<para>Пакеты Gentoo обычно обновляются вскоре после обновления основного кода программы. А если речь идет о том, как часто выходят файлы стадий/профили/выпуски ISO самого дистрибутива, смотрите страницу Release Engineering Project (англ.) Новые стабильные версии анонсируются в списке рассылки gentoo-announce. Смотрите вопрос об обновлении. </para>
<para/></sect3><sect3><title>Мой динамик орет как сумасшедший. Как выключить динамик в консоли? </title>
<para/>
<para>Консольные звуки можно выключить, используя setterm: </para>
<para/>
<para>Листинг 7.1: Использование setterm</para>
<para># setterm -blength 0</para>
<para/>
<para>Если вы хотите, чтобы звуки выключались при загрузке, поместите эту команду в сценарий /etc/conf.d/local.start. Однако, это избавит вас от звуков только в текущем терминале. Чтобы выключить звук и на других терминалах, перенаправьте вывод команды на нужный терминал: </para>
<para/>
<para>Листинг 7.2: Использование setterm (bis)</para>
<para># setterm -blength 0 &gt;/dev/vc/1</para>
<para/>
<para/>
<para>Нужно заменить /dev/vc/1 на терминал, в котором вы хотите выключить звук. </para>
<para/>
<para/></sect3></sect2><sect2><title>8. Ресурсы</title>
<para/><sect3><title>Где найти информацию о Gentoo Linux?</title>
<para/>
<para>Официальная документация Gentoo находится по адресу http://www.gentoo.org/doc/ru/. </para>
<para/></sect3><sect3><title>Могу ли я купить CD с Gentoo Linux?</title>
<para/>
<para>Установочные диски для всех поддерживаемых архитектур имеются в нашем магазине Gentoo. При покупке дисков в нашем магазине, вы поддерживаете разработку дистрибутива. Поэтому, если можно, покупайте диски у нас. </para>
<para/>
<para>Также список продавцов находится на странице загрузки Gentoo Linux. </para>
<para/></sect3><sect3><title>В этом списке нет ответа на мой вопрос. Что делать?</title>
<para/>
<para>В первую очередь, просмотрите соответствующую документацию, если это не помогло, в Google можно найти всевозможные списки рассылки Gentoo. Чтобы искать в списках рассылки Gentoo, наберите "lists.gentoo.org что-то-там" в строке поиска. Если все попытки тщетны, и вы готовы просто покончить с Gentoo, сходите на irc канал: #gentoo on irc.freenode.net. </para>
<para>Примечание: Также можно заглянуть на http://forums.gentoo.org, где, ко всему прочему, есть русскоязычное сообщество пользователей - прим. Пер.</para></sect3></sect2></sect1><sect1><title>Наивные вопросы юных линуксоидов</title>
<para/><sect2><title>Вступление</title>
<para/>
<para>Перейдя из ОС Windows в Linux пользователи сталкиваются с кучей непонятных им вещей. Есть много вопросов которые их тревожат, но спросить они не решаються - боятся. Так давайте же поможем им поскорее разобраться с новой замечательной системой. Может и сами узнаем чего нового.Примечание: Так как Gentoo новичкам не поставить, то этот материал носит скорее пропагандистский характер </para>
<para/>
<para/>
<para>Общие вопросы</para>
<para/><sect3><title>Как ставить программы? </title>
<para/>
<para>Первая проблема которая встает перед линуксоидом это установка программ. Программы можно ставить из исходников и бинарных пакетов. На бинарниках завязаны такие дистрибутивы как RedHat, Mandrake, Fedore Core, ASP Linux, ALT Linux, Debian и прочие. С исходниками работают Gentoo Linux и *BSD-системы. </para>
<para/>
<para>Чтобы установить программу в Gentoo Linux нужно только ввести: emerge программа emerge скачает все необходимое с интернета, скомпилирует и установит. Если же программы нет в дереве портов, то придеться ставить ее из тарболла. </para>
<para/>
<para>Поправочка: В Gentoo тоже можно ставить прекомпиленные (заранее собранные) программы путем вызова команды: emerge --usepkg --getbinpkg программа или короче так: emerge -gk программа Но сборка из исходных текстов предпочтительнее. </para>
<para/></sect3><sect3><title>Что еще за тарболл? </title>
<para/>
<para>Все программы в исходных текстах поставляются в виде тарболлов (файлы с расширением tar.gz, tar.bz2, tbz2, tgz, впрочем последние два - большая редкость). Тарболл по своей сути - это просто архив, который можно распаковать следующими командами: tar -xvjf super_proga_0.1.tar.bz2 для tar.bz2(или tbz2) и tar -xvzf super_proga_0.1.tar.gz для tar.gz(tgz). И архив будет распакован в текущий каталог. </para>
<para/>
<para>Кстати -v - абсолютно лишнее. :) Dron </para>
<para/>
<para>Я бы сказал так, распаковка tar –zxvf , архивы bz и gz2 –jxvf, удобно запомнить, различается только j в начале. =) das </para>
<para/>
<para>Некоторым проще запоминать xzf как eXtract Zipped File. j - для bzip2 wt </para>
<para/>
<para>Дальнейшие инструкции по установке можно прочитать в файле INSTALL или README, но чаще всего установка выглядит так: ./configure make Дальше от пользователя root: make install </para>
<para/>
<para>Но пользователям Gentoo лучше прочитать следующий раздел. </para>
<para/>
<para>Gentoo Way</para>
<para/>
<para>Установка из тарболлов может показаться достаточно простой на первый взгляд, однако, она может затруднить управление пакетами и создать некоторые проблемы в дальнейшем, поэтому лучше воспользоваться мощью системой управления пакетами portage. Наверняка, о беспроблемной сборке необходимой вам программы уже позаботилось сообщество пользователей и разработчиков Gentoo. Чтобы узнать это, попробуйте найти нужную вам программу в базе портежей набрав: emerge -s [название программы] или по описанию: emerge -S [ключевое слово] что правда занимает достаточно много времени, и лучше использовать специально для этого написаные утилиты, например esearch emerge esearch eupdatedb esearch [название программы] или по описанию esearch -S [ключевое слово] так же можно проводить поиск по категориям. Например esearch -F mail-client покажет все почтовые клиенты, информация о которых есть в дереве портежей. Так же при поиске можно использовать регулярные выражения. </para>
<para/>
<para>Неплохим подспорьем может послужить GUI фронтенд к портежам, например Porthole(интерфейс GTK).Для любителей KDE есть Kentoo(встраивается в центр управления) и Guitoo. </para>
<para/>
<para>Если вам потребовалось установить программу из неофицального ebuild'а, сначала прочтите Portage_Overlay. </para>
<para/>
<para>Если же ebuild скрипта найти не удалось или нужно наложить дополнительные патчи, то это значит, что пора освоить написание скриптов. Для этого можно воспользоваться skel.ebuild'ом который находится с каталоге portage. Так же не повредит прочтение en:HOWTO Create an Updated Ebuild. </para>
<para/>
<para>Удобной средой разработки и правки ebuild скриптов является abeni </para>
<para/></sect3><sect3><title>А кто такой root и как им стать?</title>
<para/>
<para>Говоря языком Windows, root - это администратор. Но в отличие от Windows, root - абсолютный хозяин системы. Он может сделать все, даже удалить системные файлы, или произвести низкоуровневое форматирование жесткого диска. По идее, root всегда знает что делает, поэтому такая власть вполне оправданна. Рутом можно стать несколькими способами: </para>
<para>первоначально войти систему под этим аккаунтом. </para>
<para>через su. Для этого в консоли введите su </para>
<para>[user@gentoo user]$su</para>
<para> Password:</para>
<para>[root@gentoo user]#</para>
<para/>
<para>Пользователь user должен быть в группе wheel. При вводе пароля он отображаться не будет. </para>
<para>через sudo. Это дополнительная программа, которую можно установить командой: </para>
<para/>
<para>$ emerge sudo </para>
<para/>
<para>Ее преимущества перед обычным su заключаются в том, что можно протоколировать все выполненные команды, а значит понять, кто и как именно сделал что-то непрвильно. :) Кроме того, можно разрешить определенным пользователям выполнять только определенные команды с правами root, что существенно повышает безопасность системы. И, наконец, для использования sudo не нужно знать пароль root - достаточно помнить свой. ;) Все эти и другие настройки производятся редактированием файла конфигурации sudo - /etc/sudoers. </para>
<para/>
<para>Пользоваться ей очень просто: </para>
<para/>
<para>$ sudo команда </para>
<para/>
<para>(например, "sudo ls -l"). Если же вам нужно выполнить не одну команду, а просто временно стать root, используйте следующий синтаксис: </para>
<para/>
<para>$ sudo -s </para>
<para/>
<para>Для того, чтобы перестать быть root после этого, достаточно ввести команду </para>
<para/>
<para>$ exit </para>
<para/>
<para>Секреты консоли</para>
<para/></sect3></sect2><sect2><title>Основные команды</title>
<para/>
<para>Можно на 100% гарантировать, что количество команд в вашей Linux системе больше пары тысяч. Но практически все линуксоиды используют из этого количества не более 100 команд, хотя и это, пожалуй, завышенное число. Человеку, который линукс видел только на скринах, будет полезно узнать, как же использовать эту консоль. </para>
<para/><sect3><title>Команда man</title>
<para/>
<para>Linux - отлично документированная система. Подробную информацию о программе, команде или основным конфигурационном файлам можно получить при помощи команды man. Например man whereis выдаст вам подробную справку по использованию команды whereis, а команда man fstab выдаст синтаксис конфигурационного файла /etc/fstab.</para>
<para>Если вам не удалось найти нужную информацию, можно заглянуть в /usr/share/doc (в Gentoo Linux так же находится в /usr/doc). Там хранится документация программ. </para>
<para/>
<para>Примечание: Для более детальной информации обратитесь в соответствующий раздел Страницы MAN </para>
<para/>
<para/></sect3><sect3><title>Команда cd</title>
<para/>
<para>Без этой команды навигация по файловой системе будет невозможна. Смысл её простой - сменить текущий каталог. А синтаксис такой: cd /home/vasya/katalog Можно использовать как абсолютные, так и относительные пути к папкам. </para>
<para>Абсолютный путь - это путь указанный от корневого каталога(/). </para>
<para>Относительный путь - это путь указанный относительно текущего каталога. </para>
<para/>
<para>Например, если вы находитесь в каталоге /home/vasya, то для перехода в /home/vasya/katalog вам нужно ввести только cd katalog Необходимо отметить, что в Linux нет такого понятия, как "диски". Все разделы жестких дисков, CD-приводы, сетевые диски и т.д. отображаются в виде каталогов файловой системы (обычно в /mnt).</para>
<para>Чтобы узнать в каком каталоге вы сейчас находитесь используется команда pwd. </para>
<para/></sect3><sect3><title>Команда ls</title>
<para/>
<para>Используется для получения списка файлов и каталогов. Например, ls выведет нам содержимое текущего каталога. Для вывода информации о каталоге, в котором вы сейчас не находитесь, используется ls /etc. Наверняка вас не удовлетворят только имена файлов. Для увеличения количества выводимой информации используйте опцию "-l" ls -l. Теперь ls выведет вам много полезной информации, такой как права, время последней модификации, размер и прочее.ls -la с опцией "-a" покажет скрытые файлы (by morgoth) </para>
<para/></sect3><sect3><title>Команда cp</title>
<para/>
<para>Предназначена для копирования файлов и каталогов. Например, скопируем файл /home/vasya/katalog/linux.txt в каталог /home/vasya. Делается это так: cp /home/vasya/katalog/linux.txt /home/vasya А вдруг мы хотим чтобы файл linux.txt получил имя gentoo.txt? Тогда делаем так: cp /home/vasya/katalog/linux.txt /home/vasya/gentoo.txt По умолчанию cp не копирует каталоги. Чтож, заставим его это делать. Скопируем /home/vasya/katalog в каталог /tmp так: cp -R /home/vasya/katalog /tmp Ключ -R указывает на рекурсивное копирование. Как и в случае с файлами, можно поменять конечное имя каталога: cp -R /home/vasya/katalog /tmp/novoe_imya У cp есть еще один полезный ключ: -p. Он предназначен для сохранения всех параметров файла (владельца, прав доступа, битов suid, sgid). Рекомендуем всегда указывать ключ -p, особенно если вы частенько сидите под суперпользователем (чего делать категорически не рекомендуется). </para>
<para/></sect3><sect3><title>Команда rm</title>
<para/>
<para>Предназначена для удаления фаилов. Например, удалим файл /home/vasya/katalog/linux.txt: rm /home/vasya/katalog/linux.txt или если каталог /home/vasya/katalog текущий, тогда можно так: rm linux.txt Будте осторожны, удаленный фаил нельзя восстановить, как в Dos или Windows.</para>
<para>Для удаления пустого каталога /home/vasya/testdir введите rmdir /home/vasya/testdir Не бойтесь указывать абсолютный путь к каталогу - будет удален только последний элемент пути. Для удаления этого же каталога рекурсивно (вместе с подкаталогами и файлами) введите rm -r /home/vasya/testdir </para>
<para/></sect3><sect3><title>Команда df</title>
<para/>
<para>Предназначена для просмотра оставшегося места на диске df -h Ключ -h позволяет увидеть вывод в удобном для человека формате (например 1K 234M 2G) </para>
<para/></sect3><sect3><title>А как мне быть если путь или имя очень длинные?</title>
<para/>
<para>Длинные пути к файлам и каталогам - довольно частое явление. И бороться с этим достаточно легко. Все современные оболчки (aka shell) обладают возможностью автодополнения. Что это значит? Например, есть файл cd home/vasya/katalog/vtoroi_katalog/ooooooooooooochendlinnoeimyakataloga. Ясно, что вбивать имя полностью - это сомнительное удовольствие. ;) Поэтому поручим часть работы shell'у. Мы пишем только часть имени, а остальное будет дополнять шелл. Для дополнения необходимо нажать Tab. Например: cd /h&lt;TAB&gt;/v&lt;TAB&gt;/k&lt;TAB&gt;/v&lt;TAB&gt;/o&lt;TAB&gt; </para>
<para>Примечание: в оболочке Zsh достаточно написать </para>
<para/>
<para>cd /h/v/k/v/o и нажать "Tab". Оболочка сама развернет сокращение в полный путь. Но тут могут возникнуть проблемы, в том случае, если в каталоге /home есть 2 подкаталога /home/vasya и /home/vika. Шелл не сможет понять куда же вы хотите попасть. Чтобы помочь ему нужно указать еще одну букву в пути, то есть /home/va&lt;TAB&gt;, чтобы выбор был однозначным. Если вы не помните части пути, то можете два раза нажать Tab и вы увидите список возможных вариантов. Например: ls /home/&lt;TAB&gt;&lt;TAB&gt; выведет на экран содержимое директории /home. </para>
<para/></sect3><sect3><title>Как сделать чтобы программа запущенная из терминала работала после его закрытия?</title>
<para/>
<para>Такая ситуация возникает довольно часто.Например вам необходимо обновить систему по ssh находясь далеко от своего компьютера, но удерживать связь постоянно вы не можете. Для этой цели можно использовать программу nohup. Например, так можно запустить xmms: nohup xmms Вызываемой программе можно передавать аргументы. Теперь при закрытии терминала xmms будет работать, работать и работать ;) или: xmms &amp; но это только освободит терминал. После закрытия терминала приложение завершиться. </para>
<para/>
<para>Так же можно использовать программу screen. </para>
<para/>
<para>Графическая оболочка X Window</para>
<para/></sect3><sect3><title>А как работать с буфером?</title>
<para/>
<para>Работа с буфером обмена в системе X Window гораздо удобнее, чем в ОС Windows. Для копирования и вставки текста делаем так: </para>
<para>выделяем нужный текст мышкой </para>
<para>в нужном месте щелкаем на среднюю кнопку или колесико мышки, и текст вставляется там, где курсор. </para>
<para/>
<para>Конечно, вы можете использовать и комбинации OC Windows (Ctrl+C, Ctrl+V), однако, следует помнить, что комбинация Ctrl+C экстренно остановит выполнение команды в терминале, другими словами, попытавшись скопировать вывод программы комбинацией Ctrl+C, вы рискуете убить ее выполнение. Будьте внимательнее. </para>
<para/>
<para>Возможно также использование комбинации Ctrl+Insert для копирования в буфер и Shift+Insert для вставки из него. </para>
<para/></sect3><sect3><title>Как заставить иксы стартовать при загрузке?</title>
<para/>
<para>Для этого их необходимо добавить в уровень запуска default. Для этого необходимо выполнить: rc-update add xfs default и rc-update add xdm default Первой командой мы заставили автоматически стартовать сервер шрифтов, а вторая указывает на автозапуск менеджера входа в систему. Для того, чтобы вместо xdm запускался другой менеджер входа необходимо немного отредактировать /etc/rc.conf. </para>
<para/>
<para>Файл: /etc/rc.conf </para>
<para>..</para>
<para>DISPLAYMANAGER="kdm"</para>
<para>.. </para>
<para/>
<para>Теперь вместо xdm будет запускаться kdm.</para>
<para>Файл: /etc/rc.conf </para>
<para>..</para>
<para>DISPLAYMANAGER="gdm"</para>
<para>.. </para>
<para/>
<para/>
<para>Теперь вместо xdm будет запускаться gdm более красивый менеджер.</para></sect3></sect2></sect1><sect1><title>Термины</title>
<para/>
<para>Мы стараемся придерживаться терминов, уже определенных здесь, а сталкивась с новыми трудностями при переводе и редактировании — пополняем словарь. </para>
<para>Кроме того, мы стремимся, чтобы терминология в разных пакетах системы была единой независимо от их происхождения. </para>
<para>Ви́ки (WiKi) (от гавайского: быстрый)— </para>
<para>гипертекстовая среда (обычно Веб-сайт) для сбора и структуризации письменных сведений (в программировании:документации, советов, часто задаваемых вопросов(FAQ), мини-руководств(HOWTO)). </para>
<para>Характеризуется следующими признаками:</para>
<orderedlist>
<listitem>
<para>Множество авторов. Некоторые вики могут править все посетители.</para>
</listitem>
<listitem>
<para>Возможность многократно править текст посредством самой вики-среды (вебсайта), без применения особых приспособлений на стороне редактора.</para>
</listitem>
<listitem>
<para>Проявление изменений сразу после их внесения.</para>
</listitem>
<listitem>
<para>Разделение информации на страницы, где у каждой своё название.</para>
</listitem>
<listitem>
<para>Особый язык разметки, позволяющий легко и быстро размечать в тексте структурные элементы, форматирование, гиперссылки и т. п.</para>
</listitem>
<listitem>
<para>Учёт изменений (учёт версий) текста и возможность отката к ранней версии.</para>
</listitem>
</orderedlist>
<para/>
<para>Для создания вики-среды необходимо особое ПО — движок вики. Это частный вид системы управления сайтом, довольно простой в своём устройстве и функциональности, ибо почти все действия по структуризации и обработке сведений делаются пользователями вручную. Главная особенность -- посетители сайта могут сами редактировать содержимое этих страниц и создавать новые. Wiki сделаны так, чтобы редактировать страницы было просто; для редактирования ничего кроме программы веб-броузера не нужно.</para>
<para>ALSA, или Advanced Linux Sound Architecture — </para>
<para>продвинутая Звуковая Архитектура Linux, обеспечивает аудио- и MIDI- (Musical Instrument Digital Interface — Цифровой Интерфейс Музыкальных Инструментов) функциональность в операционной системе Linux. ALSA является основной звуковой подсистемой в ядрах 2.6, заменившей собой OSS (Open Sound System - Открытая Звуковая Система), которая использовалась в ядрах 2.4</para>
<para/>
<para>X сервер (или  Иксы) - </para>
<para>обычного  пользователя могут испугать мысли о необходимости печатать в командной строке. Почему бы ему не прокладывать свой путь на территории свободы выбора Gentoo (и Linux вообще), просто «водя мышкой»? Ну, конечно, вы сможете это сделать :-). В Linux предлагается широкое разнообразие пользовательских интерфейсов и сред, которые можно установить поверх установленной у вас системы. </para>
<para/>
<para>Это один из самых больших сюрпризов, с которым сталкиваются новички: графический интерфейс пользователя — это всего лишь прикладная программа, выполняемая в системе. Он не является частью ядра Linux или каких-либо других компонентов системы. Это — мощный инструмент, позволяющий полностью задействовать графические возможности вашего компьютера. </para>
<para/>
<para>Так как стандартизация очень важна, для организации прорисовки и перемещения окон по экрану, взаимодействия пользователя с мышью и клавиатурой, а также других важных базовых аспектов, был создан стандарт под названием X Window System, сокращённо X11 или просто X. Он используется в Unix, Linux и других Unix-подобных операционных системах во всем мире. </para>
<para/>
<para>Приложение, которое дает пользователям Linux возможность запускать графические интерфейсы пользователя и использует стандарт X11, называется Xorg-X11, ответвление проекта XFree86. Проектом XFree86 было решено использовать лицензию, возможно, несовместимую с лицензией GPL, поэтому рекомендуется использовать Xorg. Пакет XFree86 больше не поддерживается в официальном дереве портежей. </para>
<para/>
<para>Проект X.org</para>
<para/>
<para>Проектом X.org создана и поддерживается бесплатно распространяемая реализация системы X11 с открытым исходным кодом. Это открытая инфраструктура рабочей станции, основанная на X11. </para>
<para/>
<para>Xorg обеспечивает интерфейс между устройствами вашего компьютера и нужными вам графическими программами. Кроме того, Xorg является полностью сетевым, то есть вы можете запускать программу на одной системе, а отображать ее — на другой. </para>
<para/>
<para>Ссылка на оригинал: <ulink url="http://www.rugentoo.org/glossary/index.html">http://www.rugentoo.org/glossary/index.html</ulink>
</para>
<para/><sect1 id="text"><informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Термин</para>
</entry>
<entry>
<para>Перевод</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>activation </para>
</entry>
<entry>
<para>активация; активизация; включение; приведение в действие; запуск </para>
</entry>
</row>
<row>
<entry>
<para>architecture-specific </para>
</entry>
<entry>
<para>архитектурно-зависимый (о режиме или параметре);посвящённый определённой архитектуре (о руководстве) </para>
</entry>
</row>
<row>
<entry>
<para>account </para>
</entry>
<entry>
<para>учётная запись </para>
</entry>
</row>
<row>
<entry>
<para>advanced </para>
</entry>
<entry>
<para>расширенный (напр., настройка);углублённый (напр., обучение) </para>
</entry>
</row>
<row>
<entry>
<para>attribute </para>
</entry>
<entry>
<para>атрибут (например, файла);свойство, параметр (иногда) </para>
</entry>
</row>
<row>
<entry>
<para>authentication </para>
</entry>
<entry>
<para>аутентификация </para>
</entry>
</row>
<row>
<entry>
<para>authorization </para>
</entry>
<entry>
<para>авторизация </para>
</entry>
</row>
<row>
<entry>
<para>authorized </para>
</entry>
<entry>
<para>авторизованный; допущенный; санкционированный </para>
</entry>
</row>
<row>
<entry>
<para>autocompletion </para>
</entry>
<entry>
<para>автодополнение (слов в строке) </para>
</entry>
</row>
<row>
<entry>
<para>baselayout </para>
</entry>
<entry>
<para>так и оставить — baselayout;при первом упоминании в тексте руководств хорошо бы в скобочках писать (размещение основных файлов и сценарии инициализации системы)</para>
</entry>
</row>
<row>
<entry>
<para>basic </para>
</entry>
<entry>
<para>базовый, основной; <emphasis>элементарный</emphasis> (lingvo.ru) </para>
</entry>
</row>
<row>
<entry>
<para>basics </para>
</entry>
<entry>
<para>основы, основные действия </para>
</entry>
</row>
<row>
<entry>
<para>binary </para>
</entry>
<entry>
<para>двоичный; бинарный </para>
</entry>
</row>
<row>
<entry>
<para>binary [executable] </para>
</entry>
<entry>
<para>исполняемый файл </para>
</entry>
</row>
<row>
<entry>
<para>bind-mounting ... </para>
</entry>
<entry>
<para>монтирование ... с параметром bind (см. man mount :) </para>
</entry>
</row>
<row>
<entry>
<para>bindings </para>
</entry>
<entry>
<para>привязкипри первом упоминании в тексте имеет смысл писать в скобочках английский термин</para>
</entry>
</row>
<row>
<entry>
<para>board of trustees </para>
</entry>
<entry>
<para>совет попечителей </para>
</entry>
</row>
<row>
<entry>
<para>bonding (, channel trunking) </para>
</entry>
<entry>
<para>объединение ([магистральных] сетевых каналов) </para>
</entry>
</row>
<row>
<entry>
<para>boot runlevel </para>
</entry>
<entry>
<para>загрузочный уровень исполнения </para>
</entry>
</row>
<row>
<entry>
<para>bootable (disk) </para>
</entry>
<entry>
<para>загрузочный (диск) </para>
</entry>
</row>
<row>
<entry>
<para>bootloader </para>
</entry>
<entry>
<para>[начальный] загрузчик; загрузчик OC </para>
</entry>
</row>
<row>
<entry>
<para>bootsplash </para>
</entry>
<entry>
<para>загрузочная заставка </para>
</entry>
</row>
<row>
<entry>
<para>bootsplash-enabled kernel </para>
</entry>
<entry>
<para>ядро с [включённой] загрузочной заставкой </para>
</entry>
</row>
<row>
<entry>
<para>boot (bootstrap) partition </para>
</entry>
<entry>
<para>загрузочный раздел </para>
</entry>
</row>
<row>
<entry>
<para>bootstrapping </para>
</entry>
<entry>
<para>начальная загрузка; самонастройка; самозагрузка[само]генерация (сборка) системы (в некоторых контекстах в Gentoo) </para>
</entry>
</row>
<row>
<entry>
<para>branch (portage) </para>
</entry>
<entry>
<para>ветвь (дерева портежей) </para>
</entry>
</row>
<row>
<entry>
<para>bridge (, network) </para>
</entry>
<entry>
<para>[сетевой] мост </para>
</entry>
</row>
<row>
<entry>
<para>broadcast [address] </para>
</entry>
<entry>
<para>широковещательный адрес </para>
</entry>
</row>
<row>
<entry>
<para>browse to </para>
</entry>
<entry>
<para>открыть [веб-страницу] </para>
</entry>
</row>
<row>
<entry>
<para>browser </para>
</entry>
<entry>
<para>браузер </para>
</entry>
</row>
<row>
<entry>
<para>bug </para>
</entry>
<entry>
<para>запрос (требующий реагирования); ошибка (разновидность запроса) </para>
</entry>
</row>
<row>
<entry>
<para>bug report </para>
</entry>
<entry>
<para>отчёт об ошибке <emphasis>или</emphasis> запрос [форма запроса] </para>
</entry>
</row>
<row>
<entry>
<para>bugtracking system </para>
</entry>
<entry>
<para>система распределения запросов<emphasis>(внимание! не багов, не ошибок — потому что не только их; и </emphasis>
<emphasis>не отслеживания, управления или контроля — потому что распределения — это корректный перевод одного из американизмов)</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>build </para>
</entry>
<entry>
<para>сборка (программный пакет) </para>
</entry>
</row>
<row>
<entry>
<para>cache </para>
</entry>
<entry>
<para>кэш </para>
</entry>
</row>
<row>
<entry>
<para>card </para>
</entry>
<entry>
<para>плата (деталь компьютера);карта [PCMCIA, флэш-памяти] </para>
</entry>
</row>
<row>
<entry>
<para>cascading (stacked) profile </para>
</entry>
<entry>
<para>каскадный профиль </para>
</entry>
</row>
<row>
<entry>
<para>CD </para>
</entry>
<entry>
<para>компакт-диск </para>
</entry>
</row>
<row>
<entry>
<para>change request </para>
</entry>
<entry>
<para>запрос на изменение (разновидность запроса) </para>
</entry>
</row>
<row>
<entry>
<para>chapter </para>
</entry>
<entry>
<para>глава [руководства] </para>
</entry>
</row>
<row>
<entry>
<para>child [tag] </para>
</entry>
<entry>
<para>вложенный [тег] (о XML) </para>
</entry>
</row>
<row>
<entry>
<para>choice </para>
</entry>
<entry>
<para>выбор, вариант выбора; альтернатива; пункт меню(документация по Gentoo помешана на идеологической теме свободы выбора пользователя, русский перевод стоит разнообразить) </para>
</entry>
</row>
<row>
<entry>
<para>choices </para>
</entry>
<entry>
<para>мн. ч. от choice;возможность (свобода) выбора </para>
</entry>
</row>
<row>
<entry>
<para>chroot </para>
</entry>
<entry>
<para>[команда] chroot;изменение корневого каталога </para>
</entry>
</row>
<row>
<entry>
<para>chrooted environment </para>
</entry>
<entry>
<para>среда с изменённым корневым каталогом </para>
</entry>
</row>
<row>
<entry>
<para>Code of Conduct </para>
</entry>
<entry>
<para>кодекс поведения </para>
</entry>
</row>
<row>
<entry>
<para>coldplugging </para>
</entry>
<entry>
<para>холодное подключение (с выключением оборудования) </para>
</entry>
</row>
<row>
<entry>
<para>color depth </para>
</entry>
<entry>
<para>глубина цвета; тоже самое что bits per pixel (bpp) </para>
</entry>
</row>
<row>
<entry>
<para>compose </para>
</entry>
<entry>
<para>составлять;верстать (о разметке XML) </para>
</entry>
</row>
<row>
<entry>
<para>configuration file </para>
</entry>
<entry>
<para>конфигурационный файл; файл настроек </para>
</entry>
</row>
<row>
<entry>
<para>configuring; configuration </para>
</entry>
<entry>
<para>настройка [системы, чего-либо];конфигурация [ядра] </para>
</entry>
</row>
<row>
<entry>
<para>content </para>
</entry>
<entry>
<para>текст, содержимое;разделы (о разметке GuideXML) </para>
</entry>
</row>
<row>
<entry>
<para>contributor </para>
</entry>
<entry>
<para>участник </para>
</entry>
</row>
<row>
<entry>
<para>councilcouncil meeting </para>
</entry>
<entry>
<para>советсобрание совета </para>
</entry>
</row>
<row>
<entry>
<para>daemon </para>
</entry>
<entry>
<para>демон(<emphasis>программа слежения за системными событиями; тж. </emphasis>служба<emphasis>)</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>declare </para>
</entry>
<entry>
<para>объявлять (переменную) </para>
</entry>
</row>
<row>
<entry>
<para>default [by -] </para>
</entry>
<entry>
<para>по умолчанию </para>
</entry>
</row>
<row>
<entry>
<para>define </para>
</entry>
<entry>
<para>задавать, указывать, определять (последний вариант используйте с осторожностью, чтобы не путать определение в смысле установки значения с определением в смысле обнаружения) </para>
</entry>
</row>
<row>
<entry>
<para>desktop (environment)desktop (computer)</para>
</entry>
<entry>
<para>графическая среда (о KDE/Gnome и т.п.); рабочая станция (настольный компьютер, в отличие от сервера); </para>
</entry>
</row>
<row>
<entry>
<para>desktop documentation resources </para>
</entry>
<entry>
<para>документация по графической среде Gentoo; документация по использованию в качестве рабочей станции </para>
</entry>
</row>
<row>
<entry>
<para>dependency </para>
</entry>
<entry>
<para>зависимость </para>
</entry>
</row>
<row>
<entry>
<para>dependency [package] </para>
</entry>
<entry>
<para>зависимый пакет </para>
</entry>
</row>
<row>
<entry>
<para>developer </para>
</entry>
<entry>
<para>разработчик </para>
</entry>
</row>
<row>
<entry>
<para>device file </para>
</entry>
<entry>
<para>файл устройства </para>
</entry>
</row>
<row>
<entry>
<para>device manager </para>
</entry>
<entry>
<para>диспетчер устройств </para>
</entry>
</row>
<row>
<entry>
<para>device node </para>
</entry>
<entry>
<para>специальный файл [устройства] </para>
</entry>
</row>
<row>
<entry>
<para>dial-in accessdial-up access </para>
</entry>
<entry>
<para>[входящий] коммутируемый доступ </para>
</entry>
</row>
<row>
<entry>
<para>directory </para>
</entry>
<entry>
<para>каталог </para>
</entry>
</row>
<row>
<entry>
<para>display manager </para>
</entry>
<entry>
<para>диспетчер отображения (не экрана!) </para>
</entry>
</row>
<row>
<entry>
<para>documentation listing </para>
</entry>
<entry>
<para>перечень документации </para>
</entry>
</row>
<row>
<entry>
<para>documentation repository </para>
</entry>
<entry>
<para>хранилище документации </para>
</entry>
</row>
<row>
<entry>
<para>documentation resources </para>
</entry>
<entry>
<para>документация (имеется в виду спектр доступной документации) </para>
</entry>
</row>
<row>
<entry>
<para>down [interface] </para>
</entry>
<entry>
<para>отключён </para>
</entry>
</row>
<row>
<entry>
<para>download </para>
</entry>
<entry>
<para>загрузка (из интернета); загрузить </para>
</entry>
</row>
<row>
<entry>
<para>drive </para>
</entry>
<entry>
<para>привод </para>
</entry>
</row>
<row>
<entry>
<para>driver </para>
</entry>
<entry>
<para>драйвер, <emphasis>мн.ч.</emphasis> драйверы </para>
</entry>
</row>
<row>
<entry>
<para>dump </para>
</entry>
<entry>
<para>программа [резервного копирования] dump;дамп [памяти] </para>
</entry>
</row>
<row>
<entry>
<para>ebuild </para>
</entry>
<entry>
<para>сборочный файл; пакет; файл ebuildпрограмма ebuild(при переводе транслитерация не допускается из-за исключительной неблагозвучности для русского читателя!) Примечание: <emphasis>e-build — вероятно, авторское сокращение от emerge build file</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>emerge </para>
</entry>
<entry>
<para>[команда] emerge; средство установки/удаления программПримечание: <emphasis>автор Gentoo хотел, чтобы программы «являлись» как по волшебству (изначально система называлась Енох в честь загадочного библейского персонажа); для этого придумал команду «emerge xyz», что буквально переводится как «xyz, явись!». Остальные термины системы установки подогнаны под неё</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>environment variables </para>
</entry>
<entry>
<para>переменные среды </para>
</entry>
</row>
<row>
<entry>
<para>experience [, improvement] </para>
</entry>
<entry>
<para>впечатление (от Gentoo);[повышение] удобства работы с Gentoo </para>
</entry>
</row>
<row>
<entry>
<para>FAQ,frequently asked questions </para>
</entry>
<entry>
<para>ЧаВо, часто задаваемые вопросы </para>
</entry>
</row>
<row>
<entry>
<para>feature </para>
</entry>
<entry>
<para>возможность [программы], функция;особенность </para>
</entry>
</row>
<row>
<entry>
<para>feature request </para>
</entry>
<entry>
<para>запрос на добавление функции (разновидность запроса) </para>
</entry>
</row>
<row>
<entry>
<para>fetch </para>
</entry>
<entry>
<para>извлечь (ebuild/portage tree) </para>
</entry>
</row>
<row>
<entry>
<para>firewall </para>
</entry>
<entry>
<para>межсетевой экран </para>
</entry>
</row>
<row>
<entry>
<para>firmware </para>
</entry>
<entry>
<para>прошивка; встроенное ПО </para>
</entry>
</row>
<row>
<entry>
<para>floppy [disk] </para>
</entry>
<entry>
<para>дискета </para>
</entry>
</row>
<row>
<entry>
<para>framebuffer </para>
</entry>
<entry>
<para>кадровый буфер (используется для промежуточного хранения исходных данных для программного или аппаратного формирования <emphasis>видеокадра</emphasis> или <emphasis>полукадра</emphasis> для вывода на экран монитора) </para>
</entry>
</row>
<row>
<entry>
<para>front-end</para>
</entry>
<entry>
<para>внешний интерфейс; пользовательский интерфейс</para>
</entry>
</row>
<row>
<entry>
<para>functionality </para>
</entry>
<entry>
<para>возможности, функции </para>
</entry>
</row>
<row>
<entry>
<para>generic </para>
</entry>
<entry>
<para>универсальный (о цели компиляции);общий, обычный (generic printer — обычный принтер) </para>
</entry>
</row>
<row>
<entry>
<para>Gentoo </para>
</entry>
<entry>
<para>[система] Gentoo (женский или общий род) </para>
</entry>
</row>
<row>
<entry>
<para>Gentoo Documentation Project </para>
</entry>
<entry>
<para>проект документации Gentoo </para>
</entry>
</row>
<row>
<entry>
<para>Gentoo Handbook </para>
</entry>
<entry>
<para>настольная книга Gentoo (<emphasis>не</emphasis> руководство) </para>
</entry>
</row>
<row>
<entry>
<para>Gentoo Minimal Installation CDMinimal LiveCD </para>
</entry>
<entry>
<para>Минимальный установочный компакт-диск Gentoo </para>
</entry>
</row>
<row>
<entry>
<para>Gentoo Universal Installation CD </para>
</entry>
<entry>
<para>Универсальный установочный диск Gentoo </para>
</entry>
</row>
<row>
<entry>
<para>groupware </para>
</entry>
<entry>
<para>[сервер, программа, пакет] обеспечения взаимодействия (рабочих групп) </para>
</entry>
</row>
<row>
<entry>
<para>guide </para>
</entry>
<entry>
<para>руководство (требуется термин, отличный от Handbook); </para>
</entry>
</row>
<row>
<entry>
<para>hard link </para>
</entry>
<entry>
<para>жёсткая ссылка </para>
</entry>
</row>
<row>
<entry>
<para>hardened [Gentoo project] </para>
</entry>
<entry>
<para>укреплённая система, проект укреплённого Gentoo </para>
</entry>
</row>
<row>
<entry>
<para>hardware </para>
</entry>
<entry>
<para>аппаратура; устройства </para>
</entry>
</row>
<row>
<entry>
<para>hardware [device] </para>
</entry>
<entry>
<para>устройство </para>
</entry>
</row>
<row>
<entry>
<para>hardware requirements </para>
</entry>
<entry>
<para>требования к оборудованию </para>
</entry>
</row>
<row>
<entry>
<para>herd </para>
</entry>
<entry>
<para>группа [сопровождения пакета](не стадо и не толпа!) </para>
</entry>
</row>
<row>
<entry>
<para>highlighted </para>
</entry>
<entry>
<para>выделенный (об элементе или о тексте) </para>
</entry>
</row>
<row>
<entry>
<para>host </para>
</entry>
<entry>
<para>узел, компьютер </para>
</entry>
</row>
<row>
<entry>
<para>howto </para>
</entry>
<entry>
<para>описание [выполнения чего-то]«Как [сделать то-то]» — в заголовке </para>
</entry>
</row>
<row>
<entry>
<para>hub </para>
</entry>
<entry>
<para>(сетевой) концентратор </para>
</entry>
</row>
<row>
<entry>
<para>image [kernel, disk ...] </para>
</entry>
<entry>
<para>образ </para>
</entry>
</row>
<row>
<entry>
<para>image [graphics] </para>
</entry>
<entry>
<para>изображение </para>
</entry>
</row>
<row>
<entry>
<para>init script; initscript </para>
</entry>
<entry>
<para>сценарий инициализации(**)сценарий запуска??? тж. runlevel script </para>
</entry>
</row>
<row>
<entry>
<para>initialization </para>
</entry>
<entry>
<para>инициализация [переменной];подготовка [раздела] </para>
</entry>
</row>
<row>
<entry>
<para>initrd (initial root disk) </para>
</entry>
<entry>
<para>начальный корневой диск (initrd);диск initrd </para>
</entry>
</row>
<row>
<entry>
<para>initrd image </para>
</entry>
<entry>
<para>образ диска initrd </para>
</entry>
</row>
<row>
<entry>
<para>injecting [into Portage] </para>
</entry>
<entry>
<para>внедрение [ПО в дерево Portage] </para>
</entry>
</row>
<row>
<entry>
<para>installation </para>
</entry>
<entry>
<para>установка </para>
</entry>
</row>
<row>
<entry>
<para>installation CD </para>
</entry>
<entry>
<para>... установочный [компакт-]диск;«...» — тип диска (минимальный, универсальный и т.д.) </para>
</entry>
</row>
<row>
<entry>
<para>installer </para>
</entry>
<entry>
<para>программа установки </para>
</entry>
</row>
<row>
<entry>
<para>instructions </para>
</entry>
<entry>
<para>указания; инструкции </para>
</entry>
</row>
<row>
<entry>
<para>internet </para>
</entry>
<entry>
<para>интернет (с маленькой буквы, м.р., склоняется — интернета, интернетом) </para>
</entry>
</row>
<row>
<entry>
<para>invalid </para>
</entry>
<entry>
<para>недопустимый </para>
</entry>
</row>
<row>
<entry>
<para>IP address </para>
</entry>
<entry>
<para>IP-адрес (сетевой адрес протокола интернета в виде последовательности чисел) </para>
</entry>
</row>
<row>
<entry>
<para>issue </para>
</entry>
<entry>
<para>см. bug </para>
</entry>
</row>
<row>
<entry>
<para>job </para>
</entry>
<entry>
<para>задание (пакетное; на печать и т.п.) </para>
</entry>
</row>
<row>
<entry>
<para>jumper </para>
</entry>
<entry>
<para>перемычка </para>
</entry>
</row>
<row>
<entry>
<para>kernel </para>
</entry>
<entry>
<para>ядро </para>
</entry>
</row>
<row>
<entry>
<para>keyword </para>
</entry>
<entry>
<para>ключ (в контексте типа ~arch keyword); ключевое слово </para>
</entry>
</row>
<row>
<entry>
<para>keymap </para>
</entry>
<entry>
<para>раскладка [клавиатуры] </para>
</entry>
</row>
<row>
<entry>
<para>laptop </para>
</entry>
<entry>
<para>ноутбук, портативный компьютер </para>
</entry>
</row>
<row>
<entry>
<para>latest </para>
</entry>
<entry>
<para>новейший </para>
</entry>
</row>
<row>
<entry>
<para>lightweight </para>
</entry>
<entry>
<para>упрощённый (о синтаксисе) </para>
</entry>
</row>
<row>
<entry>
<para>linker </para>
</entry>
<entry>
<para>компоновщик </para>
</entry>
</row>
<row>
<entry>
<para>linking [static] </para>
</entry>
<entry>
<para>компоновка </para>
</entry>
</row>
<row>
<entry>
<para>linking [dynamic] </para>
</entry>
<entry>
<para>динамическое связывание </para>
</entry>
</row>
<row>
<entry>
<para>LiveCD </para>
</entry>
<entry>
<para>загрузочный [установочный] [компакт-]диск (LiveCD) </para>
</entry>
</row>
<row>
<entry>
<para>LiveUSB </para>
</entry>
<entry>
<para>загрузочный USB-накопитель (LiveUSB) </para>
</entry>
</row>
<row>
<entry>
<para>locale </para>
</entry>
<entry>
<para>регион;[набор] региональных настроек(само слово locale означает «местность») </para>
</entry>
</row>
<row>
<entry>
<para>log </para>
</entry>
<entry>
<para>журнал [регистрации событий] </para>
</entry>
</row>
<row>
<entry>
<para>logger </para>
</entry>
<entry>
<para>средства журналирования </para>
</entry>
</row>
<row>
<entry>
<para>login [user's] </para>
</entry>
<entry>
<para>учётная запись </para>
</entry>
</row>
<row>
<entry>
<para>login [process] </para>
</entry>
<entry>
<para>вход в систему </para>
</entry>
</row>
<row>
<entry>
<para>login [as] </para>
</entry>
<entry>
<para>войти в систему [как / под именем] </para>
</entry>
</row>
<row>
<entry>
<para>loopback connector </para>
</entry>
<entry>
<para>[разъём-] заглушка </para>
</entry>
</row>
<row>
<entry>
<para>machine </para>
</entry>
<entry>
<para>машина; компьютер </para>
</entry>
</row>
<row>
<entry>
<para>maintainer </para>
</entry>
<entry>
<para>куратор (пакета и т.п.) </para>
</entry>
</row>
<row>
<entry>
<para>maintenance, package </para>
</entry>
<entry>
<para>сопровождение (пакета) </para>
</entry>
</row>
<row>
<entry>
<para>man page </para>
</entry>
<entry>
<para>страница справки </para>
</entry>
</row>
<row>
<entry>
<para>manager </para>
</entry>
<entry>
<para>диспетчер (о программе) </para>
</entry>
</row>
<row>
<entry>
<para>mark [up] </para>
</entry>
<entry>
<para>вёрстка, оформление, разметка (текста документа XML) </para>
</entry>
</row>
<row>
<entry>
<para>mask [package] </para>
</entry>
<entry>
<para>замаскировать [пакет] (<emphasis>не</emphasis> «заблокировать») </para>
</entry>
</row>
<row>
<entry>
<para>MBR, master boot record </para>
</entry>
<entry>
<para>главная загрузочная запись </para>
</entry>
</row>
<row>
<entry>
<para>merge [with; together]merge [software with system] </para>
</entry>
<entry>
<para>объединять [c];устанавливать [ПО] </para>
</entry>
</row>
<row>
<entry>
<para>metastructure </para>
</entry>
<entry>
<para>организация проекта, метаструктура </para>
</entry>
</row>
<row>
<entry>
<para>modeless </para>
</entry>
<entry>
<para>немодальный </para>
</entry>
</row>
<row>
<entry>
<para>mount </para>
</entry>
<entry>
<para>монтировать; смонтировать [дисковый раздел] (включить в состав файловой системы)Вопрос к обсуждению: хочется в будущем уйти от этого термина, например, заменив его на подключение/отключение или присоединение/отсоединение.Термин произошёл от процесса установки в накопители больших ЭВМ пакетов дисков (которые действительно надо было монтировать [закреплять], иначе они могли физически улететь, покалечив кого-нибудь), и потерял смысл.</para>
</entry>
</row>
<row>
<entry>
<para>mountpoint </para>
</entry>
<entry>
<para>точка монтирования [дискового раздела] (см. комментарий к mount) </para>
</entry>
</row>
<row>
<entry>
<para>multilib </para>
</entry>
<entry>
<para>многорежимный профиль (с одновременной поддержкой нескольких наборов библиотек для различных режимов среды пользователя, например, 32- и 64-битного) </para>
</entry>
</row>
<row>
<entry>
<para>naming </para>
</entry>
<entry>
<para>именование </para>
</entry>
</row>
<row>
<entry>
<para>nano </para>
</entry>
<entry>
<para>nano (текстовый редактор) </para>
</entry>
</row>
<row>
<entry>
<para>netmask </para>
</entry>
<entry>
<para>маска [подсети] </para>
</entry>
</row>
<row>
<entry>
<para>networking </para>
</entry>
<entry>
<para>подключение к сети;сетевое подключение (в контексте настройки узла) </para>
</entry>
</row>
<row>
<entry>
<para>NIS </para>
</entry>
<entry>
<para>NIS (network information service — служба сетевой информации) </para>
</entry>
</row>
<row>
<entry>
<para>open documentation license </para>
</entry>
<entry>
<para>лицензия открытой документации </para>
</entry>
</row>
<row>
<entry>
<para>option </para>
</entry>
<entry>
<para>параметр [командной строки]; директивавариант [выбора];возможность [пользователя];(никогда не опция!) </para>
</entry>
</row>
<row>
<entry>
<para>optional </para>
</entry>
<entry>
<para>необязательный [шаг, компонент];дополнительный;факультативный </para>
</entry>
</row>
<row>
<entry>
<para>output, [program] </para>
</entry>
<entry>
<para>сообщения [программы] </para>
</entry>
</row>
<row>
<entry>
<para>overlay </para>
</entry>
<entry>
<para>оверлей </para>
</entry>
</row>
<row>
<entry>
<para>override </para>
</entry>
<entry>
<para>подмена, подменить;переопределение, переопределять </para>
</entry>
</row>
<row>
<entry>
<para>overwrite </para>
</entry>
<entry>
<para>перезаписать </para>
</entry>
</row>
<row>
<entry>
<para>package </para>
</entry>
<entry>
<para>пакет [программного обеспечения] </para>
</entry>
</row>
<row>
<entry>
<para>Package CD </para>
</entry>
<entry>
<para>компакт-диск с пакетами (Package CD) </para>
</entry>
</row>
<row>
<entry>
<para>package maintenance system </para>
</entry>
<entry>
<para>система управления (!) пакетами </para>
</entry>
</row>
<row>
<entry>
<para>packaging system </para>
</entry>
<entry>
<para>система сборки (!) </para>
</entry>
</row>
<row>
<entry>
<para>paragraph </para>
</entry>
<entry>
<para>абзац (не параграф!) </para>
</entry>
</row>
<row>
<entry>
<para>part </para>
</entry>
<entry>
<para>часть [руководства](<emphasis>общая структура</emphasis>: часть-глава-раздел-абзац;<emphasis>раздел намеренно для совместимости подчинён главе в нарушение логики)</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>partition </para>
</entry>
<entry>
<para>[дисковый] раздел; раздел устройства;(не раздел на устройстве! что-либо записываем тоже «в» раздел!) </para>
</entry>
</row>
<row>
<entry>
<para>partitioning </para>
</entry>
<entry>
<para>разбиение </para>
</entry>
</row>
<row>
<entry>
<para>patch </para>
</entry>
<entry>
<para>
<emphasis>сущ.</emphasis> заплатка, исправление, файл исправлений </para>
</entry>
</row>
<row>
<entry>
<para>patched </para>
</entry>
<entry>
<para>исправленный </para>
</entry>
</row>
<row>
<entry>
<para>PC </para>
</entry>
<entry>
<para>компьютер (персональный компьютер, если есть противопоставление миниЭВМ) </para>
</entry>
</row>
<row>
<entry>
<para>ping </para>
</entry>
<entry>
<para>команда ping;проверка отклика [командой ping] </para>
</entry>
</row>
<row>
<entry>
<para>pipe</para>
</entry>
<entry>
<para>канал (механизм передачи данных между процессами)</para>
</entry>
</row>
<row>
<entry>
<para>policy</para>
</entry>
<entry>
<para>правила; положение (документ); политика</para>
</entry>
</row>
<row>
<entry>
<para>pool</para>
</entry>
<entry>
<para>группа; пространство (ресурсов, памяти)</para>
</entry>
</row>
<row>
<entry>
<para>portage [package] </para>
</entry>
<entry>
<para>портеж;пакет (системы Portage) </para>
</entry>
</row>
<row>
<entry>
<para>Portage [system] </para>
</entry>
<entry>
<para>[система] Portage (женский или общий род, без перевода); <emphasis>Примечание: для «явления» программ (см. примечание к </emphasis>emerge<emphasis>) автор взял за основу систему port, и предположительно использовал игру слов:</emphasis>port<emphasis>-</emphasis>portage<emphasis> сохраняется узнаваемость</emphasis>port-age<emphasis> — «век портов», «зрелый port»</emphasis>portage<emphasis> — «кипа, связка»</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>portage tree </para>
</entry>
<entry>
<para>дерево портежей </para>
</entry>
</row>
<row>
<entry>
<para>portage snapshot </para>
</entry>
<entry>
<para>снимок [копия] дерева портежей [в некоторый фиксированный момент времени] </para>
</entry>
</row>
<row>
<entry>
<para>prebuilt [package] </para>
</entry>
<entry>
<para>готовый [двоичный] пакет </para>
</entry>
</row>
<row>
<entry>
<para>precompiled [package] </para>
</entry>
<entry>
<para>см. prebuilt [package] </para>
</entry>
</row>
<row>
<entry>
<para>printer-friendly version </para>
</entry>
<entry>
<para>версия для печати </para>
</entry>
</row>
<row>
<entry>
<para>private key </para>
</entry>
<entry>
<para>секретный ключ [шифрования] </para>
</entry>
</row>
<row>
<entry>
<para>privilege </para>
</entry>
<entry>
<para>полномочия </para>
</entry>
</row>
<row>
<entry>
<para>proxy </para>
</entry>
<entry>
<para>прокси-сервер («сервер-посредник» для доступа в интернет) </para>
</entry>
</row>
<row>
<entry>
<para>public key </para>
</entry>
<entry>
<para>открытый ключ [шифрования] </para>
</entry>
</row>
<row>
<entry>
<para>purpose </para>
</entry>
<entry>
<para>назначение (в заголовке раздела документа) </para>
</entry>
</row>
<row>
<entry>
<para>quick installation guide </para>
</entry>
<entry>
<para>краткое руководство по установке </para>
</entry>
</row>
<row>
<entry>
<para>raise [privilege] </para>
</entry>
<entry>
<para>превышать полномочия </para>
</entry>
</row>
<row>
<entry>
<para>reboot </para>
</entry>
<entry>
<para>перезагрузка; перезагрузить </para>
</entry>
</row>
<row>
<entry>
<para>reference [manual] </para>
</entry>
<entry>
<para>справочное руководство </para>
</entry>
</row>
<row>
<entry>
<para>reference [platform] </para>
</entry>
<entry>
<para>эталонная платформа </para>
</entry>
</row>
<row>
<entry>
<para>release notes </para>
</entry>
<entry>
<para>замечания к выпуску </para>
</entry>
</row>
<row>
<entry>
<para>release, [software] </para>
</entry>
<entry>
<para>выпуск [ПО] </para>
</entry>
</row>
<row>
<entry>
<para>release [version] </para>
</entry>
<entry>
<para>окончательная (стабильная) версия </para>
</entry>
</row>
<row>
<entry>
<para>relevance</para>
</entry>
<entry>
<para>соответствие (напр., критерию);отношение (к чему-либо) </para>
</entry>
</row>
<row>
<entry>
<para>remote </para>
</entry>
<entry>
<para>удалённый [компьютер];дистанционный </para>
</entry>
</row>
<row>
<entry>
<para>rendered document </para>
</entry>
<entry>
<para>представление документа (о XML) </para>
</entry>
</row>
<row>
<entry>
<para>repository </para>
</entry>
<entry>
<para>хранилище </para>
</entry>
</row>
<row>
<entry>
<para>rescue [disk] </para>
</entry>
<entry>
<para>аварийное восстановление;диск аварийного восстановления </para>
</entry>
</row>
<row>
<entry>
<para>return [an error] </para>
</entry>
<entry>
<para>выдавать [ошибку] </para>
</entry>
</row>
<row>
<entry>
<para>root [user] </para>
</entry>
<entry>
<para>[учётная запись] root; администратор </para>
</entry>
</row>
<row>
<entry>
<para>router </para>
</entry>
<entry>
<para>(сетевой) маршрутизатор </para>
</entry>
</row>
<row>
<entry>
<para>runlevel </para>
</entry>
<entry>
<para>уровень исполнения </para>
</entry>
</row>
<row>
<entry>
<para>runlevel script </para>
</entry>
<entry>
<para>сценарий инициализации (тж. initscript) (**) </para>
</entry>
</row>
<row>
<entry>
<para>script </para>
</entry>
<entry>
<para>сценарий </para>
</entry>
</row>
<row>
<entry>
<para>section [, guide] </para>
</entry>
<entry>
<para>раздел [руководства] </para>
</entry>
</row>
<row>
<entry>
<para>security </para>
</entry>
<entry>
<para>безопасность; защита </para>
</entry>
</row>
<row>
<entry>
<para>security advisory</para>
</entry>
<entry>
<para>предупреждение об уязвимости (защиты системы)</para>
</entry>
</row>
<row>
<entry>
<para>serial </para>
</entry>
<entry>
<para>последовательный </para>
</entry>
</row>
<row>
<entry>
<para>service </para>
</entry>
<entry>
<para>служба (тж. демон) </para>
</entry>
</row>
<row>
<entry>
<para>setting (of variable) </para>
</entry>
<entry>
<para>значение; установка значения переменной </para>
</entry>
</row>
<row>
<entry>
<para>signature </para>
</entry>
<entry>
<para>признак; идентификатор; подпись </para>
</entry>
</row>
<row>
<entry>
<para>skin </para>
</entry>
<entry>
<para>образ; внешний вид? [вариант] оформления? костюм? </para>
</entry>
</row>
<row>
<entry>
<para>slot </para>
</entry>
<entry>
<para>слот </para>
</entry>
</row>
<row>
<entry>
<para>socket [network] </para>
</entry>
<entry>
<para>сокет </para>
</entry>
</row>
<row>
<entry>
<para>software </para>
</entry>
<entry>
<para>программа; программное обеспечение </para>
</entry>
</row>
<row>
<entry>
<para>software management tool </para>
</entry>
<entry>
<para>система управления программным обеспечением </para>
</entry>
</row>
<row>
<entry>
<para>source code </para>
</entry>
<entry>
<para>исходные коды (**) как лучше: коды или код? </para>
</entry>
</row>
<row>
<entry>
<para>source mirror </para>
</entry>
<entry>
<para>зеркало-источник [Gentoo](хотя это и зеркало исходных кодов, на нем есть и двоичные образы) </para>
</entry>
</row>
<row>
<entry>
<para>specific </para>
</entry>
<entry>
<para>определённый, конкретный (<emphasis>очень редко</emphasis> специфичный!) </para>
</entry>
</row>
<row>
<entry>
<para>stage </para>
</entry>
<entry>
<para>стадия (в Gentoo — генерации операционной системы, вообще — часто установки или загрузки системы) </para>
</entry>
</row>
<row>
<entry>
<para>stage file (archive) </para>
</entry>
<entry>
<para>файл [архив] стадии; stage-файл [stage-архив](при упоминании сохранять английское написание файла, чтобы его находили) </para>
</entry>
</row>
<row>
<entry>
<para>start [device] </para>
</entry>
<entry>
<para>запуск [устройства] </para>
</entry>
</row>
<row>
<entry>
<para>statement </para>
</entry>
<entry>
<para>выражение </para>
</entry>
</row>
<row>
<entry>
<para>stop [device] </para>
</entry>
<entry>
<para>остановка [устройства] </para>
</entry>
</row>
<row>
<entry>
<para>striping [raid] </para>
</entry>
<entry>
<para>чередование (RAID 0, RAID 5) </para>
</entry>
</row>
<row>
<entry>
<para>subarch[itecture] </para>
</entry>
<entry>
<para>разновидность архитектуры </para>
</entry>
</row>
<row>
<entry>
<para>summary </para>
</entry>
<entry>
<para>аннотация (краткое описание документа) </para>
</entry>
</row>
<row>
<entry>
<para>superuser </para>
</entry>
<entry>
<para>администратор (ср. пользователь) </para>
</entry>
</row>
<row>
<entry>
<para>supplicant [WPA] </para>
</entry>
<entry>
<para>запросчик </para>
</entry>
</row>
<row>
<entry>
<para>swap </para>
</entry>
<entry>
<para>подкачка </para>
</entry>
</row>
<row>
<entry>
<para>switch, [command line] </para>
</entry>
<entry>
<para>параметр [командной строки] </para>
</entry>
</row>
<row>
<entry>
<para>switch, [network] </para>
</entry>
<entry>
<para>(сетевой) коммутатор </para>
</entry>
</row>
<row>
<entry>
<para>symlink </para>
</entry>
<entry>
<para>символьная ссылка(тж. в других ОС — softlink, alias, shortcut, shadow: псевдоним, ярлык, тень) </para>
</entry>
</row>
<row>
<entry>
<para>syntax </para>
</entry>
<entry>
<para>синтаксис (выражения);формат, структура (текстового конфигурационного файла) </para>
</entry>
</row>
<row>
<entry>
<para>system information </para>
</entry>
<entry>
<para>системные параметры (в руководстве по настройке), сведения о системе (при ответе на запрос пользователя) </para>
</entry>
</row>
<row>
<entry>
<para>system, [computer] </para>
</entry>
<entry>
<para>[компьютерная] система </para>
</entry>
</row>
<row>
<entry>
<para>tag (xml/html) </para>
</entry>
<entry>
<para>тег (в XML или HTML; при указании на метки вместе с содержимым — элемент); метка (проч.) </para>
</entry>
</row>
<row>
<entry>
<para>tarball </para>
</entry>
<entry>
<para>архив (набор файлов, помещённый в один файл-контейнер) </para>
</entry>
</row>
<row>
<entry>
<para>target [of compilation] </para>
</entry>
<entry>
<para>цель [компиляции] </para>
</entry>
</row>
<row>
<entry>
<para>time zone </para>
</entry>
<entry>
<para>часовой пояс </para>
</entry>
</row>
<row>
<entry>
<para>tips &amp; tricks </para>
</entry>
<entry>
<para>полезные советы (<emphasis>не применяются выражения:</emphasis> «советы и хитрости», «маленькие хитрости») </para>
</entry>
</row>
<row>
<entry>
<para>tool </para>
</entry>
<entry>
<para>средство; утилита;(иногда, по смыслу) служба </para>
</entry>
</row>
<row>
<entry>
<para>toolchain </para>
</entry>
<entry>
<para>(**) средства компиляции?</para>
</entry>
</row>
<row>
<entry>
<para>traffic </para>
</entry>
<entry>
<para>трафик;движение, поток (употребляется реже) </para>
</entry>
</row>
<row>
<entry>
<para>tweak </para>
</entry>
<entry>
<para>ухищрение (сущ.)подстроить (гл.) </para>
</entry>
</row>
<row>
<entry>
<para>unmount </para>
</entry>
<entry>
<para>размонтировать (см. комментарий к mount) </para>
</entry>
</row>
<row>
<entry>
<para>up [interface]</para>
</entry>
<entry>
<para>включён</para>
</entry>
</row>
<row>
<entry>
<para>upstream [developers]</para>
</entry>
<entry>
<para>разработчики самогó пакета (входящего в состав Gentoo)</para>
</entry>
</row>
<row>
<entry>
<para>USE flags</para>
</entry>
<entry>
<para>USE-флаги (признаки использования функций, указываемые в переменной USE) </para>
</entry>
</row>
<row>
<entry>
<para>USE-expanded variable</para>
</entry>
<entry>
<para>переменная, преобразующаяся в USE флаг </para>
</entry>
</row>
<row>
<entry>
<para>user</para>
</entry>
<entry>
<para>учётная запись (о реквизитах пользователя);пользователь (о человеке) </para>
</entry>
</row>
<row>
<entry>
<para>user-space</para>
</entry>
<entry>
<para>режим пользователя; [адресное] пространство пользователя</para>
</entry>
</row>
<row>
<entry>
<para>userland</para>
</entry>
<entry>
<para>режим пользователя (см. user-space) (**)</para>
</entry>
</row>
<row>
<entry>
<para>variable</para>
</entry>
<entry>
<para>переменная; значение переменной (будьте внимательны!)</para>
</entry>
</row>
<row>
<entry>
<para>verbose</para>
</entry>
<entry>
<para>подробный; расширенный [вывод, листинг]подробные сообщения</para>
</entry>
</row>
<row>
<entry>
<para>wallpaper</para>
</entry>
<entry>
<para>обои (на графическом рабочем столе)</para>
</entry>
</row>
<row>
<entry>
<para>web site</para>
</entry>
<entry>
<para>веб-сайт</para>
</entry>
</row>
<row>
<entry>
<para>window manager</para>
</entry>
<entry>
<para>диспетчер окон</para>
</entry>
</row>
<row>
<entry>
<para>wireless (сущ.)</para>
</entry>
<entry>
<para>беспроводное подключение; беспроводная сеть; беспроводное устройство (по контексту) </para>
</entry>
</row>
<row>
<entry>
<para>wrapper</para>
</entry>
<entry>
<para>обёртка? упаковщик? (**)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<title>Запрещённые термины, или КАК НЕ НАДО</title>
<para>Употребление этих терминов — лучший способ «облегчить» работу редактора: при этом задержка публикации вашего материала (из-за того, что правка документа будет вызывать непреодолимую грусть) — обеспечена ;-) </para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Неверный перевод</para>
</entry>
<entry>
<para>Правильно</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>брандмауэр, firewall</para>
</entry>
<entry>
<para>межсетевой экран</para>
</entry>
</row>
<row>
<entry>
<para>карта(видео/сетевая/...)</para>
</entry>
<entry>
<para>плата<emphasis>(а карта — игральная [card] или географическая </emphasis>
<emphasis>[map])</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>гид </para>
</entry>
<entry>
<para>руководство(гид — это экскурсовод) </para>
</entry>
</row>
<row>
<entry>
<para>десктоп </para>
</entry>
<entry>
<para>настольный (прил.)[графическая] среда (сущ.) </para>
</entry>
</row>
<row>
<entry>
<para>директория </para>
</entry>
<entry>
<para>каталог<emphasis>(по-русски директория — справочник или орган </emphasis>
<emphasis>власти)</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>ебилд </para>
</entry>
<entry>
<para>сборочный файл [ebuild]<emphasis>(догадываетесь, почему?)</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>локаль </para>
</entry>
<entry>
<para>регион;региональные настройки </para>
</entry>
</row>
<row>
<entry>
<para>менеджер </para>
</entry>
<entry>
<para>диспетчер </para>
</entry>
</row>
<row>
<entry>
<para>опция,опциональный </para>
</entry>
<entry>
<para>возможность; функция; параметр </para>
</entry>
</row>
<row>
<entry>
<para>патч </para>
</entry>
<entry>
<para>заплатка, исправление </para>
</entry>
</row>
<row>
<entry>
<para>переменные окружения </para>
</entry>
<entry>
<para>переменные среды<emphasis>(речь идёт о среде исполнения)</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>продвинутый </para>
</entry>
<entry>
<para>расширенный, углубленный </para>
</entry>
</row>
<row>
<entry>
<para>релиз </para>
</entry>
<entry>
<para>выпуск <emphasis>(о программе)</emphasis>издание <emphasis>(о книге)</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>репозиторий документации </para>
</entry>
<entry>
<para>хранилище документации </para>
</entry>
</row>
<row>
<entry>
<para>сигнатура </para>
</entry>
<entry>
<para>признак, идентификатор, подпись </para>
</entry>
</row>
<row>
<entry>
<para>система уведомления о ошибках и изменениях;система управления изменениямисистема отчёта об ошибках </para>
</entry>
<entry>
<para>система распределения запросов </para>
</entry>
</row>
<row>
<entry>
<para>скрипт </para>
</entry>
<entry>
<para>сценарий </para>
</entry>
</row>
<row>
<entry>
<para>суперпользовательсверхпользователь </para>
</entry>
<entry>
<para>администратор;[корневая] учётная запись root (root administrative account)<emphasis>Споры о разности понятий в разных ОС — отставить (я не виноват, что именно в Linux упрощённая модель допуска)</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>сценарий управления сервисом </para>
</entry>
<entry>
<para>сценарий инициализации<emphasis>(расширение смысла разумно, но это изменение есть смысл вносить в оригинальный текст, иначе будет путаница)</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>ускорение не двухмерной графики </para>
</entry>
<entry>
<para>ускорение <emphasis>двумерной</emphasis> (нет буквы х) графики </para>
</entry>
</row>
<row>
<entry>
<para>фреймбуфер </para>
</entry>
<entry>
<para>кадровый буфер<emphasis>(термин устоялся, когда Линус ещё не родился)</emphasis> </para>
</entry>
</row></tbody></tgroup>
</informaltable></sect1><sect2><title>Запрещённые термины, или КАК НЕ НАДО</title>
<para>Употребление этих терминов — лучший способ «облегчить» работу редактора: при этом задержка публикации вашего материала (из-за того, что правка документа будет вызывать непреодолимую грусть) — обеспечена ;-) </para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row>
<entry>
<para>Неверный перевод</para>
</entry>
<entry>
<para>Правильно</para>
</entry>
</row>
</thead><tbody>
<row>
<entry>
<para>брандмауэр, firewall</para>
</entry>
<entry>
<para>межсетевой экран</para>
</entry>
</row>
<row>
<entry>
<para>карта(видео/сетевая/...)</para>
</entry>
<entry>
<para>плата<emphasis>(а карта — игральная [card] или географическая </emphasis>
<emphasis>[map])</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>гид </para>
</entry>
<entry>
<para>руководство(гид — это экскурсовод) </para>
</entry>
</row>
<row>
<entry>
<para>десктоп </para>
</entry>
<entry>
<para>настольный (прил.)[графическая] среда (сущ.) </para>
</entry>
</row>
<row>
<entry>
<para>директория </para>
</entry>
<entry>
<para>каталог<emphasis>(по-русски директория — справочник или орган </emphasis>
<emphasis>власти)</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>ебилд </para>
</entry>
<entry>
<para>сборочный файл [ebuild]<emphasis>(догадываетесь, почему?)</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>локаль </para>
</entry>
<entry>
<para>регион;региональные настройки </para>
</entry>
</row>
<row>
<entry>
<para>менеджер </para>
</entry>
<entry>
<para>диспетчер </para>
</entry>
</row>
<row>
<entry>
<para>опция,опциональный </para>
</entry>
<entry>
<para>возможность; функция; параметр </para>
</entry>
</row>
<row>
<entry>
<para>патч </para>
</entry>
<entry>
<para>заплатка, исправление </para>
</entry>
</row>
<row>
<entry>
<para>переменные окружения </para>
</entry>
<entry>
<para>переменные среды<emphasis>(речь идёт о среде исполнения)</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>продвинутый </para>
</entry>
<entry>
<para>расширенный, углубленный </para>
</entry>
</row>
<row>
<entry>
<para>релиз </para>
</entry>
<entry>
<para>выпуск <emphasis>(о программе)</emphasis>издание <emphasis>(о книге)</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>репозиторий документации </para>
</entry>
<entry>
<para>хранилище документации </para>
</entry>
</row>
<row>
<entry>
<para>сигнатура </para>
</entry>
<entry>
<para>признак, идентификатор, подпись </para>
</entry>
</row>
<row>
<entry>
<para>система уведомления о ошибках и изменениях;система управления изменениямисистема отчёта об ошибках </para>
</entry>
<entry>
<para>система распределения запросов </para>
</entry>
</row>
<row>
<entry>
<para>скрипт </para>
</entry>
<entry>
<para>сценарий </para>
</entry>
</row>
<row>
<entry>
<para>суперпользовательсверхпользователь </para>
</entry>
<entry>
<para>администратор;[корневая] учётная запись root (root administrative account)<emphasis>Споры о разности понятий в разных ОС — отставить (я не виноват, что именно в Linux упрощённая модель допуска)</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>сценарий управления сервисом </para>
</entry>
<entry>
<para>сценарий инициализации<emphasis>(расширение смысла разумно, но это изменение есть смысл вносить в оригинальный текст, иначе будет путаница)</emphasis> </para>
</entry>
</row>
<row>
<entry>
<para>ускорение не двухмерной графики </para>
</entry>
<entry>
<para>ускорение <emphasis>двумерной</emphasis> (нет буквы х) графики </para>
</entry>
</row>
<row>
<entry>
<para>фреймбуфер </para>
</entry>
<entry>
<para>кадровый буфер<emphasis>(термин устоялся, когда Линус ещё не родился)</emphasis> </para>
</entry>
</row></tbody></tgroup>
</informaltable><sect1 id="footer"><para>Текст документа распространяется на условиях лицензии <ulink url="http://creativecommons.org/licenses/by-sa/2.5">Creative Commons — Attribution / Share Alike</ulink>.Этот <emphasis>неофициальный</emphasis> сайт создал и поддерживает <ulink url="mailto:achumakov@gentoo.org">Алексей Чумаков</ulink>. © 2005—2006 проект «русский гентý».Материалы проекта Gentoo © 2001—2006 </para></sect1><para/></sect2></sect1><sect1><title>MAN (справки по командам)</title><sect2><title>Emerge</title>
<para>Имя:</para>
<para>emerge - интерфейс командной строки к системе портежей (Portage system) </para>
<para/>
<para>Синтаксис:</para>
<para/>
<para>emerge [опции] [действие] [ebuild | файл_tbz2 | класс | зависимость]... </para>
<para/>
<para>emerge [опции] [действие] файл_ebuild </para>
<para/>
<para>emerge sync | rsync </para>
<para/>
<para>emerge --help -h [system | config | sync] </para>
<para/>
<para>emerge --version </para>
<para/>
<para>Описание:</para>
<para/>
<para>emerge - это полный интерфейс командной строки к системе портежей. Используется, в основном, для установки пакетов, причем, emerge может автоматически обрабатывать любые зависимости, заданые в требуемом пакете. Утилита emerge может также обновлять дерево портежей, предоставляя доступ к новым и обновленным пакетам. Утилита emerge также обеспечивает беспроблемное обновление версий установленных пакетов. Позволяет работать с пакетами как в виде исходных кодов, так и в двоичном виде, также может использоваться для создания двоичных пакетов с целью дальнейшего распространения. Пакеты EBUILD, файлы TBZ2, классы и зависимости </para>
<para/>
<para>Основное назначение утилиты emerge - установка пакетов. Устанавливаемые пакеты можно задать одним из четырех основных способов: как пакет ebuild, как файл tbz2, как класс или как зависимость. </para>
<para/>
<para>ebuild</para>
<para/>
<para>ebuild необходимо задавать, как минимум, в виде допустимого имени в каталоге пакетов портежей (valid Portage package directory name) без указания версии или категории, например, portage или python. Можно добавить также категорию и номер версии, например, sys-apps/portage или python-2.2.1-r2. Утилита emerge игнорирует завершающую косую черту, так что, можно использовать автоматическое завершение для имён файлов. В качестве значения ebuild можно также задавать реальное имя файла, например, /usr/portage/app-admin/python/python-2.2.1-r2.ebuild. </para>
<para/>
<para>Файл_tbz2</para>
<para/>
<para>Файл_tbz2 должен быть корректным файлом .tbz2, созданным с помощью команды </para>
<para/>
<para>ebuild &lt;пакет&gt;-&lt;версия&gt;.ebuild пакет или </para>
<para/>
<para>emerge --buildpkg [категория/]&lt;пакет&gt;, или </para>
<para/>
<para>quickpkg /var/db/pkg/&lt;категория&gt;/&lt;пакет&gt;. </para>
<para/>
<para>Класс</para>
<para/>
<para>Классы пакетов - удобный способ обозначить большую группу пакетов. В настоящее время поддерживается два класса: system и world. Класс system содержит набор пакетов, считающихся необходимыми для правильной работы системы. Класс world содержит все пакеты в системе плюс все пакеты, перечисленные в файле /var/cache/edb/world или /var/lib/portage/world (=&gt;portage-2.0.51). Подробнее см. далее в разделе Файлы </para>
<para/>
<para>Учтите, что эти команды обычно используются вместе с --update. </para>
<para/>
<para>Зависимость</para>
<para/>
<para>Зависимость описывает ограничения на пакет, который будет установлен. Например, &gt;=dev-lang/python-2.2.1-r2 что соответствует последней доступной версии языка Python, большей или равной 2.2.1-r2. Аналогично, &lt;dev-lang/python-2.0 соответствует последней доступной версии языка Python до 2.0. Учтите, что во многих командных интерпретаторах потребуется замаскировать символы вроде '&lt;' и '=' ; чтобы избежать проблем с маскировкой, берите зависимость в одиночные или двойные кавычки. </para>
<para/>
<para>Действия</para>
<para/>
<para>Нет действия</para>
<para/>
<para>Если действие не указано, в систему добавляются указанные пакеты и удовлетворяются все их зависимости. В качестве аргументов можно указывать пакеты ebuild, файлы tbz2, классы или зависимости. Учтите, что для установки файла tbz2 необходимо указать опцию --usrpkg. Пакеты добавляются в конце файла world, так что они учитываются при последующих обновлениях. </para>
<para/>
<para>--clean</para>
<para>-c </para>
<para/>
<para>Очищает систему, удаляя пакеты, не влияющие на функциональность системы. В качестве аргументов можно указывать пакеты build, классы или зависимости. Например, </para>
<para/>
<para>emerge clean binutils удаляет старые версии binutils; </para>
<para/>
<para>emerge clean net-www/mozilla-0.9.9-r2 удаляет указанную версию Mozilla. </para>
<para/>
<para>Использовать эту команду, в общем случае, безопасно. Учтите, что пакеты в единственном экземпляре (unslotted packages) команда clean не удаляет. </para>
<para/>
<para>--depclean</para>
<para/>
<para>Выявляет все пакеты, установленные в системе без видимой причины. Утилита emerge генерирует список пакетов, которые должны быть установлены, на основе списка системных пакетов и файла world. Затем она сравнивает этот список со списком фактически установленных пакетов; найденные различия выдаются как ненужные пакеты, которые предлагается удалить. Предупреждение: Удаление некоторых пакетов может привести к тому, что пакеты, связанные с удаленными, перестанут работать и начнут сообщать о недостающих библиотеках. Снова установите с помощью emerge пакет, который перестал работать, и эта проблема будет решена. Учтите, что изменения флагов USE могут существенно повлиять на результат, выдаваемый при выполнении действия depclean. </para>
<para/>
<para/>
<para>--help</para>
<para>-h </para>
<para/>
<para>Выдает справочную информацию по утилите emerge. Добавление одного из прочих перечисленных дополнительных аргументов приводит к выдаче более детальной справочной информации по соответствующему действию. Встроенная справочная документация утилиты emerge обновляется чаще, чем эта страница справочного руководства; обратитесь к ней при возникновении проблем, которые не поможет решить эта страница справочного руководства. </para>
<para/>
<para>--info</para>
<para/>
<para>Выдает информацию для включения в отчеты об ошибках. Эта информация помогает разработчикам при решении проблем, о которых вы сообщаете. Включайте, пожалуйста, эту информацию при посылке отчета об ошибке. Расширенную информацию можно получить при указании опции --verbose. </para>
<para/>
<para>При "впрыске" пакета для него вставляется "заглушка" так, что система портежей считает его установленным. Это удобно если необходимо, например, установить двоичную версию XFree86 для нетривиальной видеокарты или просто добавить собственные пакеты. Необходимо указать категорию и конкретную версию вставляемого пакета. Например, emerge inject sys-kernel/gentoo-sources-2.4.19 </para>
<para/>
<para>--prune</para>
<para>-P </para>
<para>Предупреждение: Это действие может удалить важные пакеты! Удаляются все, кроме последних, версий соответствующих пакетов. Если для пакета есть несколько слотов, остается только последняя версия в каждом слоте. При этом не происходит проверки зависимостей, поэтому могут быть удалены пакеты, необходимые для нормальной работы системы. Используйте действие clean, если не уверены абсолютно в том, что делаете. В качестве аргуменгтов можно указывать пакеты ebuild, классы или зависимости -- примеры см. в описании действия clean. </para>
<para/>
<para>--regen</para>
<para/>
<para>Вызывает проверку и обновление кеша зависимостей для всех пакетов ebuild в дереве портежей. Кеш используется для ускорения поиска и построения деревьев зависимостей. Эта команда не рекомендуется для пользователей rsync, поскольку rsync обновляет кеш, используя кеши на сервере. Если вы не знаете, чем отличается "пользователь rsync" от других пользователей, значит, вы - "пользователь rsync" :). Пользователи rsync должны просто выполнить команду emerge sync для регенерации кеша. </para>
<para/>
<para>--search</para>
<para>-s </para>
<para/>
<para>Ищет соответствия переданной строке в дереве портежей. Искомая строка представляет собой регулярное выражение. Например, команда </para>
<para/>
<para>emerge search "^kde" ищет любой пакет, имя которого начинается с "kde"; </para>
<para/>
<para>emerge search "gcc$" ищет любой пакет, имя которого заканчивается на "gcc"; </para>
<para/>
<para>emerge search "office" ищет любой пакет, имя которого содержит слово "office". </para>
<para/>
<para>Если поиск необходимо выполнять и в описании пакета, используйте опцию --searchdesc или -S. </para>
<para/>
<para>--sync</para>
<para/>
<para>Инициирует обновление дерева портежей с одного из зеркал rsync.gentoo.org. Учтите, что любые изменения, выполненные в дереве портежей, при этом будут стерты. За исключением специальных случаев, для обновления используется rsync. Чтобы узнать, как избежать удаления изменения, см. описание PORTDIR_OVERLAY на странице справочного руководства make.conf(5). </para>
<para/>
<para/>
<para/>
<para>--unmerge</para>
<para>-C </para>
<para>Предупреждение: При этом могут быть удалены важные пакеты! Удаляются все соответствующие пакеты. Проверка зависимостей не выполняется, поэтому могут быть удалены пакеты, необходимые для нормальной работы системы. В качестве аргументов можно задавать пакеты ebuild, классы или зависимости - примеры см. выше в описании clean. </para>
<para/>
<para>--ask</para>
<para>-a </para>
<para/>
<para>--buildpkg</para>
<para>-b </para>
<para/>
<para>Говорит emerge о необходимости построить двоичные пакеты для всех соответствующих пакетов ebuild, помимо их обычного добавления в дерево. Полезно для тех, кто занимается поддержкой пакетов или при администрировании нескольких систем Gentoo Linux (строим один раз, устанавливаем пакеты tbz2 с помощью emerge везде). Пакет будет создан в каталоге ${PKGDIR}/All. В качестве альтернативы для уже включенных в дерево пакетов можно использовать опцию quickpkq, которая создает пакеты tbz2 из "живой" файловой системы. </para>
<para/>
<para>--buildpkgonly</para>
<para>-B </para>
<para/>
<para>Создает двоичные пакеты для всех обработанных пакетов ebuild, не включая их фактически в дерево пакетов. Проблема только в том, что все зависимости времени построения уже должны быть включены в систему с помощью emerge. </para>
<para/>
<para/>
<para/>
<para/>
<para>--changelog</para>
<para>-l </para>
<para/>
<para>Используйте эту опцию вместе с действием --pretend. В результате, будут показаны записи ChangeLog для всех пакетов, которые будут обновляться. </para>
<para/>
<para>--columns</para>
<para/>
<para>При использовании совместно с --pretend выдает имена пакетов, новую и старую версию выравненными по столбцам для простоты вырезания и копирования. </para>
<para/>
<para>--debug</para>
<para>-d </para>
<para/>
<para>Требует от emerge работать в отладочном режиме. В этом режиме среда построения bash будет работать с опцией -x, выдавая детальную отладочную информацию в стандартных выходной поток. Опция --debug отлично подходит для поиска синтаксических ошибок bash. </para>
<para/>
<para>--deep</para>
<para>-D </para>
<para/>
<para>При использовании совместно с опцией --update, этот флаг требует от emerge учитывать все дерево зависимостей пакетов, а не просто проверять непосредственные зависимости пакетов. Это, например, позволяет учесть обновления в библиотеках, не перечисленных явно в зависимостях пакета. </para>
<para/>
<para>--emptytree</para>
<para>-e </para>
<para/>
<para>Создает видимость того, что дерево установленных пакетов содержит только glibc; эту опцию стоит использовать совместно с --pretend. Она позволяет разработчикам получить полное представление о дереве всех зависимостей пакета и перестраивать деревья в целом с использованием новейших версий библиотек. </para>
<para/>
<para>--fetchonly</para>
<para>-f </para>
<para/>
<para>Вместо создания(установки) пакета, просто выбирает(скачивает, загружает) (fetches) в ../distfiles все пакеты (главный пакет и все его зависимости). </para>
<para/>
<para>--fetch-all-uri</para>
<para>-F </para>
<para/>
<para>--getbinpkg</para>
<para>-g </para>
<para/>
<para>--getbinpkg</para>
<para>-G </para>
<para/>
<para>--help</para>
<para>-h </para>
<para/>
<para>--newuse</para>
<para>-N </para>
<para/>
<para>используя совместно с опцией --update, позволяет проверить(и переустановить) все пакеты, флаги которых на данный момент были изменены в /etc/make.conf </para>
<para/>
<para>--noconfmem</para>
<para/>
<para>Требует от портежей не учитывать записи слияния, показывающий, что файл конфигурации в каталоге CONFIG_PROTECT уже был включен в дерево. Система портежей обычно будет включать такие файлы только раз, чтобы не заставлять пользователя возиться с одной и той же конфигурацией несколько раз. Этот флаг приведет к включению файла конфгиурации каждый раз. </para>
<para/>
<para>--nodeps</para>
<para>-O </para>
<para/>
<para>Включает указанные пакеты, не включая зависимости. Учтите, что процесс построения может закончиться неудачно, если зависимости окажутся не удовлетворенными. </para>
<para/>
<para>--noreplace</para>
<para>-n </para>
<para/>
<para>Пропускает указанные в командной строке пакеты, если они уже были установлены. Без этой опции любые указанные в командной строке пакеты, пакеты ebuild или зависимости будут приводить к повторному включению соответствующего пакета системой Portage, даже если он уже установлен. Учтите, что зависимости система Portage по умолчанию повторно не включает. </para>
<para/>
<para>--nospinner</para>
<para/>
<para>Отключает для сеанса "крутилку" (spinner). "Крутилка" активируется, если команда подана с терминала (TTY). Этот флаг отключает ее, независимо от устройства. </para>
<para/>
<para>--oneshot</para>
<para/>
<para>Включает пакеты как обычно, но не добавляет в профиль world с целью дальнейшего обновления. </para>
<para/>
<para>--onlydeps</para>
<para>-o </para>
<para/>
<para>Включает (или делает вид, что включает) зависимости указанных пакетов, а не сами пакеты. </para>
<para/>
<para>--pretend</para>
<para>-p </para>
<para/>
<para>Вместо реального включения просто показывает, что должно устанавливаться, если не указать --pretend. Использование опции --pretend настоятельно рекомендуется перед установкой любого незнакомого пакета. В выдаваемом результате: </para>
<para>N = новый </para>
<para>U = обновление </para>
<para>R = замена </para>
<para>B = блокируется уже установленным пакетом. </para>
<para/>
<para>--quiet</para>
<para>-q </para>
<para/>
<para>Результаты могут отличаться, но, в общем случае, объем выдаваемых системой портежей результатов сокращается или выдача уплотняется. </para>
<para/>
<para/>
<para/>
<para/>
<para/>
<para>--resume</para>
<para/>
<para>Возобновляет последнее действие по включению пакетов. Учтите, пожалуйста, что возобновить можно только действие, закончившиеся с ошибкой из-за сбоя. Если делать нечего, будет просто выдано сообщение об успешном выполнении. </para>
<para/>
<para>--searchdesc</para>
<para>-S </para>
<para/>
<para>Сопоставляет строку поиска с полем описания и именем пакета. Учтите, что сопоставление с регулярным выражением ведется и в описании пакета. </para>
<para/>
<para>--skipfirst</para>
<para/>
<para>Это действие допустимо только совместно с --resume. Оно удаляет первый пакет в списке кандидатов на возобновление установки, так, чтобы включение могло продолжиться даже при наличии неисправимой или несущественной ошибки. Эту опцию надо использовать только в случаях, когда пропуск пакета не нарушает зависимости. </para>
<para/>
<para>--tree</para>
<para>-t </para>
<para/>
<para>--update</para>
<para>-u </para>
<para/>
<para>Обновляет пакеты до самой новой из доступных версий. Учтите, что --update еще не обладает всеми необходимыми возможностями. Он не будет автоматически обновлять зависимости пакетов в файле world, если их самих там еще нет. </para>
<para/>
<para>--upgradeonly</para>
<para>-U </para>
<para/>
<para>Обновляет пакеты, исключая обновления, приводящие к понижению версии устанавливаемого пакета. Слоты (SLOTs) учитываются на простейшем уровне. </para>
<para/>
<para>--usepkg</para>
<para>-k </para>
<para/>
<para>Требует от emerge использовать двоичные пакеты (из каталога $PKGDIR), если они есть, избегая этим, по возможности, продолжительных компиляций. Эта опция полезна для установок с компакт-дисков; можно выполнить export PKGDIR=/mnt/cdrom/packages, а затем использовать эту опцию, чтобы emerge "вытягивала" пакеты с CD для удовлетворения зависимостей. </para>
<para/>
<para>--usepkgonly</para>
<para>-K </para>
<para/>
<para>Работает так же, как и --usepkg, но включает только двоичные пакеты. Все необходимые двоичные пакеты должны быть доступны на момент проверки зависимостей или emerge просто прекратит работу. </para>
<para/>
<para>--verbose</para>
<para>-v </para>
<para/>
<para>Требует от emerge работать в многословном (verbose) режиме. В настоящее время этот флаг приводит к тому, что emerge выдает сообщения об ошибках GNU info, если они будут. </para>
<para/>
<para>--version</para>
<para>-V </para>
<para/>
<para>Выдает номер версии emerge. Эту опцию нельзя сочетать с другими; имя и формат действия при этом не важны. </para>
<para/>
<para>Выдаваемые результаты</para>
<para/>
<para>При использовании emerge с флагами pretend/verbose, результаты на первый взгляд могут показаться сложными для понимания. Этот раздел объясняет, что означает вся эта "стенографическая" информация. </para>
<para/>
<para>[blocks B ]</para>
<para>[blocks B ] app-text/dos2unix (from pkg app-text/hd2u-0.8.0) </para>
<para/>
<para>Пакет Dos2unix блокирует включение в дерево пакета hd2u. Блокирование выявляется, когда два пакета перекрываются по файлам или могут вызвать те или иные повреждения в системе. Однако обычно включать одновременно блокирующие друг друга пакеты не нужно, поскольку обычно они обеспечивают одинаковые возможности. </para>
<para/>
<para>[ebuild N ]</para>
<para>[ebuild N ] app-games/qstat-25c </para>
<para/>
<para>Пакет Qstat - новый в вашей системе и будет включаться в дерево с помощью emerge впервые. </para>
<para/>
<para>[ebuild R ]</para>
<para>[ebuild R ] sys-apps/sed-4.0.5 </para>
<para/>
<para>Пакет sed 4.0.5 уже был включен, но если выполнить команду еще раз, система портежей повторно включит этот пакет (в данном случае, sed). </para>
<para/>
<para>[ebuild F ]</para>
<para>[ebuild F ] media-video/realplayer-8-r6 </para>
<para/>
<para>Пакет realplayer требует, чтобы вы загрузили исходники вручную. При попытке включить пакет в дерево, если исходные тексты пакета не найдены, система портежей остановится и выдаст инструкции о том, как загрузить недостающие файлы. </para>
<para/>
<para>[ebuild U ]</para>
<para>[ebuild U ] net-fs/samba-2.2.8_pre1 [2.2.7a] </para>
<para/>
<para>Пакет Samba 2.2.7a уже был включен и может быть обновлен до версии 2.2.8_pre1. </para>
<para/>
<para>[ebuild UD]</para>
<para>[ebuild UD] media-libs/libgd-1.8.4 [2.0.11] </para>
<para/>
<para>Пакет Libgd 2.0.11 уже был включен, но если выполнить команду, система портежей автоматически понизит (Downgrade) версию пакета до 1.8.4. Это может произойти, если более новая версия пакета была замаксирована, поскольку оказалась поврежденной или создает угрозу защите системы, а исправление еще не выпущено. </para>
<para/>
<para>Еще это может произойти потому, что пакет, который вы пытаетесь включить с помощью emerge требует для успешного включения более старую версию пакета. В данном случае, библиотека libgd 2.x несовместима с libgd 1.x. Это означает, что пакеты, созданные с использованием libgd 1.x, не скомпилируются с версией 2.x, и ее надо понизить, прежде чем удастся эти пакеты успешно установить. </para>
<para/>
<para>[ebuild U-]</para>
<para>[ebuild U-] x11-base/xfree-4.3.0 [4.2.99.902] </para>
<para/>
<para>Дефис (-) представляет отсутствие информации о слоте (SLOT information) пакета Xfree. Это происходит, когда предыдущая версия была просто "впрыснута" (подробнее см. описание действия inject, или оказалась настолько старой, что соответствующий слот не существует. В любом случае, более новая версия Xfree доступна для обновления. </para>
<para/>
<para>[ebuild U ]</para>
<para>[ebuild U ] net-analyzer/nmap-3.15_beta2 [3.15_beta1] -gtk -gnome </para>
<para/>
<para>Значения -gtk и -gnome отражают статус USE-переменных при включении пакета nmap. Здесь мы видим, что nmap может использовать USE-переменные gtk и gnome, но в текущих установках переменные gtk и gnome отключены. Поэтому дополнительная поддержка gtk и gnome не будет включена в nmap при его установке. </para>
<para/>
<para>Примечание</para>
<para/>
<para>Статус USE выдается только если используются опции --pretend и --verbose. </para>
<para/>
<para>ПРИМЕЧАНИЯ</para>
<para/>
<para>Практически всегда надо перед любой попыткой установки или обновления выполнять ее же, но с опцией --pretend. Это позволяет увидеть, что будет сделано, а также выявить блокирующие пакеты, которые надо будет предварительно удалить. Это тем более важно для классов system и world, которые могут вызвать обновление большого количества пакетов, если дерево портежей было достаточно активно. </para>
<para/>
<para>Обычно также имеет смысл использовать опцию --update, которая позволяет игнорировать уже полностью обновленные пакеты, но обновлять при этом все остальные. При установке пакета с неустановленными зависимостями, если зависимости эти не указаны явно в списке параметров, они не будут добавляться в файл world. Если необходимо внести зависимости в файл world для дальнейшего обновления, не забудьте явно указать их в качестве параметров emerge. </para>
<para/>
<para>В командной строке можно указывать USE-переменные, переопределяющие значения, указанные в стандартных местах, что позволяет избежать использования ряда нежелательных зависимостей. Флаги USE, заданные в командной строке, НЕ запоминаются. Например, команда </para>
<para/>
<para>USE="-x -gnome" emerge mc </para>
<para/>
<para>установит пакет mc с указанными установками USE. </para>
<para/>
<para>Если команда emerge --update system или </para>
<para/>
<para>emerge --update world не сработает с выдачей сообщений об ошибках, причина может быть в том, что пакет ebuild использует новую возможность, которой нет в этой версии утилиты emerge. Можно сначала выполнить </para>
<para/>
<para>emerge --update portage для обновления до последней версии, которая должна поддерживать любые необходимые новые возможности. </para>
<para/>
<para>Примечание: Будьте осторожны при использовании пакетов, находящихся в стадии разработки. Проблемы и ошибки, возникающие в результате неправильного использования замаскированных пакетов, приводят к напрасной трате времени разработчиков Gentoo. Подумайте заранее, сможете ли справиться с проблемами, которые могут возникнуть. </para>
<para/>
<para>Маски в системе портежей обеспечивают три основные функции: они позволяют задать период тестирования, в течение которого пакеты могут использоваться на машинах; они предотвращают использование пакета, который начал сбоить, и позволяют маскировать существующие пакеты, поломанные или угрожающие защите. Маскирование можно делать двумя способами: с помощью файла package.mask и с помощью ключевых слов. Как демаскировать пакет при использовании этих способов описано ниже. Учтите также, что если утилите emerge передается пакет ebuild, то все виды максировки игнорируются и emerge будет пытаться включить пакет в систему. </para>
<para/>
<para>package.mask</para>
<para/>
<para>Файл package.mask, в основном, блокирует использование пакетов, вызывающих проблемы или известных, как приводящие к проблемах на некоторых машинах. Он находится в каталоге /etc/portage. Пакеты можно демаскировать в файле путем добавления символа комментария (#) в начале строки, маскирующей пакет. </para>
<para/>
<para>Ключевые слова</para>
<para/>
<para>Ключевые слова (KEYWORDS) также используются для маскировки пакетов, находящихся на стадии тестирования. Есть определяющие архитектуру ключевые слова для каждого пакета, позволяющие системе портежей определить, с какими системами совместим пакет. Пакеты, компилирующиеся на некоторой архитектуре, но не считающиеся "стабильными", маскируются путем указания тильды (~) перед названием архитектуры. Утилита emerge проверяет значение переменной среды ACCEPT_KEYWORDS, прежде чем разрешить или запретить включение пакета, замаскированного с помощью КЛЮЧЕВЫХ СЛОВ. </para>
<para/>
<para>Чтобы проинформировать утилиту emerge, что необходимо построить эти "тестовые" версии пакетов, можно установить переменной ACCEPT_KEYWORDS значение "~arch", где arch - одно из значений: x86, ppc, sparc, mips, alpha, arm, hppa. Например, команда ACCEPT_KEYWORDS="~x86" emerge xfree приведет к тому, что emerge будет учитывать замаскированные ключевыми словами версии XFree в качестве потоенциальных кандидатов на обновление. </para>
<para>Предупреждение: Не устанавливайте этой переменной значение, отличающееся от соответствующего вашей архитектуре. </para>
<para/>
<para>Как сообщать об ошибках</para>
<para/>
<para>Пожалуйста, сообщайте о любых обнаруженных ошибках через bugs.gentoo.org web-сайт </para>
<para/>
<para>Пожалуйста, включайте в отчет об ошибке результат, который выдает утилита emerge. </para>
<para/>
<para>Ссылки</para>
<para>emerge --help, ebuild(1), ebuild(5), make.conf(5) </para>
<para/>
<para>Ряд вспомогательных приложений находится в каталоге /usr/lib/portage/bin. Пакет app-admin/gentoolkit содержит полезные сценарии, например, qpkg (средство запросов к пакетам). </para>
<para/>
<para>Файлы</para>
<para/>
<para>/var/cache/edb/world (/var/lib/portage/world в версиях &gt;=portage-2.0.51)</para>
<para/>
<para>Содержит список всех указанных пользователем пакетов. Можно без опаски редактировать этот файл, добавляя пакеты, которые необходимо учитывать при обновлении класса world, и удаляя те, которые обновлять при этом не нужно. </para>
<para/>
<para>/etc/make.conf</para>
<para/>
<para>Содержит переменные для процесса построения пакетов, переопределяя значения, заданные в make.globals. Именно этот файл надо редактировать вместо перечисленных далее. </para>
<para/>
<para>/etc/make.globals</para>
<para/>
<para>Содержит стандартные переменные для процесса построения. Не редактируйте этот файл. </para>
<para/>
<para>/etc/portage/mirrorsCode: # cat /etc/portage/mirrors </para>
<para/>
<para>local http://192.168.0.10 http://192.168.0.1:8080</para>
<para>http://distfiles.gentoo.org http://distro.ibiblio.org/pub/linux/distributions/gentoo </para>
<para/>
<para/>
<para>Содержит список зеркал, на которых будет производится поиск пакетов, запрошенных emerge. Стоит отметить, что данный список имеет приоритет выше, чем GENTOO_MIRRORS в файле /etc/make.conf, следовательно, данный список будет обрабатываться первым, причем зеркала, прописанные под словом local, будут обрабатываться самыми первыми. </para>
<para/>
<para>/etc/portage/package.keywordsCode: # cat /etc/portage/package.keywords </para>
<para/>
<para>x11-misc/xcompmgr ~x86</para>
<para>x11-misc/transset ~x86</para>
<para>app-portage/getdelta ~x86</para>
<para>app-portage/deltup ~x86</para>
<para>dev-util/bdelta ~x86</para>
<para>net-im/jabberd ~x86</para>
<para>net-wireless/wifiscanner ~x86</para>
<para>net-wireless/wlassistant ~x86 </para>
<para/>
<para/>
<para>Позволяет установить ACCESS_KEYWORDS для конкретных пакетов. Данный файл обрабатывается позже чем /etc/make.conf, следовательно его параметры будут актуальнее... </para>
<para/>
<para>/etc/portage/package.useCode: # cat /etc/portage/package.use </para>
<para/>
<para>x11-wm/fluxbox kde</para>
<para>app-misc/mc -X </para>
<para/>
<para/>
<para>Позволяет установить USE флаги для конкретных пакетов. Данный файл обрабатывается позже чем /etc/make.conf, следовательно его параметры будут актуальнее... </para>
<para/>
<para>/etc/make.profile/package</para>
<para/>
<para>Содержит список пакетов, используемых для базовой системы. Классы system и world учитывают содержимое этого файла. Не редактируйте его. </para>
<para/>
<para>/etc/make.profile/make.defaults</para>
<para/>
<para>Содержит специфические для профиля переменные для процесса построения пакетов. Не редактируйте этот файл. </para>
<para/>
<para>/etc/make.profile/use.defaults</para>
<para/>
<para>Содержит список пакетов, которые, в случае установки, приводят к установке по умолчанию соответствующего флага использования (use flag). Не редактируйте этот файл. </para>
<para/>
<para>/etc/make.profile/virtuals</para>
<para/>
<para>Содержит список стандартных пакетов, используемых для разрешения виртуальных зависимостей. Не редактируйте этот файл. </para>
<para/>
<para>/var/cache/edb/virtuals</para>
<para/>
<para>Содержит список пакетов, используемых для разрешения виртуальных зависимостей. В случае, когда поиск виртуальных зависимостей заканчивается неудачно, можно переупорядочить записи соответствующих виртуальных зависимостей в этом файле. Первый пакет, указанный после virtual, используется для сопоставления с virtual. </para>
<para/>
<para>/usr/portage/profiles/use.desc</para>
<para>Содержит основной список флагов USE с описаниями их функций. Не редактируйте этот файл.</para></sect2></sect1><sect1><title>Примеры конфигурационных файлов</title>
<para/>
<para>Автор:  <ulink url="mailto:johnbat26@gmail.com?subject=По%20поводу%20примеров%20конфигурационных%20файлов">Евгений Батогов a.k.a JohnBat26</ulink>
</para>
<para>С версии: 1.0</para>
<para>Обновлено: 1.5 (30.03.08)</para>
<para/>
<para>Мой компьютер:   </para>
<para>Ноутбук DELL Inspiron 9400:</para>
<orderedlist>
<listitem>
<para>Intel Core 2 Duo 2 Ghz.</para>
</listitem>
<listitem>
<para>RAM: 2 gb DDR2.</para>
</listitem>
<listitem>
<para>VIDEO: Nvidia Geforce 7900 GS 256 Mb DDR3 </para>
</listitem>
<listitem>
<para>HDD: 120 Gb.</para>
</listitem>
<listitem>
<para>Max. Res. 1920X1200 pixels</para>
</listitem>
<listitem>
<para>FS: Only XFS !</para>
</listitem>
</orderedlist>
<para>Программное обеспечение:</para>
<orderedlist>
<listitem>
<para>Gentoo Linux.</para>
</listitem>
<listitem>
<para>Kernel: 2.6.24</para>
</listitem>
<listitem>
<para>GCC: 4.2.3</para>
</listitem>
<listitem>
<para>Glibc: 2.7</para>
</listitem>
<listitem>
<para>X.org: 1.4.0.90-r2</para>
</listitem>
<listitem>
<para>KDE 3.5.9</para>
</listitem>
<listitem>
<para>...</para>
</listitem>
</orderedlist>
<para>  </para>
<orderedlist>
<listitem/>
</orderedlist><sect2><title>Мой make.conf</title>
<para>Важно: в данном файле я использую оптимизацию: O3. Этот вариант не гарантирует надежной работы. Поэтому используйте O2, когда не хотите рисковать.</para>
<para># These settings were set by the catalyst build script that automatically built this stage</para>
<para># Please consult /etc/make.conf.example for a more detailed example</para>
<para>CFLAGS="-O3 -march=native -mtune=native -msse3 -mfpmath=sse -pipe -fomit-frame-pointer"</para>
<para>CHOST="x86_64-pc-linux-gnu"</para>
<para>CXXFLAGS="${CFLAGS}"</para>
<para>MAKEOPTS="-j3"</para>
<para>USE="64bit 7zip X a52 aac aalib accessibility acl acpi aim alsa amarok amazon</para>
<para>     amuled apm archive arts asf async audiofile automount avi bash-completion</para>
<para>     bcmath berkdb big-iron binary-drivers bitmap-fonts bluetooth branding</para>
<para>     bzip2 c++ cairo caps captury cardbus ccache cdda cddb cdinstall cdio</para>
<para>     cdparanoia cdr cdrom cdsound chm chroot cisco clamav clamd colordiff</para>
<para>     compress connectionstatus contactnotes cpio cpudetection cpulimit</para>
<para>     cracklib crypt cscope ctype cups curl curlwrappers custom-cflags cviewer</para>
<para>     cxx cyrillic darcs dba dbus dell depth32 designer-plugin device-mapper</para>
<para>     devil dhcp dia dialup dict directfb divx divx4linux djvu dri dv dvb dvd</para>
<para>     dvdr dvdread dvi dxr3 editor effects emerald emovix enca encode exif</para>
<para>     expat extensions fat fbcon fbsplash festival ffmpeg fftw firefox flac</para>
<para>     flash font-server fontconfig foomaticdb fortran freeimage ftp gadu games</para>
<para>     gd gdb gdbm gif gimp gimpprint ginac glitz gmail gnuplot gpac gpg gphoto2</para>
<para>     gpm graphics graphviz groupwise grub gtk gtk2 hal hbci hddtemp highlight</para>
<para>     history htmlhandbook iconv icq id3tag ieee1394 ifp imagemagick imap imlib</para>
<para>     inkjar interbase ipq-mon iptv ipv6 ipw3945 ipw4965 irc jabber java java6</para>
<para>     javascript jbig jce jpeg jpeg2k kcal kde kdecards kdeenablefinal</para>
<para>     kdehiddenvisibility kdepim kdexdeltas kdgraphics kdm kdrive kernel_linux</para>
<para>     kig-scripting kipi kontact krb4 lame laptop latex lcd lcmsjpeg ldap</para>
<para>     ldapsam lha libcaca libclamav libg++ libgcrypt libnotify libvisual libwww</para>
<para>     live lm_sensors logitech-mouse logrotate magic maps matroska md5sum</para>
<para>     memlimit mikmod mime mmx mng modplug mozbranding mozdevelop mozilla mp2</para>
<para>     mp3 mp4 mp4live mpeg mpeg2 mplayer mplayer-bin musepack musicbrains mysql</para>
<para>     ncurses nemesi netmeeting networkmanager nfs nls nokia6600 nomotif</para>
<para>     nowlistening nptl nptlonly nsplugin ntfs numeric nvidia obex objc objc++</para>
<para>     objc-gc octave office ofx ogg oggvorbis oodict openexr opengl openssl</para>
<para>     openvpn oscar overlays pam pcntl pcre pda pdf pdflib perl pie pink plasma</para>
<para>     player pmount pmu png portage posix postgres povray ppp pptp pulseaudio</para>
<para>     pymol python qq qt qt-copy qt-static qt3 qt3support qt4 query-browser</para>
<para>     quicktime rar rc5 rdesktop readline real realmedia rss rtc ruby samba</para>
<para>     sametime sasl savepwd sbig scaner scanfolder scanner sdl search sensord</para>
<para>     session sharedext sharedmem simplexml skins slang slp smp sms smtp</para>
<para>     snapshot sndfile soap sockets solver sound sounds spamassassin speech</para>
<para>     speedo speex spell spexx sql sqlite sqlite3 sse sse2 ssl statistics stats</para>
<para>     stream subtitles subversion svg svnserve symlink sysfs tcl tcltk tcpd</para>
<para>     texteffect tga theora thesaurus threads tiff translator transparency</para>
<para>     trayicon truetype tunepimp type1 udev unicode upnp usb utempter utf8 vcd</para>
<para>     videos vim vim-pager vim-syntax vim-with-x visualization vnc vncviewer</para>
<para>     vorbis vorbis-psy weather webpresence widescreen wifi winpopup wireshark</para>
<para>     wmf wmp wxgtk1 wxwindows xcomposite xforms xfs xine xinerama xml xml2 xmp</para>
<para>     xorg xosd xpm xprint xrender xskatcards xsl xv xvid yahoo zip zlib -daap</para>
<para>     -privacy -unzip"</para>
<para>ACCEPT_KEYWORDS="~amd64 ~x86 amd64 x86"</para>
<para>AUTOCLEAN="yes"</para>
<para>PORTAGE_NICENESS=39</para>
<para>#FEATURES="ccache candy userfetch buildpkg -sandbox collision-protect"</para>
<para>FEATURES="ccache candy userfetch buildpkg -sandbox"</para>
<para>CCACHE_DIR="/var/tmp/ccache/"</para>
<para>CCACHE_SIZE="4G"</para>
<para>CC="gcc"</para>
<para>CXX="g++"</para>
<para>#PORTDIR_OVERLAY="/usr/portage/local/alsa /usr/portage/local/infra /usr/portage/local/qstardict #/usr/portage/local/stardict  /usr/portage/local/layman /usr/portage/local/google /usr/portage/local/layman/#sunrise /usr/portage/local/layman/xeffects /usr/portage/local/krusader"</para>
<para/>
<para>GENTOO_MIRRORS="http://trumpetti.atm.tut.fi/gentoo ftp://ftp.ussg.iu.edu/pub/linux/gentoo ftp://ftp.ucsb.edu/pub/mirrors/linux/gentoo/ http://ftp.ucsb.edu/pub/mirrors/linux/gentoo/ http://gentoo.chem.wisc.edu/gentoo/ ftp://gentoo.mirrors.pair.com/  http://gentoo.mirrors.tds.net/gentoo/ ftp://gentoo.mirrors.tds.net/gentoo/ http://gentoo.netnitco.net/  ftp://gentoo.netnitco.net/pub/mirrors/gentoo/source/ http://mirror.espri.arizona.edu/gentoo/</para>
<para>#http://mirrors.acm.cs.rpi.edu/gentoo/ ftp://ftp.ndlug.nd.edu/pub/gentoo/ http://open-systems.ufl.edu/mirrors/gentoo #http://gentoo.llarian.net/ ftp://gentoo.llarian.net/pub/gentoo #http://gentoo.binarycompass.org #http://mirror.datapipe.net/gentoo ftp://mirror.datapipe.net/gentoo http://prometheus.cs.wmich.edu/gentoo #http://modzer0.cs.uaf.edu/public/gentoo/ #http://mirror.usu.edu/mirrors/gentoo/ ftp://mirror.usu.edu/mirrors/gentoo/ #ftp://lug.mtu.edu/gentoo http://mirror.phy.olemiss.edu/mirror/gentoo http://mirror.mcs.anl.gov/pub/gentoo/ #ftp://mirror.mcs.anl.gov/pub/gentoo/ http://gentoo.mirrors.easynews.com/linux/gentoo/ #http://gentoo.cites.uiuc.edu/pub/gentoo/ ftp://gentoo.cites.uiuc.edu/pub/gentoo/ #ftp://ftp.wwc.edu/pub/mirrors/ftp.gentoo.org http://gentoo.localhost.net.ar/ #ftp://mirrors.localhost.net.ar/pub/mirrors/gentoo http://www.las.ic.unicamp.br/pub/gentoo/ #ftp://ftp.las.ic.unicamp.br/pub/gentoo/ http://gentoo.inode.at/ ftp://gentoo.inode.at/source/ #http://gd.tuwien.ac.at/opsys/linux/gentoo/ ftp://gd.tuwien.ac.at/opsys/linux/gentoo/ #http://ftp.belnet.be/mirror/rsync.gentoo.org/gentoo/ ftp://ftp.belnet.be/mirror/rsync.gentoo.org/gentoo/ #http://mirror.bih.net.ba/gentoo/ ftp://mirror.bih.net.ba/gentoo/ #ftp://ftp.sh.cvut.cz/MIRRORS/gentoo/gentoo #http://gentoo.supp.name/ http://mirror.uni-c.dk/pub/gentoo/ http://ftp.linux.ee/pub/gentoo/distfiles/ #ftp://ftp.linux.ee/pub/gentoo/distfiles/ #http://trumpetti.atm.tut.fi/gentoo/ ftp://trumpetti.atm.tut.fi/gentoo/ #http://ftp.public.fix.fi/gentoo/ ftp://ftp.public.fix.fi/gentoo http://gentoo.modulix.net/gentoo/ #http://ftp.club-internet.fr/pub/mirrors/gentoo ftp://gentoo.imj.fr/pub/gentoo/ #ftp://ftp.tu-clausthal.de/pub/linux/gentoo/ ftp://sunsite.informatik.rwth-aachen.de/pub/Linux/gentoo #http://linux.rz.ruhr-uni-bochum.de/download/gentoo-mirror/ "</para>
<para/>
<para>#FETCHCOMMAND="/usr/bin/getdelta.sh \${URI}"</para>
<para>SYNC="rsync://rsync.gentoo.org/gentoo-portage"</para>
<para>INPUT_DEVICES="keyboard mouse synaptics evdev"</para>
<para>VIDEO_CARDS="nv nvidia vesa"</para>
<para>LINGUAS="ru"</para>
<para>PORTDIR="/usr/portage" </para>
<para>ALSA_CARDS="hda-intel"</para>
<para/></sect2><sect2><title>2. Файл xorg.conf для NVIDIA Geforce</title>
<para/>
<para>Section "Module" </para>
<para>    Load        "ddc"   # ddc probing of monitor </para>
<para>    Load        "dbe"   # Double buffer extension </para>
<para>    SubSection  "extmod" </para>
<para>      Option    "omit xfree86-dga"   # don't initialize the DGA extension </para>
<para>    EndSubSection </para>
<para>    Load          "record"</para>
<para>    Load          "xtrap"</para>
<para>    Load               "type1" </para>
<para>    Load             "freetype" </para>
<para>    Load             "synaptics" </para>
<para>    Load             "glx"</para>
<para>    Load             "wfb" </para>
<para>EndSection</para>
<para/>
<para>Section "Files"</para>
<para>    FontPath     "/usr/share/fonts/misc:unscaled"</para>
<para>    FontPath     "/usr/share/fonts/Type1/" </para>
<para>    FontPath     "/usr/share/fonts/TTF/"</para>
<para>    FontPath     "/usr/share/fonts/corefonts"</para>
<para>    FontPath     "/usr/share/fonts/freefonts"</para>
<para>    FontPath     "/usr/share/fonts/sharefonts"        </para>
<para>    FontPath     "/usr/share/fonts/terminus"</para>
<para>    FontPath     "/usr/share/fonts/ttf-bitstream-vera"</para>
<para>    FontPath     "/usr/share/fonts/unifont"</para>
<para>    FontPath     "/usr/share/fonts/100dpi:unscaled"</para>
<para>    FontPath     "/usr/share/fonts/75dpi:unscaled" </para>
<para>    FontPath     "/usr/share/fonts/artwiz"</para>
<para>    FontPath     "/usr/share/fonts/cyrillic"</para>
<para>EndSection</para>
<para/>
<para>Section "ServerFlags" </para>
<para>    Option       "AllowMouseOpenFail" "true" </para>
<para>    Option       "SuspendTime"        "10" </para>
<para>    Option       "OffTime"            "15"</para>
<para>    Option "AutoAddDevices" "false" </para>
<para>EndSection</para>
<para/>
<para>Section "InputDevice" </para>
<para>    Identifier  "Keyboard1" </para>
<para>    Driver      "kbd" </para>
<para>    Option      "XkbRules"      "xorg"</para>
<para>    Option      "XkbModel"      "microsoftpro" </para>
<para>    Option      "XkbLayout"     "us,ru" </para>
<para>    Option      "XkbVariant"     ",winkeys"</para>
<para>    Option      "XkbOptions"    "grp:shift_toggle,grp_led:scroll"</para>
<para>    Option      "AutoRepeat"    "500 30" </para>
<para>EndSection</para>
<para/>
<para>Section "InputDevice" </para>
<para>    Identifier  "USBMouse" </para>
<para>    Driver      "mouse"</para>
<para>    Option      "Device" "/dev/input/mice"</para>
<para>    Option      "Buttons"      "7"</para>
<para>    Option      "CorePointer"</para>
<para>    Option      "Protocol" "auto"</para>
<para>    Option      "ZAxisMapping" "4 5 6 7"</para>
<para>EndSection</para>
<para/>
<para>Section "InputDevice"</para>
<para>    Driver      "synaptics"</para>
<para>    Identifier  "TouchPad"</para>
<para>    Option      "Device"       "/dev/input/mice"</para>
<para>    Option      "Protocol"     "auto-dev"</para>
<para>    Option      "LeftEdge"     "1900"</para>
<para>    Option      "RightEdge"    "5400"</para>
<para>    Option      "BottomEdge"   "1800"</para>
<para>    Option      "TopEdge"      "3900"</para>
<para>    Option      "FingerLow"    "25"</para>
<para>    Option      "FingerHigh"   "30"</para>
<para>    Option      "MaxTapTime"   "180"</para>
<para>    Option      "MaxTapMove"   "220"</para>
<para>    Option      "VertScrollDelta" "100"</para>
<para>    Option      "MinSpeed"     "0.02"</para>
<para>    Option      "MaxSpeed"     "0.18"</para>
<para>    Option      "AccelFactor"  "0.0010"</para>
<para>    Option      "SendCoreEvents" "true"</para>
<para>    Option      "Repeater"     "/dev/ps2mouse"</para>
<para>    Option      "SHMConfig"    "true"</para>
<para>EndSection</para>
<para>Section "Monitor" </para>
<para>    Identifier  "DellLFP" </para>
<para>    HorizSync       28.0 - 96.0</para>
<para>    VertRefresh     43.0 - 60.0</para>
<para>    Option      "DPMS" </para>
<para>#    DisplaySize     320 240</para>
<para>EndSection</para>
<para/>
<para/>
<para>Section "Device" </para>
<para>    # Some names might need to be changed hereafter: </para>
<para>    Identifier  "NVIDIA GeForce 7900GS" </para>
<para>    Driver      "nvidia" </para>
<para>    VendorName  "nVidia Corporation"</para>
<para>    BoardName   "GeForce 7900 GS" </para>
<para>    BusID       "PCI:1:0:0"</para>
<para>    #Option     "NoLogo" "1" </para>
<para>    Option "UseDisplayDevice" "DFP"</para>
<para>    ### 2D ACCELLERATION</para>
<para>    #Option  "RenderAccel"           "false" # hardware Render acceleration</para>
<para>    #Option  "BackinStore"           "true"  #[] prevent artifacts?</para>
<para>    #Option  "NoRenderExtension"     "true"</para>
<para>    ## some options</para>
<para>    Option  "SWcursor"              "false" #[]</para>
<para>    Option  "Render"                "true"</para>
<para>    Option  "Composite"             "true"</para>
<para>    ### 3D ACCELLERATION</para>
<para>    Option  "EnablePageFlip"        "yes"   #[] Improves performance</para>
<para>    Option  "AGPFastWrite"          "yes"   #[]</para>
<para>    Option  "AGPMode"               "4"     # Supports AGP 4x</para>
<para>    # VideoRam    262144 </para>
<para>    # Insert Clocks lines here if appropriate </para>
<para>    #Option "IgnoreDisplayDevices" "CRT, TV"</para>
<para>    Option "TripleBuffer" "True"</para>
<para>    Option "AddARGBGLXVisuals" "True"</para>
<para>    Option "AllowGLXWithComposite" "true" </para>
<para>    Option "Coolbits" "1"</para>
<para>EndSection</para>
<para/>
<para>Section "Screen"</para>
<para>        Identifier "Screen1"</para>
<para>        Device     "NVIDIA GeForce 7900GS"</para>
<para>        Monitor    "DellLFP"</para>
<para>        DefaultDepth     24</para>
<para>        SubSection "Display"</para>
<para>                Viewport   0 0</para>
<para>                Depth     8</para>
<para>                Modes    "1920x1200" "1400x1050" "1280x1024" "1024x768" "800x600" "640x480"</para>
<para>        EndSubSection</para>
<para>        SubSection "Display"</para>
<para>                Viewport   0 0</para>
<para>                Depth     16</para>
<para>                Modes    "1920x1200" "1400x1050" "1280x1024" "1024x768" "800x600" "640x480"</para>
<para>        EndSubSection</para>
<para>        SubSection "Display"</para>
<para>                Viewport   0 0</para>
<para>                Depth     24</para>
<para>                Modes    "1920x1200" "1400x1050" "1280x1024" "1024x768" "800x600" "640x480"</para>
<para>        EndSubSection</para>
<para>    Option         "RenderAccel" "true"</para>
<para>    Option         "AddARGBGLXVisuals" "True"</para>
<para>    Option         "DisableGLXRootClipping" "True" </para>
<para>EndSection</para>
<para/>
<para>Section "ServerLayout" </para>
<para>    Identifier  "Flat Panel Only" </para>
<para>    Screen      "Screen 1" </para>
<para>  #InputDevice "Touchpad"      "AlwaysCore" </para>
<para>    InputDevice    "TouchPad" </para>
<para>    InputDevice    "USBMouse" "CorePointer"</para>
<para>EndSection </para>
<para> Section "Extensions"</para>
<para>        Option      "Composite"   "enable"</para>
<para>EndSection</para>
<para/></sect2><sect2><title> 3. Файл xorg.conf для ATI radeon:</title>
<para>Section "ServerLayout"</para>
<para>        Identifier     "X.org Configured"</para>
<para>        Screen      0  "Screen0" 0 0</para>
<para>        InputDevice    "Synaptics" "CorePointer"</para>
<para>        InputDevice    "Mouse"      "SendCoreEvents"</para>
<para>        InputDevice    "Keyboard0" "CoreKeyboard"</para>
<para>        Option               "OffTime"  "3"        # 3 indicates number of min until monitor-off</para>
<para>EndSection</para>
<para/>
<para>Section "ServerFlags"</para>
<para>  Option        "AllowMouseOpenFail"</para>
<para>EndSection</para>
<para/>
<para>Section "dri"</para>
<para># Access to OpenGL ICD is allowed for all users:</para>
<para>#    Mode 0666</para>
<para># Access to OpenGL ICD is restricted to a specific user group:</para>
<para>    Group 27    # video</para>
<para>    Mode 0660</para>
<para>EndSection</para>
<para/>
<para/>
<para>Section "Files"</para>
<para>    FontPath     "/usr/share/fonts/misc:unscaled"</para>
<para>    FontPath     "/usr/share/fonts/Type1/" </para>
<para>    FontPath     "/usr/share/fonts/TTF/"</para>
<para>    FontPath     "/usr/share/fonts/corefonts"</para>
<para>    FontPath     "/usr/share/fonts/freefonts"</para>
<para>    FontPath     "/usr/share/fonts/sharefonts"        </para>
<para>    FontPath     "/usr/share/fonts/terminus"</para>
<para>    FontPath     "/usr/share/fonts/ttf-bitstream-vera"</para>
<para>    FontPath     "/usr/share/fonts/unifont"</para>
<para>    FontPath     "/usr/share/fonts/100dpi:unscaled"</para>
<para>    FontPath     "/usr/share/fonts/75dpi:unscaled" </para>
<para>    FontPath     "/usr/share/fonts/artwiz"</para>
<para>    FontPath     "/usr/share/fonts/cyrillic"</para>
<para>EndSection</para>
<para/>
<para>Section "Module"</para>
<para>        Load  "glx"</para>
<para>        # This loads the miscellaneous extensions module, and disables</para>
<para>        # initialisation of the XFree86-DGA extension within that module.</para>
<para>            SubSection  "extmod"</para>
<para>                 Option    "omit xfree86-dga"   # don't initialise the DGA extension</para>
<para>            EndSubSection</para>
<para>        Load  "dbe"</para>
<para>        Load  "dri"</para>
<para>        Load  "xtrap"</para>
<para>        Load  "record"</para>
<para>        Load  "freetype"</para>
<para>        Load  "type1"</para>
<para>EndSection</para>
<para/>
<para>Section "InputDevice"</para>
<para>        Identifier  "Keyboard0"</para>
<para>        Driver          "kbd"</para>
<para/>
<para>        Option                "XkbModel"      "aspire5020"</para>
<para>        Option                "XkbLayout"     "se"</para>
<para>        #Option                "XkbVariant"    "nodeadkeys"</para>
<para>EndSection</para>
<para/>
<para>Section "InputDevice"</para>
<para>  Identifier    "Synaptics"</para>
<para>  Driver        "synaptics"</para>
<para>  Option        "Device"        "/dev/psaux"</para>
<para>  Option        "Protocol"      "auto-dev"</para>
<para>  Option        "LeftEdge"      "1700"</para>
<para>  Option        "RightEdge"     "5300"</para>
<para>  Option        "TopEdge"       "1700"</para>
<para>  Option        "BottomEdge"    "4200"</para>
<para>  Option        "FingerLow"     "25"</para>
<para>  Option        "FingerHigh"    "30"</para>
<para>  Option        "MaxTapTime"    "180"</para>
<para>  Option        "MaxTapMove"    "220"</para>
<para>  Option        "VertScrollDelta" "100"</para>
<para>  Option        "MinSpeed"      "0.09"</para>
<para>  Option        "MaxSpeed"      "0.18"</para>
<para>  Option        "AccelFactor"   "0.0015"</para>
<para>  Option        "SHMConfig"     "on"</para>
<para>#  #  Option       "Repeater"      "/dev/ps2mouse"</para>
<para>EndSection</para>
<para/>
<para>Section "InputDevice"</para>
<para>  Identifier    "Mouse"</para>
<para>  Driver        "mouse"</para>
<para>  Option        "Device"        "/dev/input/mice"</para>
<para>  Option        "Protocol"      "imps/2"</para>
<para>  Option        "ZAxisMapping"  "4 5"</para>
<para>  Option        "Buttons"        "5"</para>
<para>EndSection</para>
<para/>
<para>Section "Monitor"</para>
<para>        Identifier   "Monitor0"</para>
<para>        VendorName   "LPL"</para>
<para>        ModelName    "0"</para>
<para>        Option             "DPMS"</para>
<para>EndSection</para>
<para/>
<para># === ATI device section ===</para>
<para/>
<para>Section "Device"</para>
<para>    Identifier  "Card0"</para>
<para>    Driver      "fglrx"        </para>
<para>    VendorName  "ATI Technologies Inc"</para>
<para>    BoardName   "ATI Mobility X600"</para>
<para># ### generic DRI settings ###</para>
<para># === disable PnP Monitor  ===</para>
<para>    #Option                              "NoDDC"</para>
<para># === disable/enable XAA/DRI ===</para>
<para>    Option "no_accel"                   "no"</para>
<para>    Option "no_dri"                     "no"</para>
<para># === misc DRI settings ===</para>
<para>    Option "mtrr"                       "off" # disable DRI mtrr mapper, driver has its own code for mtrr</para>
<para># ### FireGL DDX driver module specific settings ###</para>
<para># === Screen Management ===</para>
<para>    Option "DesktopSetup"               "0x00000100"</para>
<para>    Option "MonitorLayout"              "NONE,LVDS"</para>
<para>    Option "IgnoreEDID"                 "off"</para>
<para>    Option "HSync2"                     "unspecified"</para>
<para>    Option "VRefresh2"                  "unspecified"</para>
<para>    Option "ScreenOverlap"              "0"</para>
<para># === TV-out Management ===</para>
<para>    Option "NoTV"                       "yes"</para>
<para>    Option "TVStandard"                 "NTSC-M"</para>
<para>    Option "TVHSizeAdj"                 "0"</para>
<para>    Option "TVVSizeAdj"                 "0"</para>
<para>    Option "TVHPosAdj"                  "0"</para>
<para>    Option "TVVPosAdj"                  "0"</para>
<para>    Option "TVHStartAdj"                "0"</para>
<para>    Option "TVColorAdj"                 "0"</para>
<para>    Option "GammaCorrectionI"           "0x00000000"</para>
<para>    Option "GammaCorrectionII"          "0x00000000"</para>
<para># === OpenGL specific profiles/settings ===</para>
<para>    Option "Capabilities"               "0x00000000"</para>
<para># === Video Overlay for the Xv extension ===</para>
<para>    Option "VideoOverlay"               "on"</para>
<para># === OpenGL Overlay ===</para>
<para># Note: When OpenGL Overlay is enabled, Video Overlay</para>
<para>#       will be disabled automatically</para>
<para>    Option "OpenGLOverlay"              "off"</para>
<para># === Center Mode (Laptops only) ===</para>
<para>    Option "CenterMode"                 "off"</para>
<para># === Pseudo Color Visuals (8-bit visuals) ===</para>
<para>    Option "PseudoColorVisuals"         "off"</para>
<para># === QBS Management ===</para>
<para>    Option "Stereo"                     "off"</para>
<para>    Option "StereoSyncEnable"           "1"</para>
<para># === FSAA Management ===</para>
<para>    Option "FSAAEnable"                 "no"</para>
<para>    Option "FSAAScale"                  "1"</para>
<para>    Option "FSAADisableGamma"           "no"</para>
<para>    Option "FSAACustomizeMSPos"         "no"</para>
<para>    Option "FSAAMSPosX0"                "0.000000"</para>
<para>    Option "FSAAMSPosY0"                "0.000000"</para>
<para>    Option "FSAAMSPosX1"                "0.000000"</para>
<para>    Option "FSAAMSPosY1"                "0.000000"</para>
<para>    Option "FSAAMSPosX2"                "0.000000"</para>
<para>    Option "FSAAMSPosY2"                "0.000000"</para>
<para>    Option "FSAAMSPosX3"                "0.000000"</para>
<para>    Option "FSAAMSPosY3"                "0.000000"</para>
<para>    Option "FSAAMSPosX4"                "0.000000"</para>
<para>    Option "FSAAMSPosY4"                "0.000000"</para>
<para>    Option "FSAAMSPosX5"                "0.000000"</para>
<para>    Option "FSAAMSPosY5"                "0.000000"</para>
<para># === Misc Options ===</para>
<para>    Option "UseFastTLS"                 "0"</para>
<para>    Option "BlockSignalsOnLock"         "on"</para>
<para>    Option "UseInternalAGPGART"         "no"</para>
<para>    Option "ForceGenericCPU"            "no"</para>
<para>    Option "DynamicClocks"                "on" # Use ATI Powerplay features</para>
<para>    BusID "PCI:1:0:0"    # vendor=1002, device=3150</para>
<para>    Screen 0</para>
<para>EndSection</para>
<para/>
<para>#Section "Device"</para>
<para>        ### Available Driver options are:-</para>
<para>        ### Values: &lt;i&gt;: integer, &lt;f&gt;: float, &lt;bool&gt;: "True"/"False",</para>
<para>        ### &lt;string&gt;: "String", &lt;freq&gt;: "&lt;f&gt; Hz/kHz/MHz"</para>
<para>        ### [arg]: arg optional</para>
<para>        #Option     "NoAccel"                    # [&lt;bool&gt;]</para>
<para>        #Option     "SWcursor"                   # [&lt;bool&gt;]</para>
<para>        #Option     "Dac6Bit"                    # [&lt;bool&gt;]</para>
<para>        #Option     "Dac8Bit"                    # [&lt;bool&gt;]</para>
<para>        #Option     "BusType"                    # [&lt;str&gt;]</para>
<para>        #Option     "CPPIOMode"                  # [&lt;bool&gt;]</para>
<para>        #Option     "CPusecTimeout"              # &lt;i&gt;</para>
<para>        #Option     "AGPMode"                    # &lt;i&gt;</para>
<para>        #Option     "AGPFastWrite"               # [&lt;bool&gt;]</para>
<para>        #Option     "AGPSize"                    # &lt;i&gt;</para>
<para>        #Option     "GARTSize"                   # &lt;i&gt;</para>
<para>        #Option     "RingSize"                   # &lt;i&gt;</para>
<para>        #Option     "BufferSize"                 # &lt;i&gt;</para>
<para>        #Option     "EnableDepthMoves"           # [&lt;bool&gt;]</para>
<para>        #Option     "EnablePageFlip"             # [&lt;bool&gt;]</para>
<para>        #Option     "NoBackBuffer"               # [&lt;bool&gt;]</para>
<para>        #Option     "DRIReinit"                  # [&lt;bool&gt;]</para>
<para>        #Option     "PanelOff"                   # [&lt;bool&gt;]</para>
<para>        #Option     "DDCMode"                    # [&lt;bool&gt;]</para>
<para>        #Option     "MonitorLayout"              # [&lt;str&gt;]</para>
<para>        #Option     "IgnoreEDID"                 # [&lt;bool&gt;]</para>
<para>        #Option     "UseFBDev"                   # [&lt;bool&gt;]</para>
<para>        #Option     "VideoKey"                   # &lt;i&gt;</para>
<para>        #Option     "MergedFB"                   # [&lt;bool&gt;]</para>
<para>        #Option     "CRT2HSync"                  # [&lt;str&gt;]</para>
<para>        #Option     "CRT2VRefresh"               # [&lt;str&gt;]</para>
<para>        #Option     "CRT2Position"               # [&lt;str&gt;]</para>
<para>        #Option     "MetaModes"                  # [&lt;str&gt;]</para>
<para>        #Option     "MergedDPI"                  # [&lt;str&gt;]</para>
<para>        #Option     "NoMergedXinerama"           # [&lt;bool&gt;]</para>
<para>        #Option     "MergedXineramaCRT2IsScreen0"         # [&lt;bool&gt;]</para>
<para>        #Option     "DisplayPriority"            # [&lt;str&gt;]</para>
<para>        #Option     "PanelSize"                  # [&lt;str&gt;]</para>
<para>        #Option     "ForceMinDotClock"           # &lt;freq&gt;</para>
<para>        #Option     "RenderAccel"                # [&lt;bool&gt;]</para>
<para>        #Option     "SubPixelOrder"              # [&lt;str&gt;]</para>
<para>        #Option     "ShowCache"                  # [&lt;bool&gt;]</para>
<para>        #Option     "DynamicClocks"              # [&lt;bool&gt;]</para>
<para>        #Option     "VGAAccess"                  # [&lt;bool&gt;]</para>
<para>        #Option     "LVDSProbePLL"               # [&lt;bool&gt;]</para>
<para>        #Option     "ReverseDDC"                 # [&lt;bool&gt;]</para>
<para>        #Option     "BIOSHotkeys"                # [&lt;bool&gt;]</para>
<para>#        Identifier  "Card0"</para>
<para>#        Driver      "ati"</para>
<para>#        VendorName  "ATI Technologies Inc"</para>
<para>#        BoardName   "ATI Mobility X600"</para>
<para>#        BusID       "PCI:1:0:0"</para>
<para>#EndSection</para>
<para/>
<para>Section "Screen"</para>
<para>        Identifier "Screen0"</para>
<para>        Device     "Card0"</para>
<para>        Monitor    "Monitor0"</para>
<para>           DefaultDepth 24</para>
<para/>
<para>        SubSection "Display"</para>
<para>                Viewport   0 0</para>
<para>                Depth     16</para>
<para>#                Modes     "1280x800"</para>
<para>        EndSubSection</para>
<para>        SubSection "Display"</para>
<para>                Viewport   0 0</para>
<para>                Depth     24</para>
<para>#                Modes     "1280x800"</para>
<para>        EndSubSection</para>
<para>EndSection</para>
<para/></sect2><sect2><title>4. Файл<link linkend=""> /etc/fstab</link>
</title>
<link linkend=""> /etc/fstab</link>
<para/>
<para/>
<para/></sect2></sect1><sect1><title>Важные команды Gentoo Linux</title>
<para/>
<orderedlist>
<listitem>
<para>emerge --ask --verbose (или emerge -av) - просмотр USE-флагов перед началом компиляции.</para>
</listitem>
<listitem>
<para>emerge имя_пакета – установка пакета.</para>
</listitem>
<listitem>
<para>emerge sync – обновление локального дерева портежей.</para>
</listitem>
<listitem>
<para>echo "category/some_package some_flags" &gt;&gt; /etc/portage/package.use --  прописывание USE-флагов в /etc/portage/package.use, для этого выполните </para>
</listitem>
</orderedlist>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/>
<para/></sect1><sect1><title>Unix Toolbox</title>
<para>Ссылка на оригинал: <ulink url="http://cb.vu/unixtoolbox.xhtml">http://cb.vu/unixtoolbox.xhtml</ulink>
</para>
<para>Revision: 11</para>
<para>C версии: 1.5</para>
<para>This document is a collection of Unix/Linux/BSD commands and tasks which are useful for IT work or for advanced users. This is a practical guide with concise explanations, however the reader is supposed to know what s/he is doing.</para>
<para>The latest version of this document can be found at http://cb.vu/unixtoolbox.xhtml.  </para><sect2><title>1. SYSTEM</title>
<para/>
<para>Running kernel and system information</para>
<para># uname -a # Get the kernel version (and BSD version)</para>
<para># cat /etc/SuSE-release # Get SuSE version</para>
<para># cat /etc/debian_version # Get Debian version</para>
<para>Use /etc/DISTR-release with DISTR= lsb (Ubuntu), redhat, gentoo, mandrake, sun (Solaris), and so on.</para>
<para># uptime # Show how long the system has been running + load</para>
<para># hostname # system's host name</para>
<para># hostname -i # Display the IP address of the host.</para>
<para># man hier # Description of the file system hierarchy</para>
<para># last reboot # Show system reboot history</para><sect3><title>1.1 Hardware Informations</title>
<para>Kernel detected hardware</para>
<para># dmesg # Detected hardware and boot messages</para>
<para># lsdev # information about installed hardware</para>
<para># dd if=/dev/mem bs=1k skip=768 count=256 2&gt;/dev/null | strings -n 8 # Read BIOS</para>
<para>Linux</para>
<para># cat /proc/cpuinfo # CPU model</para>
<para># cat /proc/meminfo # Hardware memory</para>
<para># grep MemTotal /proc/meminfo # Display the physical memory</para>
<para># watch -n1 'cat /proc/interrupts' # Watch changeable interrupts continuously</para>
<para># free -m # Used and free memory (-m for MB)</para>
<para># cat /proc/devices # Configured devices</para>
<para># lspci -tv # Show PCI devices</para>
<para># lsusb -tv # Show USB devices</para>
<para># lshal # Show a list of all devices with their properties</para>
<para># dmidecode # Show DMI/SMBIOS: hw info from the BIOS</para>
<para>FreeBSD</para>
<para># sysctl hw.model # CPU model</para>
<para># sysctl hw # Gives a lot of hardware information</para>
<para># sysctl vm # Memory usage</para>
<para># dmesg | grep "real mem" # Hardware memory</para>
<para># sysctl -a | grep mem # Kernel memory settings and info</para>
<para># sysctl dev # Configured devices</para>
<para># pciconf -l -cv # Show PCI devices</para>
<para># usbdevs -v # Show USB devices</para>
<para># atacontrol list # Show ATA devices</para></sect3><sect3><title>1.2 Load, statistics and messages</title>
<para>The following commands are useful to find out what is going on on the system.</para>
<para># top # display and update the top cpu processes</para>
<para># mpstat 1 # display processors related statistics</para>
<para># vmstat 2 # display virtual memory statistics</para>
<para># iostat 2 # display I/O statistics (2 s intervals)</para>
<para># systat -vmstat 1 # BSD summary of system statistics (1 s intervals)</para>
<para># systat -tcp 1 # BSD tcp connections (try also -ip)</para>
<para># systat -netstat 1 # BSD active network connections</para>
<para># systat -ifstat 1 # BSD network traffic through active interfaces</para>
<para># systat -iostat 1 # BSD CPU and and disk throughput</para>
<para># tail -n 500 /var/log/messages # Last 500 kernel/syslog messages</para>
<para># tail /var/log/warn # System warnings messages see syslog.conf</para></sect3><sect3><title>1.3 Users</title>
<para># id # Show the active user id with login and group</para>
<para># last # Show last logins on the system</para>
<para># who # Show who is logged on the system</para>
<para># groupadd admin # Add group "admin" and user colin (Linux/Solaris)</para>
<para># useradd -c "Colin Barschel" -g admin -m colin</para>
<para># userdel colin # Delete user colin (Linux/Solaris)</para>
<para># adduser joe # FreeBSD add user joe (interactive)</para>
<para># rmuser joe # FreeBSD delete user joe (interactive)</para>
<para># pw groupadd admin # Use pw on FreeBSD</para>
<para># pw groupmod admin -m newmember # Add a new member to a group</para>
<para># pw useradd colin -c "Colin Barschel" -g admin -m -s /bin/tcsh</para>
<para># pw userdel colin; pw groupdel admin</para>
<para>Encrypted passwords are stored in /etc/shadow for Linux and Solaris and /etc/master.passwd on FreeBSD. If the master.passwd is modified manually (say to delete a password), run #</para>
<para>pwd_mkdb -p master.passwd to rebuild the database.</para>
<para>To temporarily prevent logins system wide (for all users but root) use nologin. The message in nologin will be displayed.</para>
<para># echo "Sorry no login now" &gt; /etc/nologin # (Linux)</para>
<para># echo "Sorry no login now" &gt; /var/run/nologin # (FreeBSD)</para></sect3><sect3><title>1.4 Limits</title>
<para>Some application require higher limits on open files and sockets (like a proxy web server,database). The default limits are usually too low.</para>
<para>Linux</para>
<para>Per shell/script</para>
<para>The shell limits are governed by ulimit. The status is checked with ulimit -a. For example to change the open files limit from 1024 to 10240 do:</para>
<para># ulimit -n 10240 # This is only valid within the shell</para>
<para>The ulimit command can be used in a script to change the limits for the script only.</para>
<para>Per user/process</para>
<para>Login users and applications can be configured in /etc/security/limits.conf. For example:</para>
<para># cat /etc/security/limits.conf</para>
<para>* hard nproc 250 # Limit user processes</para>
<para>asterisk hard nofile 409600 # Limit application open files</para>
<para>System wide</para>
<para>Kernel limits are set with sysctl. Permanent limits are set in /etc/sysctl.conf.</para>
<para># sysctl -a # View all system limits</para>
<para># sysctl fs.file-max # View max open files limit</para>
<para>fs.file-max=102400 # Permanent entry in sysctl.conf</para>
<para># cat /proc/sys/fs/file-nr # How many file descriptors are in use</para>
<para>FreeBSD</para>
<para>Per shell/script</para>
<para>Use the command limits in csh or tcsh or as in Linux, use ulimit in an sh or bash shell.</para>
<para>Per user/process</para>
<para>The default limits on login are set in /etc/login.conf. An unlimited value is still limited by the</para>
<para>system maximal value.</para>
<para>System wide</para>
<para>Kernel limits are also set with sysctl. Permanent limits are set in /etc/sysctl.conf or /boot/</para>
<para>loader.conf. The syntax is the same as Linux but the keys are different.</para>
<para># sysctl -a # View all system limits</para>
<para># sysctl kern.maxfiles=XXXX # maximum number of file descriptors</para>
<para>kern.ipc.nmbclusters=32768 # Permanent entry in /etc/sysctl.conf</para>
<para>kern.maxfiles=65536 # Typical values for Squid</para>
<para>kern.maxfilesperproc=32768</para>
<para>kern.ipc.somaxconn=8192 # TCP queue. Better for apache/sendmail</para>
<para># sysctl kern.openfiles # How many file descriptors are in use</para>
<para># sysctl kern.ipc.numopensockets # How many open sockets are in use</para>
<para>See The FreeBSD handbook Chapter 111 for details.</para>
<para>Solaris</para>
<para>The following values in /etc/system will increase the maximum file descriptors per proc:</para>
<para>set rlim_fd_max = 4096 # Hard limit on file descriptors for a single proc</para>
<para>set rlim_fd_cur = 1024 # Soft limit on file descriptors for a single proc</para></sect3><sect3><title>1.5 Runlevels</title>
<para>Linux</para>
<para>Once booted, the kernel starts init which then starts rc which starts all scripts belonging to a runlevel. The scripts are stored in /etc/init.d and are linked into /etc/rc.d/rcN.d with N the runlevel number.</para>
<para>The default runlevel is configured in /etc/inittab. It is usually 3 or 5:</para>
<para># grep default: /etc/inittab</para>
<para>id:3:initdefault:</para>
<para>The actual runlevel (the list is shown below) can be changed with init. For example to go from 3 to 5:</para>
<para># init 5 # Enters runlevel 5</para>
<para>0 Shutdown and halt</para>
<para>1 Single-User mode (also S)</para>
<para>2 Multi-user without network</para>
<para>3 Multi-user with network</para>
<para>5 Multi-user with X</para>
<para>6 Reboot</para>
<para>Use chkconfig to configure the programs that will be started at boot in a runlevel.</para>
<para># chkconfig --list # List all init scripts</para>
<para># chkconfig --list sshd # Report the status of sshd</para>
<para>1.http://www.freebsd.org/handbook/configtuning-kernel-limits.html</para>
<para># chkconfig sshd --level 35 on # Configure sshd for levels 3 and 5</para>
<para># chkconfig sshd off # Disable sshd for all runlevels</para>
<para>Debian and Debian based distributions like Ubuntu or Knoppix use the command update-rc.d</para>
<para>to manage the runlevels scripts. Default is to start in 2,3,4 and 5 and shutdown in 0,1 and 6.</para>
<para># update-rc.d sshd defaults # Activate sshd with the default runlevels</para>
<para># update-rc.d sshd start 20 2 3 4 5 . stop 20 0 1 6 . # With explicit arguments</para>
<para># update-rc.d -f sshd remove # Disable sshd for all runlevels</para>
<para># shutdown -h now (or # poweroff) # Shutdown and halt the system</para>
<para>FreeBSD</para>
<para>The BSD boot approach is different from the SysV, there are no runlevels. The final boot state (single user, with or without X) is configured in /etc/ttys. All OS scripts are located in /etc/rc.d/ and in /usr/local/etc/rc.d/ for third-party applications. The activation of the service is configured in /etc/rc.conf and /etc/rc.conf.local. The default behavior is configured in /etc/defaults/rc.conf. The scripts responds at least to start|stop|status.</para>
<para># /etc/rc.d/sshd status</para>
<para>sshd is running as pid 552.</para>
<para># shutdown now # Go into single-user mode</para>
<para># exit # Go back to multi-user mode</para>
<para># shutdown -p now # Shutdown and halt the system</para>
<para># shutdown -r now # Reboot</para>
<para>The process init can also be used to reach one of the following states level. For example #</para>
<para>init 6 for reboot.</para>
<para>0 Halt and turn the power off (signal USR2)</para>
<para>1 Go to single-user mode (signal TERM)</para>
<para>6 Reboot the machine (signal INT)</para>
<para>c Block further logins (signal TSTP)</para>
<para>q Rescan the ttys(5) file (signal HUP)</para></sect3><sect3><title>1.6 Reset root password</title>
<para>Linux method 1</para>
<para>At the boot loader (lilo or grub), enter the following boot option:</para>
<para>init=/bin/sh</para>
<para>The kernel will mount the root partition and init will start the bourne shell instead of rc and then a runlevel. Use the command passwd at the prompt to change the password and then reboot. Forget the single user mode as you need the password for that.</para>
<para>If, after booting, the root partition is mounted read only, remount it rw:</para>
<para># mount -o remount,rw /</para>
<para># passwd # or delete the root password (/etc/shadow)</para>
<para># sync; mount -o remount,ro / # sync before to remount read only</para>
<para># reboot</para>
<para>FreeBSD and Linux method 2</para>
<para>FreeBSD won't let you go away with the simple init trick. The solution is to mount the root partition from an other OS (like a rescue CD) and change the password on the disk.</para>
<para>• Boot a live CD or installation CD into a rescue mode which will give you a shell.</para>
<para>• Find the root partition with fdisk e.g. fdisk /dev/sda</para>
<para>• Mount it and use chroot:</para>
<para># mount -o rw /dev/ad4s3a /mnt</para>
<para># chroot /mnt # chroot into /mnt</para>
<para># passwd</para>
<para># reboot</para>
<para>Alternatively on FreeBSD, boot in single user mode, remount / rw and use passwd.</para>
<para># mount -u /; mount -a # will mount / rw</para>
<para># passwd</para>
<para># reboot</para></sect3><sect3><title>1.7 Kernel modules</title>
<para>Linux</para>
<para># lsmod # List all modules loaded in the kernel</para>
<para># modprobe isdn # To load a module (here isdn)</para>
<para>FreeBSD</para>
<para># kldstat # List all modules loaded in the kernel</para>
<para># kldload crypto # To load a module (here crypto)</para></sect3><sect3><title>1.8 Compile Kernel</title>
<para>Linux</para>
<para># cd /usr/src/linux</para>
<para># make mrproper # Clean everything, including config files</para>
<para># make oldconfig # Create a new config file from the current kernel</para>
<para># make menuconfig # or xconfig (Qt) or gconfig (GTK)</para>
<para># make # Create a compressed kernel image</para>
<para># make modules # Compile the modules</para>
<para># make modules_install # Install the modules</para>
<para># make install # Install the kernel</para>
<para># reboot</para>
<para>FreeBSD</para>
<para>To modify and rebuild the kernel, copy the generic configuration file to a new name and edit it as needed. It is however also possible to edit the file GENERIC directly.</para>
<para># cd /usr/src/sys/i386/conf/</para>
<para># cp GENERIC MYKERNEL</para>
<para># cd /usr/src</para>
<para># make buildkernel KERNCONF=MYKERNEL</para>
<para># make installkernel KERNCONF=MYKERNEL</para>
<para>To rebuild the full OS:</para>
<para># make buildworld # Build the full OS but not the kernel</para>
<para># make buildkernel # Use KERNCONF as above if appropriate</para>
<para># make installkernel</para>
<para># reboot</para>
<para># mergemaster -p # Compares only files known to be essential</para>
<para># make installworld</para>
<para># mergemaster # Update all configuration and other files</para>
<para># reboot</para>
<para>For small changes in the source, sometimes the short version is enough:</para>
<para># make kernel world # Compile and install both kernel and OS</para>
<para># mergemaster</para>
<para># reboot</para>
<para/></sect3></sect2><sect2><title>2. PROCESSES</title><sect3><title>2.1 Listing and PIDs</title>
<para>Each process has a unique number, the PID. A list of all running process is retrieved with ps.</para>
<para># ps -auxefw # Extensive list of all running process</para>
<para>However more typical usage is with a pipe or with pgrep:</para>
<para># ps axww | grep cron</para>
<para>586 ?? Is 0:01.48 /usr/sbin/cron -s</para>
<para># pgrep -l sshd # Find the PIDs of processes by (part of) name</para>
<para># fuser -va 22/tcp # List processes using port 22</para>
<para># fuser -va /home # List processes accessing the /home partiton</para>
<para># strace df # Trace system calls and signals</para>
<para># truss df # same as above on FreeBSD/Solaris/Unixware</para>
<para># history | tail -50 # Display the last 50 used commands</para></sect3><sect3><title>2.2 Priority</title>
<para>Change the priority of a running process with renice. Negative numbers have a higher priority, the lowest is -20 and "nice" have a positive value.</para>
<para># renice -5 586 # Stronger priority</para>
<para>586: old priority 0, new priority -5</para>
<para>Start the process with a defined priority with nice. Positive is "nice" or weak, negative is strong scheduling priority. Make sure you know if /usr/bin/nice or the shell built-in is used (check with # which nice).</para>
<para># nice -n -5 top # Stronger priority (/usr/bin/nice)</para>
<para># nice -n 5 top # Weaker priority (/usr/bin/nice)</para>
<para># nice +5 top # tcsh builtin nice (same as above!)</para></sect3><sect3><title>2.3 Background/Foreground</title>
<para>When started from a shell, processes can be brought in the background and back to the</para>
<para>foreground with [Ctrl]-[Z] (^Z), bg and fg. For example start two processes, bring them in the background, list the processes with jobs and bring one in the foreground.</para>
<para># ping cb.vu &gt; ping.log</para>
<para>^Z # ping is suspended (stopped) with [Ctrl]-[Z]</para>
<para># bg # put in background and continues running</para>
<para># jobs -l # List processes in background</para>
<para>[1] - 36232 Running ping cb.vu &gt; ping.log</para>
<para>[2] + 36233 Suspended (tty output) top</para>
<para># fg %2 # Bring process 2 back in foreground</para>
<para>Use nohup to start a process which has to keep running when the shell is closed (immune to hangups).</para>
<para># nohup ping -i 60 &gt; ping.log &amp;</para></sect3><sect3><title>2.4 Top</title>
<para>The program top displays running information of processes.</para>
<para># top</para>
<para>While top is running press the key h for a help overview. Useful keys are:</para>
<para>• u [user name] To display only the processes belonging to the user. Use + or blank to</para>
<para>see all users</para>
<para>• k [pid] Kill the process with pid.</para>
<para>• 1 To display all processors statistics (Linux only)</para>
<para>• R Toggle normal/reverse sort.</para></sect3><sect3><title>2.5 Signals/Kill</title>
<para>Terminate or send a signal with kill or killall.</para>
<para># ping -i 60 cb.vu &gt; ping.log &amp;</para>
<para>[1] 4712</para>
<para># kill -s TERM 4712 # same as kill -15 4712</para>
<para># killall -1 httpd # Kill HUP processes by exact name</para>
<para># pkill -9 http # Kill TERM processes by (part of) name</para>
<para># pkill -TERM -u www # Kill TERM processes owned by www</para>
<para># fuser -k -TERM -m /home # Kill every process accessing /home (to umount)</para>
<para>Important signals are:</para>
<para>1 HUP (hang up)</para>
<para>2 INT (interrupt)</para>
<para>3 QUIT (quit)</para>
<para>9 KILL (non-catchable, non-ignorable kill)</para>
<para>15 TERM (software termination signal)</para></sect3></sect2><sect2><title>3. FILE SYSTEM</title>
<para/><sect3><title>3.1 Permissions</title>
<para>Change permission and ownership with chmod and chown. The default umask can be changed for all users in /etc/profile for Linux or /etc/login.conf for FreeBSD. The default umask is usually 022. The umsak is subtracted from 777, thus umask 022 results in a permission 0f 755.</para>
<para>1 --x execute # Mode 764 = exec/read/write | read/write | read</para>
<para>2 -w- write # For: |-- Owner --| |- Group-| |Oth|</para>
<para>4 r-- read</para>
<para>ugo=a u=user, g=group, o=others, a=everyone</para>
<para># chmod [OPTION] MODE[,MODE] FILE # MODE is of the form [ugoa]*([-+=]([rwxXst]))</para>
<para># chmod 640 /var/log/maillog # Restrict the log -rw-r-----</para>
<para># chmod u=rw,g=r,o= /var/log/maillog # Same as above</para>
<para># chmod -R o-r /home/* # Recursive remove other readable for all users</para>
<para># chmod u+s /path/to/prog # Set SUID bit on executable (know what you do!)</para>
<para># find / -perm -u+s -print # Find all programs with the SUID bit</para>
<para># chown user:group /path/to/file # Change the user and group ownership of a file</para>
<para># chgrp group /path/to/file # Change the group ownership of a file</para></sect3><sect3><title>3.2 Disk information</title>
<para># diskinfo -v /dev/ad2 # information about disk (sector/size) FreeBSD</para>
<para># hdparm -I /dev/sda # information about the IDE/ATA disk (Linux)</para>
<para># fdisk /dev/ad2 # Display and manipulate the partition table</para>
<para># smartctl -a /dev/ad2 # Display the disk SMART info</para>
<para/></sect3><sect3><title>3.3 Boot</title>
<para>FreeBSD</para>
<para>To boot an old kernel if the new kernel doesn't boot, stop the boot at during the count down.</para>
<para># unload</para>
<para># load kernel.old</para>
<para># boot</para></sect3><sect3><title>3.4 System mount points/Disk usage</title>
<para># mount | column -t # Show mounted file-systems on the system</para>
<para># df # display free disk space and mounted devices</para>
<para># cat /proc/partitions # Show all registered partitions (Linux)</para>
<para>Disk usage</para>
<para># du -sh * # Directory sizes as listing</para>
<para># du -csh # Total directory size of the current directory</para>
<para># du -ks * | sort -n -r # Sort everything by size in kilobytes</para>
<para># ls -lSr # Show files, biggest last</para></sect3><sect3><title>3.5 Who has which files opened</title>
<para>This is useful to find out which file is blocking a partition which has to be unmounted and gives a typical error of:</para>
<para># umount /home/</para>
<para>umount: unmount of /home # umount impossible because a file is locking home</para>
<para>failed: Device busy</para>
<para>FreeBSD and most Unixes</para>
<para># fstat -f /home # for a mount point</para>
<para># fstat -p PID # for an application with PID</para>
<para># fstat -u user # for a user name</para>
<para>Find opened log file (or other opened files), say for Xorg:</para>
<para># ps ax | grep Xorg | awk '{print $1}'</para>
<para>1252</para>
<para># fstat -p 1252</para>
<para>USER CMD PID FD MOUNT INUM MODE SZ|DV R/W</para>
<para>root Xorg 1252 root / 2 drwxr-xr-x 512 r</para>
<para>root Xorg 1252 text /usr 216016 -rws--x--x 1679848 r</para>
<para>root Xorg 1252 0 /var 212042 -rw-r--r-- 56987 w</para>
<para>The file with inum 212042 is the only file in /var:</para>
<para># find -x /var -inum 212042</para>
<para>/var/log/Xorg.0.log</para>
<para>Linux</para>
<para>Find opened files on a mount point with fuser or lsof:</para>
<para># fuser -m /home # List processes accessing /home</para>
<para># lsof /home</para>
<para>COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME</para>
<para>tcsh 29029 eedcoba cwd DIR 0,18 12288 1048587 /home/eedcoba (guam:/home)</para>
<para>lsof 29140 eedcoba cwd DIR 0,18 12288 1048587 /home/eedcoba (guam:/home)</para>
<para/>
<para>About an application:</para>
<para>ps ax | grep Xorg | awk '{print $1}'</para>
<para>3324</para>
<para># lsof -p 3324</para>
<para>COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME</para>
<para>Xorg 3324 root 0w REG 8,6 56296 12492 /var/log/Xorg.0.log</para>
<para>About a single file:</para>
<para># lsof /var/log/Xorg.0.log</para>
<para>COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME</para>
<para>Xorg 3324 root 0w REG 8,6 56296 12492 /var/log/Xorg.0.log</para></sect3><sect3><title>3.6 Mount/remount a file system</title>
<para>For example the cdrom. If listed in /etc/fstab:</para>
<para># mount /cdrom</para>
<para>Or find the device in /dev/ or with dmesg</para>
<para>FreeBSD</para>
<para># mount -v -t cd9660 /dev/cd0c /mnt # cdrom</para>
<para># mount_cd9660 /dev/wcd0c /cdrom # other method</para>
<para># mount -v -t msdos /dev/fd0c /mnt # floppy</para>
<para>Entry in /etc/fstab:</para>
<para># Device Mountpoint FStype Options Dump Pass#</para>
<para>/dev/acd0 /cdrom cd9660 ro,noauto 0 0</para>
<para>To let users do it:</para>
<para># sysctl vfs.usermount=1 # Or insert the line "vfs.usermount=1" in /etc/sysctl.conf</para>
<para>Linux</para>
<para># mount -t auto /dev/cdrom /mnt/cdrom # typical cdrom mount command</para>
<para># mount /dev/hdc -t iso9660 -r /cdrom # typical IDE</para>
<para># mount /dev/sdc0 -t iso9660 -r /cdrom # typical SCSI</para>
<para>Entry in /etc/fstab:</para>
<para>/dev/cdrom /media/cdrom subfs noauto,fs=cdfss,ro,procuid,nosuid,nodev,exec 0 0</para>
<para>Mount a FreeBSD partition with Linux</para>
<para>Find the partition number containing with fdisk, this is usually the root partition, but it could be an other BSD slice too. If the FreeBSD has many slices, they are the one not listed in the fdisk table, but visible in /dev/sda* or /dev/hda*.</para>
<para># fdisk /dev/sda # Find the FreeBSD partition</para>
<para>/dev/sda3 * 5357 7905 20474842+ a5 FreeBSD</para>
<para># mount -t ufs -o ufstype=ufs2,ro /dev/sda3 /mnt</para>
<para>/dev/sda10 = /tmp; /dev/sda11 /usr # The other slices</para>
<para>Remount</para>
<para>Remount a device without unmounting it. Necessary for fsck for example</para>
<para># mount -o remount,ro / # Linux</para>
<para># mount -o ro / # FreeBSD</para>
<para>Copy the raw data from a cdrom into an iso image:</para>
<para># dd if=/dev/cd0c of=file.iso</para>
<para/></sect3><sect3><title>3.7 Mount an SMB share</title>
<para>Suppose we want to access the SMB share myshare on the computer smbserver, the address as typed on a Windows PC is \\smbserver\myshare\. We mount on /mnt/smbshare. Warning&gt; cifs wants an IP or DNS name, not a Windows name.</para>
<para>Linux</para>
<para># smbclient -U user -I 192.168.16.229 -L //smbshare/ # List the shares</para>
<para># mount -t smbfs -o username=winuser //smbserver/myshare /mnt/smbshare</para>
<para># mount -t cifs -o username=winuser,password=winpwd //192.168.16.229/myshare /mnt/share</para>
<para>Additionally with the package mount.cifs it is possible to store the credentials in a file, for</para>
<para>example /home/user/.smb:</para>
<para>username=winuser</para>
<para>password=winpwd</para>
<para>And mount as follow:</para>
<para># mount -t cifs -o credentials=/home/user/.smb //192.168.16.229/myshare /mnt/smbshare</para>
<para>FreeBSD</para>
<para>Use -I to give the IP (or DNS name); smbserver is the Windows name.</para>
<para># smbutil view -I 192.168.16.229 //winuser@smbserver # List the shares</para>
<para># mount_smbfs -I 192.168.16.229 //winuser@smbserver/myshare /mnt/smbshare</para></sect3><sect3><title>3.8 Mount an image</title>
<para>Linux loop-back</para>
<para># mount -t iso9660 -o loop file.iso /mnt # Mount a CD image</para>
<para># mount -t ext3 -o loop file.img /mnt # Mount an image with ext3 fs</para>
<para>FreeBSD</para>
<para>With memory device (do # kldload md.ko if necessary):</para>
<para># mdconfig -a -t vnode -f file.iso -u 0</para>
<para># mount -t cd9660 /dev/md0 /mnt</para>
<para># umount /mnt; mdconfig -d -u 0 # Cleanup the md device</para>
<para>Or with virtual node:</para>
<para># vnconfig /dev/vn0c file.iso; mount -t cd9660 /dev/vn0c /mnt</para>
<para># umount /mnt; vnconfig -u /dev/vn0c # Cleanup the vn device</para>
<para>Solaris and FreeBSD</para>
<para>with loop-back file interface or lofi:</para>
<para># lofiadm -a file.iso</para>
<para># mount -F hsfs -o ro /dev/lofi/1 /mnt</para>
<para># umount /mnt; lofiadm -d /dev/lofi/1 # Cleanup the lofi device</para></sect3><sect3><title>3.9 Create and burn an ISO image</title>
<para>This will copy the cd or DVD sector for sector. Without conv=notrunc, the image will be smaller if there is less content on the cd. See below and the dd examples (page 38).</para>
<para/>
<para># dd if=/dev/hdc of=/tmp/mycd.iso bs=2048 conv=notrunc</para>
<para/>
<para>Use mkisofs to create a CD/DVD image from files in a directory. To overcome the file names restrictions: -r enables the Rock Ridge extensions common to UNIX systems, -J enables Joliet extensions used by Microsoft systems. -L allows ISO9660 filenames to begin with a period.</para>
<para># mkisofs -J -L -r -V TITLE -o imagefile.iso /path/to/dir</para>
<para>On FreeBSD, mkisofs is found in the ports in sysutils/cdrtools.</para>
<para>Burn a CD/DVD ISO image</para>
<para>FreeBSD</para>
<para>FreeBSD does not enable DMA on ATAPI drives by default. DMA is enabled with the sysctl command and the arguments below, or with /boot/loader.conf with the following entries:</para>
<para>hw.ata.ata_dma="1"</para>
<para>hw.ata.atapi_dma="1"</para>
<para>Use burncd with an ATAPI device (burncd is part of the base system) and cdrecord (in sysutils/</para>
<para>cdrtools) with a SCSI drive.</para>
<para># burncd -f /dev/acd0 data imagefile.iso fixate # For ATAPI drive</para>
<para># cdrecord -scanbus # To find the burner device (like 1,0,0)</para>
<para># cdrecord dev=1,0,0 imagefile.iso</para>
<para>Linux</para>
<para>Also use cdrecord with Linux as described above. Additionally it is possible to use the native ATAPI interface which is found with:</para>
<para># cdrecord dev=ATAPI -scanbus</para>
<para>And burn the CD/DVD as above.</para>
<para>Convert a Nero .nrg file to .iso</para>
<para>Nero simply adds a 300Kb header to a normal iso image. This can be trimmed with dd.</para>
<para># dd bs=1k if=imagefile.nrg of=imagefile.iso skip=300</para>
<para>Convert a bin/cue image to .iso</para>
<para>The little bchunk program2 can do this. It is in the FreeBSD ports in sysutils/bchunk.</para>
<para># bchunk imagefile.bin imagefile.cue imagefile.iso</para></sect3><sect3><title>3.10 Create a file based image</title>
<para>For example a partition of 1GB using the file /usr/vdisk.img.</para>
<para>FreeBSD</para>
<para># dd if=/dev/random of=/usr/vdisk.img bs=1K count=1M</para>
<para># mdconfig -a -t vnode -f /usr/vdisk.img -u 1 # Creates device /dev/md1</para>
<para># bsdlabel -w /dev/md1</para>
<para># newfs /dev/md1c</para>
<para># mount /dev/md1c /mnt</para>
<para># umount /mnt; mdconfig -d -u 1; rm /usr/vdisk.img # Cleanup the md device</para>
<para>Linux</para>
<para># dd if=/dev/zero of=/usr/vdisk.img bs=1024k count=1024</para>
<para># mkfs.ext3 /usr/vdisk.img</para>
<para>2.http://freshmeat.net/projects/bchunk/</para>
<para># mount -o loop /usr/vdisk.img /mnt</para>
<para># umount /mnt; rm /usr/vdisk.img # Cleanup</para>
<para>Linux with losetup</para>
<para>/dev/zero is much faster than urandom, but less secure for encryption.</para>
<para># dd if=/dev/urandom of=/usr/vdisk.img bs=1024k count=1024</para>
<para># losetup /dev/loop0 /usr/vdisk.img # Creates and associates /dev/loop0</para>
<para># mkfs.ext3 /dev/loop0</para>
<para># mount /dev/loop0 /mnt</para>
<para># losetup -a # Check used loops</para>
<para># umount /mnt</para>
<para># losetup -d /dev/loop0 # Detach</para>
<para># rm /usr/vdisk.img</para></sect3><sect3><title>3.11 Create a memory file system</title>
<para>A memory based file system is very fast for heavy IO application. How to create a 64 MB partition mounted on /memdisk:</para>
<para>FreeBSD</para>
<para># mount_mfs -o rw -s 64M md /memdisk</para>
<para># umount /memdisk; mdconfig -d -u 0 # Cleanup the md device</para>
<para>md /memdisk mfs rw,-s64M 0 0 # /etc/fstab entry</para>
<para>Linux</para>
<para># mount -t tmpfs -osize=64m tmpfs /memdisk</para></sect3><sect3><title>3.12 Disk performance</title>
<para>Read and write a 1 GB file on partition ad4s3c (/home)</para>
<para># time dd if=/dev/ad4s3c of=/dev/null bs=1024k count=1000</para>
<para># time dd if=/dev/zero bs=1024k count=1000 of=/home/1Gb.file</para>
<para># hdparm -tT /dev/hda # Linux only</para></sect3></sect2><sect2><title>4. NETWORK</title>
<para/><sect3><title>4.1 Debugging (See also Traffic analysis) (page 18)</title>
<para># mii-diag eth0 # Show the link status (Linux)</para>
<para># ifconfig fxp0 # Check the "media" field on FreeBSD</para>
<para># arp -a # Check the router (or host) ARP entry (all OS)</para>
<para># ping cb.vu # The first thing to try...</para>
<para># traceroute cb.vu # Print the route path to destination</para>
<para># mii-diag -F 100baseTx-FD eth0 # Force 100Mbit Full duplex (Linux)</para>
<para># ifconfig fxp0 media 100baseTX mediaopt full-duplex # Same for FreeBSD</para>
<para># netstat -s # System-wide statistics for each network protocol</para>
<para/></sect3><sect3><title>4.2 Routing</title>
<para>Print routing table</para>
<para># route -n # Linux</para>
<para># netstat -rn # Linux, BSD and UNIX</para>
<para># route print # Windows</para>
<para>Add and delete a route</para>
<para>FreeBSD</para>
<para># route add 212.117.0.0/16 192.168.1.1</para>
<para># route delete 212.117.0.0/16</para>
<para># route add default 192.168.1.1</para>
<para>Add the route permanently in /etc/rc.conf</para>
<para>static_routes="myroute"</para>
<para>route_myroute="-net 212.117.0.0/16 192.168.1.1"</para>
<para>Linux</para>
<para># route add -net 192.168.20.0 netmask 255.255.255.0 gw 192.168.16.254</para>
<para># ip route add 192.168.20.0/24 via 192.168.16.254 # same as above with ip route</para>
<para># route add -net 192.168.20.0 netmask 255.255.255.0 dev eth0</para>
<para># route add default gw 192.168.51.254</para>
<para># ip route add default via 192.168.51.254 # same as above with ip route</para>
<para># route delete -net 192.168.20.0 netmask 255.255.255.0</para>
<para>Windows</para>
<para># Route add 192.168.50.0 mask 255.255.255.0 192.168.51.253</para>
<para># Route add 0.0.0.0 mask 0.0.0.0 192.168.51.254</para>
<para>Use add -p to make the route persistent.</para></sect3><sect3><title>4.3 Configure additional IP addresses</title>
<para>Linux</para>
<para># ifconfig eth0 192.168.50.254 netmask 255.255.255.0 # First IP</para>
<para># ifconfig eth0:0 192.168.51.254 netmask 255.255.255.0 # Second IP</para>
<para>FreeBSD</para>
<para># ifconfig fxp0 inet 192.168.50.254/24 # First IP</para>
<para># ifconfig fxp0 alias 192.168.51.254 netmask 255.255.255.0 # Second IP</para>
<para>Permanent entries in /etc/rc.conf</para>
<para>ifconfig_fxp0="inet 192.168.50.254 netmask 255.255.255.0"</para>
<para>ifconfig_fxp0_alias0="192.168.51.254 netmask 255.255.255.0"</para></sect3><sect3><title>4.4 Change MAC address</title>
<para># ifconfig eth0 hw ether 00:01:02:03:04:05 # Linux</para>
<para># ifconfig fxp0 link 00:01:02:03:04:05 # FreeBSD</para></sect3><sect3><title>4.5 Ports in use</title>
<para>Listening open ports:</para>
<para># netstat -an | grep LISTEN</para>
<para># lsof -i # Linux list all Internet connections</para>
<para># socklist # Linux display list of open sockets</para>
<para># sockstat -4 # FreeBSD application listing</para>
<para># netstat -anp --udp --tcp | grep LISTEN # Linux</para>
<para># netstat -tup # List active connections to/from system (Linux)</para>
<para># netstat -tupl # List listening ports from system (Linux)</para>
<para># netstat -ano # Windows</para></sect3><sect3><title>4.6 Firewall</title>
<para>Check if a firewall is running (typical configuration only):</para>
<para>Linux</para>
<para># iptables -L -n -v # For status</para>
<para>Open the iptables firewall</para>
<para># iptables -Z # Zero the packet and byte counters in all chains</para>
<para># iptables -F # Flush all chains</para>
<para># iptables -X # Delete all chains</para>
<para># iptables -P INPUT ACCEPT # Open everything</para>
<para># iptables -P FORWARD ACCEPT</para>
<para># iptables -P OUTPUT ACCEPT</para>
<para>FreeBSD</para>
<para># ipfw show # For status</para>
<para># ipfw list 65535 # if answer is "65535 deny ip from any to any" the fw is disabled</para>
<para># sysctl net.inet.ip.fw.enable=0 # Disable</para>
<para># sysctl net.inet.ip.fw.enable=1 # Enable</para></sect3><sect3><title>4.7 IP Forward for routing</title>
<para>Linux</para>
<para>Check and then enable IP forward with:</para>
<para># cat /proc/sys/net/ipv4/ip_forward # Check IP forward 0=off, 1=on</para>
<para># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</para>
<para>or edit /etc/sysctl.conf with:</para>
<para>net.ipv4.ip_forward = 1</para>
<para>FreeBSD</para>
<para>Check and enable with:</para>
<para># sysctl net.inet.ip.forwarding # Check IP forward 0=off, 1=on</para>
<para># sysctl net.inet.ip.forwarding=1</para>
<para># sysctl net.inet.ip.fastforwarding=1 # For dedicated router or firewall</para>
<para>Permanent with entry in /etc/rc.conf:</para>
<para>gateway_enable="YES" # Set to YES if this host will be a gateway.</para></sect3><sect3><title>4.8 NAT Network Address Translation</title>
<para>Linux</para>
<para># iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE # to activate NAT</para>
<para># iptables -t nat -A PREROUTING -p tcp -d 78.31.70.238 --dport 20022 -j DNAT \</para>
<para>--to 192.168.16.44:22 # Port forward 20022 to internal IP port ssh</para>
<para># iptables -t nat -A PREROUTING -p tcp -d 78.31.70.238 --dport 993:995 -j DNAT \</para>
<para>--to 192.168.16.254:993:995 # Port forward of range 993-995</para>
<para># ip route flush cache</para>
<para># iptables -L -t nat # Check NAT status</para>
<para>Delete the port forward with -D instead of -A.</para>
<para>FreeBSD</para>
<para># natd -s -m -u -dynamic -f /etc/natd.conf -n fxp0</para>
<para>Or edit /etc/rc.conf with:</para>
<para>firewall_enable="YES" # Set to YES to enable firewall functionality</para>
<para>firewall_type="open" # Firewall type (see /etc/rc.firewall)</para>
<para>natd_enable="YES" # Enable natd (if firewall_enable == YES).</para>
<para>natd_interface="tun0" # Public interface or IP address to use.</para>
<para>natd_flags="-s -m -u -dynamic -f /etc/natd.conf"</para>
<para>Port forward with:</para>
<para># cat /etc/natd.conf</para>
<para>same_ports yes</para>
<para>use_sockets yes</para>
<para>unregistered_only</para>
<para># redirect_port tcp insideIP:2300-2399 3300-3399 # port range</para>
<para>redirect_port udp 192.168.51.103:7777 7777</para></sect3><sect3><title>4.9 DNS</title>
<para>On Unix the DNS entries are valid for all interfaces and are stored in /etc/resolv.conf. The domain to which the host belongs is also stored in this file. A minimal configuration is:</para>
<para>nameserver 78.31.70.238</para>
<para>search sleepyowl.net intern.lab</para>
<para>domain sleepyowl.net</para>
<para>Check the system domain name with:</para>
<para># hostname -d # Same as dnsdomainname</para>
<para>Windows</para>
<para>On Windows the DNS are configured per interface. To display the configured DNS and to flush the DNS cache use:</para>
<para># ipconfig /? # Display help</para>
<para># ipconfig /all # See all information including DNS</para>
<para># ipconfig /flushdns # Flush the DNS cache</para>
<para>Forward queries</para>
<para>Dig is you friend to test the DNS settings. For example the public DNS server 213.133.105.2</para>
<para>ns.second-ns.de can be used for testing. See from which server the client receives the answer</para>
<para>(simplified answer).</para>
<para># dig sleepyowl.net</para>
<para>sleepyowl.net. 600 IN A 78.31.70.238</para>
<para>;; SERVER: 192.168.51.254#53(192.168.51.254)</para>
<para>The router 192.168.51.254 answered and the response is the A entry. Any entry can be queried and the DNS server can be selected with @:</para>
<para/>
<para>The program host is also powerful.</para>
<para># host -t MX cb.vu # Get the mail MX entry</para>
<para># host -t NS -T sun.com # Get the NS record over a TCP connection</para>
<para># host -a sleepyowl.net # Get everything</para>
<para>Reverse queries</para>
<para>Find the name belonging to an IP address (in-addr.arpa.). This can be done with dig, host and</para>
<para>nslookup:</para>
<para># dig -x 78.31.70.238</para>
<para># host 78.31.70.238</para>
<para># nslookup 78.31.70.238</para>
<para>/etc/hosts</para>
<para>Single hosts can be configured in the file /etc/hosts instead of running named locally to resolve the hostname queries. The format is simple, for example:</para>
<para>78.31.70.238 sleepyowl.net sleepyowl</para>
<para>The priority between hosts and a dns query, that is the name resolution order, can be</para>
<para>configured in /etc/nsswitch.conf AND /etc/host.conf. The file also exists on Windows, it is</para>
<para>usually in:</para>
<para>C:\WINDOWS\SYSTEM32\DRIVERS\ETC</para></sect3><sect3><title>4.10 DHCP</title>
<para>Linux</para>
<para>Some distributions (SuSE) use dhcpcd as client. The default interface is eth0.</para>
<para># dhcpcd -n eth0 # Trigger a renew</para>
<para># dhcpcd -k eth0 # release and shutdown</para>
<para>The lease with the full information is stored in:</para>
<para>/var/lib/dhcpcd/dhcpcd-eth0.info</para>
<para>FreeBSD</para>
<para>FreeBSD (and Debian) uses dhclient. To configure an interface (for example bge0) run:</para>
<para># dhclient bge0</para>
<para>The lease with the full information is stored in:</para>
<para>/var/db/dhclient.leases.bge0</para>
<para>Use</para>
<para>/etc/dhclient.conf</para>
<para>to prepend options or force different options:</para>
<para># cat /etc/dhclient.conf</para>
<para>interface "rl0" {</para>
<para>prepend domain-name-servers 127.0.0.1;</para>
<para>default domain-name "sleepyowl.net";</para>
<para>supersede domain-name "sleepyowl.net";</para>
<para>}</para>
<para>Windows</para>
<para># ipconfig /renew # renew all adapters</para>
<para># ipconfig /renew LAN # renew the adapter named "LAN"</para>
<para># ipconfig /release WLAN # release the adapter named "WLAN"</para>
<para>Yes it is a good idea to rename you adapter with simple names!</para></sect3><sect3><title>4.11 Traffic analysis</title>
<para>Bmon3 is a small console bandwidth monitor and can display the flow on different interfaces.</para>
<para>Sniff with tcpdump</para>
<para># tcpdump -nl -i bge0 not port ssh and src \(192.168.16.121 or 192.168.16.54\)</para>
<para># tcpdump -l &gt; dump &amp;&amp; tail -f dump # Buffered output</para>
<para># tcpdump -i rl0 -w traffic.rl0 # Write traffic in binary file</para>
<para># tcpdump -r traffic.rl0 # Read from file (also for ethereal</para>
<para># tcpdump port 80 # The two classic commands</para>
<para># tcpdump host google.com</para>
<para># tcpdump -i eth0 -X port \(110 or 143\) # Check if pop or imap is secure</para>
<para># tcpdump -n -i eth0 icmp # Only catch pings</para>
<para># tcpdump -i eth0 -s 0 -A port 80 | grep GET # -s 0 for full packet -A for ASCII</para>
<para>Additional important options:</para>
<para>-A Print each packets in clear text (without header)</para>
<para>-X Print packets in hex and ASCII</para>
<para>-l Make stdout line buffered</para>
<para>-D Print all interfaces available</para>
<para>On Windows use windump from www.winpcap.org. Use windump -D to list the interfaces.</para>
<para>Scan with nmap</para>
<para>Nmap4 is a port scanner with OS detection, it is usually installed on most distributions and is also available for Windows. If you don't scan your servers, hackers do it for you...</para>
<para># nmap cb.vu # scans all reserved TCP ports on the host</para>
<para># nmap -sP 192.168.16.0/24 # Find out which IP are used and by which host on 0/24</para>
<para># nmap -sS -sV -O cb.vu # Do a stealth SYN scan with version and OS detection</para>
<para>PORT STATE SERVICE VERSION</para>
<para>22/tcp open ssh OpenSSH 3.8.1p1 FreeBSD-20060930 (protocol 2.0)</para>
<para>25/tcp open smtp Sendmail smtpd 8.13.6/8.13.6</para>
<para>80/tcp open http Apache httpd 2.0.59 ((FreeBSD) DAV/2 PHP/4.</para>
<para>[...]</para>
<para>Running: FreeBSD 5.X</para>
<para>Uptime 33.120 days (since Fri Aug 31 11:41:04 2007)</para></sect3><sect3><title>4.12 Traffic control (QoS)</title>
<para>Traffic control manages the queuing, policing, scheduling, and other traffic parameters for a network. The following examples are simple practical uses of the Linux and FreeBSD capabilities to better use the available bandwidth.</para>
<para>Limit upload</para>
<para>DSL or cable modems have a long queue to improve the upload throughput. However filling the queue with a fast device (e.g. ethernet) will dramatically decrease the interactivity. It is therefore useful to limit the device upload rate to match the physical capacity of the modem, this should greatly improve the interactivity. Set to about 90% of the modem maximal (cable)</para>
<para>speed.</para>
<para>3.http://people.suug.ch/~tgr/bmon/</para>
<para>4.http://insecure.org/nmap/</para>
<para/>
<para>Linux</para>
<para>For a 512 Kbit upload modem.</para>
<para># tc qdisc add dev eth0 root tbf rate 480kbit latency 50ms burst 1540</para>
<para># tc -s qdisc ls dev eth0 # Status</para>
<para># tc qdisc del dev eth0 root # Delete the queue</para>
<para># tc qdisc change dev eth0 root tbf rate 220kbit latency 50ms burst 1540</para>
<para>FreeBSD</para>
<para>FreeBSD uses the dummynet traffic shaper which is configured with ipfw. Pipes are used to set limits the bandwidth in units of [K|M]{bit/s|Byte/s}, 0 means unlimited bandwidth. Using the same pipe number will reconfigure it. For example limit the upload bandwidth to 500 Kbit.</para>
<para># kldload dummynet # load the module if necessary</para>
<para># ipfw pipe 1 config bw 500Kbit/s # create a pipe with limited bandwidth</para>
<para># ipfw add pipe 1 ip from me to any # divert the full upload into the pipe</para>
<para>Quality of service</para>
<para>Linux</para>
<para>Priority queuing with tc to optimize VoIP. See the full example on voip-info.org or</para>
<para>www.howtoforge.com. Suppose VoIP uses udp on ports 10000:11024 and device eth0 (could also be ppp0 or so). The following commands define the QoS to three queues and force the VoIP traffic to queue 1 with QoS 0x1e (all bits set). The default traffic flows into queue 3 and QoS</para>
<para>Minimize-Delay flows into queue 2.</para>
<para># tc qdisc add dev eth0 root handle 1: prio priomap 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 0</para>
<para># tc qdisc add dev eth0 parent 1:1 handle 10: sfq</para>
<para># tc qdisc add dev eth0 parent 1:2 handle 20: sfq</para>
<para># tc qdisc add dev eth0 parent 1:3 handle 30: sfq</para>
<para># tc filter add dev eth0 protocol ip parent 1: prio 1 u32 \</para>
<para>match ip dport 10000 0x3C00 flowid 1:1 # use server port range</para>
<para>match ip dst 123.23.0.1 flowid 1:1 # or/and use server IP</para>
<para>Status and remove with</para>
<para># tc -s qdisc ls dev eth0 # queue status</para>
<para># tc qdisc del dev eth0 root # delete all QoS</para>
<para>Calculate port range and mask</para>
<para>The tc filter defines the port range with port and mask which you have to calculate. Find the 2^N ending of the port range, deduce the range and convert to HEX. This is your mask.</para>
<para>Example for 10000 -&gt; 11024, the range is 1024.</para>
<para># 2^13 (8192) &lt; 10000 &lt; 2^14 (16384) # ending is 2^14 = 16384</para>
<para># echo "obase=16;(2^14)-1024" | bc # mask is 0x3C00</para>
<para>FreeBSD</para>
<para>The max link bandwidth is 500Kbit/s and we define 3 queues with priority 100:10:1 for</para>
<para>VoIP:ssh:all the rest.</para>
<para># ipfw pipe 1 config bw 500Kbit/s</para>
<para># ipfw queue 1 config pipe 1 weight 100</para>
<para># ipfw queue 2 config pipe 1 weight 10</para>
<para># ipfw queue 3 config pipe 1 weight 1</para>
<para># ipfw add 10 queue 1 proto udp dst-port 10000-11024</para>
<para># ipfw add 11 queue 1 proto udp dst-ip 123.23.0.1 # or/and use server IP</para>
<para># ipfw add 20 queue 2 dsp-port ssh</para>
<para># ipfw add 30 queue 3 from me to any # all the rest</para>
<para>Status and remove with</para>
<para># ipfw list # rules status</para>
<para># ipfw pipe list # pipe status</para>
<para># ipfw flush # deletes all rules but default</para></sect3><sect3><title>4.13 NIS Debugging</title>
<para>Some commands which should work on a well configured NIS client:</para>
<para># ypwhich # get the connected NIS server name</para>
<para># domainname # The NIS domain name as configured</para>
<para># ypcat group # should display the group from the NIS server</para>
<para># cd /var/yp &amp;&amp; make # Rebuild the yp database</para>
<para>Is ypbind running?</para>
<para># ps auxww | grep ypbind</para>
<para>/usr/sbin/ypbind -s -m -S servername1,servername2 # FreeBSD</para>
<para>/usr/sbin/ypbind # Linux</para>
<para># yppoll passwd.byname</para>
<para>Map passwd.byname has order number 1190635041. Mon Sep 24 13:57:21 2007</para>
<para>The master server is servername.domain.net.</para>
<para>Linux</para>
<para># cat /etc/yp.conf</para>
<para>ypserver servername</para>
<para>domain domain.net broadcast</para></sect3></sect2><sect2><title>5. SSH SCP</title>
<para/><sect3><title>5.1 Public key authentication</title>
<para>Connect to a host without password using public key authentication. The idea is to append your public key to the authorized_keys2 file on the remote host. For this example let's connect host-client to host-server, the key is generated on the client.</para>
<para>• Use ssh-keygen to generate a key pair. ~/.ssh/id_dsa is the private key, ~/.ssh/</para>
<para>id_dsa.pub is the public key.</para>
<para>• Copy only the public key to the server and append it to the file ~/.ssh/</para>
<para>authorized_keys2 on your home on the server.</para>
<para># ssh-keygen -t dsa -N ''</para>
<para># cat ~/.ssh/id_dsa.pub | ssh you@host-server "cat - &gt;&gt; ~/.ssh/authorized_keys2"</para>
<para>Using the Windows client from ssh.com</para>
<para>The non commercial version of the ssh.com client can be downloaded the main ftp site:</para>
<para>ftp.ssh.com/pub/ssh/. Keys generated by the ssh.com client need to be converted for the OpenSSH server. This can be done with the ssh-keygen command.</para>
<para>• Create a key pair with the ssh.com client: Settings - User Authentication - Generate</para>
<para>New....</para>
<para>• I use Key type DSA; key length 2048.</para>
<para>• Copy the public key generated by the ssh.com client to the server into the ~/.ssh folder.</para>
<para>• The keys are in C:\Documents and Settings\%USERNAME%\Application</para>
<para>Data\SSH\UserKeys.</para>
<para>• Use the ssh-keygen command on the server to convert the key:</para>
<para># cd ~/.ssh</para>
<para># ssh-keygen -i -f keyfilename.pub &gt;&gt; authorized_keys2</para>
<para/>
<para>Notice: We used a DSA key, RSA is also possible. The key is not protected by a password.</para>
<para>Using putty for Windows</para>
<para>Putty5 is a simple and free ssh client for Windows.</para>
<para>• Create a key pair with the puTTYgen program.</para>
<para>• Save the public and private keys (for example into C:\Documents and</para>
<para>Settings\%USERNAME%\.ssh).</para>
<para>• Copy the public key to the server into the ~/.ssh folder:</para>
<para># scp .ssh/puttykey.pub root@192.168.51.254:.ssh/</para>
<para>• Use the ssh-keygen command on the server to convert the key for OpenSSH:</para>
<para># cd ~/.ssh</para>
<para># ssh-keygen -i -f puttykey.pub &gt;&gt; authorized_keys2</para>
<para>• Point the private key location in the putty settings: Connection - SSH - Auth</para></sect3><sect3><title>5.2 Check fingerprint</title>
<para>At the first login, ssh will ask if the unknown host with the fingerprint has to be stored in the known hosts. To avoid a man-in-the-middle attack the administrator of the server can send you the server fingerprint which is then compared on the first login. Use ssh-keygen -l to get the fingerprint (on the server):</para>
<para># ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key.pub # For RSA key</para>
<para>2048 61:33:be:9b:ae:6c:36:31:fd:83:98:b7:99:2d:9f:cd /etc/ssh/ssh_host_rsa_key.pub</para>
<para># ssh-keygen -l -f /etc/ssh/ssh_host_dsa_key.pub # For DSA key (default)</para>
<para>2048 14:4a:aa:d9:73:25:46:6d:0a:48:35:c7:f4:16:d4:ee /etc/ssh/ssh_host_dsa_key.pub</para>
<para>Now the client connecting to this server can verify that he is connecting to the right server:</para>
<para># ssh linda</para>
<para>The authenticity of host 'linda (192.168.16.54)' can't be established.</para>
<para>DSA key fingerprint is 14:4a:aa:d9:73:25:46:6d:0a:48:35:c7:f4:16:d4:ee.</para>
<para>Are you sure you want to continue connecting (yes/no)? yes</para></sect3><sect3><title>5.3 Secure file transfer</title>
<para>Some simple commands:</para>
<para># scp file.txt host-two:/tmp</para>
<para># scp joe@host-two:/www/*.html /www/tmp</para>
<para># scp -r joe@host-two:/www /www/tmp</para>
<para>In Konqueror or Midnight Commander it is possible to access a remote file system with the address fish://user@gate. However the implementation is very slow.</para>
<para>Furthermore it is possible to mount a remote folder with sshfs a file system client based on SCP. See fuse sshfs6.</para></sect3><sect3><title>5.4 Tunneling</title>
<para>SSH tunneling allows to forward or reverse forward a port over the SSH connection, thus securing the traffic and accessing ports which would otherwise be blocked. This only works with TCP. The general nomenclature for forward and reverse is (see also ssh and NAT example):</para>
<para># ssh -L localport:desthost:destport user@gate # desthost as seen from the gate</para>
<para># ssh -R destport:desthost:localport user@gate # forwards your localport to destination</para>
<para># ssh -X user@gate # To force X forwarding</para>
<para>5.http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html</para>
<para>6.http://fuse.sourceforge.net/sshfs.html</para>
<para/>
<para>This will connect to gate and forward the local port to the host desthost:destport. Note desthost is the destination host as seen by the gate, so if the connection is to the gate, then desthost is localhost. More than one port forward is possible.</para>
<para>Direct forward on the gate</para>
<para>Let say we want to access the CVS (port 2401) and http (port 80) which are running on the gate. This is the simplest example, desthost is thus localhost, and we use the port 8080 locally instead of 80 so we don't need to be root. Once the ssh session is open, both services are accessible on the local ports.</para>
<para># ssh -L 2401:localhost:2401 -L 8080:localhost:80 user@gate</para>
<para>Netbios and remote desktop forward to a second server</para>
<para>Let say a Windows smb server is behind the gate and is not running ssh. We need access to the smb share and also remote desktop to the server.</para>
<para># ssh -L 139:smbserver:139 -L 3388:smbserver:3389 user@gate</para>
<para>The smb share can now be accessed with \\127.0.0.1\, but only if the local share is disabled, because the local share is listening on port 139.</para>
<para>It is possible to keep the local share enabled, for this we need to create a new virtual device with a new IP address for the tunnel, the smb share will be connected over this address.</para>
<para>Furthermore the local RDP is already listening on 3389, so we choose 3388. For this example let's use a virtual IP of 10.1.1.1.</para>
<para>• With putty use Source port=10.1.1.1:139. It is possible to create multiple loop devices</para>
<para>and tunnel. On Windows 2000, only putty worked for me.</para>
<para>• With the ssh.com client, disable "Allow local connections only". Since ssh.com will bind</para>
<para>to all addresses, only a single share can be connected.</para>
<para>Now create the loopback interface with IP 10.1.1.1:</para>
<para>• # System-&gt;Control Panel-&gt;Add Hardware # Yes, Hardware is already connected # Add</para>
<para>a new hardware device (at bottom).</para>
<para>• # Install the hardware that I manually select # Network adapters # Microsoft , Microsoft</para>
<para>Loopback Adapter.</para>
<para>• Configure the IP address of the fake device to 10.1.1.1 mask 255.255.255.0, no</para>
<para>gateway.</para>
<para>• advanced-&gt;WINS, Enable LMHosts Lookup; Disable NetBIOS over TCP/IP.</para>
<para>• # Enable Client for Microsoft Networks. # Disable File and Printer Sharing for Microsoft</para>
<para>Networks.</para>
<para>I HAD to reboot for this to work. Now connect to the smb share with \\10.1.1.1 and remote</para>
<para>desktop to 10.1.1.1:3388.</para>
<para>Debug</para>
<para>If it is not working:</para>
<para>• Are the ports forwarded: netstat -an? Look at 0.0.0.0:139 or 10.1.1.1:139</para>
<para>• Does telnet 10.1.1.1 139 connect?</para>
<para>• You need the checkbox "Local ports accept connections from other hosts".</para>
<para>• Is "File and Printer Sharing for Microsoft Networks" disabled on the loopback interface?</para>
<para>Connect two clients behind NAT</para>
<para>Suppose two clients are behind a NAT gateway and client cliadmin has to connect to client</para>
<para>cliuser (the destination), both can login to the gate with ssh and are running Linux with sshd.</para>
<para>You don't need root access anywhere as long as the ports on gate are above 1024. We use 2022</para>
<para>on gate. Also since the gate is used locally, the option GatewayPorts is not necessary.</para>
<para>On client cliuser (from destination to gate):</para>
<para># ssh -R 2022:localhost:22 user@gate # forwards client 22 to gate:2022</para>
<para>On client cliadmin (from host to gate):</para>
<para/>
<para># ssh -L 3022:localhost:2022 admin@gate # forwards client 3022 to gate:2022</para>
<para>Now the admin can connect directly to the client cliuser with:</para>
<para># ssh -p 3022 admin@localhost # local:3022 -&gt; gate:2022 -&gt; client:22</para>
<para>Connect to VNC behind NAT</para>
<para>Suppose a Windows client with VNC listening on port 5900 has to be accessed from behind NAT.</para>
<para>On client cliwin to gate:</para>
<para># ssh -R 15900:localhost:5900 user@gate</para>
<para>On client cliadmin (from host to gate):</para>
<para># ssh -L 5900:localhost:15900 admin@gate</para>
<para>Now the admin can connect directly to the client VNC with:</para>
<para># vncconnect -display :0 localhost</para></sect3></sect2><sect2><title>6. VPN WITH SSH</title>
<para>As of version 4.3, OpenSSH can use the tun/tap device to encrypt a tunnel. This is very similar to other TLS based VPN solutions like OpenVPN. One advantage with SSH is that there is no need to install and configure additional software. Additionally the tunnel uses the SSH authentication like pre shared keys. The drawback is that the encapsulation is done over TCP which might result in poor performance on a slow link. Also the tunnel is relying on a single (fragile) TCP connection. This technique is very useful for a quick IP based VPN setup. There is no limitation as with the single TCP port forward, all layer 3/4 protocols like ICMP, TCP/UDP, etc. are forwarded over the VPN. In any case, the following options are needed in the sshd_conf</para>
<para>file:</para>
<para>PermitRootLogin yes</para>
<para>PermitTunnel yes</para><sect3><title>6.1 Single P2P connection</title>
<para>Here we are connecting two hosts, hclient and hserver with a peer to peer tunnel. The</para>
<para>connection is started from hclient to hserver and is done as root. The tunnel end points are 10.0.1.1 (server) and 10.0.1.2 (client) and we create a device tun5 (this could also be an other number). The procedure is very simple:</para>
<para>• Connect with SSH using the tunnel option -w</para>
<para>• Configure the IP addresses of the tunnel. Once on the server and once on the client.</para>
<para>Connect to the server</para>
<para>Connection started on the client and commands are executed on the server.</para>
<para>Server is on Linux</para>
<para>cli&gt;# ssh -w5:5 root@hserver</para>
<para>srv&gt;# ifconfig tun5 10.0.1.1 netmask 255.255.255.252 # Executed on the server shell</para>
<para>Server is on FreeBSD</para>
<para>cli&gt;# ssh -w5:5 root@hserver</para>
<para>srv&gt;# ifconfig tun5 10.0.1.1 10.0.1.2 # Executed on the server shell</para>
<para>Configure the client</para>
<para>Commands executed on the client:</para>
<para/>
<para>cli&gt;# ifconfig tun5 10.0.1.2 netmask 255.255.255.252 # Client is on Linux</para>
<para>cli&gt;# ifconfig tun5 10.0.1.2 10.0.1.1 # Client is on FreeBSD</para>
<para>The two hosts are now connected and can transparently communicate with any layer 3/4</para>
<para>protocol using the tunnel IP addresses.</para></sect3><sect3><title>6.2 Connect two networks</title>
<para>In addition to the p2p setup above, it is more useful to connect two private networks with an</para>
<para>SSH VPN using two gates. Suppose for the example, netA is 192.168.51.0/24 and netB</para>
<para>192.168.16.0/24. The procedure is similar as above, we only need to add the routing. NAT must</para>
<para>be activated on the private interface only if the gates are not the same as the default gateway</para>
<para>of their network.</para>
<para>192.168.51.0/24 (netA)|gateA &lt;-&gt; gateB|192.168.16.0/24 (netB)</para>
<para>• Connect with SSH using the tunnel option -w.</para>
<para>• Configure the IP addresses of the tunnel. Once on the server and once on the client.</para>
<para>• Add the routing for the two networks.</para>
<para>• If necessary, activate NAT on the private interface of the gate.</para>
<para>The setup is started from gateA in netA.</para>
<para>Connect from gateA to gateB</para>
<para>Connection is started from gateA and commands are executed on gateB.</para>
<para>gateB is on Linux</para>
<para>gateA&gt;# ssh -w5:5 root@gateB</para>
<para>gateB&gt;# ifconfig tun5 10.0.1.1 netmask 255.255.255.252 # Executed on the gateB shell</para>
<para>gateB&gt;# route add -net 192.168.51.0 netmask 255.255.255.0 dev tun5</para>
<para>gateB&gt;# echo 1 &gt; /proc/sys/net/ipv4/ip_forward # Only needed if not default gw</para>
<para>gateB&gt;# iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</para>
<para>gateB is on FreeBSD</para>
<para>gateA&gt;# ssh -w5:5 root@gateB # Creates the tun5 devices</para>
<para>gateB&gt;# ifconfig tun5 10.0.1.1 10.0.1.2 # Executed on the gateB shell</para>
<para>gateB&gt;# route add 192.168.51.0/24 10.0.1.2</para>
<para>gateB&gt;# sysctl net.inet.ip.forwarding=1 # Only needed if not default gw</para>
<para>gateB&gt;# natd -s -m -u -dynamic -n fxp0 # see NAT (page 15)</para>
<para>gateA&gt;# sysctl net.inet.ip.fw.enable=1</para>
<para>Configure gateA</para>
<para>Commands executed on gateA:</para>
<para>gateA is on Linux</para>
<para>gateA&gt;# ifconfig tun5 10.0.1.2 netmask 255.255.255.252</para>
<para>gateA&gt;# route add -net 192.168.16.0 netmask 255.255.255.0 dev tun5</para>
<para>gateA&gt;# echo 1 &gt; /proc/sys/net/ipv4/ip_forward</para>
<para>gateA&gt;# iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</para>
<para>gateA is on FreeBSD</para>
<para>gateA&gt;# ifconfig tun5 10.0.1.2 10.0.1.1</para>
<para>gateA&gt;# route add 192.168.16.0/24 10.0.1.2</para>
<para>gateA&gt;# sysctl net.inet.ip.forwarding=1</para>
<para>gateA&gt;# natd -s -m -u -dynamic -n fxp0 # see NAT (page 15)</para>
<para>gateA&gt;# sysctl net.inet.ip.fw.enable=1</para>
<para>The two private networks are now transparently connected via the SSH VPN. The IP forward and NAT settings are only necessary if the gates are not the default gateways. In this case the clients would not know where to forward the response, and nat must be activated.</para>
<para/></sect3></sect2><sect2><title>7. RSYNC</title>
<para>Rsync can almost completely replace cp and scp, furthermore interrupted transfers are</para>
<para>efficiently restarted. A trailing slash (and the absence thereof) has different meanings, the man page is good... Here some examples:</para>
<para>Copy the directories with full content:</para>
<para># rsync -a /home/colin/ /backup/colin/</para>
<para># rsync -a /var/ /var_bak/</para>
<para># rsync -aR --delete-during /home/user/ /backup/ # use relative (see below)</para>
<para>Same as before but over the network and with compression. Rsync uses SSH for the transport per default and will use the ssh key if they are set. Use ":" as with SCP. A typical remote copy:</para>
<para># rsync -axSRzv /home/user/ user@server:/backup/user/</para>
<para>Exclude any directory tmp within /home/user/ and keep the relative folders hierarchy, that is the remote directory will have the structure /backup/home/user/. This is typically used for backups.</para>
<para># rsync -azR --exclude /tmp/ /home/user/ user@server:/backup/</para>
<para>Use port 20022 for the ssh connection:</para>
<para># rsync -az -e 'ssh -p 20022' /home/colin/ user@server:/backup/colin/</para>
<para>Using the rsync daemon (used with "::") is much faster, but not encrypted over ssh. The</para>
<para>location of /backup is defined by the configuration in /etc/rsyncd.conf. The variable</para>
<para>RSYNC_PASSWORD can be set to avoid the need to enter the password manually.</para>
<para># rsync -axSRz /home/ ruser@hostname::rmodule/backup/</para>
<para># rsync -axSRz ruser@hostname::rmodule/backup/ /home/ # To copy back</para>
<para>Some important options:</para>
<para>-a, --archive archive mode; same as -rlptgoD (no -H)</para>
<para>-r, --recursive recurse into directories</para>
<para>-R, --relative use relative path names</para>
<para>-H, --hard-links preserve hard links</para>
<para>-S, --sparse handle sparse files efficiently</para>
<para>-x, --one-file-system don't cross file system boundaries</para>
<para>--exclude=PATTERN exclude files matching PATTERN</para>
<para>--delete-during receiver deletes during xfer, not before</para>
<para>--delete-after receiver deletes after transfer, not before</para><sect3><title>7.1 Rsync on Windows</title>
<para>Rsync is available for Windows through cygwin or as stand-alone packaged in cwrsync7. This is very convenient for automated backups. Install one of them (not both) and add the path to the Windows system variables: # Control Panel -&gt; System -&gt; tab Advanced, button Environment</para>
<para>Variables. Edit the "Path" system variable and add the full path to the installed rsync, e.g.</para>
<para>C:\Program Files\cwRsync\bin or C:\cygwin\bin. This way the commands rsync and ssh are available in a Windows command shell.</para>
<para>Public key authentication</para>
<para>Rsync is automatically tunneled over SSH and thus uses the SSH authentication on the server.</para>
<para>Automatic backups have to avoid a user interaction, for this the SSH public key authentication can be used and the rsync command will run without a password.</para>
<para>All the following commands are executed within a Windows console. In a console (Start -&gt; Run -&gt; cmd) create and upload the key as described in SSH, change "user" and "server" as appropriate. If the file authorized_keys2 does not exist yet, simply copy id_dsa.pub to authorized_keys2 and upload it.</para>
<para># ssh-keygen -t dsa -N '' # Creates a public and a private key</para>
<para># rsync user@server:.ssh/authorized_keys2 . # Copy the file locally from the server</para>
<para># cat id_dsa.pub &gt;&gt; authorized_keys2 # Or use an editor to add the key</para>
<para># rsync authorized_keys2 user@server:.ssh/ # Copy the file back to the server</para>
<para># del authorized_keys2 # Remove the local copy</para>
<para>Now test it with (in one line):</para>
<para>rsync -rv "/cygdrive/c/Documents and Settings/%USERNAME%/My Documents/" \</para>
<para>'user@server:My\ Documents/'</para>
<para>Automatic backup</para>
<para>Use a batch file to automate the backup and add the file in the scheduled tasks (Programs -&gt; Accessories -&gt; System Tools -&gt; Scheduled Tasks). For example create the file backup.bat and</para>
<para>replace user@server.</para>
<para>@ECHO OFF</para>
<para>REM rsync the directory My Documents</para>
<para>SETLOCAL</para>
<para>SET CWRSYNCHOME=C:\PROGRAM FILES\CWRSYNC</para>
<para>SET CYGWIN=nontsec</para>
<para>SET CWOLDPATH=%PATH%</para>
<para>REM uncomment the next line when using cygwin</para>
<para>SET PATH=%CWRSYNCHOME%\BIN;%PATH%</para>
<para>echo Press Control-C to abort</para>
<para>rsync -av "/cygdrive/c/Documents and Settings/%USERNAME%/My Documents/" \</para>
<para>'user@server:My\ Documents/'</para>
<para>pause</para></sect3></sect2><sect2><title>8. SUDO</title>
<para>Sudo is a standard way to give users some administrative rights without giving out the root password. Sudo is very useful in a multi user environment with a mix of server and</para>
<para>workstations. Simply call the command with sudo:</para>
<para># sudo /etc/init.d/dhcpd restart # Run the rc script as root</para>
<para># sudo -u sysadmin whoami # Run cmd as an other user</para><sect3><title>8.1 Configuration</title>
<para>Sudo is configured in /etc/sudoers and must only be edited with visudo. The basic syntax is</para>
<para>(the lists are comma separated):</para>
<para>user hosts = (runas) commands # In /etc/sudoers</para>
<para>users one or more users or %group (like %wheel) to gain the rights</para>
<para>hosts list of hosts (or ALL)</para>
<para>runas list of users (or ALL) that the command rule can be run as. It is enclosed in ( )!</para>
<para>commands list of commands (or ALL) that will be run as root or as (runas)</para>
<para>Additionally those keywords can be defined as alias, they are called User_Alias, Host_Alias, Runas_Alias and Cmnd_Alias. This is useful for larger setups. Here a sudoers example:</para>
<para># cat /etc/sudoers</para>
<para># Host aliases are subnets or hostnames.</para>
<para>Host_Alias DMZ = 212.118.81.40/28</para>
<para>User_Alias ADMINS = colin, luca, admin</para>
<para>User_Alias DEVEL = joe, jack, julia</para>
<para>Runas_Alias DBA = oracle,pgsql</para>
<para># Command aliases define the full path of a list of commands</para>
<para>Cmnd_Alias SYSTEM = /sbin/reboot,/usr/bin/kill,/sbin/halt,/sbin/shutdown,/etc/init.d/</para>
<para>Cmnd_Alias PW = /usr/bin/passwd [A-z]*, !/usr/bin/passwd root # Not root pwd!</para>
<para>Cmnd_Alias DEBUG = /usr/sbin/tcpdump,/usr/bin/wireshark,/usr/bin/nmap</para>
<para># The actual rules</para>
<para>root,ADMINS ALL = (ALL) NOPASSWD: ALL # ADMINS can do anything w/o a password.</para>
<para>DEVEL DESKTOP = (ALL) NOPASSWD: ALL # Developers have full right on desktops</para>
<para>DEVEL DMZ = (ALL) NOPASSWD: DEBUG # Developers can debug the DMZ servers.</para>
<para># User sysadmin can mess around in the DMZ servers with some commands.</para>
<para>sysadmin DMZ = (ALL) NOPASSWD: SYSTEM,PW,DEBUG</para>
<para>sysadmin ALL,!DMZ = (ALL) NOPASSWD: ALL # Can do anything outside the DMZ.</para>
<para>%dba ALL = (DBA) ALL # Group dba can run as database user.</para>
<para># anyone can mount/unmount a cd-rom on the desktop machines</para>
<para>ALL DESKTOP = NOPASSWD: /sbin/mount /cdrom,/sbin/umount /cdrom</para></sect3></sect2><sect2><title>9. ENCRYPT FILES</title><sect3><title>9.1 A single file</title>
<para>Encrypt and decrypt:</para>
<para># openssl des -salt -in file -out file.des</para>
<para># openssl des -d -salt -in file.des -out file</para>
<para>Note that the file can of course be a tar archive.</para></sect3><sect3><title>9.2 tar and encrypt a whole directory</title>
<para># tar -cf - directory | openssl des -salt -out directory.tar.des # Encrypt</para>
<para># openssl des -d -salt -in directory.tar.des | tar -x # Decrypt</para></sect3><sect3><title>9.3 tar zip and encrypt a whole directory</title>
<para># tar -zcf - directory | openssl des -salt -out directory.tar.gz.des # Encrypt</para>
<para># openssl des -d -salt -in directory.tar.gz.des | tar -xz # Decrypt</para>
<para>• Use -k mysecretpassword after des to avoid the interactive password request. However note that this is highly insecure.</para>
<para>• Use des3 instead of des to get even stronger encryption (Triple-DES Cipher). This uses also more CPU.</para></sect3></sect2><sect2><title>10. ENCRYPT PARTITIONS</title>
<para>There are (many) other alternative methods to encrypt disks, I only show here the methods I know and use. Keep in mind that the security is only good as long the OS has not been tempered with. An intruder could easily record the password from the keyboard events.</para>
<para>Furthermore the data is freely accessible when the partition is attached and will not prevent an intruder to have access to it in this state.</para>
<para/><sect3><title>10.1 Linux</title>
<para>Those instructions use the Linux dm-crypt (device-mapper) facility available on the 2.6 kernel.</para>
<para>In this example, lets encrypt the partition /dev/sdc1, it could be however any other partition or disk, or USB or a file based partition created with losetup. In this case we would use /dev/loop0. See file image partition. The device mapper uses labels to identify a partition. We use sdc1 in this example, but it could be any string.</para>
<para>dm-crypt with LUKS</para>
<para>LUKS with dm-crypt has better encryption and makes it possible to have multiple passphrase for the same partition or to change the password easily. To test if LUKS is available, simply type #</para>
<para>cryptsetup --help, if nothing about LUKS shows up, use the instructions below Without LUKS.</para>
<para>First create a partition if necessary: fdisk /dev/sdc.</para>
<para>Create encrypted partition</para>
<para># dd if=/dev/urandom of=/dev/sdc1 # Optional. For paranoids only (takes days)</para>
<para># cryptsetup -y luksFormat /dev/sdc1 # This destroys any data on sdc1</para>
<para># cryptsetup luksOpen /dev/sdc1 sdc1</para>
<para># mkfs.ext3 /dev/mapper/sdc1 # create ext3 file system</para>
<para># mount -t ext3 /dev/mapper/sdc1 /mnt</para>
<para># umount /mnt</para>
<para># cryptsetup luksClose sdc1 # Detach the encrypted partition</para>
<para>Attach</para>
<para># cryptsetup luksOpen /dev/sdc1 sdc1</para>
<para># mount -t ext3 /dev/mapper/sdc1 /mnt</para>
<para>Detach</para>
<para># umount /mnt</para>
<para># cryptsetup luksClose sdc1</para>
<para>dm-crypt without LUKS</para>
<para># cryptsetup -y create sdc1 /dev/sdc1 # or any other partition like /dev/loop0</para>
<para># dmsetup ls # check it, will display: sdc1 (254, 0)</para>
<para># mkfs.ext3 /dev/mapper/sdc1 # This is done only the first time!</para>
<para># mount -t ext3 /dev/mapper/sdc1 /mnt</para>
<para># umount /mnt/</para>
<para># cryptsetup remove sdc1 # Detach the encrypted partition</para>
<para>Do exactly the same (without the mkfs part!) to re-attach the partition. If the password is not correct, the mount command will fail. In this case simply remove the map sdc1 (cryptsetup remove sdc1) and create it again.</para></sect3><sect3><title>10.2 FreeBSD</title>
<para>The two popular FreeBSD disk encryption modules are gbde and geli. I now use geli because it is faster and also uses the crypto device for hardware acceleration. See The FreeBSD handbook Chapter 18.68 for all the details. The geli module must be loaded or compiled into the kernel:</para>
<para>options GEOM_ELI</para>
<para>device crypto # or as module:</para>
<para># echo 'geom_eli_load="YES"' &gt;&gt; /boot/loader.conf # or do: kldload geom_eli</para>
<para>8.http://www.freebsd.org/handbook/disks-encrypting.html</para>
<para/>
<para>Use password and key</para>
<para>I use those settings for a typical disk encryption, it uses a passphrase AND a key to encrypt the master key.  That is you need both the password and the generated key /root/ad1.key to attach the partition. The master key is stored inside the partition and is not visible. See below for typical USB or file based image.</para>
<para>Create encrypted partition</para>
<para># dd if=/dev/random of=/root/ad1.key bs=64 count=1 # this key encrypts the mater key</para>
<para># geli init -s 4096 -K /root/ad1.key /dev/ad1 # -s 8192 is also OK for disks</para>
<para># geli attach -k /root/ad1.key /dev/ad1 # DO make a backup of /root/ad1.key</para>
<para># dd if=/dev/random of=/dev/ad1.eli bs=1m # Optional and takes a long time</para>
<para># newfs /dev/ad1.eli # Create file system</para>
<para># mount /dev/ad1.eli /mnt</para>
<para>Attach</para>
<para># geli attach -k /root/ad1.key /dev/ad1</para>
<para># fsck -ny -t ffs /dev/ad1.eli # In doubt check the file system</para>
<para># mount /dev/ad1.eli /mnt</para>
<para>Detach</para>
<para>The detach procedure is done automatically on shutdown.</para>
<para># umount /mnt</para>
<para># geli detach /dev/ad1.eli</para>
<para>/etc/fstab</para>
<para>The encrypted partition can be configured to be mounted with /etc/fstab. The password will be</para>
<para>prompted when booting. The following settings are required for this example:</para>
<para># grep geli /etc/rc.conf</para>
<para>geli_devices="ad1"</para>
<para>geli_ad1_flags="-k /root/ad1.key"</para>
<para># grep geli /etc/fstab</para>
<para>/dev/ad1.eli /home/private ufs rw 0 0</para>
<para>Use password only</para>
<para>It is more convenient to encrypt a USB stick or file based image with a passphrase only and no key. In this case it is not necessary to carry the additional key file around. The procedure is very much the same as above, simply without the key file. Let's encrypt a file based image</para>
<para>/cryptedfile of 1 GB.</para>
<para># dd if=/dev/zero of=/cryptedfile bs=1M count=1000 # 1 GB file</para>
<para># mdconfig -at vnode -f /cryptedfile</para>
<para># geli init /dev/md0 # encrypts with password only</para>
<para># geli attach /dev/md0</para>
<para># newfs -U -m 0 /dev/md0.eli</para>
<para># mount /dev/md0.eli /mnt</para>
<para># umount /dev/md0.eli</para>
<para># geli detach md0.eli</para>
<para>It is now possible to mount this image on an other system with the password only.</para>
<para># mdconfig -at vnode -f /cryptedfile</para>
<para># geli attach /dev/md0</para>
<para># mount /dev/md0.eli /mnt</para>
<para>— Encrypt Partitions —</para>
<para>29</para></sect3></sect2><sect2><title>11. SSL CERTIFICATES</title>
<para>So called SSL/TLS certificates are cryptographic public key certificates and are composed of a public and a private key. The certificates are used to authenticate the endpoints and encrypt the data. They are used for example on a web server (https) or mail server (imaps).</para><sect3><title>11.1 Procedure</title>
<para>• We need a certificate authority to sign our certificate. This step is usually provided by a vendor like Thawte, Verisign, etc., however we can also create our own.</para>
<para>• Create a certificate signing request. This request is like an unsigned certificate (the</para>
<para>public part) and already contains all necessary information. The certificate request is</para>
<para>normally sent to the authority vendor for signing. This step also creates the private key</para>
<para>on the local machine.</para>
<para>• Sign the certificate with the certificate authority.</para>
<para>• If necessary join the certificate and the key in a single file to be used by the application</para>
<para>(web server, mail server etc.).</para></sect3><sect3><title>11.2 Configure OpenSSL</title>
<para>We use /usr/local/certs as directory for this example check or edit /etc/ssl/openssl.cnf</para>
<para>accordingly to your settings so you know where the files will be created. Here are the relevant part of openssl.cnf:</para>
<para>[ CA_default ]</para>
<para>dir = /usr/local/certs/CA # Where everything is kept</para>
<para>certs = $dir/certs # Where the issued certs are kept</para>
<para>crl_dir = $dir/crl # Where the issued crl are kept</para>
<para>database = $dir/index.txt # database index file.</para>
<para>Make sure the directories exist or create them</para>
<para># mkdir -p /usr/local/certs/CA</para>
<para># cd /usr/local/certs/CA</para>
<para># mkdir certs crl newcerts private</para>
<para># echo "01" &gt; serial # Only if serial does not exist</para>
<para># touch index.txt</para></sect3><sect3><title>11.3 Create a certificate authority</title>
<para>If you do not have a certificate authority from a vendor, you'll have to create your own. This</para>
<para>step is not necessary if one intend to use a vendor to sign the request. To make a certificate</para>
<para>authority (CA):</para>
<para># openssl req -new -x509 -days 730 -config /etc/ssl/openssl.cnf \</para>
<para>-keyout CA/private/cakey.pem -out CA/cacert.pem</para></sect3><sect3><title>11.4 Create a certificate signing request</title>
<para>To make a new certificate (for mail server or web server for example), first create a request certificate with its private key. If your application do not support encrypted private key (for example UW-IMAP does not), then disable encryption with -nodes.</para>
<para># openssl req -new -keyout newkey.pem -out newreq.pem \</para>
<para>-config /etc/ssl/openssl.cnf</para>
<para># openssl req -nodes -new -keyout newkey.pem -out newreq.pem \</para>
<para>-config /etc/ssl/openssl.cnf # No encryption for the key</para>
<para>— SSL Certificates —</para>
<para>30</para></sect3><sect3><title>11.5 Sign the certificate</title>
<para>The certificate request has to be signed by the CA to be valid, this step is usually done by the vendor. Note: replace "servername" with the name of your server in the next commands.</para>
<para># cat newreq.pem newkey.pem &gt; new.pem</para>
<para># openssl ca -policy policy_anything -out servernamecert.pem \</para>
<para>-config /etc/ssl/openssl.cnf -infiles new.pem</para>
<para># mv newkey.pem servernamekey.pem</para>
<para>Now servernamekey.pem is the private key and servernamecert.pem is the server certificate.</para></sect3><sect3><title>11.6 Create united certificate</title>
<para>The IMAP server wants to have both private key and server certificate in the same file. And in general, this is also easier to handle, but the file has to be kept securely!. Apache also can deal with it well. Create a file servername.pem containing both the certificate and key. </para>
<para>• Open the private key (servernamekey.pem) with a text editor and copy the private key</para>
<para>into the "servername.pem" file.</para>
<para>• Do the same with the server certificate (servernamecert.pem).</para>
<para>The final servername.pem file should look like this:</para>
<para>-----BEGIN RSA PRIVATE KEY-----</para>
<para>MIICXQIBAAKBgQDutWy+o/XZ/[...]qK5LqQgT3c9dU6fcR+WuSs6aejdEDDqBRQ</para>
<para>-----END RSA PRIVATE KEY-----</para>
<para>-----BEGIN CERTIFICATE-----</para>
<para>MIIERzCCA7CgAwIBAgIBBDANB[...]iG9w0BAQQFADCBxTELMAkGA1UEBhMCREUx</para>
<para>-----END CERTIFICATE-----</para>
<para>What we have now in the directory /usr/local/certs/:</para>
<para>CA/private/cakey.pem (CA server private key)</para>
<para>CA/cacert.pem (CA server public key)</para>
<para>certs/servernamekey.pem (server private key)</para>
<para>certs/servernamecert.pem (server signed certificate)</para>
<para>certs/servername.pem (server certificate with private key)</para>
<para>Keep the private key secure!</para></sect3><sect3><title>11.7 View certificate information</title>
<para>To view the certificate information simply do:</para>
<para># openssl x509 -text -in servernamecert.pem # View the certificate info</para>
<para># openssl req -noout -text -in server.csr # View the request info</para></sect3></sect2><sect2><title>12. CVS</title>
<para/><sect3><title>12.1 Server setup</title>
<para>Initiate the CVS</para>
<para>Decide where the main repository will rest and create a root cvs. For example /usr/local/cvs (as</para>
<para>root):</para>
<para># mkdir -p /usr/local/cvs</para>
<para># setenv CVSROOT /usr/local/cvs # Set CVSROOT to the new location (local)</para>
<para># cvs init # Creates all internal CVS config files</para>
<para># cvs checkout CVSROOT # Checkout the config files to modify them</para>
<para># cd CVSROOT</para>
<para>edit config ( fine as it is)</para>
<para># cvs commit config</para>
<para>cat &gt;&gt; writers # Create a writers file (optionally also readers)</para>
<para>colin</para>
<para>^D # Use [Control][D] to quit the edit</para>
<para># cvs add writers # Add the file writers into the repository</para>
<para># cvs edit checkoutlist</para>
<para># cat &gt;&gt; checkoutlist</para>
<para>writers</para>
<para>^D # Use [Control][D] to quit the edit</para>
<para># cvs commit # Commit all the configuration changes</para>
<para>Add a readers file if you want to differentiate read and write permissions Note: Do not (ever) edit files directly into the main cvs, but rather checkout the file, modify it and check it in. We did this with the file writers to define the write access.</para>
<para>There are three popular ways to access the CVS at this point. The first two don't need any</para>
<para>further configuration. See the examples on CVSROOT below for how to use them:</para>
<para>• Direct local access to the file system. The user(s) need sufficient file permission to</para>
<para>access the CS directly and there is no further authentication in addition to the OS login.</para>
<para>However this is only useful if the repository is local.</para>
<para>• Remote access with ssh with the ext protocol. Any use with an ssh shell account and</para>
<para>read/write permissions on the CVS server can access the CVS directly with ext over ssh</para>
<para>without any additional tunnel. There is no server process running on the CVS for this to</para>
<para>work. The ssh login does the authentication.</para>
<para>• Remote access with pserver. This is the preferred use for larger user base as the users</para>
<para>are authenticated by the CVS pserver with a dedicated password database, there is</para>
<para>therefore no need for local users accounts. This setup is explained below.</para>
<para>Network setup with inetd</para>
<para>The CVS can be run locally only if a network access is not needed. For a remote access, the</para>
<para>daemon inetd can start the pserver with the following line in /etc/inetd.conf (/etc/xinetd.d/cvs</para>
<para>on SuSE):</para>
<para>cvspserver stream tcp nowait cvs /usr/bin/cvs cvs \</para>
<para>--allow-root=/usr/local/cvs pserver</para>
<para>It is a good idea to block the cvs port from the Internet with the firewall and use an ssh tunnel</para>
<para>to access the repository remotely.</para>
<para>Separate authentication</para>
<para>It is possible to have cvs users which are not part of the OS (no local users). This is actually probably wanted too from the security point of view. Simply add a file named passwd (in the CVSROOT directory) containing the users login and password in the crypt format. This is can be done with the apache htpasswd tool.</para>
<para>Note: This passwd file is the only file which has to be edited directly in the CVSROOT directory.</para>
<para>Also it won't be checked out. More info with htpasswd --help</para>
<para># htpasswd -cb passwd user1 password1 # -c creates the file</para>
<para># htpasswd -b passwd user2 password2</para>
<para>Now add :cvs at the end of each line to tell the cvs server to change the user to cvs (or</para>
<para>whatever your cvs server is running under). It looks like this:</para>
<para># cat passwd</para>
<para>user1:xsFjhU22u8Fuo:cvs</para>
<para/></sect3><sect3><title>12.2 Test it</title>
<para>Test the login as normal user (for example here me)</para>
<para># cvs -d :pserver:colin@192.168.50.254:/usr/local/cvs login</para>
<para>Logging in to :pserver:colin@192.168.50.254:2401/usr/local/cvs</para>
<para>CVS password:</para>
<para>CVSROOT variable</para>
<para>This is an environment variable used to specify the location of the repository we're doing operations on. For local use, it can be just set to the directory of the repository. For use over the network, the transport protocol must be specified. Set the CVSROOT variable with setenv</para>
<para>CVSROOT string on a csh, tcsh shell, or with export CVSROOT=string on a sh, bash shell.</para>
<para># setenv CVSROOT :pserver:&lt;username&gt;@&lt;host&gt;:/cvsdirectory</para>
<para>For example:</para>
<para># setenv CVSROOT /usr/local/cvs # Used locally only</para>
<para># setenv CVSROOT :local:/usr/local/cvs # Same as above</para>
<para># setenv CVSROOT :ext:user@cvsserver:/usr/local/cvs # Direct access with SSH</para>
<para># setenv CVS_RSH ssh # for the ext access</para>
<para># setenv CVSROOT :pserver:user@cvsserver.254:/usr/local/cvs # network with pserver</para>
<para>When the login succeeded one can import a new project into the repository: cd into your</para>
<para>project root directory</para>
<para>cvs import &lt;module name&gt; &lt;vendor tag&gt; &lt;initial tag&gt;</para>
<para>cvs -d :pserver:colin@192.168.50.254:/usr/local/cvs import MyProject MyCompany START</para>
<para>Where MyProject is the name of the new project in the repository (used later to checkout). Cvs</para>
<para>will import the current directory content into the new project.</para>
<para>To checkout:</para>
<para># cvs -d :pserver:colin@192.168.50.254:/usr/local/cvs checkout MyProject</para>
<para>or</para>
<para># setenv CVSROOT :pserver:colin@192.168.50.254:/usr/local/cvs</para>
<para># cvs checkout MyProject</para></sect3><sect3><title>12.3 SSH tunneling for CVS</title>
<para>We need 2 shells for this. On the first shell we connect to the cvs server with ssh and</para>
<para>port-forward the cvs connection. On the second shell we use the cvs normally as if it where</para>
<para>running locally.</para>
<para>on shell 1:</para>
<para># ssh -L2401:localhost:2401 colin@cvs_server # Connect directly to the CVS server. Or:</para>
<para># ssh -L2401:cvs_server:2401 colin@gateway # Use a gateway to reach the CVS</para>
<para>on shell 2:</para>
<para># setenv CVSROOT :pserver:colin@localhost:/usr/local/cvs</para>
<para># cvs login</para>
<para>Logging in to :pserver:colin@localhost:2401/usr/local/cvs</para>
<para>CVS password:</para>
<para># cvs checkout MyProject/src</para>
<para/></sect3><sect3><title>12.4 CVS commands and usage</title>
<para>Import</para>
<para>The import command is used to add a whole directory, it must be run from within the directory to be imported. Say the directory /devel/ contains all files and subdirectories to be imported.</para>
<para>The directory name on the CVS (the module) will be called "myapp".</para>
<para># cvs import [options] directory-name vendor-tag release-tag</para>
<para># cd /devel # Must be inside the project to import it</para>
<para># cvs import myapp Company R1_0 # Release tag can be anything in one word</para>
<para>After a while a new directory "/devel/tools/" was added and it has to be imported too.</para>
<para># cd /devel/tools</para>
<para># cvs import myapp/tools Company R1_0</para>
<para>Checkout update add commit</para>
<para># cvs co myapp/tools # Will only checkout the directory tools</para>
<para># cvs co -r R1_1 myapp # Checkout myapp at release R1_1 (is sticky)</para>
<para># cvs -q -d update -P # A typical CVS update</para>
<para># cvs update -A # Reset any sticky tag (or date, option)</para>
<para># cvs add newfile # Add a new file</para>
<para># cvs add -kb newfile # Add a new binary file</para>
<para># cvs commit file1 file2 # Commit the two files only</para>
<para># cvs commit -m "message" # Commit all changes done with a message</para>
<para>Create a patch</para>
<para>It is best to create and apply a patch from the working development directory related to the project, or from within the source directory.</para>
<para># cd /devel/project</para>
<para># diff -Naur olddir newdir &gt; patchfile # Create a patch from a directory or a file</para>
<para># diff -Naur oldfile newfile &gt; patchfile</para>
<para>Apply a patch</para>
<para>Sometimes it is necessary to strip a directory level from the patch, depending how it was created. In case of difficulties, simply look at the first lines of the patch and try -p0, -p1 or -p2.</para>
<para># cd /devel/project</para>
<para># patch --dry-run -p0 &lt; patchfile # Test the path without applying it</para>
<para># patch -p0 &lt; patchfile</para>
<para># patch -p1 &lt; patchfile # strip off the 1st level from the path</para></sect3></sect2><sect2><title>13. SVN</title>
<para>Subversion (SVN)9 is a version control system designed to be the successor of CVS (Concurrent</para>
<para>Versions System). The concept is similar to CVS, but many shortcomings where improved. See also the SVN book10.</para><sect3><title>13.1 Server setup</title>
<para>The initiation of the repository is fairly simple (here for example /home/svn/ must exist):</para>
<para># svnadmin create --fs-type fsfs /home/svn/project1</para>
<para>9.http://subversion.tigris.org/</para>
<para>10.http://svnbook.red-bean.com/en/1.4/</para>
<para/>
<para>Now the access to the repository is made possible with:</para>
<para>• file:// Direct file system access with the svn client with. This requires local</para>
<para>permissions on the file system.</para>
<para>• svn:// or svn+ssh:// Remote access with the svnserve server (also over SSH). This</para>
<para>requires local permissions on the file system.</para>
<para>• http:// Remote access with webdav using apache. No local users are necessary for this</para>
<para>method.</para>
<para>Using the local file system, it is now possible to import and then check out an existing project.</para>
<para>Unlike with CVS it is not necessary to cd into the project directory, simply give the full path:</para>
<para># svn import /project1/ file:///home/svn/project1/trunk -m 'Initial import'</para>
<para># svn checkout file:///home/svn/project1</para>
<para>The new directory "trunk" is only a convention, this is not required.</para>
<para>Remote access with ssh</para>
<para>No special setup is required to access the repository via ssh, simply replace file:// with</para>
<para>svn+ssh/hostname. For example:</para>
<para># svn checkout svn+ssh://hostname/home/svn/project1</para>
<para>As with the local file access, every user needs an ssh access to the server (with a local account) and also read/write access. This method might be suitable for a small group. All users could belong to a subversion group which owns the repository, for example:</para>
<para># groupadd subversion</para>
<para># groupmod -A user1 subversion</para>
<para># chown -R root:subversion /home/svn</para>
<para># chmod -R 770 /home/svn</para>
<para>Remote access with http (apache)</para>
<para>Remote access over http (https) is the only good solution for a larger user group. This method</para>
<para>uses the apache authentication, not the local accounts. This is a typical but small apache</para>
<para>configuration:</para>
<para>LoadModule dav_module modules/mod_dav.so</para>
<para>LoadModule dav_svn_module modules/mod_dav_svn.so</para>
<para>LoadModule authz_svn_module modules/mod_authz_svn.so # Only for access control</para>
<para>&lt;Location /svn&gt;</para>
<para>DAV svn</para>
<para># any "/svn/foo" URL will map to a repository /home/svn/foo</para>
<para>SVNParentPath /home/svn</para>
<para>AuthType Basic</para>
<para>AuthName "Subversion repository"</para>
<para>AuthzSVNAccessFile /etc/apache2/svn.acl</para>
<para>AuthUserFile /etc/apache2/svn-passwd</para>
<para>Require valid-user</para>
<para>&lt;/Location&gt;</para>
<para>The apache server needs full access to the repository:</para>
<para># chown -R www:www /home/svn</para>
<para>Create a user with htpasswd2:</para>
<para># htpasswd -c /etc/svn-passwd user1 # -c creates the file</para>
<para>Access control svn.acl example</para>
<para># Default it read access. "* =" would be default no access</para>
<para>[/]</para>
<para>* = r</para>
<para>project1-developers = joe, jack, jane</para>
<para># Give write access to the developers</para>
<para>[project1:]</para>
<para>@project1-developers = rw</para></sect3><sect3><title>13.2 SVN commands and usage</title>
<para>See also the Subversion Quick Reference Card11. Tortoise SVN12 is a nice Windows interface.</para>
<para>Import</para>
<para>A new project, that is a directory with some files, is imported into the repository with the import command. Import is also used to add a directory with its content to an existing project.</para>
<para># svn help import # Get help for any command</para>
<para># Add a new directory (with content) into the src dir on project1</para>
<para># svn import /project1/newdir http://host.url/svn/project1/trunk/src -m 'add newdir'</para>
<para>Typical SVN commands</para>
<para># svn co http://host.url/svn/project1/trunk # Checkout the most recent version</para>
<para># Tags and branches are created by copying</para>
<para># svn mkdir http://host.url/svn/project1/tags/ # Create the tags directory</para>
<para># svn copy -m "Tag rc1 rel." http://host.url/svn/project1/trunk \</para>
<para>http://host.url/svn/project1/tags/1.0rc1</para>
<para># svn status [--verbose] # Check files status into working dir</para>
<para># svn add src/file.h src/file.cpp # Add two files</para>
<para># svn commit -m 'Added new class file' # Commit the changes with a message</para>
<para># svn ls http://host.url/svn/project1/tags/ # List all tags</para>
<para># svn move foo.c bar.c # Move (rename) files</para>
<para># svn delete some_old_file # Delete files</para></sect3></sect2><sect2><title>14. USEFUL COMMANDS</title>
<para/><sect3><title>14.1 less</title>
<para>The less command displays a text document on the console. It is present on most installation.</para>
<para># less unixtoolbox.xhtml</para>
<para>Some important commands are (^N stands for [control]-[N]):</para>
<para>h H good help on display</para>
<para>f ^F ^V SPACE Forward one window (or N lines).</para>
<para>b ^B ESC-v Backward one window (or N lines).</para>
<para>F Forward forever; like "tail -f".</para>
<para>/pattern Search forward for (N-th) matching line.</para>
<para>?pattern Search backward for (N-th) matching line.</para>
<para>n Repeat previous search (for N-th occurrence).</para>
<para>N Repeat previous search in reverse direction.</para>
<para>q quit</para>
<para>11.http://www.cs.put.poznan.pl/csobaniec/Papers/svn-refcard.pdf</para>
<para>12.http://tortoisesvn.tigris.org</para>
<para/></sect3><sect3><title>14.2 vi</title>
<para>Vi is present on ANY Linux/Unix installation and it is therefore useful to know some basic commands. There are two modes: command mode and insertion mode. The commands mode is accessed with [ESC], the insertion mode with i.</para>
<para>Quit</para>
<para>:w newfilename save the file to newfilename</para>
<para>:wq or :x save and quit</para>
<para>:q! quit without saving</para>
<para>Search and move</para>
<para>/string Search forward for string</para>
<para>?string Search back for string</para>
<para>n Search for next instance of string</para>
<para>N Search for previous instance of string</para>
<para>{ Move a paragraph back</para>
<para>} Move a paragraph forward</para>
<para>1G Move to the first line of the file</para>
<para>nG Move to the n th line of the file</para>
<para>G Move to the last line of the file</para>
<para>:%s/OLD/NEW/g Search and replace every occurrence</para>
<para>Delete text</para>
<para>dd delete current line</para>
<para>D Delete to the end of the line</para>
<para>dw Delete word</para>
<para>x Delete character</para>
<para>u Undo last</para>
<para>U Undo all changes to current line</para></sect3><sect3><title>14.3 mail</title>
<para>The mail command is a basic application to read and send email, it is usually installed. To send</para>
<para>an email simply type "mail user@domain". The first line is the subject, then the mail content.</para>
<para>Terminate and send the email with a single dot (.) in a new line. Example:</para>
<para># mail c@cb.vu</para>
<para>Subject: Your text is full of typos</para>
<para>"For a moment, nothing happened. Then, after a second or so,</para>
<para>nothing continued to happen."</para>
<para>.</para>
<para>EOT</para>
<para>#</para>
<para>This is also working with a pipe:</para>
<para># echo "This is the mail body" | mail c@cb.vu</para>
<para>This is also a simple way to test the mail server.</para></sect3><sect3><title>14.4 tar</title>
<para>The command tar (tape archive) creates and extracts archives of file and directories. The archive .tar is uncompressed, a compressed archive has the extension .tgz or .tar.gz (zip) or .tbz (bzip2). Do not use absolute path when creating an archive, you probably want to unpack it</para>
<para/>
<para>Create</para>
<para># cd /</para>
<para># tar -cf home.tar home/ # archive the whole /home directory (c for create)</para>
<para># tar -czf home.tgz home/ # same with zip compression</para>
<para># tar -cjf home.tbz home/ # same with bzip2 compression</para>
<para>Only include one (or two) directories from a tree, but keep the relative structure. For example</para>
<para>archive /usr/local/etc and /usr/local/www and the first directory in the archive should be local/.</para>
<para># tar -C /usr -czf local.tgz local/etc local/www</para>
<para># tar -C /usr -xzf local.tgz # To untar the local dir into /usr</para>
<para># cd /usr; tar -xzf local.tgz # Is the same as above</para>
<para>Extract</para>
<para># tar -tzf home.tgz # look inside the archive without extracting (list)</para>
<para># tar -xf home.tar # extract the archive here (x for extract)</para>
<para># tar -xzf home.tgz # same with zip compression</para>
<para># tar -xjf home.tgz # same with bzip2 compression</para>
<para># tar -xjf home.tgz home/colin/file.txt # Restore a single file</para>
<para>More advanced</para>
<para># tar c dir/ | gzip | ssh user@remote 'dd of=dir.tgz' # arch dir/ and store remotely.</para>
<para># tar cvf - `find . -print` &gt; backup.tar # arch the current directory.</para>
<para># tar -cf - -C /etc . | tar xpf - -C /backup/etc # Copy directories</para>
<para># tar -cf - -C /etc . | ssh user@remote tar xpf - -C /backup/etc # Remote copy.</para>
<para># tar -czf home.tgz --exclude '*.o' --exclude 'tmp/' home/</para></sect3><sect3><title>14.5 dd</title>
<para>The program dd (disk dump) is used to copy partitions and disks and for other copy tricks.</para>
<para>Typical usage:</para>
<para># dd if=&lt;source&gt; of=&lt;target&gt; bs=&lt;byte size&gt; conv=&lt;conversion&gt;</para>
<para>Important conv options:</para>
<para>notrunc do not truncate the output file, all zeros will be written as zeros.</para>
<para>noerror continue after read errors (e.g. bad blocks)</para>
<para>sync pad every input block with Nulls to ibs-size</para>
<para>The default byte size is 512 (one block). The MBR, where the partiton table is located, is on the first block, the first 63 blocks of a disk are empty. Larger byte sizes are faster to copy but require also more memory.</para>
<para>Backup and restore</para>
<para># dd if=/dev/hda of=/dev/hdc bs=16065b # Copy disk to disk (same size)</para>
<para># dd if=/dev/sda7 of /home/root.img bs=4096 conv=notrunc,noerror # Backup /</para>
<para># dd if /home/root.img of=/dev/sda7 bs=4096 conv=notrunc,noerror # Restore /</para>
<para># dd bs=1M if=/dev/ad4s3e | gzip -c &gt; ad4s3e.gz # Zip the backup</para>
<para># gunzip -dc ad4s3e.gz | dd of=/dev/ad0s3e bs=1M # Restore the zip</para>
<para># dd bs=1M if=/dev/ad4s3e | gzip | ssh eedcoba@fry 'dd of=ad4s3e.gz' # also remote</para>
<para># gunzip -dc ad4s3e.gz | ssh eedcoba@host 'dd of=/dev/ad0s3e bs=1M'</para>
<para># dd if=/dev/ad0 of=/dev/ad2 skip=1 seek=1 bs=4k conv=noerror # Skip MBR</para>
<para># This is necessary if the destination (ad2) is smaller.</para>
<para>Recover</para>
<para>The command dd will read every single block of the partiton, even the blocks. In case of problems it is better to use the option conv=sync,noerror so dd will skip the bad block and write zeros at the destination. Accordingly it is important to set the block size equal or smaller than the disk block size. A 1k size seems safe, set it with bs=1k. If a disk has bad sectors and the data should be recovered from a partiton, create an image file with dd, mount the image and copy the content to a new disk. With the option noerror, dd will skip the bad sectors and write zeros instead, thus only the data contained in the bad sectors will be lost.</para>
<para># dd if=/dev/hda of=/dev/null bs=1m # Check for bad blocks</para>
<para># dd bs=1k if=/dev/hda1 conv=sync,noerror,notrunc | gzip | ssh \ # Send to remote</para>
<para>root@fry 'dd of=hda1.gz bs=1k'</para>
<para># dd bs=1k if=/dev/hda1 conv=sync,noerror,notrunc of=hda1.img # Store into an image</para>
<para># mount -o loop /hda1.img /mnt # Mount the image (page 12)</para>
<para># rsync -ax /mnt/ /newdisk/ # Copy on a new disk</para>
<para># dd if=/dev/hda of=/dev/hda # Refresh the magnetic state</para>
<para># The above is useful to refresh a disk. It is perfectly safe, but must be unmounted.</para>
<para>Delete</para>
<para># dd if=/dev/zero of=/dev/hdc count=1 # Delete MBR and partiton table</para>
<para># dd if=/dev/zero of=/dev/hdc # Delete full disk</para>
<para># dd if=/dev/urandom of=/dev/hdc # Delete full disk better</para>
<para># kill -USR1 PID # View dd progress (Linux only!)</para></sect3><sect3><title>14.6 screen</title>
<para>Screen has two main functionalities:</para>
<para>• Run multiple terminal session within a single terminal.</para>
<para>• A started program is decoupled from the real terminal and can thus run in the</para>
<para>background. The real terminal can be closed and reattached later.</para>
<para>Short start example</para>
<para>start screen with:</para>
<para># screen</para>
<para>Within the screen session we can start a long lasting program (like top). Detach the terminal</para>
<para>and reattach the same terminal from an other machine (over ssh for example).</para>
<para># top</para>
<para>Now detach with Ctrl-a Ctrl-d. Reattach the terminal with</para>
<para># screen -r</para>
<para>or better:</para>
<para># screen -R -D</para>
<para>Attach here and now. In detail this means: If a session is running, then reattach. If necessary detach and logout remotely first. If it was not running create it and notify the user.</para>
<para>Screen commands (within screen)</para>
<para>All screen commands start with Ctrl-a.</para>
<para>• Ctrl-a ? help and summary of functions</para>
<para>• Ctrl-a c create an new window (terminal)</para>
<para>• Ctrl-a Ctrl-n and Ctrl-a Ctrl-p to switch to the next or previous window in the list, by</para>
<para>number.</para>
<para>• Ctrl-a Ctrl-N where N is a number from 0 to 9, to switch to the corresponding window.</para>
<para>• Ctrl-a " to get a navigable list of running windows</para>
<para>• Ctrl-a a to clear a missed Ctrl-a</para>
<para>• Ctrl-a Ctrl-d to disconnect and leave the session running in the background</para>
<para>• Ctrl-a x lock the screen terminal with a password</para>
<para>— Useful Commands —</para>
<para>39</para>
<para>The screen session is terminated when the program within the running terminal is closed and you logout from the terminal.</para></sect3><sect3><title>14.7 Find</title>
<para>Some important options:</para>
<para>-x (on BSD) -xdev (on Linux) Stay on the same file system (dev in fstab).</para>
<para>-exec cmd {} \; Execute the command and replace {} with the full path</para>
<para>-iname Like -name but is case insensitive</para>
<para>-ls Display information about the file (like ls -la)</para>
<para>-size n n is +-n (k M G T P)</para>
<para>-cmin n File's status was last changed n minutes ago.</para>
<para># find . -type f ! -perm -444 # Find files not readable by all</para>
<para># find . -type d ! -perm -111 # Find dirs not accessible by all</para>
<para># find /home/user/ -cmin 10 -print # Files created or modified in the last 10 min.</para>
<para># find . -name '*.[ch]' | xargs grep -E 'expr' # Search 'expr' in this dir and below.</para>
<para># find / -name "*.core" | xargs rm # Find core dumps and delete them</para>
<para># find / -name "*.core" -print -exec rm {} \; # Other syntax</para>
<para># find . \( -name "*.png" -o -name "*.jpg" \) -print</para>
<para># iname is not case sensitive</para>
<para># find . \( -iname "*.png" -o -iname "*.jpg" \) -print -exec tar -rf images.tar {} \;</para>
<para># find . -type f -name "*.txt" ! -name README.txt -print # Exclude README.txt files</para>
<para># find /var/ -size +1M -exec ls -lh {} \;</para>
<para># find /var/ -size +1M -ls # This is simpler</para>
<para># find . -size +10M -size -50M -print</para>
<para># find /usr/ports/ -name work -type d -print -exec rm -rf {} \; # Clean the ports</para>
<para>Find files with SUID; those file have to be kept secure</para>
<para># find / -type f -user root -perm -4000 -exec ls -l {} \;</para></sect3><sect3><title>14.8 Miscellaneous</title>
<para># which command # Show full path name of command</para>
<para># time command # See how long a command takes to execute</para>
<para># time cat # Use time as stopwatch. Ctrl-c to stop</para>
<para># set | grep $USER # List the current environment</para>
<para># cal -3 # Display a three month calendar</para>
<para># date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</para>
<para># date 10022155 # Set date and time</para>
<para># whatis grep # Display a short info on the command or word</para>
<para># whereis java # Search path and standard directories for word</para>
<para># setenv varname value # Set env. variable varname to value (csh/tcsh)</para>
<para># export varname="value" # set env. variable varname to value (sh/ksh/bash)</para>
<para># pwd # Print working directory</para>
<para># mkdir -p /path/to/dir # no error if existing, make parent dirs as needed</para>
<para># rmdir /path/to/dir # Remove directory</para>
<para># rm -rf /path/to/dir # Remove directory and its content (force)</para>
<para># cp -la /dir1 /dir2 # Archive and hard link files instead of copy</para>
<para># cp -lpR /dir1 /dir2 # Same for FreeBSD</para>
<para># mv /dir1 /dir2 # Rename a directory</para></sect3></sect2><sect2><title>15. INSTALL SOFTWARE</title><sect3><title>15.1 List installed packages</title>
<para># rpm -qa # List installed packages (RH, SuSE, RPM based)</para>
<para># dpkg -l # Debian, Ubuntu</para>
<para># pkg_info -W smbd # FreeBSD show which package smbd belongs to</para>
<para># pkginfo # Solaris</para></sect3><sect3><title>15.2 Add/remove software</title>
<para>Front ends: yast2/yast for SuSE, redhat-config-packages for Red Hat.</para>
<para># rpm -i pkgname.rpm # install the package (RH, SuSE, RPM based)</para>
<para># rpm -e pkgname # Remove package</para>
<para>Debian</para>
<para># apt-get update # First update the package lists</para>
<para># apt-get install emacs # Install the package emacs</para>
<para># dpkg --remove emacs # Remove the package emacs</para>
<para>FreeBSD</para>
<para># pkg_add -r rsync # Fetch and install rsync.</para>
<para># pkg_delete /var/db/pkg/rsync-xx # Delete the rsync package</para>
<para>Set where the packages are fetched from with the PACKAGESITE variable. For example:</para>
<para># export PACKAGESITE=ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages/Latest/</para>
<para># or ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6-stable/Latest/</para>
<para>FreeBSD ports. The port tree /usr/ports/ is a collection of software ready to compile and install. The ports are updated with the program portsnap.</para>
<para># portsnap fetch extract # Create the tree when running the first time</para>
<para># portsnap fetch update # Update the port tree</para>
<para># cd /usr/ports/net/rsync/ # Select the package to install</para>
<para># make install distclean # Install and cleanup (also see man ports)</para>
<para># make package # Make a binary package for the port</para></sect3><sect3><title>15.3 Library path</title>
<para>Due to complex dependencies and runtime linking, programs are difficult to copy to an other system or distribution. However for small programs with little dependencies, the missing libraries can be copied over. The runtime libraries (and the missing one) are checked with ldd and managed with ldconfig.</para>
<para># ldd /usr/bin/rsync # List all needed runtime libraries</para>
<para># ldconfig -n /path/to/libs/ # Add a path to the shared libraries directories</para>
<para># ldconfig -m /path/to/libs/ # FreeBSD</para>
<para># LD_LIBRARY_PATH # The variable set the link library path</para></sect3></sect2><sect2><title>16. CONVERT MEDIA</title>
<para>Sometimes one simply need to convert a video, audio file or document to another format.</para><sect3><title>16.1 Text encoding</title>
<para>Text encoding can get totally wrong, specially when the language requires special characters like адз. The command iconv can convert from one encoding to an other.</para>
<para/>
<para># iconv -f &lt;from_encoding&gt; -t &lt;to_encoding&gt; &lt;input_file&gt;</para>
<para># iconv -f ISO8859-1 -t UTF-8 -o file.input &gt; file_utf8</para>
<para># iconv -l # List known coded character sets</para>
<para>Without the -f option, iconv will use the local char-set, which is usually fine if the document displays well.</para></sect3><sect3><title>16.2 Unix - DOS newlines</title>
<para>Convert DOS (CR/LF) to Unix (LF) newlines within a Unix shell. See also dos2unix and unix2dos</para>
<para>if you have them.</para>
<para># sed 's/.$//' dosfile.txt &gt; unixfile.txt</para>
<para>Convert Unix to DOS newlines within a Windows environment. Use sed from mingw or cygwin.</para>
<para># sed -n p unixfile.txt &gt; dosfile.txt</para></sect3><sect3><title>16.3 PDF to Jpeg and concatenate PDF files</title>
<para>Convert a PDF document with gs (GhostScript) to jpeg (or png) images for each page. Also</para>
<para>much shorter with convert (from ImageMagick or GraphicsMagick).</para>
<para># gs -dBATCH -dNOPAUSE -sDEVICE=jpeg -r150 -dTextAlphaBits=4 -dGraphicsAlphaBits=4 \</para>
<para>-dMaxStripSize=8192 -sOutputFile=unixtoolbox_%d.jpg unixtoolbox.pdf</para>
<para># convert unixtoolbox.pdf unixtoolbox-%03d.png</para>
<para># convert *.jpeg images.pdf # Create a simple PDF with all pictures</para>
<para>Ghostscript can also concatenate multiple pdf files into a single one.</para>
<para># gs -q -sPAPERSIZE=a4 -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=all.pdf \</para>
<para>file1.pdf file2.pdf ... # On Windows use '#' instead of '='</para></sect3><sect3><title>16.4 Convert video</title>
<para>Compress the Canon digicam video with an mpeg4 codec and repair the crappy sound.</para>
<para># mencoder -o videoout.avi -oac mp3lame -ovc lavc -srate 11025 \</para>
<para>-channels 1 -af-adv force=1 -lameopts preset=medium -lavcopts \</para>
<para>vcodec=msmpeg4v2:vbitrate=600 -mc 0 vidoein.AVI</para></sect3><sect3><title>16.5 Copy an audio cd</title>
<para>The program cdparanoia13 can save the audio tracks (FreeBSD port in  audio/cdparanoia/),</para>
<para>oggenc can encode in Ogg Vorbis format, lame converts to mp3.</para>
<para># cdparanoia -B # Copy the tracks to wav files in current dir</para>
<para># lame -b 256 in.wav out.mp3 # Encode in mp3 256 kb/s</para>
<para># for i in *.wav; do lame -b 256 $i `basename $i .wav`.mp3; done</para>
<para># oggenc in.wav -b 256 out.ogg # Encode in Ogg Vorbis 256 kb/s</para>
<para>13.http://xiph.org/paranoia/</para>
<para/></sect3></sect2><sect2><title>17. PRINTING</title><sect3><title>17.1 Print with lpr</title>
<para># lpr unixtoolbox.ps # Print on default printer</para>
<para># export PRINTER=hp4600 # Change the default printer</para>
<para># lpr -Php4500 #2 unixtoolbox.ps # Use printer hp4500 and print 2 copies</para>
<para># lpr -o Duplex=DuplexNoTumble ... # Print duplex along the long side</para>
<para># lpr -o PageSize=A4,Duplex=DuplexNoTumble ...</para>
<para># lpq # Check the queue on default printer</para>
<para># lpq -l -Php4500 # Queue on printer hp4500 with verbose</para>
<para># lprm - # Remove all users jobs on default printer</para>
<para># lprm -Php4500 3186 # Remove job 3186. Find job nbr with lpq</para>
<para># lpc status # List all available printers</para>
<para># lpc status hp4500 # Check if printer is online and queue length</para></sect3></sect2><sect2><title>18. DATABASES</title><sect3><title>18.1 PostgreSQL</title>
<para>Change root or a username password</para>
<para># psql -d template1 -U pgsql</para>
<para>&gt; alter user pgsql with password 'pgsql_password'; # Use username instead of "pgsql"</para>
<para>Create user and database</para>
<para>The commands createuser, dropuser, createdb and dropdb are convenient shortcuts</para>
<para>equivalent to the SQL commands. The new user is bob with database bobdb ; use as root with</para>
<para>pgsql the database super user:</para>
<para># createuser -U pgsql -P bob # -P will ask for password</para>
<para># createdb -U pgsql -O bob bobdb # new bobdb is owned by bob</para>
<para># dropdb bobdb # Delete database bobdb</para>
<para># dropuser bob # Delete user bob</para>
<para>The general database authentication mechanism is configured in pg_hba.conf</para>
<para>Grant remote access</para>
<para>The file $PGSQL_DATA_D/postgresql.conf specifies the address to bind to. Typically</para>
<para>listen_addresses = '*' for Postgres 8.x.</para>
<para>The file $PGSQL_DATA_D/pg_hba.conf defines the access control. Examples:</para>
<para># TYPE DATABASE USER IP-ADDRESS IP-MASK METHOD</para>
<para>host bobdb bob 212.117.81.42 255.255.255.255 password</para>
<para>host all all 0.0.0.0/0 password</para>
<para>Backup and restore</para>
<para>The backups and restore are done with the user pgsql or postgres. Backup and restore a single</para>
<para>database:</para>
<para># pg_dump --clean dbname &gt; dbname_sql.dump</para>
<para># psql dbname &lt; dbname_sql.dump</para>
<para>Backup and restore all databases (including users):</para>
<para># pg_dumpall --clean &gt; full.dump</para>
<para># psql -f full.dump postgres</para>
<para>In this case the restore is started with the database postgres which is better when reloading an empty cluster.</para></sect3><sect3><title>18.2 MySQL</title>
<para>Change mysql root or username password</para>
<para>Method 1</para>
<para># /etc/init.d/mysql stop</para>
<para>or</para>
<para># killall mysqld</para>
<para># mysqld --skip-grant-tables</para>
<para># mysqladmin -u root password 'newpasswd'</para>
<para># /etc/init.d/mysql start</para>
<para>Method 2</para>
<para># mysql -u root mysql</para>
<para>mysql&gt; UPDATE USER SET PASSWORD=PASSWORD("newpassword") where user='root';</para>
<para>mysql&gt; FLUSH PRIVILEGES; # Use username instead of "root"</para>
<para>mysql&gt; quit</para>
<para>Create user and database</para>
<para># mysql -u root mysql</para>
<para>mysql&gt; CREATE DATABASE bobdb;</para>
<para>mysql&gt; GRANT ALL ON *.* TO 'bob'@'%' IDENTIFIED BY 'pwd'; # Use localhost instead of %</para>
<para># to restrict the network access</para>
<para>mysql&gt; DROP DATABASE bobdb; # Delete database</para>
<para>mysql&gt; DROP USER bob; # Delete user</para>
<para>mysql&gt; DELETE FROM mysql.user WHERE user='bob and host='hostname'; # Alt. command</para>
<para>mysql&gt; FLUSH PRIVILEGES;</para>
<para>Grant remote access</para>
<para>Remote access is typically permitted for a database, and not all databases. The file /etc/my.cnf</para>
<para>contains the IP address to bind to. Typically comment the line bind-address = out.</para>
<para># mysql -u root mysql</para>
<para>mysql&gt; GRANT ALL ON bobdb.* TO bob@'xxx.xxx.xxx.xxx' IDENTIFIED BY 'PASSWORD';</para>
<para>mysql&gt; REVOKE GRANT OPTION ON foo.* FROM bar@'xxx.xxx.xxx.xxx';</para>
<para>mysql&gt; FLUSH PRIVILEGES; # Use 'hostname' or also '%' for full access</para>
<para>Backup and restore</para>
<para>Backup and restore a single database:</para>
<para># mysqldump -u root -psecret --add-drop-database dbname &gt; dbname_sql.dump</para>
<para># mysql -u root -psecret -D dbname &lt; dbname_sql.dump</para>
<para>Backup and restore all databases:</para>
<para># mysqldump -u root -psecret --add-drop-database --all-databases &gt; full.dump</para>
<para># mysql -u root -psecret &lt; full.dump</para>
<para>Here is "secret" the mysql root password, there is no space after -p. When the -p option is used</para>
<para>alone (w/o password), the password is asked at the command prompt.</para></sect3><sect3><title>18.1 SQLite</title>
<para>SQLite14 is a small powerfull self-contined, serverless, zero-configuration SQL database.</para>
<para>14.http://www.sqlite.org</para>
<para>— Databases —</para>
<para>44</para>
<para>Dump and restore</para>
<para>It can be useful to dump and restore an SQLite database. For example you can edit the dump</para>
<para>file to change a column attribute or type and then restore the database. This is easier than</para>
<para>messing with SQL commands. Use the command sqlite3 for a 3.x database.</para>
<para># sqlite database.db .dump &gt; dump.sql # dump</para>
<para># sqlite database.db &lt; dump.sql # restore</para>
<para>Convert 2.x to 3.x database</para>
<para>sqlite database_v2.db .dump | sqlite3 database_v3.db</para></sect3></sect2><sect2><title>19. DISK QUOTA</title>
<para>A disk quota allows to limit the amount of disk space and/or the number of files a user or (or member of group) can use. The quotas are allocated on a per-file system basis and are enforced by the kernel.</para><sect3><title>19.1 Linux setup</title>
<para>The quota tools package usually needs to be installed, it contains the command line tools. Activate the user quota in the fstab and remount the partition. If the partition is busy, either all locked files must be closed, or the system must be rebooted. Add usrquota to the fstab mount options, for example:</para>
<para>/dev/sda2 /home reiserfs rw,acl,user_xattr,usrquota 1 1</para>
<para># mount -o remount /home</para>
<para># mount # Check if usrquota is active, otherwise reboot</para>
<para>Initialize the quota.user file with quotacheck.</para>
<para># quotacheck -vum /home</para>
<para># chmod 644 /home/aquota.user # To let the users check their own quota</para>
<para>Activate the quota either with the provided script (e.g. /etc/init.d/quotad on SuSE) or with</para>
<para>quotaon:</para>
<para>quotaon -vu /home</para>
<para>Check that the quota is active with:</para>
<para>quota -v</para></sect3><sect3><title>19.2 FreeBSD setup</title>
<para>The quota tools are part of the base system, however the kernel needs the option quota. If it is</para>
<para>not there, add it and recompile the kernel.</para>
<para>options QUOTA</para>
<para>As with Linux, add the quota to the fstab options (userquota, not usrquota):</para>
<para>/dev/ad0s1d /home ufs rw,noatime,userquota 2 2</para>
<para># mount /home # To remount the partition</para>
<para>Enable disk quotas in /etc/rc.conf and start the quota.</para>
<para># grep quotas /etc/rc.conf</para>
<para>enable_quotas="YES" # turn on quotas on startup (or NO).</para>
<para>check_quotas="YES" # Check quotas on startup (or NO).</para>
<para># /etc/rc.d/quota start</para>
<para/></sect3><sect3><title>19.3 Assign quota limits</title>
<para>The quotas are not limited per default (set to 0). The limits are set with edquota for single</para>
<para>users. A quota can be also duplicated to many users. The file structure is different between the</para>
<para>quota implementations, but the principle is the same: the values of blocks and inodes can be</para>
<para>limited. Only change the values of soft and hard. If not specified, the blocks are 1k. The grace</para>
<para>period is set with edquota -t. For example:</para>
<para># edquota -u colin</para>
<para>Linux</para>
<para>Disk quotas for user colin (uid 1007):</para>
<para>Filesystem blocks soft hard inodes soft hard</para>
<para>/dev/sda8 108 1000 2000 1 0 0</para>
<para>FreeBSD</para>
<para>Quotas for user colin:</para>
<para>/home: kbytes in use: 504184, limits (soft = 700000, hard = 800000)</para>
<para>inodes in use: 1792, limits (soft = 0, hard = 0)</para>
<para>For many users</para>
<para>The command edquota -p is used to duplicate a quota to other users. For example to duplicate</para>
<para>a reference quota to all users:</para>
<para># edquota -p refuser `awk -F: '$3 &gt; 499 {print $1}' /etc/passwd`</para>
<para># edquota -p refuser user1 user2 # Duplicate to 2 users</para>
<para>Checks</para>
<para>Users can check their quota by simply typing quota (the file quota.user must be readable). Root</para>
<para>can check all quotas.</para>
<para># quota -u colin # Check quota for a user</para>
<para># repquota /home # Full report for the partition for all users</para></sect3></sect2><sect2><title>20. SHELLS</title>
<para>Most Linux distributions use the bash shell while the BSDs use tcsh, the bourne shell is only</para>
<para>used for scripts. Filters are very useful and can be piped:</para>
<para>grep Pattern matching</para>
<para>sed Search and Replace strings or characters</para>
<para>cut Print specific columns from a marker</para>
<para>sort Sort alphabetically or numerically</para>
<para>uniq Remove duplicate lines from a file</para>
<para>For example used all at once:</para>
<para># ifconfig | sed 's/ / /g' | cut -d" " -f1 | uniq | grep -E "[a-z0-9]+" | sort -r</para>
<para># ifconfig | sed '/.*inet addr:/!d;s///;s/ .*//'|sort -t. -k1,1n -k2,2n -k3,3n -k4,4n</para>
<para>The first character in the sed pattern is a tab. To write a tab on the console, use ctrl-v ctrl-tab.</para><sect3><title>20.1 bash</title>
<para>Redirects and pipes for bash and sh:</para>
<para># cmd 1&gt; file # Redirect stdout to file.</para>
<para># cmd 2&gt; file # Redirect stderr to file.</para>
<para># cmd 1&gt;&gt; file # Redirect and append stdout to file.</para>
<para># cmd &amp;&gt; file # Redirect both stdout and stderr to file.</para>
<para># cmd &gt;file 2&gt;&amp;1 # Redirects stderr to stdout and then to file.</para>
<para># cmd1 | cmd2 # pipe stdout to cmd2</para>
<para># cmd1 2&gt;&amp;1 | cmd2 # pipe stdout and stderr to cmd2</para>
<para>Modify your configuration in ~/.bashrc (it can also be ~/.bash_profile). The following entries are useful, reload with ". .bashrc".</para>
<para># in .bashrc</para>
<para>bind '"\e[A"':history-search-backward # Use up and down arrow to search</para>
<para>bind '"\e[B"':history-search-forward # the history. Invaluable!</para>
<para>set -o emacs # Set emacs mode in bash (see below)</para>
<para>set bell-style visible # Do not beep, inverse colors</para>
<para># Set a nice prompt like [user@host]/path/todir&gt;</para>
<para>PS1="\[\033[1;30m\][\[\033[1;34m\]\u\[\033[1;30m\]"</para>
<para>PS1="$PS1@\[\033[0;33m\]\h\[\033[1;30m\]]\[\033[0;37m\]"</para>
<para>PS1="$PS1\w\[\033[1;30m\]&gt;\[\033[0m\]"</para>
<para># To check the currently active aliases, simply type alias</para>
<para>alias ls='ls -aF' # Append indicator (one of */=&gt;@|)</para>
<para>alias ll='ls -aFls' # Listing</para>
<para>alias la='ls -all'</para>
<para>alias ..='cd ..'</para>
<para>alias ...='cd ../..'</para>
<para>export HISTFILESIZE=5000 # Larger history</para>
<para>export CLICOLOR=1 # Use colors (if possible)</para>
<para>export LSCOLORS=ExGxFxdxCxDxDxBxBxExEx</para></sect3><sect3><title>20.2 tcsh</title>
<para>Redirects and pipes for tcsh and csh (simple &gt; and &gt;&gt; are the same as sh):</para>
<para># cmd &gt;&amp; file # Redirect both stdout and stderr to file.</para>
<para># cmd &gt;&gt;&amp; file # Append both stdout and stderr to file.</para>
<para># cmd1 | cmd2 # pipe stdout to cmd2</para>
<para># cmd1 |&amp; cmd2 # pipe stdout and stderr to cmd2</para>
<para>The settings for csh/tcsh are set in ~/.cshrc, reload with "source .cshrc". Examples:</para>
<para># in .cshrc</para>
<para>alias ls 'ls -aF'</para>
<para>alias ll 'ls -aFls'</para>
<para>alias la 'ls -all'</para>
<para>alias .. 'cd ..'</para>
<para>alias ... 'cd ../..'</para>
<para>set prompt = "%B%n%b@%B%m%b%/&gt; " # like user@host/path/todir&gt;</para>
<para>set history = 5000</para>
<para>set savehist = ( 6000 merge )</para>
<para>set autolist # Report possible completions with tab</para>
<para>set visiblebell # Do not beep, inverse colors</para>
<para># Bindkey and colors</para>
<para>bindkey -e Select Emacs bindings # Use emacs keys to edit the command prompt</para>
<para>bindkey -k up history-search-backward # Use up and down arrow to search</para>
<para>bindkey -k down history-search-forward</para>
<para>setenv CLICOLOR 1 # Use colors (if possible)</para>
<para>setenv LSCOLORS ExGxFxdxCxDxDxBxBxExEx</para>
<para>The emacs mode enables to use the emacs keys shortcuts to modify the command prompt line.</para>
<para>This is extremely useful (not only for emacs users). The most used commands are:</para>
<para>C-a Move cursor to beginning of line</para>
<para>C-e Move cursor to end of line</para>
<para>— Shells —</para>
<para>47</para>
<para>M-b Move cursor back one word</para>
<para>M-f Move cursor forward one word</para>
<para>M-d Cut the next word</para>
<para>C-w Cut the last word</para>
<para>C-u Cut everything before the cursor</para>
<para>C-k Cut everything after the cursor (rest of the line)</para>
<para>C-y Paste the last thing to be cut (simply paste)</para>
<para>C-_ Undo</para>
<para>Note: C- = hold control, M- = hold meta (which is usually the alt or escape key).</para></sect3></sect2><sect2><title>21. SCRIPTING</title>
<para/>
<para>The Bourne shell (/bin/sh) is present on all Unix installations and scripts written in this language</para>
<para>are (quite) portable; man 1 sh is a good reference.</para><sect3><title>21.1 Basics</title>
<para>Variables and arguments</para>
<para>Assign with variable=value and get content with $variable</para>
<para>MESSAGE="Hello World" # Assign a string</para>
<para>PI=3.1415 # Assign a decimal number</para>
<para>N=8</para>
<para>TWON=`expr $N * 2` # Arithmetic expression (only integers)</para>
<para>TWON=$(($N * 2)) # Other syntax</para>
<para>TWOPI=`echo "$PI * 2" | bc -l` # Use bc for floating point operations</para>
<para>ZERO=`echo "c($PI/4)-sqrt(2)/2" | bc -l`</para>
<para>The command line arguments are</para>
<para>$0, $1, $2, ... # $0 is the command itself</para>
<para>$# # The number of arguments</para>
<para>$* # All arguments (also $@)</para>
<para>Special Variables</para>
<para>$$ # The current process ID</para>
<para>$? # exit status of last command</para>
<para>command</para>
<para>if [ $? != 0 ]; then</para>
<para>echo "command failed"</para>
<para>fi</para>
<para>mypath=`pwd`</para>
<para>mypath=${mypath}/file.txt</para>
<para>echo ${mypath##*/} # Display the filename only</para>
<para>echo ${mypath%%.*} # Full path without extention</para>
<para>var2=${var:=string} # Use var if set, otherwise use string</para>
<para># assign string to var and then to var2.</para>
<para>Constructs</para>
<para>for file in `ls`</para>
<para>do</para>
<para>echo $file</para>
<para>done</para>
<para>count=0</para>
<para>while [ $count -lt 5 ]; do</para>
<para>echo $count</para>
<para>sleep 1</para>
<para>count=$(($count + 1))</para>
<para>done</para>
<para>myfunction() {</para>
<para>find . -type f -name "*.$1" -print # $1 is first argument of the function</para>
<para>}</para>
<para>myfunction "txt"</para>
<para>Generate a file</para>
<para>MYHOME=/home/colin</para>
<para>cat &gt; testhome.sh &lt;&lt; _EOF</para>
<para># All of this goes into the file testhome.sh</para>
<para>if [ -d "$MYHOME" ] ; then</para>
<para>echo $MYHOME exists</para>
<para>else</para>
<para>echo $MYHOME does not exist</para>
<para>fi</para>
<para>_EOF</para>
<para>sh testhome.sh</para></sect3><sect3><title>21.2 Bourne script example</title>
<para>As a small example, the script used to create a PDF booklet from this xhtml document:</para>
<para>#!/bin/sh</para>
<para># This script creates a book in pdf format ready to print on a duplex printer</para>
<para>if [ $# -ne 1 ]; then # Check the argument</para>
<para>echo 1&gt;&amp;2 "Usage: $0 HtmlFile"</para>
<para>exit 1 # non zero exit if error</para>
<para>fi</para>
<para>file=$1 # Assign the filename</para>
<para>fname=${file%.*} # Get the name of the file only</para>
<para>fext=${file#*.} # Get the extension of the file</para>
<para>prince $file -o $fname.pdf # from www.princexml.com</para>
<para>pdftops -paper A4 -noshrink $fname.pdf $fname.ps # create postscript booklet</para>
<para>cat $fname.ps |psbook|psnup -Pa4 -2 |pstops -b "2:0,1U(21cm,29.7cm)" &gt; $fname.book.ps</para>
<para>ps2pdf13 -sPAPERSIZE=a4 -sAutoRotatePages=None $fname.book.ps $fname.book.pdf</para>
<para># use #a4 and #None on Windows!</para>
<para>exit 0 # exit 0 means successful</para></sect3><sect3><title>21.3 Some sed commands</title>
<para>sed 's/string1/string2/g' # Replace string1 with string2</para>
<para>sed -i 's/wroong/wrong/g' *.txt # Replace a recurring word with g</para>
<para>sed 's/\(.*\)1/\12/g' # Modify anystring1 to anystring2</para>
<para>sed '/&lt;p&gt;/,/&lt;\/p&gt;/d' t.xhtml # Delete lines that start with &lt;p&gt;</para>
<para># and end with &lt;/p&gt;</para>
<para>sed '/ *#/d; /^ *$/d' # Remove comments and blank lines</para>
<para>sed 's/[ \t]*$//' # Remove trailing spaces (use tab as \t)</para>
<para>sed 's/^[ \t]*//;s/[ \t]*$//' # Remove leading and trailing spaces</para>
<para>sed 's/[^*]/[&amp;]/' # Enclose first char with [] top-&gt;[t]op</para>
<para/></sect3><sect3><title>21.4 Some useful commands</title>
<para>sort -t. -k1,1n -k2,2n -k3,3n -k4,4n # Sort IPv4 ip addresses</para>
<para>echo 'Test' | tr '[:lower:]' '[:upper:]' # Case conversion</para>
<para>echo foo.bar | cut -d . -f 1 # Returns foo</para>
<para>PID=$(ps | grep script.sh | grep bin | awk '{print $1}') # PID of a running script</para>
<para>PID=$(ps axww | grep [p]ing | awk '{print $1}') # PID of ping (w/o grep pid)</para>
<para>IP=$(ifconfig $INTERFACE | sed '/.*inet addr:/!d;s///;s/ .*//') # Linux</para>
<para>IP=$(ifconfig $INTERFACE | sed '/.*inet /!d;s///;s/ .*//') # FreeBSD</para>
<para>if [ `diff file1 file2 | wc -l` != 0 ]; then [...] fi # File changed?</para>
<para>cat /etc/master.passwd | grep -v root | grep -v \*: | awk -F":" \ # Create http passwd</para>
<para>'{ printf("%s:%s\n", $1, $2) }' &gt; /usr/local/etc/apache2/passwd</para>
<para>testuser=$(cat /usr/local/etc/apache2/passwd | grep -v \ # Check user in passwd</para>
<para>root | grep -v \*: | awk -F":" '{ printf("%s\n", $1) }' | grep ^user$)</para></sect3></sect2><sect2><title>22. PROGRAMMING</title><sect3><title>22.1 C basics</title>
<para>strcpy(newstr,str) /* copy str to newstr */</para>
<para>expr1 ? expr2 : expr3 /* if (expr1) expr2 else expr3 */</para>
<para>x = (y &gt; z) ? y : z; /* if (y &gt; z) x = y; else x = z; */</para>
<para>int a[]={0,1,2}; /* Initialized array (or a[3]={0,1,2}; */</para>
<para>int a[2][3]={{1,2,3},{4,5,6}}; /* Array of array of ints */</para>
<para>int i = 12345; /* Convert in i to char str */</para>
<para>char str[10];</para>
<para>sprintf(str, "%d", i);</para></sect3><sect3><title>22.2 C example</title>
<para>A minimal c program simple.c:</para>
<para>#include &lt;stdio.h&gt;</para>
<para>main() {</para>
<para>int number=42;</para>
<para>printf("The answer is %i\n", number);</para>
<para>}</para>
<para>Compile with:</para>
<para># gcc simple.c -o simple</para>
<para># ./simple</para>
<para>The answer is 42</para></sect3><sect3><title>22.3 C++ basics</title>
<para>*pointer // Object pointed to by pointer</para>
<para>&amp;obj // Address of object obj</para>
<para>obj.x // Member x of class obj (object obj)</para>
<para>pobj-&gt;x // Member x of class pointed to by pobj</para>
<para>// (*pobj).x and pobj-&gt;x are the same</para></sect3><sect3><title>22.4 C++ example</title>
<para>As a slightly more realistic program in C++, let's create a class in its own header (IPv4.h) and</para>
<para>implementation (IPv4.cpp) and create a program which uses the class functionality. The class has a member to convert an IP address in integer format to the known quad format. This is a minimal c++ program with a class and multi-source compile.</para>
<para>IPv4 class</para>
<para>IPv4.h:</para>
<para>#ifndef IPV4_H</para>
<para>#define IPV4_H</para>
<para>#include &lt;string&gt;</para>
<para>namespace GenericUtils { // create a namespace</para>
<para>class IPv4 { // class definition</para>
<para>public:</para>
<para>IPv4();</para>
<para>~IPv4();</para>
<para>std::string IPint_to_IPquad(unsigned long ip);// member interface</para>
<para>};</para>
<para>} //namespace GenericUtils</para>
<para>#endif // IPV4_H</para>
<para>IPv4.cpp:</para>
<para>#include "IPv4.h"</para>
<para>#include &lt;string&gt;</para>
<para>#include &lt;sstream&gt;</para>
<para>using namespace std; // use the namespaces</para>
<para>using namespace GenericUtils;</para>
<para>IPv4::IPv4() {} // default constructor/destructor</para>
<para>IPv4::~IPv4() {}</para>
<para>string IPv4::IPint_to_IPquad(unsigned long ip) { // member implementation</para>
<para>ostringstream ipstr; // use a stringstream</para>
<para>ipstr &lt;&lt; ((ip &amp;0xff000000) &gt;&gt; 24) // Bitwise right shift</para>
<para>&lt;&lt; "." &lt;&lt; ((ip &amp;0x00ff0000) &gt;&gt; 16)</para>
<para>&lt;&lt; "." &lt;&lt; ((ip &amp;0x0000ff00) &gt;&gt; 8)</para>
<para>&lt;&lt; "." &lt;&lt; ((ip &amp;0x000000ff));</para>
<para>return ipstr.str();</para>
<para>}</para>
<para>The program simplecpp.cpp</para>
<para>#include "IPv4.h"</para>
<para>#include &lt;iostream&gt;</para>
<para>#include &lt;string&gt;</para>
<para>using namespace std;</para>
<para>int main (int argc, char* argv[]) {</para>
<para>string ipstr; // define variables</para>
<para>unsigned long ipint = 1347861486; // The IP in integer form</para>
<para>GenericUtils::IPv4 iputils; // create an object of the class</para>
<para>ipstr = iputils.IPint_to_IPquad(ipint); // call the class member</para>
<para>cout &lt;&lt; ipint &lt;&lt; " = " &lt;&lt; ipstr &lt;&lt; endl; // print the result</para>
<para>return 0;</para>
<para>}</para>
<para>Compile and execute with:</para>
<para># g++ -c IPv4.cpp simplecpp.cpp # Compile in objects</para>
<para># g++ IPv4.o simplecpp.o -o simplecpp.exe # Link the objects to final executable</para>
<para># ./simplecpp.exe</para>
<para>1347861486 = 80.86.187.238</para>
<para>Use ldd to check which libraries are used by the executable and where they are located. This command is also used to check if a shared library is missing or if the executable is static.</para>
<para># ldd /sbin/ifconfig</para></sect3><sect3><title>22.5 Simple Makefile</title>
<para>The corresponding minimal Makefile for the multi-source program is shown below. The lines with</para>
<para>instructions must begin with a tab! The back slash "\" can be used to cut long lines.</para>
<para>CC = g++</para>
<para>CFLAGS = -O</para>
<para>OBJS = IPv4.o simplecpp.o</para>
<para>simplecpp: ${OBJS}</para>
<para>${CC} -o simplecpp ${CFLAGS} ${OBJS}</para>
<para>clean:</para>
<para>rm -f ${TARGET} ${OBJS}</para></sect3></sect2><sect2><title>23. ONLINE HELP</title><sect3><title>23.1 Documentation</title>
<para>Linux Documentation en.tldp.org</para>
<para>Linux Man Pages www.linuxmanpages.com</para>
<para>Linux commands directory www.oreillynet.com/linux/cmd</para>
<para>Linux doc man howtos linux.die.net</para>
<para>FreeBSD Handbook www.freebsd.org/handbook</para>
<para>FreeBSD Man Pages www.freebsd.org/cgi/man.cgi</para>
<para>FreeBSD user wiki www.freebsdwiki.net</para>
<para>Solaris Man Pages docs.sun.com/app/docs/coll/40.10</para></sect3><sect3><title>23.2 Other Unix/Linux references</title>
<para>Rosetta Stone for Unix bhami.com/rosetta.html (a Unix command translator)</para>
<para>Unix guide cross reference unixguide.net/unixguide.shtml</para>
<para>Linux commands line list www.linuxguide.it/commands_list.php</para>
<para>Short Linux reference www.pixelbeat.org/cmdline.html</para>
<para>That's all folks!</para>
<para>This document: "Unix Toolbox revision 11" is licensed under a Creative Commons Licence</para>
<para/>
<para/>
<para/></sect3></sect2></sect1><sect1><title>Полезные утилиты Gentoo Linux</title>
<para/>
<orderedlist>
<listitem>
<para>Пакет gentoolkit (для установки наберите: emerge gentoolkit) содержит:</para>
</listitem>
</orderedlist>
<orderedlist>
<listitem>
<para/>
</listitem>
</orderedlist>
<orderedlist>
<listitem>
<para>Утилита genlop (для установки наберите: emerge genlop) позволяет извлечь множество различной инфрмации из этого файла. Например genlop -c покажет вам какой пакет собирается в данный момент и попытается предсказать сколько времени осталось до конца сборки.м</para>
<para/>
</listitem>
<listitem>
<para>Утилита ufed (для установки наберите: emerge ufed) позволяет просматривать и устанавливать USE флаги в более дружественном интерфейсе.</para>
<para/>
</listitem>
<listitem>
<para>Скрипт update-world (ссылка: <ulink url="http://www.gentoo.org/news/ru/gwn/20061204-newsletter.xml">http://www.gentoo.org/news/ru/gwn/20061204-newsletter.xml</ulink>  Пункт 3. Полезные советы / Простейший путь обновления своей системы)  позволяет оставлять обновляющуюся систему не боясь, что обновление прервется на каком-либо пакете. Данный скрипт просто </para>
<para>продолжит обновление со следующего пакета.</para>
<para/>
</listitem>
<listitem>
<para>Оконные приложения: </para>
<para>   -  kuroo (написана на Qt, установка: emerge kuroo);</para>
<para>   -  porthole (написана на GTK, установка: emerge porthole);</para>
<para>   -  portagemaster (написана на Java, установка: emerge portagemaster); </para>
<para/>
<para> предлагают доступ к portage в оконном режиме. Выбирайте на свой вкус! :)</para>
<para/>
</listitem>
<listitem>
<para>Общая Linux утилита lshw – hardware list (emerge lshw) показывает информацию о аппаратном обеспечении компьютера.</para>
<para/>
</listitem>
<listitem>
<para>Если необходимо заново сгенерировать файл world используйте команду regenworld. </para>
<para/>
</listitem>
<listitem>
<para>Если необходимо пересобрать модули ядра после компиляции нового ядра, то воспользуйтесь утилитой module-rebuild (emerge module-rebuild)</para>
<title>Ресурсы с документацией</title>
</listitem>
</orderedlist></sect1><sect1><title>Ресурсы с документацией</title>
<para/>
<orderedlist>
<listitem>
<para>
<ulink url="http://gentoo.ru/">http://gentoo.ru</ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://gentoo.org/">http://gentoo.org</ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://ru.gentoo-wiki.com/">http://ru.gentoo-wiki.com</ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://gentoo.blog.ru/">http://gentoo.blog.ru</ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://www.rugentoo.org/">http://www.rugentoo.org</ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://linuxforum.ru/">http://linuxforum.ru</ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://myfotomx.com/dalth/linuxbook.odt">http://myfotomx.com/dalth/linuxbook.odt</ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://linuxshop.ru/">http://linuxshop.ru</ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://citkit.ru/">http://citkit.ru</ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://rus-linux.net/">http://rus-linux.net</ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://lxj.endofinternet.net/">http://lxj.endofinternet.net</ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://www.habrahabr.ru/blog/linux">http://www.habrahabr.ru/blog/linux</ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://perlovka.homelinux.net/">http://perlovka.homelinux.net</ulink>
</para>
</listitem>
</orderedlist>
<para/></sect1><sect1><title>Ресурсы с программным обеспечением</title>
<orderedlist>
<listitem>
<para>
<ulink url="http://packages.gentoo.org/">http://packages.gentoo.org</ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://gentoo-portage.com/">http://gentoo-portage.com</ulink>
</para>
</listitem>
</orderedlist>
<para/></sect1><sect1><title>Каналы IRC (freenode.net)</title>
<orderedlist>
<listitem>
<para>#gentoo.</para>
</listitem>
<listitem>
<para>#gentoo-amd64</para>
</listitem>
<listitem>
<para>#gentoo-kde</para>
</listitem>
<listitem>
<para>#gentoo-ru.</para>
</listitem>
<listitem>
<para>#rugentoo.</para>
</listitem>
<listitem>
<para>#gentoo-doc-ru</para>
</listitem>
<listitem>
<para>#gentoo-laptop</para>
</listitem>
</orderedlist>
<para/></sect1><para>35</para>
</article>
