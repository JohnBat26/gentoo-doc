<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbookxi.rng" type="xml"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <info>
        <title>Тюнинг Gentoo</title>
    </info>
    <section>
        <info>
            <title>Ядро 2.6: Тонкости настройки</title>
        </info>
        <para>Ссылка на оригинал: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/Ядро_2.6">http://ru.gentoo-wiki.com/Ядро_2.6</link>
        </para>
        <para>С версии: 1.5</para>
        <section>
            <info>
                <title>Параметры виртуальной памяти</title>
            </info>
            <para>Ядро Linux позволяет регулировать параметры свопинга двумя способами: автоматически, исходя из того, насколько активно используется та или иная программа, либо вручную задавая агрессивность свопинга. </para>
            <para>Содержимое файла <filename>/proc/sys/vm/swappiness</filename> определяет агрессивность свопинга, а истинность (неравенство нулю) значения в файле <filename>/proc/sys/vm/autoswappiness</filename> определяет какой из двух режимов будет использоваться. Таким образом, если вы хотите установить агрессивность свопинга вручную, то следует воспользоваться командой: </para>
            <screen><prompt>#</prompt> <userinput>echo 0 &gt; /proc/sys/vm/autoswappiness</userinput></screen>
            <para>чтобы отключить автоматический режим и уже затем установить желаемый режим вручную. Значения в файле <filename>/proc/sys/vm/swappiness</filename> изменяются от 0 до 100. При минимальном значении ядро стремится большую часть содержимого держать в физической памяти, при максимальном стремится к экономии физической памяти.Чтобы максимльно сэкономить оперативную память введите: </para>
            <screen><prompt>#</prompt> <userinput>echo 100 &gt; /proc/sys/vm/swappiness</userinput></screen>
            <para>По умолчанию значение 60, но если поставить 0, это должно побудить систему пользоваться подкачкой только в критических ситуациях. Для медленных систем может ускорить работу. Значение 100 не рекомендуется для тех у кого достаточно медленный жесткий диск. Казалось бы, это значение вообще не желательно для использования, однако, Andrew Morton, один из разработчиков ядра Linux, заявляет, что на своих рабочих компьютерах (десктопах, не серверах) использует значение 100, т.к. считает, что ему совершенно ни к чему эти сотни занятых мегабайт оперативной памяти. И он в некоторых случаях прав, так как известно, что Linux использует свободную оперативную память для кэширования дисковых операций, таким образом, значение близкое или равное 100 может и ускорить систему. Таким образом, решать вам, исходя из количества и ресурсоемкости используемых вами задач. Хотя, вряд ли вы так же активно используете свой десктоп, как Эндрю ;) </para>
            <para>Также, возможно заставить систему устанавливать нужный режим при загрузке, прописав в файл <filename>/etc/sysctl.conf</filename> строку </para>
            <example>
                <title>Файл: /etc/sysctl.conf</title>
                <programlisting>vm.swappiness=100</programlisting>
            </example>
            <para>разумеется, вместо 100 следует подставить то значение, которое вам подходит. </para>
        </section>
    </section>
    <section>
        <info>
            <title>Руководство по предварительному связыванию в Gentoo Linux</title>
        </info>
        <para>Ссылка на оригинал: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gentoo.org/doc/ru/prelink-howto.xml">http://www.gentoo.org/doc/ru/prelink-howto.xml</link>
        </para>
        <para>C версии: 1.0</para>
        <para>Перенесено в: 1.5</para>
        <section>
            <info>
                <title>Введение</title>
            </info>
            <section>
                <info>
                    <title>Что такое предварительное связывание (Prelink) и как оно может помочь мне? </title>
                </info>
                <para>Большинство приложений используют разделяемые библиотеки. Эти разделяемые библиотеки должны быть загружены в память во время выполнения программы, при этом необходимо определить различные символьные ссылки. Для большинства небольших программ динамическое связывание происходит очень быстро. Но для программ, написанных на C++, имеющих много библиотечных зависимостей, динамическое связывание может занять много времени. </para>
                <para>На большинстве систем, библиотеки обычно остаются неизменными и когда программа запускается, операции необходимые для связывания, каждый раз одинаковы. Предварительное связывание использует данную особенность, выполняя связывание и сохраняя библиотеки в выполняемом файле, фактически уже связанными. Для связывания, вам потребуется ld-linux.so в glibc; для распознавания предварительного связывания версия glibc должна быть &gt;= 2.3.1-r2 </para>
                <para>Предварительное связывание может уменьшить время загрузки приложений. Например, типичные программы KDE могут загружаться на 50% быстрее. Необходимым условием является перезапуск процесса предварительного связывания каждый раз при обновлении библиотек для программ, которые на них ссылаются. </para>
            </section>
            <section>
                <info>
                    <title>Резюме</title>
                </info>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>Предварительное связывание производится программой, имеющей название, как не странно, <command>prelink</command>. Она изменяет выполняемый файл таким образом, что он запускается быстрее.</para>
                        </listitem>
                        <listitem>
                            <para>Если зависимые от приложения библиотеки были изменены после того, как были предварительно связаны с приложением, то они потребуют повторного предварительного связывания, иначе вы потеряете преимущества в скорости загрузки. </para>
                        </listitem>
                        <listitem>
                            <para>Изменения выполняемого файла полностью обратимы, поскольку программа <command>prelink</command> имеет функцию undo. </para>
                        </listitem>
                        <listitem>
                            <para>Новые версии portage могут обрабатывать, при помощи программы <command>prelink</command>, изменяющиеся контрольные суммы MD5 и поля mtime выполняемых файлов. </para>
                        </listitem>
                        <listitem>
                            <para>У вас должен быть <package>glibc-2.3.1-r2</package> или более новый, и бинарные файлы должны быть скомпилированы с <package>binutils-2.13.90.0.xx</package> или выше. </para>
                        </listitem>
                    </itemizedlist>
                </para>
            </section>
        </section>
        <section>
            <info>
                <title>Инициализация предварительного связывания</title>
            </info>
            <section>
                <info>
                    <title>Установка программ</title>
                </info>
                <note>
                    <para>Я подразумеваю, что у вас есть Gentoo-1.4, который был собран при помощи gcc-3.2 или более поздней версии и <package>binutils-2.13.90.0.xx</package>. Это требуется для того, что бы выполняемые файлы могли быть предварительно связаны. </para>
                </note>
                <warning>
                    <para>Должен быть установлен <package>glibc 2.3.1</package> или более новый, иначе программа <command>prelink</command> может испортить все ваши выполняемые файлы! </para>
                </warning>
                <para>Для начала обновите свое дерево портежей, потому что многие из необходимых приложений часто обновляются и постоянно выходят исправления ошибок. </para>
                <example>
                    <title>Обновление вашего дерева портежей</title>
                    <screen><prompt>#</prompt> <userinput>emerge sync</userinput></screen>
                </example>
                <para>Далее, убедитесь, что у вас установлен <package>portage-2.0.26</package> или более новый. Это требуется для того, что бы portage могло распознать предварительно связанные выполняемые файлы и при необходимости корректно их деинсталлировать. Т.к. предварительное связывание изменяет контрольную сумму MD5 бинарных файлов. </para>
                <example>
                    <title>Проверка версии дерева портежей</title>
                    <screen><prompt>#</prompt> <userinput>emerge "&gt;=portage-2.0.46"</userinput></screen>
                </example>
                <para>Теперь вы можете вызвать <command>emerge</command> для программы предварительного связывания. Процесс emerge автоматически проверит, что ваша система может безопасно выполнять предварительное связывание. </para>
                <example>
                    <title>Устанавливаем предварительное связывание</title>
                    <screen><prompt>#</prompt> <userinput>emerge prelink</userinput></screen>
                </example>
                <para>Некоторые люди, в ходе выполнения тестов, получают ошибки выполняя emerge для программы prelink. Тесты размещены в пакете из соображений безопасности, предварительное связывание будет непредсказуемым, если их отменить. Эти ошибки обычно связаны с базовыми пакетами, такими как <package>binutils</package>, <package>gcc</package> и <package>glibс</package>. В таком случае попробуйте выполнить emerge этих пакетов повторно.</para>
                <para>Примечание: Если ошибки продолжают появляться, попробуйте скомпилировать и протестировать программу prelink самостоятельно (<command>./configure ; make ; make check</command>). В случае сбоя вы можете просмотреть <filename>*.log</filename> файлы в директории с набором тестов. Они могут дать вам некоторые полезные подсказки. </para>
                <para>Если вы имеете набор действий, которые демонстрируют ошибки в другой системе, пожалуйста отправьте его на Stefan Jones. </para>
            </section>
            <section>
                <info>
                    <title>Настройка</title>
                </info>
                <para>Portage автоматически генерирует файл <filename>/etc/prelink.conf</filename>, который говорит программе prelink какие файлы требуется предварительно связать. </para>
                <para>К сожалению, вы не сможете предварительно связать файлы, которые были скомпилированы старыми версиями пакета <package>binutils</package>. Большинство таких приложений поставляется уже скомпилированными, не имея исходных кодов, и устанавливаются в каталоге /opt. Создайте следующий файл, для того, что бы запретить программе prelink использовать предварительное связывание для подобных файлов. </para>
                <example>
                    <title><filename>/etc/env.d/99prelink</filename></title>
                    <programlisting>PRELINK_PATH_MASK="/opt"</programlisting>
                </example>
                <note>
                    <para>Вы можете добавить больше или меньше директорий, в список, разделенный двоеточиями. </para>
                </note>
            </section>
        </section>
        <section>
            <info>
                <title>Предварительное связывание</title>
            </info>
            <section>
                <info>
                    <title>Применение предварительного связывания</title>
                </info>
                <para>Я использую следующую команду для предварительного связывания всех бинарных файлов в директориях, заданных в файле <filename>/etc/prelink.conf</filename>.</para>
                <example>
                    <title>Предварительное связывание заданных файлов</title>
                    <screen><prompt>#</prompt> <userinput>prelink -afmR</userinput></screen>
                </example>
                <warning>
                    <para>Наблюдалось, что при наличии небольшого свободного пространства в момент выполнения предварительного связывания для всей системы, существует вероятность усечения выполняемых файлов. Результатом может стать испорченная система. Используйте команду <command>file</command> или <command>readelf</command> для проверки целостности выполняемых файлов. Также вы можете заранее проверить наличие свободного места коммандо <command>df -h</command>.</para>
                </warning>
                <para>Описание опций:</para>
                <orderedlist>
                    <listitem>
                        <para><parameter>-a</parameter>        All, применить предварительное связывание ко всем выполняемым файлам. </para>
                    </listitem>
                    <listitem>
                        <para><parameter>-f</parameter>        Вынуждает повторить предварительное связывание для файлов, которые уже подвергались ему. Это требуется т.к. программа prelink прекращает обработку существующих старых связанных файлов, зависимые библиотеки которых могли измениться. </para>
                    </listitem>
                    <listitem>
                        <para><parameter>-m</parameter>        Сохраняет пространство виртуальной памяти. Это требуется, если вы имеете много библиотек, которые необходимо связать. </para>
                    </listitem>
                    <listitem>
                        <para><parameter>-R</parameter>        Random, -- Выбирает случайный порядок адресов, это увеличивает безопасность против переполнений буферов. </para>
                    </listitem>
                </orderedlist>
                <note>
                    <para>Более подробно об опциях можно узнать, набрав <command>man prelink</command>
                    </para>
                </note>
            </section>
        </section>
        <section>
            <title>Известные проблемы и методы их решения</title>
            <section>
                <title>"Предварительное связывание не работает с разделяемой библиотекой, собранной без опции PIC"</title>
                <para>Причиной данной проблемы являются объектные файлы разделяемой библиотеки, скомпилированные без опции gcc <parameter>-fPIC</parameter>. </para>
                <para>Далее следует список проблемных библиотек и список пакетов, для которых требуется повторно вызвать emerge, в случае возникновения данной проблемы. </para>
                <example>
                    <title>Исправления</title>
                    <screen><lineannotation>(Для библиотеки ORBit /usr/lib/libIIOP.so.0.5.17)</lineannotation>
# emerge ">=sys-apps/tcp-wrappers-7.6-r4" ORBit
<lineannotation>(Для библиотеки zlib  /usr/lib/libz.so.1.1.4)</lineannotation>
# emerge ">=sys-libs/zlib-1.1.4"
<lineannotation>(Для svgalib, /usr/lib/libsvga.so.xx)</lineannotation>
# emerge ">=media-libs/svgalib-1.9.16"
<lineannotation>(Для библиотеки XFree openGL, libGLU.so.1)</lineannotation>
# emerge ">=x11-base/xfree-4.2.1-r2"
<lineannotation>(Для libpcap.so.0.6)</lineannotation>
# emerge ">=net-libs/libpcap-0.7.1-r2"
<lineannotation>(Для библиотеки lcms, /usr/lib/liblcms.so.1)</lineannotation>
# emerge ">=media-libs/lcms-1.09"
</screen>
                </example>
                <note>
                    <para>Многие библиотеки статично связаны с zlib и/или tcp-wrappers, так что сначала попробуйте выполнить emerge для них, после чего, повторно запустите emerge для проблемных библиотек. </para>
                </note>
                <para>Если вы имеете проблемы с предварительным связыванием Qt/KDE, то сначала попытайтесь обновить <package>x11-base/xfree</package> до версии 4.2.1-r2 или более новой и <package>x11-libs/qt</package> до версии 3.1.0-r1 или более новой. Если QT так и не работает, тогда попробуйте скомпилировать его без поддержки xinerama, задав строку <code>myconf="-no-xinerama ${myconf}"</code> в файле ebuild для qt. </para>
                <para>Далее приводится список библиотек, которые пока не работают или не могут работать вообще: </para>
                <orderedlist>
                    <listitem>
                        <para>Библиотеки в пакете wine, включая windex. Они в любом случае не могут ускорить выполняемые файлы MS Windows. </para>
                    </listitem>
                    <listitem>
                        <para>Библиотека в <package>media-video/mjpgtools</package>, <filename>/usr/lib/liblavfile-1.6.so.0</filename></para>
                    </listitem>
                </orderedlist>
                <para>Если у вас есть проблемы с библиотекой, которой нет в списке, пожалуйста сообщите об этом, предпочтительно, добавив <parameter>-fPIC</parameter> к соответствующим <envar>CFLAGS</envar>.</para>
            </section>
            <section>
                <title>Прерывание предварительного связывания файла, с выводом сообщения, вида: "1631 Aborted ...." </title>
                <para>Вам необходимо использовать опцию <parameter>-f</parameter> программы prelink; т.е. повторить предварительное связывание для всей системы с нуля. Попробуйте запустить <command>prelink -af</command>.</para>
            </section>
            <section>
                <title>"Ошибка: &lt;file&gt;: error while loading shared libraries: unexpected reloc type..." </title>
                <para>Это было исправлено в пакете <package>sys-libs/glibc-2.3.1-r2</package> 2002/11/18, выполните emerge для glibc, если у вас более старая версия. </para>
                <para>Так же запустите <command>prelink -u -a -m ; prelink -a -m</command> это должно помочь. Если все это не помогает, просто запустите <command>prelink -u &lt;file&gt;</command>.</para>
            </section>
            <section>
                <title>У меня проблемы с библиотеками Nvidia openGL</title>
                <para>Ускоренные библиотеки openGL идущие с пакетом nvidia-glx скомпилированы нестандартным образом, и программа prelink выводит массу предупреждений. Здесь нет повода для беспокойства, и это не может быть исправленo кем-либо помимо компании nvidia. Вы всегда можете вернуться к xfree версии библиотеки libGL.so, если вам не требуется ускорение 3D. Хотя драйвер xfree nvidia работает нормально. </para>
            </section>
            <section>
                <title>После предварительного связывания моей системы, некоторые статичные выполняемые файлы более не работают </title>
                <para>Там где участвует glibc, не бывает такой вещи как 100% статичный выполняемый файл. Если вы статично скомпилировали выполняемый файл с glibс, он может продолжать оставаться зависимым от других системных файлов. Далее приводится объяснение от Dick Howell. </para>
                <para>"Я предполагал, что все должно находиться в скачанном файле и не должно быть никаких зависимостей с локальными библиотеками на целевой системе. К сожалению, в Linux, и я думаю везде, где используется GLIBC, это до сих пор не совсем верно. Существует библиотека "libnss" (name service switch - переключатель сервиса имен, некоторые люди думают, что это network secutiry system - сетевая система безопасности) которая предоставляет функции для доступа к различным базам данных для аутентификации, сетевой информации и для других вещей. Эта библиотека предполагает сделать приложения независимыми от отдельно сконфигурированных сетевых окружений машины. Хорошая идея, но изменения GLIBC может вести к проблемам ее загрузки. И вы не можете статически связать "libnss" так как она сконфигурирована для каждой машины индивидуально. Я думаю, что, главным образом, это происходит из-за статического связывания других GLIBC библиотек, особенно "libpthread, "libm" и "libc", откуда
                    приходят несовместимые вызовы к функциям "libnss"" </para>
            </section>
            <section>
                <title>Предварительное связывание обрывается с ошибкой"prelink: dso.c:306: fdopen_dso: Assertion `j == k' failed." </title>
                <para>Это известная проблема, любезно продиагностирована <link xlink:href="http://bugs.gentoo.org/show_bug.cgi?id=13878">здесь</link>. Программа prelink не может справиться с выполняемыми файлами сжатыми методом UPX. Для версии prelink-20021213 нет другого способа решить эту проблему, кроме как спрятать выполняемые файлы во время предварительного связывания. Смотрите раздел <link xlink:href="#">конфигурации выше</link>, где обсуждается вопрос о том, как это осуществить. </para>
            </section>
        </section>
        <section>
            <info>
                <title>Заключение</title>
            </info>
            <para>Предварительное связывание может решительно ускорить время запуска для некоторых больших приложений. Его поддержка встроена в дерево портежей. Предварительное связывание безопасно, т.к. вы всегда можете отменить его действие для любого выполняемого файла, если вы столкнетесь с какими-либо проблемами. Помните что когда вы обновляете glibc или другие библиотеки, с которыми вы осуществили предварительное связывание, вам надо будет перезапустить prelink. В общем, удачи!</para>
        </section>
    </section>
    <section>
        <info>
            <title>Тюнинг системы и запуска некоторых программ</title>
        </info>
        <para>Ссылка на оригинал: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/Тюнинг_сис%D1%25">http://ru.gentoo-wiki.com/Тюнинг системы и запуска некоторых программ</link>
        </para>
        <para>С версии: 1.5</para>
        <section>
            <info>
                <title>Введение</title>
            </info>
            <para>Многие программы и части системы Linux работают по-умолчанию не на полную "мощность", т.к. они должны корректно работать на широком спектре системных конфигураций. Иногда, это может создать иллюзию о том, что Linux - более медленная система чем другие. Это не так. В данной статье будут рассмотренны наиболее важные настройки, которые дадут вам наибольший прирост скорости и эффективности системы. </para>
            <para>Тонкая настройка дисковой подсистемы (hdparm, планировщики ввода-вывода) перенесена в <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/Hастройка_дисковой_подсистемы">отдельную статью</link>
            </para>
        </section>
    </section>
    <section>
        <info>
            <title> mplayer</title>
        </info>
        <orderedlist>
            <listitem>
                <para>Желательно использовать <parameter>-vo xvidix</parameter> или <parameter>-vo xv</parameter>, чтобы перенести нагрузку с CPU на вашу видео-карту </para>
            </listitem>
            <listitem>
                <para>Собирайте mplayer с поддержкой особенностей именно вашего процессора (используйте <command>emerge mplayer -pv</command> - там много всего полезного), многие части кода mplayer оптимизированы для использования на конкретных процессорах. </para>
            </listitem>
            <listitem>
                <para>При проигрывании используйте </para>
                <screen><prompt>#</prompt> <userinput>hdparm -u1 -A1 -a 128 /dev/hda</userinput> <lineannotation>(или что там у вас вместо hda)</lineannotation></screen>
            </listitem>
            <listitem>
                <para>Ипользование команды <command>nice</command> при запуске mplayer с приоритетами -5 и -10 также дает преимущества </para>
            </listitem>
        </orderedlist>
    </section>
    <section>
        <info>
            <title>XMMS</title>
        </info>
        <orderedlist>
            <listitem>
                <para>Как и для mplayer не забудьте собрать XMMS с поддержкой особенностей вашего процессора </para>
            </listitem>
            <listitem>
                <para>Установите значение для output-buffer побольше (где-то 2500-3000) </para>
                <para>Preferences → Output Plugin → Configure → Buffering → Buffer size(ms) </para>
                <para>или то же самое, но для локализованной версии </para>
                <para>Настройки → ВАШ плагин вывода звука → Настройка → Дополнительные настройки → Размер буфера (милисек) </para>
            </listitem>
            <listitem>
                <para>Старайтесь использовать качественные звуковые карты, которые имеют более полную обработку звука на уровне железа </para>
            </listitem>
        </orderedlist>
    </section>
    <section>
        <info>
            <title>Тюнинг настроек программ из семейства Mozilla</title>
        </info>
        <para>Ссылка на оригинал: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/Тюнинг_настроек_программ_из_семейства_Mozilla">http://ru.gentoo-wiki.com/Тюнинг настроек программ из семейства Mozilla</link></para>
        <para>С версии: 1.5</para>
        <section>
            <info>
                <title>Navigator(Seamonkey/Firefox)</title>
            </info>
            <para>Браузеры семейства Mozilla имеют большое количество настроек, все из которых легко доступны, если набрать в строке адреса вместо URL строку 'about:config'. Следующие пять настроек позволят ускорить загрузку страниц: </para>
            <orderedlist>
                <listitem>
                    <para><varname>network.http.pipelining</varname></para>
                </listitem>
                <listitem>
                    <para><varname>network.http.pipelining.firstrequest</varname></para>
                </listitem>
                <listitem>
                    <para><varname>network.http.pipelining.maxrequests</varname></para>
                </listitem>
                <listitem>
                    <para><varname>network.http.proxy.pipelining</varname></para>
                </listitem>
                <listitem>
                    <para><varname>nglayout.initialpaint.delay</varname></para>
                </listitem>
            </orderedlist>
            <para>Настройка pipelining позволит браузеру делать одновременно несколько запросов к серверу. По-умолчанию используется одно соединение. Соответственно, значения network.http.pipelining, network.http.pipelining.firstrequest и network.http.proxy.pipelining следует выставить в true. Параметр network.http.pipelining.maxrequests отвечает за максимальное количество соединений. Но не стоит его делать слишком большим, т.к. это может привести к ошибкам при загрузке, рекомендуется выставить его в районе 12. И, наконец, nglayout.initialpaint.delay это визуальное ускорение, то есть задержка между тем как браузер начал получать ответ от сервера и началом отображения в окне браузера. Стоит поставить здесь 0 т.к. это позволит вам получить доступ к уже загруженной части страницы. </para>
            <para>Примечание: вторая и пятая настройки по пока невыясненным причинам могут отсутствовать в вашем браузере. Чтобы их задействовать, можно добавить их вручную (правая кнопка мыши→New→тип значения). </para>
            <para><varname>browser.turbo.enabled</varname>
            </para>
            <para>И выставляем ему значение 'true' </para>
            <para>Далее ищем </para>
            <orderedlist>
                <listitem>
                    <para><varname>network.http.max-connections-per-server</varname></para>
                </listitem>
                <listitem>
                    <para><varname>network.http.max-persistent-connections-per-proxy</varname></para>
                </listitem>
                <listitem>
                    <para><varname>network.http.max-persistent-connections-per-server</varname></para>
                </listitem>
            </orderedlist>
            <para>Выставляем всем этим параметрам значение '8' </para>
        </section>
        <section>
            <info>
                <title>Управление Кешем в Firefox и Seamonkey</title>
            </info>
            <para>С версий Firefox 1.5.x и Seamonkey 1.0.x стала доступна функция быстрого перехода по открытым ранее страницам за счет хранения отрендереной страницы в оперативной памяти. Не всем это понравилось т.к. броузер стал потреблять больше оперативной памяти и много и в качестве лекарства предлагали отключить эту функцию, установив в about:config опцию </para>
            <orderedlist>
                <listitem>
                    <para><varname>browser.cache.memory.enable</varname></para>
                    <para>соответственно в false. В то время как можно тонко оттюнинговать отведенный для этой функции размер памяти с помощью опции </para>
                </listitem>
                <listitem>
                    <para><varname>browser.cache.memory.capacity</varname></para>
                    <para>Которая по умолчанию отсутствует, соответственно тип имеет - integer, а значение задается в килобайтах. Проверить изменения, а также просто просматривать сатистику кешей (memory и disk) можно открыв about:cache до и после.</para>
                </listitem>
            </orderedlist>
        </section>
        <section>
            <info>
                <title> Управление логотипами сайтов</title>
            </info>
            <para>Есть две опции для включения/выключения логотипов сайтов в табах и адресной стрке: </para>
            <orderedlist>
                <listitem>
                    <para><varname>browser.chrome.favicons</varname> boolean </para>
                </listitem>
                <listitem>
                    <para><varname>browser.chrome.site_icons</varname> boolean </para>
                </listitem>
            </orderedlist>
            <para>Как я понял это два стандарта (если не прав, поправьте[favicon.ico обычно лежит в корне сайта, как обстоит с site_icon не знаю]). Например gentoo.ru использует favicon, а на странице mult.ru (непосредственно на той на каторой загружается выбранный мульт, на главной странице никакого лого не показывается) показывалось лого при выключенном favicons и включенном site_icons. </para>
        </section>
        <section>
            <info>
                <title>Для перешедших с Firefox на Seamonkey.</title>
            </info>
            <para>Не знаю как вам а мне в Firefox нравится функция сохраняющая и соответственно показывающая эти самые лого при просмотре закладок. И перейдя с недавних пор на Seamonkey мне очень ее недоставало, ибо зрительно с ней гораздо удобней отыскивать нужную закладку, но по умолчанию эта функция там отключена. А управляется она оказывается опцией </para>
            <orderedlist>
                <listitem>
                    <para><varname>browser.chrome.load_toolbar_icons</varname> integer </para>
                </listitem>
            </orderedlist>
        </section>
        <section>
            <info>
                <title>Thumbnail'ы просматриваемых картинок в табах</title>
            </info>
            <para>Итак с недавних пор появилась такая небольшая функция как thumbnail просматриваемой картинки на табе и в адресной строке, но к сожалению у некоторых эта малозначимая функция вызывает тормоза интерфейса, но не все знают как ее отключить не отключая favicon(логотип сайта). Делается это с помощью опции </para>
            <orderedlist>
                <listitem>
                    <para><varname>browser.chrome.image_icons.max_size</varname></para>
                </listitem>
            </orderedlist>
            <para>для которой можно задать размер картинки, по умолчанию ее значение 1024 (килобайт или разрешение?), соответственно чтобы отключить ее, нужно установить значение 0. </para>
        </section>
    </section>
    <section>
        <info>
            <title>Тонкая настройка IDE дисков с помощью hdparm</title>
        </info>
        <para>Ссылка на оригинал: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.opennet.ru/base/sys/htparm_tune.txt.html">http://www.opennet.ru/base/sys/htparm_tune.txt.html</link>
        </para>
        <para>Перенесено в: 1.5</para>
        <section>
            <title>Введение</title>
            <para>К сожалению настройки по-умолчанию для IDE жёстких дисков сделаны с уклоном в надёжность работы, в том числе на некачественном оборудовании. На большинстве же современных материнских плат и жёстких дисков можно заметно увеличить производительность IDE подсистемы, причём это не потребует много времени. </para>
        </section>
        <section>
            <title>Характеристики IDE устройства</title>
            <para>Для получения характеристик IDE устройства выполните команду: </para>
            <screen><prompt>#</prompt> <userinput>hdparm -i /dev/hda</userinput></screen>
            <para>Вместо <filename>/dev/hda</filename> можно указать любое другое IDE устройство </para>
            <para>Расшифровка</para>
            <para>Max Mult Sect: Это поле содержит максимальное число секторов, которое ваш жесткий диск может прочитать за «один присест». </para>
            <para>Mult Sect: Текущая настройка количества секторов, считываемых за один раз. </para>
            <para>PIO modes и DMA modes: Здесь перечисляются режимы, которые поддерживает жесткий диск. Режим, помеченный символом «звездочка» (*), является текущим. </para>
            <para>Advanced PM: Признак 'yes' указывает на то, что жесткий диск поддерживает APM (Advanced Power Management – Расширенное Управление Питанием). </para>
            <para>Запустив другую команду, вы получите дополнительную информацию: </para>
            <screen><prompt>darkstar:$</prompt> <userinput>hdparm /dev/hda</userinput></screen>
            <para>Результат работы команды: </para>
            <screen>/dev/hda: 
multcount = 0 (on) 
I / O? support = 0 (16-bit) 
unmaskirq = 0 (off) 
using_dma = 0 (off) 
keepsettings = 0 (off) 
nowerr = 0 (off) 
readonly = 0 (off) 
readahead = 8 (on) 
geometry = 2482/255/63, sectors = 39876480, start = 0 </screen>
            <para>Коротко... </para>
            <orderedlist>
                <listitem>
                    <para>multcount – число секторов, считываемых одновременно; </para>
                </listitem>
                <listitem>
                    <para>I/O support – режим обмена с жестким диском (16/32/32sync); </para>
                </listitem>
                <listitem>
                    <para>using_dma – указывает, используется ли в настоящий момент режим DMA или нет; </para>
                </listitem>
                <listitem>
                    <para>keepsettings – указывает, сохраняются ли настройки после программного сброса (изменять эту настройку не рекомендуется, если вы не уверены в том, что делаете); </para>
                </listitem>
                <listitem>
                    <para>readonly – обычно установлен в 1 только для CD-ROM, этот флаг сообщает системе  является ли устройство read-only или нет; </para>
                </listitem>
                <listitem>
                    <para>readahead – количество секторов для опережающего чтения; </para>
                </listitem>
            </orderedlist>
        </section>
        <section>
            <title>Настройка</title>
            <warning>
                <para>Неправильная настройка может привести к потере данных на жёстком диске, а возможно и самого дика. </para>
            </warning>
            <section>
                <title>I/O Support</title>
                <para><parameter>-с0</parameter> — установка 16-и битного режима (по-умолчанию)</para>
                <para><parameter>-c1</parameter> — установка 32-х битного режима (обычно то, что вам нужно)</para>
                <para><parameter>-c3</parameter> — установка 32-х битного синхронного режима (мне не известно, когда именно это надо)</para>
            </section>
            <section>
                <title>Multicount</title>
                <para>Количество секторов передаваемых сразу (одним блоком). Степень двойки, максимальное число — параметр Max Mult Sect в выводе <command>hdparm -i</command>. Чаще всего вам именно его и нужно указывать. </para>
            </section>
            <section>
                <title>Включение DMA</title>
                <para>Большинство современных чипсетов и HDD поддерживают DMA под линуксом. Для некоторых самых новых чипсетов в данный момент поддержки DMA может не быть, однако это не так часто бывает. Обычно в течении нескольких недель после выхода нового чипсета появляется его поддержка в последнем ядре, так что если DMA у вас не включается, то следует, скорее всего, обновить ядро. </para>
                <para><parameter>-d0</parameter> — запрещение DMA</para>
                <para><parameter>-d1</parameter> — включение DMA </para>
            </section>
            <section>
                <title>DMA mode и PIO mode</title>
                <para>Самая опасная настройка — её неправильное использование чаще всего приводит к повреждению данных или оборудования. </para>
                <para><parameter>-X<replaceable>&lt;число&gt;</replaceable></parameter> — установка режима PIO или DMA </para>
                <para>Режимы multiword DMA: </para>
                <para>32 (базовое число) + номер режима: </para>
                <para><parameter>-X32</parameter> — mdma0 </para>
                <para><parameter>-X33</parameter> — mdma1 </para>
                <para><parameter>-X34</parameter> — mdma2 </para>
                <para>Для PIO базовое число 8, для Ultra DMA? 64. </para>
                <para><parameter>-X64</parameter> — udma0 </para>
                <para><parameter>-X65</parameter> — udma1 </para>
                <para><parameter>-X66</parameter> — udma2 </para>
                <para><parameter>-X67</parameter> — udma3 </para>
                <para><parameter>-X68</parameter> — udma4 </para>
                <para><parameter>-X69</parameter> — udma5 </para>
            </section>
            <section>
                <title>Readahead (опережающее чтение)</title>
                <para>На сколько секторов вперёд читать при запросе. Ускоряет производительность при чтении файлов большого размера, однако замедляет работу с файлами небольшого размера. </para>
                <para>Лучше всего установить то же значение, что и для multicount. </para>
                <para><parameter>-a<replaceable>N</replaceable></parameter> — опережающее чтение N секторов </para>
            </section>
        </section>
        <section>
            <title>Тестирование</title>
            <para>Для тестирования наберите: </para>
            <screen><prompt>#</prompt> <userinput>hdparm -t <replaceable>&lt;имя устройства&gt;</replaceable></userinput></screen>
            <para>Желательно это делать, когда заметной дисковой активности нет. </para>
            <para>Потом попробуйте какой-нибудь вариант конфигурации, например: </para>
            <screen><prompt>#</prompt> <userinput>hdparm -u1c1d1m8a8 <replaceable>&lt;имя устройства&gt;</replaceable></userinput></screen>
            <para>После чего опять повторите: </para>
            <screen><prompt>#</prompt> <userinput>hdparm -t <replaceable>&lt;имя устройства&gt;</replaceable></userinput></screen>
            <para>И сравните результаты. </para>
            <para>По результату этого теста не стоит подбирать опции <parameter>-a</parameter> и <parameter>-m</parameter>, для этого лучим тестом будут реальные приложения, исполняемые на вашей машине. Если это домашняя машина, а не боевой сервер, на котором важна сверхтонкая подстройка (но на таких серверах редко оказываются IDE-диски, о которых здесь идёт речь), то тогда параметр multicount (<parameter>-m</parameter>) ставите на максимум, а параметр read-ahead (<parameter>-a</parameter>) равным multicount. </para>
        </section>
    </section>
    <section>
        <info>
            <title>Ускорение загрузки системы</title>
        </info>
        <para>Ссылка на оригинал: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/Ускорение_загрузки_системы">http://ru.gentoo-wiki.com/Ускорение загрузки системы</link>
        </para>
        <para>Перенесено в: 1.5</para>
        <section>
            <title>Введение</title>
            <para>Одно из достоинств Gentoo Linux - это возможность настроить и оптимизировать буквально ВСЮ систему, в том числе и её загрузку. Данное направление оптимизации практически неисчерпаемо. При желании (но и при большом риске убить систему) загрузку можно довести и до нескольких секунд. Здесь же мы рассмотрим некоторые наиболее простые и безопасные методы ускорения загрузки. </para>
        </section>
        <section>
            <title>Параллельный запуск</title>
            <para>Первое, что может дать заметный прирост скорости загрузки, это распараллеливание запуска системных сервисов. В файле <filename>/etc/conf.d/rc</filename> замените <code>NO</code> на <code>YES</code> в переменной <varname>RC_PARALLEL_STARTUP</varname>.</para>
            <example>
                <title>Файл: /etc/conf.d/rc</title>
                <programlisting>...
RC_PARALLEL_STARTUP="YES"
... </programlisting>
            </example>
            <para>Если у вас нет такой переменной, обновите пакет baselayout <command>emerge -u baselayout</command>.</para>
            <note>
                <para>Если эта настройка создаст проблемы при загрузке (некоторые сервисы могут пытаться загрузиться не тогда, когда это нужно), то верните значение <code>NO</code>.</para>
            </note>
            <para>Значительно был улучшен механизм параллельного запуска в новых (нестабильных) версиях baselayout <command>echo "sys-apps/baselayout ~x86" &gt;&gt; /etc/portage/package.keywords emerge sync &amp;&amp; emerge sys-apps/baselayout -u</command>
            </para>
            <para>Для совсем реактивного запуска используйте initng </para>
            <screen><prompt>#</prompt> <userinput>emerge sys-apps/initng</userinput></screen>
        </section>
        <section>
            <title>Локальная сеть</title>
            <para>Если вы часто работаете без подключения к локальной сети, то наверняка заметили, как много времени уходит на определение настроек сети (точнее, на определение того, что настраивать нечего). В этом случае поможет демон ifplugd, который определяет, подключен ли сетевой кабель (точнее, активна ли сеть). Итак: </para>
            <screen><prompt>#</prompt> <userinput>emerge -n ifplugd</userinput></screen>
            <para>теперь добавляем ifplugd в список запускаемых сервисов: </para>
            <screen><prompt>#</prompt> <userinput>rc-update add ifplugd boot</userinput></screen>
        </section>
        <section>
            <title>Обновление зависимостей и переменных окружения</title>
            <para>Каждый раз при загрузке Gentoo обновляет зависимости модулей и переменные окружения, разумеется, что это имеет смысл лишь тогда, когда вы действительно внесли изменения в вашу систему. Чтобы это осуществить, сделаем следующие изменения. </para>
            <para>Меняем:</para>
            <example>
                <title>Файл: <filename>/etc/init.d/modules</filename> - оригинал</title>
                <programlisting>...
ebegin "Calculating module dependencies"
    /sbin/modules-update &amp;>/dev/null
    eend $? "Failed to calculate dependencies"
...</programlisting>
            </example>
            <example>
                <title>Файл: <filename>/etc/init.d/modules</filename> - замена</title>
                <programlisting>...
if [ /etc/modules.d -nt /etc/modules.conf ]
    then
        ebegin "Calculating module dependencies"
        /sbin/modules-update &amp;>/dev/null
        eend $? "Failed to calculate dependencies"
    else
        einfo "Module dependencies are up-to-date"
fi
... </programlisting>
            </example>
            <para>Меняем: </para>
            <example>
                <title>Файл: <filename>/etc/init.d/bootmisc</filename> - оригинал</title>
                <programlisting>...
if [ -x /sbin/env-update.sh ]
    then
        ebegin "Updating environment"
        /sbin/env-update.sh >/dev/null
        eend 0
fi
...</programlisting>
            </example>
            <example>
                <title>Файл: <filename>/etc/init.d/bootmisc</filename> - замена</title>
                <programlisting>...
if [ -x /sbin/env-update.sh ]
  then
    if [ /etc/env.d -nt /etc/profile.env ]
      then
        ebegin "Updating environment"
        /sbin/env-update.sh >/dev/null
        eend 0
      else
        einfo "Environment up-to-date"
    fi
fi
... </programlisting>
            </example>
            <note>
                <para>При использовании данного трюка следует быть внимательным при обновлении baselayout, т.к. обновление каждый раз будет пытаться вернуть изменения, сделанные вами. </para>
            </note>
        </section>
        <section>
            <title>Монтирование локальных файловых систем</title>
            <para>Можно подправить сервис <systemitem class="service">localmount</systemitem>, чтобы он монтировал локальные файловые системы не одну за другой, а все сразу. </para>
            <para>Замените: </para>
            <example>
                <title>Файл: <filename>/etc/init.d/localmount</filename> - оригинал</title>
                <programlisting>...
mount -at ... >/dev/null
... </programlisting>
            </example>
            <example>
                <title>Файл: <filename>/etc/init.d/localmount</filename> - замена</title>
                <programlisting>...
mount -aFt ... >/dev/null
... </programlisting>
            </example>
        </section>
    </section>
</article>
