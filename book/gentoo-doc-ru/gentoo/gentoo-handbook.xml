<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbookxi.rng" type="xml"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="gentoo-handbook" xreflabel="Настольная книга Gentoo Linux x86">
    <info>
        <title>Настольная книга Gentoo Linux x86</title>
    </info>
    <para>Ссылка на оригинал: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gentoo.org/doc/ru/handbook/handbook-x86.xml">http://www.gentoo.org/doc/ru/handbook/handbook-x86.xml</link></para>
    <para>С версии: 1.0</para>
    <para>Содержание:</para>
    <para><xref xlink:href="#gnt-hb.install"/></para>
    <para>Из этой части вы узнаете, как устанавливать Gentoo на свою систему. </para>
    <para>Об установке Gentoo Linux</para>
    <para>В этой главе дается общее представление о предлагаемом порядке установки. </para>
    <para>Выбор подходящего источника для установки</para>
    <para>Gentoo можно устанавливать по-разному. Здесь описывается, как установить Gentoo с минимального установочного диска. Способ подходит и для установки с универсального установочного диска. </para>
    <para>Настройка сети</para>
    <para>Чтобы загрузить новейший исходный код, потребуется настройка сети. Здесь описывается порядок ее выполнения. </para>
    <para>Подготовка дисков</para>
    <para>Чтобы установить Gentoo, нужно создать подходящие дисковые разделы. В этой главе описывается, как разбить диск для будущего использования. </para>
    <para>Установка установочных файлов Gentoo</para>
    <para>Установка Gentoo выполняется с помощью архива третьей стадии (stage3). В этой главе мы расскажем, как извлечь файл третьей стадии и настроить Portage. </para>
    <para>Установка базовой системы Gentoo</para>
    <para>После установки и настройки третьей стадии в вашем распоряжении оказывается базовая система Gentoo. Здесь описывается, как этого достичь. </para>
    <para>Настройка ядра</para>
    <para>Ядро Linux — сердце каждого дистрибутива. В этой главе описывается, как его настроить. </para>
    <para>Настройка параметров системы</para>
    <para>Вам потребуется отредактировать несколько важных конфигурационных файлов. Из этой главы вы получите представление об этих файлах и поймете, как с ними обращаться. </para>
    <para>Установка нужных системных средств</para>
    <para>Как отмечено ранее, Gentoo — это богатство выбора. В этой главе мы поможем вам выбрать и установить некоторые важные инструменты. </para>
    <para>Настройка начального загрузчика</para>
    <para>Для архитектуры x86 существует несколько загрузчиков. Каждый из них настраивается по-своему. В этой главе мы шаг за шагом объясним вам порядок настройки начального загрузчика для ваших нужд. </para>
    <para>Завершение установки Gentoo</para>
    <para>Установка почти закончена. Осталось создать одну (или несколько) учетных записей для пользователей вашей системы. Как это делается, описано в данной главе. </para>
    <para>Чем заняться дальше?</para>
    <para>Теперь у вас появилась собственная система Gentoo. Но чем же заняться дальше? </para>
    <para/>
    <para><xref xlink:href="#gnt-hb.working"/></para>
    <para>Здесь вы научитесь работать с Gentoo: устанавливать программное обеспечение, изменять значения переменных, управлять поведением Portage и т.д. </para>
    <para>Введение в Portage</para>
    <para>В этой главе описываются «простые» шаги, которые вам точно потребуется знать для поддержания в порядке и обслуживания программного обеспечения. </para>
    <para>USE-флаги</para>
    <para>USE-флаги (признаки использования) — очень важный аспект Gentoo. Прочитав эту главу, вы научитесь обращаться с ними и разберетесь, как USE-флаги влияют на систему. </para>
    <para>Возможности Portage</para>
    <para>Откройте для себя дополнительные возможности Portage: поддержку распределенной компиляции, кэш компилятора и др. </para>
    <para>Сценарии инициализации</para>
    <para>В Gentoo используется специальный формат сценариев инициализации (initscript), в котором, например, предусмотрены решения, управляемые зависимостями, и виртуальные сценарии. Здесь описываются эти аспекты, и объясняется, как обращаться со сценариями. </para>
    <para>Переменные среды</para>
    <para>В Gentoo можно довольно легко управлять системными переменными среды. В этой главе объясняется, как это делать, и описываются часто используемые переменные.</para>
    <para/>
    <para><xref xlink:href="#gnt-hb.portage"/></para>
    <para>В этой части подробно описывается Portage, средство управления программным обеспечением Gentoo.</para>
    <para>Файлы и каталоги</para>
    <para>Чтобы поближе познакомиться с Portage, вам потребуется узнать, где же хранятся его файлы и данные. </para>
    <para>Настройка с помощью переменных</para>
    <para>Portage полностью настраивается с помощью различных переменных, которые устанавливаются в конфигурационном файле или как переменные среды. </para>
    <para>Смешение ветвей программного обеспечения</para>
    <para>Программное обеспечение в составе Gentoo подразделяется на ветви в зависимости от стабильности и поддержки различных архитектур. В этой главе рассказывается, как настраивать использование ветвей, а также как при необходимости преодолевать такое разделение. </para>
    <para>Дополнительные средства Portage</para>
    <para>В состав Portage входит несколько дополнительных инструментов, которые могут значительно улучшить ваше впечатление от Gentoo. В этой главе раскрываются секреты использования dispatch-conf и других инструментов. </para>
    <para>Отступление от официального дерева</para>
    <para>Здесь даются советы и показываются приемы «выращивания» собственного дерева Portage, рассказывается о том, как синхронизировать только нужные категории, добавлять свои пакеты и т.д. </para>
    <para>Использование ebuild</para>
    <para>В этой главе рассказывается о шагах, выполняемых Portage при установке программного обеспечения, и об их самостоятельном выполнении с помощью утилиты ebuild. </para>
    <para/>
    <para><xref xlink:href="#gnt-hb.network"/></para>
    <para>Полное руководство по сетям в Gentoo.</para>
    <para>Начальная настройка</para>
    <para>Руководство по быстрому запуску и подключению сетевого интерфейса в наиболее распространенных случаях. </para>
    <para>Расширенная настройка</para>
    <para>Здесь вы изучите, как работает конфигурация — это нужно сделать перед изучением модульного построения сети. </para>
    <para>Модульное построение сети</para>
    <para>В Gentoo предусмотрены гибкие сетевые средства: здесь рассказывается о выборе различных клиентов DHCP, настройке объединения, образования мостов, виртуальных сетей (VLAN) и т.п. </para>
    <para>Беспроводная сеть</para>
    <para>Настроить беспроводную сеть не совсем просто. Надеемся, мы поможем вам заставить ее работать. </para>
    <para>Дополнительные возможности</para>
    <para>Если вы ищете приключений, можете подключить к сети свои собственные функции. </para>
    <para>Управление сетью</para>
    <para>Для пользователей ноутбуков и тех, кто перемещает свои компьютеры из сети в сеть. </para>
    <section xml:id="gnt-hb.install" xreflabel="Установка  Gentoo">
        <info>
            <title>Установка  Gentoo</title>
        </info>
        <section xreflabel="Об установке Gentoo Linux">
            <title>Об установке Gentoo Linux</title>
            <section xreflabel="Введение">
                <title>Введение</title>
                <section xreflabel="Добро пожаловать!">
                    <title>Добро пожаловать!</title>
                    <para>Прежде всего, добро пожаловать в Gentoo! Вы — на пороге мира больших возможностей и высокой производительности! Gentoo весь пропитан идеей свободы выбора. При установке Gentoo вы не раз убедитесь в этом: вам предстоит выбрать объем самостоятельной компиляции, способ установки Gentoo, службу журналирования системы и т.д. </para>
                    <para>Gentoo — быстрый современный метадистрибутив, обладающий большой чистотой и гибкостью. Gentoo основан на свободном программном обеспечении, и не скрывает от пользователя, «что под капотом». Portage, система управления пакетами Gentoo, написана на языке Python, что позволяет легко просматривать и изменять ее исходный код. Сборка Gentoo также выполняется из исходных текстов (хотя есть и поддержка бинарных пакетов), а настройка Gentoo выполняется с помощью обычных текстовых файлов. Другими словами — сплошная открытость и свобода! </para>
                    <para>Важно понимать, что Gentoo развивается именно благодаря свободе выбора. Мы стараемся ничего вам не навязывать. А если вам покажется обратное — пожалуйста, <link xlink:href="http://bugs.gentoo.org/">сообщите нам об этой оплошности</link>. </para>
                </section>
                <section xreflabel="Как организована установка?">
                    <title>Как организована установка?</title>
                    <para>Установка Gentoo рассматривается как последовательность из 10 шагов, которым соответствуют главы 2—11. Каждый шаг приводит к определенному состоянию: </para>
                    <orderedlist>
                        <listitem>
                            <para>результат шага 1: вы — в рабочей среде, готовой к установке Gentoo; </para>
                        </listitem>
                        <listitem>
                            <para>результат шага 2: ваше подключение к интернету готово для установки Gentoo; </para>
                        </listitem>
                        <listitem>
                            <para>результат шага 3: ваши жесткие диски готовы стать родным домом для Gentoo;</para>
                        </listitem>
                        <listitem>
                            <para>результат шага 4: подготовлена установочная среда, и вы готовы переключиться (chroot) в новую среду; </para>
                        </listitem>
                        <listitem>
                            <para>результат шага 5: развернуты пакеты ядра, общие для всех систем Gentoo; </para>
                        </listitem>
                        <listitem>
                            <para>результат шага 6: вы скомпилировали собственное ядро Linux; </para>
                        </listitem>
                        <listitem>
                            <para>результат шага 7: вы написали большую часть конфигурационных файлов системы Gentoo; </para>
                        </listitem>
                        <listitem>
                            <para>результат шага 8: установлены необходимые системные средства (которые вы сами выбрали из славного списка); </para>
                        </listitem>
                        <listitem>
                            <para>результат шага 9: установлен и настроен избранный загрузчик ОС, и вы вошли в новую систему Gentoo; </para>
                        </listitem>
                        <listitem>
                            <para>результат шага 10: вы можете начинать изучение своей собственной среды Gentoo Linux! </para>
                        </listitem>
                    </orderedlist>
                    <para>Мы приложили все усилия, чтобы объяснить вам все «за» и «против» каждого варианта, когда вам предоставляется возможность выбора. При этом один из вариантов помечен как «По умолчанию: ». Другие варианты помечены как «Альтернатива:». Не подумайте, что вариант по умолчанию — наша рекомендация. Нам просто кажется, что именно его выбирает большинство пользователей. </para>
                    <para>Иногда есть возможность выполнить необязательный шаг. Такие шаги помечены как «Дополнительно:», и не требуются для установки Gentoo. Однако, некоторые из них будут обусловлены вашими предшествующими решениями. Мы будем сообщать об этом, как в момент выбора, так и непосредственно перед описанием необязательных шагов. </para>
                </section>
                <section xreflabel="Какие варианты установки существуют?">
                    <title>Какие варианты установки существуют?</title>
                    <para>Gentoo можно установить разными способами. Можно скачать и запустить один из установочных компакт-дисков, установить с имеющегося дистрибутива, с загрузочного CD (например, Knoppix), из сетевой загрузочной среды, с дискеты аварийного восстановления и т.д. </para>
                    <para>В этом руководстве описывается установка с установочных дисков Gentoo, и, в некоторых случаях, с помощью сетевой загрузки (netboot). Предполагается, что вы собираетесь устанавливать самые свежие версии пакетов. Если вам нужна установка, при которой не требуется использование сети, обратитесь к <link xlink:href="http://www.gentoo.org/doc/en/handbook/2006.1/">настольным книгам Gentoo 2006.1 (англ.)</link>, где даются указания по установке в бессетевой среде. </para>
                    <para>Если вы планируете использовать GRP (Gentoo Reference Platform — эталонная платформа Gentoo, набор бинарных пакетов, предназначенных для немедленного использования сразу после установки Gentoo), вам необходимо следовать инструкциям, приведенных в <link xlink:href="http://www.gentoo.org/doc/en/handbook/2006.1/">настольной книге Gentoo 2006.1 (англ.)</link>. </para>
                    <para>Чтобы получить сведения о других способах установки, прочитайте <link xlink:href="#gentoo-install-alt">описание альтернативных способов установки</link>. Также рекомендуется прочитать <link xlink:href="#gentoo-install-advices">полезные советы по установке Gentoo</link>. Если вы почувствуете, что приведенные указания по установке слишком подробны, обратитесь к краткому руководству по установке (см. <link xlink:href="http://www.gentoo.org/doc/ru/index.xml">перечень документации</link>), если, конечно, такое существует для вашей архитектуры. </para>
                    <para>Кроме того, вы можете выбрать между компиляцией своей системы полностью «с нуля» или установкой заранее собранной среды, позволяющей запустить Gentoo практически моментально. Естественно, есть и промежуточные варианты, в которых вы не компилируете все подряд, а начинаете с полу готовой системы. </para>
                </section>
                <section xreflabel="Появились затруднения?">
                    <title>Появились затруднения?</title>
                    <para>Если при установке вы столкнулись с проблемой (или с ошибкой в документации по установке), войдите в нашу систему <link xlink:href="http://bugs.gentoo.org/">распределения запросов (англ.)</link> и убедитесь, что такая ошибка еще не заявлена. В этом случае, создайте отчет об ошибке, чтобы мы о ней позаботились. Не бойтесь разработчиков, которым выпадает работа над (вашими) ошибками — людей они обычно не едят. </para>
                    <para>Обратите внимание, что, хотя руководство, которое вы сейчас читаете, посвящено определенной архитектуре, в нем упоминаются и другие архитектуры. Это связано с тем, что значительная часть текста настольной книги Gentoo является общей для всех архитектур (чтобы не дублировать работу, а также из-за острой нехватки разработчиков). Во избежание путаницы, мы стараемся сократить такие упоминания до минимума. </para>
                    <para>Если вы не уверены, пользовательская ли у вас ошибка (какую-то ошибку совершили вы, хотя внимательно прочитали документацию), или программная (какую-то ошибку совершили мы, хотя тщательно тестировали установку/документацию), то не стесняясь, заходите на канал #gentoo (а также #gentoo-amd64, #gentoo-ru, #rugentoo) сервера irc.freenode.net. Разумеется, мы в любом случае будем вам рады :) </para>
                    <para>Если у вас есть вопрос, касающийся Gentoo, сначала загляните в список <link xlink:href="#gentoo-faq">распространенных вопросов (FAQ)</link>, входящий в состав <link xlink:href="http://www.gentoo.org/doc/ru/">документации Gentoo</link>. Можно также обратиться к <link xlink:href="http://forums.gentoo.org/viewforum.php?f=40">FAQ (англ.)</link> в наших <link xlink:href="http://forums.gentoo.org/">форумах</link>. Если вы не найдете там ответа, задайте вопрос на #gentoo, нашем IRC-канале на irc.freenode.net. Да-да, кое-кто из нас — маньяки, висящие на IRC :-) </para>
                </section>
            </section>
        </section>
        <section xreflabel="Выбор подходящего источника для установки">
            <title>Выбор подходящего источника для установки</title>
            <section xreflabel="Аппаратные требования">
                <title>Аппаратные требования</title>
                <section>
                    <title>Введение</title>
                    <para>Прежде чем начать, перечислим аппаратные требования, необходимые для успешной установки Gentoo на вашем компьютере. </para>
                </section>
                <section xreflabel="Аппаратные требования">
                    <title>Аппаратные требования</title>
                    <informaltable>
                        <tgroup cols="2">
                            <tbody>
                                <row>
                                    <entry>Центральный процессор</entry>
                                    <entry>i486 или новее</entry>
                                </row>
                                <row>
                                    <entry>Память</entry>
                                    <entry>64 МБ</entry>
                                </row>
                                <row>
                                    <entry>Дисковое пространство</entry>
                                    <entry>1.5 ГБ (исключая пространство подкачки)</entry>
                                </row>
                                <row>
                                    <entry>Пространство подкачки</entry>
                                    <entry>256 МБ</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </section>
            </section>
            <section xreflabel="Установочные компакт-диски Gentoo">
                <title>Установочные компакт-диски Gentoo</title>
                <section xreflabel="Введение">
                    <title>Введение</title>
                    <para><emphasis role="italic">Установочные компакт-диски Gentoo</emphasis> — это загрузочные диски, содержащие самодостаточную среду Gentoo. Они позволяют загружать Linux прямо с компакт-диска. При запуске определяются ваши устройства и загружаются соответствующие драйверы. Эти диски сопровождаются разработчиками Gentoo. </para>
                    <para>Все установочные компакт-диски позволяют загрузиться, настроить сеть, разметить разделы жесткого диска и начать установку Gentoo из интернета. В настоящее время мы выпускаем два установочных компакт-диска, одинаково подходящих для установки Gentoo с загрузкой последних версий существующих пакетов из интернета. </para>
                    <para>Если вы хотите установить Gentoo без работоспособного соединения с интернетом, или желаете использовать одну из существующих программ установки, пожалуйста, следуйте указаниям по установке, приведенным в настольной книге Gentoo 2006.0 (англ.).</para>
                    <para>В настоящее время мы выпускаем два установочных компакт-диска: </para>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para><emphasis role="italic">Минимальный</emphasis> установочный диск Gentoo, маленький загрузочный компакт-диск без излишеств, единственное назначение которого — загрузить систему, подготовить подключение к сети и перейти к установке Gentoo. </para>
                            </listitem>
                            <listitem>
                                <para><emphasis role="italic">Живой установочный диск</emphasis> Gentoo, содержащий все необходимое для установки Gentoo. На нем есть графическая среда, графическая и консольная программы автоматической установки, и, конечно, указания по установке для вашей архитектуры.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <para>Чтобы помочь вам решить, какой из них нужен, мы привели главные преимущества и недостатки каждого диска. </para>
                </section>
                <section>
                    <title>Минимальный установочный диск Gentoo</title>
                    <para>Минимальный установочный диск называется <filename>install-x86-minimal-2006.0.iso</filename> и занимает всего 49 МБ. Gentoo можно устанавливать с этого диска только при постоянном наличии работоспособного подключения к интернету.</para>
                    <informaltable>
                        <tgroup cols="2">
                            <thead>
                                <row>
                                    <entry>Минимальный установочный диск</entry>
                                    <entry>За и против</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>+</entry>
                                    <entry>наименьший объем загрузки из сети</entry>
                                </row>
                                <row>
                                    <entry>–</entry>
                                    <entry>не содержит ни архива stage3, ни снимков Portage, ни готовых двоичных пакетов, и поэтому не подходит для установки без сети</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </section>
                <section>
                    <title>Живой (live) установочный диск Gentoo</title>
                    <para>Живой установочный диск называется <filename>install-x86-universal-2006.0.iso</filename> и занимает 697 МБ. С этого диска вы сможете установить Gentoo даже без исправного подключения к интернету, на случай, если в процессе установки Gentoo на свой компьютер у вас появится неодолимое желание занести его еще и на соседний :)</para>
                    <informaltable>
                        <tgroup cols="2">
                            <thead>
                                <row>
                                    <entry>Живой установочный диск Gentoo</entry>
                                    <entry>За и против</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>+</entry>
                                    <entry>содержит все, что требуется; установку можно выполнять даже без сетевого подключения</entry>
                                </row>
                                <row>
                                    <entry>–</entry>
                                    <entry>огромный объем загрузки</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </section>
                <section>
                    <title>Файл Stage3</title>
                    <para>Архив третьей стадии — stage3 — это файл, содержащий минимальную среду Gentoo, пригодную для продолжения установки Gentoo в соответствии с инструкциями, данными в этом руководстве (другими словами: образ (снимок) минимальной системы. </para>
                    <para>Когда-то в настольной книге Gentoo описывались варианты установки с использованием файла любой из трех существующих стадий создания системы. Несмотря на то, что в Gentoo до сих представлены файлы stage1 и stage2, в официальном способе установки используется архив stage3. Если вас интересует установка Gentoo из файлов stage1 или stage2, пожалуйста, обратитесь к сборнику распространенных вопросов по Gentoo, раздел как установить Gentoo, используя файлы Stage1 или Stage2? </para>
                    <para>Архивы stage3 можно загрузить из <filename>releases/x86/2007.0/stages/</filename> или с любого из <link xlink:href="http://www.gentoo.org/main/ru/mirrors.xml">официальных зеркал Gentoo</link>; на «живом диске» они не поставляются. </para>
                </section>
            </section>
            <section>
                <info>
                    <title>Скачивание, запись и загрузка с установочного диска Gentoo</title>
                </info>
                <para>Скачивание образа и запись на диск</para>
                <para>Итак, вы выбрали нужный установочный диск Gentoo. Начнем с загрузки его образа из сети, и его записи на компакт-диск. Ранее обсуждались варианты доступных дисков, но где же их взять? </para>
                <para>Любой из установочных дисков (а при желании — заодно и диск пакетов, если есть) можно загрузить с одного из наших <link xlink:href="http://www.gentoo.org/main/ru/mirrors.xml">зеркал</link>. Установочные диски расположены в каталоге <filename>releases/x86/2007.0/installcd</filename>. </para>
                <para>В этом каталоге находятся ISO-файлы. Это полные образы компакт-дисков, которые можно записать на CD-R. </para>
                <para>Если вас волнует, не искажен ли загруженный файл, можно сверить его контрольную сумму MD5 с рассчитанной нами (например, <filename>install-x86-minimal-2007.0.iso.DIGESTS</filename>). Вычислить контрольную сумму MD5 можно утилитой <command>md5sum</command> в Linux/Unix, или программой <link xlink:href="http://www.etree.org/md5com.html">md5sum (англ.)</link> для Windows. </para>
                <para>Другой способ убедиться в пригодности загруженного файла — с помощью GnuPG сверить криптографическую подпись с той, что хранится у нас (в файле с расширением <filename>.asc</filename>). Скачайте файл подписи, затем получите открытый ключ:</para>
                <example>
                    <title>Получение открытого ключа</title>
                    <screen><prompt>$</prompt> <userinput>gpg --keyserver subkeys.pgp.net --recv-keys 17072058</userinput></screen>
                </example>
                <para>Теперь сверьте подпись: </para>
                <example>
                    <title>Сверка криптографической подписи</title>
                    <screen><prompt>$</prompt> <userinput>gpg --verify <replaceable>&lt;файл подписи&gt;</replaceable> <replaceable>&lt;скачанный образ диска&gt;</replaceable></userinput></screen>
                </example>
                <para>Записывать загруженный ISO-образ на компакт-диск нужно в «сыром» режиме. Как это сделать, сильно зависит от используемой программы. Здесь мы обсудим запись с помощью cdrecord и K3B. Дополнительные сведения находятся в нашем сборнике распространенных вопросов. </para>
                <para>При использовании cdrecord, просто введите <command>cdrecord dev=/dev/hdc <replaceable>&lt;скачанный iso-файл&gt;</replaceable></command> (<filename>/dev/hdc</filename> замените на путь к вашему устройству CD-RW). </para>
                <para>При использования K3B, выберите <menuchoice>
                        <guimenu>Tools</guimenu>
                        <guisubmenu>CD</guisubmenu>
                        <guimenuitem>Burn Image</guimenuitem>
                    </menuchoice> (<menuchoice>
                        <guimenu>Инструменты</guimenu>
                        <guisubmenu>Компакт-диск</guisubmenu>
                        <guimenuitem>Прожечь образ</guimenuitem>
                    </menuchoice>). Затем в области 'Image to Burn' ('Образ для записи') укажите свой ISO-файл. В завершение нажмите Start (Запуск). </para>
            </section>
            <section>
                <title>Загрузка с установочного компакт-диска</title>
                <important>
                    <para>Перед тем, как приступить, полностью прочитайте этот подраздел, так как перед последующими действиями вам, скорее всего, больше не представится такая возможность. </para>
                </important>
                <para>Записав установочный компакт-диск, пора его загрузить. Уберите все компакт-диски из своих приводов CD, перезагрузите компьютер и войдите в BIOS. В зависимости от BIOS, для этого обычно нужно нажать <keycap>DEL</keycap>, <keycap>F1</keycap> или <keycap>ESC</keycap>. В BIOS измените порядок загрузки так, чтобы обращение к CD-ROM выполнялось до обращения к жесткому диску. Этот параметр часто задается в разделе «CMOS Setup». Если порядок загрузки не изменить, система просто перезагрузится с жесткого диска, игнорируя CD-ROM. </para>
                <para>Теперь поместите установочный диск в привод CD-ROM (наконец-то!) и перезагрузитесь. Должно появиться загрузочное приглашение. Здесь можно просто нажать <keycap>ENTER</keycap>, чтобы запустить процесс загрузки с параметрами по умолчанию, или загрузить установочный диск по-своему: указать ядро, потом загрузочные параметры, а затем нажать <keycap>ENTER</keycap>. </para>
                <para>Указать ядро? Да, на нашем установочном компакт-диске есть несколько вариантов ядра. По умолчанию используется gentoo. Другие ядра предназначены для специфических аппаратных задач; вариант <option>-nofb</option> отключает кадровый буфер. </para>
                <para>Ниже перечислены доступные варианты ядра: </para>
                <informaltable>
                    <tgroup cols="2">
                        <thead>
                            <row>
                                <entry>Ядро</entry>
                                <entry>Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>gentoo</entry>
                                <entry>ядро 2.6 с многопроцессорной поддержкой (используется по умолчанию)</entry>
                            </row>
                            <row>
                                <entry>gentoo-nofb</entry>
                                <entry>аналогично gentoo, но без поддержки кадрового буфера</entry>
                            </row>
                            <row>
                                <entry>memtest86</entry>
                                <entry>для выявления ошибок локальной оперативной памяти</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para>Также можно указать параметры ядра, явно включающие или отключающие определенные режимы. Приведенный список соответствует тому, что выводится при нажатия F2 в экране загрузки. </para>
                <para>Листинг 3: Параметры, которые можно сообщить выбранному ядру</para>
                <example>
                    <title>Параметры, которые можно сообщить выбранному ядру</title>
                    <screen>- agpgart      загрузка agpgart (используйте при сбоях графики, зависаниях)
- acpi=on      включение поддержки ACPI
- ide=nodma    принудительное отключение DMA для сбойных IDE-устройств
- doscsi       поиск scsi-устройств (нарушает работу некоторых ethernet-плат)
- dopcmcia     запуск службы pcmcia для PCMCIA-приводов компакт-дисков
- nofirewire   отключение в initrd модулей firewire (предназначенных для
                  приводов компакт-дисков с подключением firewire и т.п.)
- nokeymap     отключение выбора неамериканских раскладок клавиатуры
- docache      кэширование исполняемой части компакт-диска в памяти, позволяет
                  размонтировать /mnt/cdrom для установки другого диска 
- nodetect     запрет запуска hwsetup/kudzu и hotplug
- nousb        отключение загрузки модулей usb в initrd, отключает hotplug
- nodhcp       отмена автоматического запуска dhcp при обнаружении сетевой 
                  платы
- nohotplug    отключение загрузки службы hotplug
- noapic       отключение apic (попробуйте, если есть аппаратные проблемы
                  с устройствами scsi, сетевыми платами и т.д.)
- noevms       отключение поддержки модулей EVMS2
- nolvm2       отключение поддержки модулей LVM2
- hdx=stroke   озволяет использовать жесткий диск целиком, даже если BIOS 
                  не поддерживает диски большого размера
- noload=module1,[module2,[...]]
                   запрет загрузки определенных модулей ядра</screen>
                </example>
                <para>Теперь загрузите систему с компакт-диска, выбрав ядро (если вас не устраивает ядро по умолчанию gentoo) и указав дополнительные параметры. В качестве примера мы покажем, как загрузить ядро gentoo с параметром dopcmcia: </para>
                <example>
                    <title>Загрузка установочного диска</title>
                    <screen><prompt>boot:</prompt> <userinput>gentoo dopcmcia</userinput></screen>
                </example>
                <para>Появится заставка с полосой индикатора загрузки. Если вы устанавливаете Gentoo на машину с не американской раскладкой клавиатуры, нужно немедленно нажать ALT+F1, чтобы переключиться в подробный режим, и следовать появившимся указаниям. Если ничего не выбрано в течение 10 секунд, устанавливается раскладка по умолчанию (клавиатура США), а загрузка продолжается. По окончании загрузки для вас будет выполнен автоматический вход в «живой» Gentoo Linux в качестве «root» (администратора). В текущей консоли должно появиться прилашение root («#»). Также можно переключаться в другие консоли, нажимая <keycombo>
                        <keycap>ALT</keycap>
                        <keycap>F2</keycap>
                    </keycombo>, <keycombo>
                        <keycap>ALT</keycap>
                        <keycap>F3</keycap>
                    </keycombo> и <keycombo>
                        <keycap>ALT</keycap>
                        <keycap>F4</keycap>
                    </keycombo>. Вернуться в первоначальную консоль можно нажатием <keycombo>
                        <keycap>ALT</keycap>
                        <keycap>F1</keycap>
                    </keycombo>. </para>
                <para>Приступим к дополнительной настройке оборудования. </para>
            </section>
            <section>
                <title>Дополнительная настройка оборудования</title>
                <para>При загрузке с установочного компакт-диска система пытается определить все устройства и загрузить соответствующие модули для их поддержки. В подавляющем большинстве случаев она очень хорошо справляется с этим. Однако, в редких случаях некоторые из нужных модулей не загружаются автоматически. Если какие-либо устройства пропущены при автоматическом опросе шины PCI, модули ядра для их поддержки вам придется загрузить вручную. </para>
                <para>В следующем примере мы попробуем загрузить модуль 8139too (для поддержки некоторых типов сетевого интерфейса): </para>
                <example>
                    <title>Загрузка модуля ядра</title>
                    <screen><prompt>#</prompt> <userinput>modprobe 8139too</userinput></screen>
                </example>
                <para>Если вам нужна поддержка PCMCIA, требуется запустить сценарий инициализации pcmcia: </para>
                <example>
                    <title>Запуск сценария инициализации PCMCIA</title>
                    <screen><prompt>#</prompt> <userinput>/etc/init.d/pcmcia start</userinput></screen>
                </example>
                <para>Дополнительно: оптимизация скорости жесткого диска</para>
                <para>Если вы опытный пользователь, возможно, вам захочется настроить скоростные параметры жесткого диска IDE с помощью программы <command>hdparm</command>. Указав параметр <option>-tT</option>, можно измерить скорость вашего диска (для уточнения значений запускайте программу несколько раз подряд): </para>
                <example>
                    <title>Тестирование производительности диска</title>
                    <screen><prompt>#</prompt> <userinput>hdparm -tT /dev/hda</userinput></screen>
                </example>
                <para>Для настройки вы можете использовать любой из приведенных примеров (или поэкспериментировать самостоятельно), при необходимости указав название своего диска вместо <filename>/dev/hda</filename>: </para>
                <example>
                    <title>Оптимизация скорости жесткого диска</title>
                    <screen><lineannotation>Включение DMA:</lineannotation>
<prompt>#</prompt> <userinput>hdparm -d 1 /dev/hda</userinput>
<lineannotation>Установка безопасных значений:</lineannotation>
<prompt>#</prompt> <userinput>hdparm -d 1 -A 1 -m 16 -u 1 -a 64 /dev/hda</userinput></screen>
                </example>
            </section>
            <section xml:id="gnt-hb.user-accounts" xreflabel="Дополнительно: учетные записи пользователей">
                <title>Дополнительно: учетные записи пользователей</title>
                <para>Если вы собираетесь дать другим людям доступ к своей системе, или намерены входить в чат irssi без прав администратора (из соображений безопасности), потребуется создать учетные записи пользователей и изменить пароль администратора. </para>
                <para>Для изменения пароля администратора используйте <command>passwd</command>: </para>
                <example>
                    <title>Изменение пароля администратора</title>
                    <screen><prompt>#</prompt> <userinput>passwd</userinput>
New password: <userinput><replaceable>(введите новый пароль)</replaceable></userinput>
Re-enter password: <userinput><replaceable>(введите новый пароль еще раз)</replaceable></userinput></screen>
                </example>
                <para>Для создания учетной записи пользователя сначала задаются его реквизиты, а затем вводится пароль. Для этого служат программы <command>useradd</command> и <command>passwd</command>. В следующем примере мы создадим пользователя «john»: </para>
                <example>
                    <title>Создание учетной записи пользователя</title>
                    <screen><prompt>#</prompt> <userinput>useradd -m -G users john</userinput>
<prompt>#</prompt> <userinput>passwd john</userinput>
New password: <userinput><replaceable>(введите новый пароль для john)</replaceable></userinput>
Re-enter password: <userinput><replaceable>(введите новый пароль Джона еще раз)</replaceable></userinput></screen>
                </example>
                <para>Вы также можете изменить свой идентификатор пользователя с администратора (root) на вновь созданного пользователя командой <command>su</command>: </para>
                <example>
                    <title>Изменение идентификатора пользователя</title>
                    <screen><prompt>#</prompt> <userinput>su - john</userinput></screen>
                </example>
            </section>
            <section>
                <title>Дополнительно: просмотр документации во время установки</title>
                <para>Если вам нужна возможность просмотра настольной книги Gentoo в процессе установки (не важно, из сети или с компакт-диска), убедитесь, что вы создали учетную запись обычного пользователя (см. <xref xlink:href="#gnt-hb.user-accounts"/>). Затем нажмите <keycombo>
                        <keycap>ALT</keycap>
                        <keycap>F2</keycap>
                    </keycombo> для перехода в другой терминал, и войдите в систему. </para>
                <para>Для чтения документации c компакт-диска, вы можете сразу запустить <command>links</command>: </para>
                <example>
                    <title>Просмотр документации с компакт-диска</title>
                    <screen><prompt>#</prompt> <userinput>links /mnt/cdrom/docs/html/index.html</userinput></screen>
                </example>
                <para>Но лучше открывать настольную книгу Gentoo из сети (там она новее, чем на компакт-диске). Для этого тоже можно пользоваться links, но только после настройки сети (иначе вы не сможете выйти в интернет, чтобы прочесть документ): </para>
                <example>
                    <title>Просмотр документации, находящейся в сети</title>
                    <screen><prompt>#</prompt> <userinput>links http://www.gentoo.org/doc/ru/handbook/handbook-x86.xml</userinput></screen>
                </example>
                <para>На исходный терминал можно переключаться нажатием <keycombo>
                        <keycap>ALT</keycap>
                        <keycap>F1</keycap>
                    </keycombo>. </para>
            </section>
            <section>
                <title>Дополнительно: запуск демона SSH</title>
                <para>Если вы хотите разрешить другим пользователям доступ к своей системе в процессе установки Gentoo (возможно затем, чтобы они помогли вам с установкой или даже провели ее за вас), для них потребуется создать учетные записи, а возможно, даже дать им пароль администратора (делайте это только в том случае, если вы им полностью доверяете). </para>
                <para>Чтобы запустить демон SSH, выполните следующую команду: </para>
                <example>
                    <title>Запуск демона SSH</title>
                    <screen><prompt>#</prompt> <userinput>/etc/init.d/sshd start</userinput></screen>
                </example>
                <para>Для использования sshd, сначала требуется настроить сеть. Переходите к главе <xref xlink:href="#gnt-hb.network-config"/>. </para>
            </section>
        </section>
        <section xml:id="gnt-hb.network-config" xreflabel="Настройка сети">
            <title>Настройка сети</title>
            <section>
                <title>Автоматическое подключение к сети</title>
                <section>
                    <title>Может, она уже настроена?</title>
                    <para>Если ваша система подсоединена к сети Ethernet, в которой есть сервер DHCP, очень вероятно, что сетевое подключение на вашей машине уже автоматически настроено. Если так, вы сможете воспользоваться многими сетевыми командами, находящимися на установочном компакт-диске, например, <command>ssh</command>, <command>scp</command>, <command>ping</command>, <command>irssi</command>, <command>wget</command> и <command>links</command>. </para>
                    <para>Если сеть уже настроена, команда <command>/sbin/ifconfig</command> должна показывать сетевые интерфейсы кроме lo, например, eth0: </para>
                    <example>
                        <title>/sbin/ifconfig для рабочей сетевой конфигурации</title>
                        <screen><prompt>#</prompt> <userinput>/sbin/ifconfig</userinput>
(...)
eth0   Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11 Base address:0xe800</screen>
                    </example>
                </section>
                <section>
                    <title>Дополнительно: указание прокси-серверов</title>
                    <para>Если вы подключены к интернету через прокси-сервер, при установке вам может потребоваться ввести сведения о нем. Задать прокси-сервер очень просто: нужно определить переменные, содержащие необходимые сведения. </para>
                    <para>В большинстве случаев в определении переменных достаточно указать имя прокси-сервера. Предположим, например, что прокси-сервер называется proxy.gentoo.org, а его порт — 8080: </para>
                    <example>
                        <title>Указание прокси-сервера</title>
                        <screen> <lineannotation>(если прокси-сервер фильтрует трафик HTTP)</lineannotation>
<prompt>#</prompt> <userinput>export http_proxy="http://proxy.gentoo.org:8080"</userinput>
 <lineannotation>(если прокси-сервер фильтрует трафик FTP)</lineannotation>
<prompt>#</prompt> <userinput>export ftp_proxy="ftp://proxy.gentoo.org:8080"</userinput>
 <lineannotation>(если прокси-сервер фильтрует трафик RSYNC)</lineannotation>
<prompt>#</prompt> <userinput>export RSYNC_PROXY="proxy.gentoo.org:8080"</userinput></screen>
                    </example>
                    <para>Если прокси-сервер запрашивает имя пользователя и пароль, для значения переменной следует использовать такой формат: </para>
                    <example>
                        <title>Указание имени/пароля в адресе прокси-сервера</title>
                        <programlisting>http://имя_пользователя:пароль@proxy.gentoo.org:8080</programlisting>
                    </example>
                </section>
                <section>
                    <title>Проверка сети</title>
                    <para>Может оказаться полезным проверить отклик DNS-сервера вашего поставщика услуг интернета (адрес сервера находится в <filename>/etc/resolv.conf</filename>), а также произвольного веб-сайта, чтобы убедиться, что ваши пакеты выходят в интернет, разрешение имен DNS работает и т.д. </para>
                    <example>
                        <title>Проверка доступности сети</title>
                        <screen><prompt>#</prompt> <userinput>ping -c 3 google.com</userinput></screen>
                    </example>
                    <para>Сеть доступна? Тогда пропустите остаток этого раздела, и переходите к разделу подготовка дисков. Если сеть все же недоступна, то, к сожалению, вам придется еще поработать над ее настройкой. </para>
                </section>
            </section>
            <section>
                <info>
                    <title>Автоматизированная настройка сети</title>
                </info>
                <para>Если сеть не заработает сразу, при установке с некоторых носителей можно использовать net-setup (для обычных или беспроводных сетей), pppoe-setup (для пользователей ADSL) или pptp (для пользователей PPTP; есть на x86, amd64, alpha, ppc и ppc64). </para>
                <para>Если на вашем установочном диске нет ни одного из этих средств, или сеть еще не подключена, приступайте к ручной настройке сети: </para>
                <orderedlist>
                    <listitem>
                        <para>пользователи обычной сети Ethernet — переходите к разделу по умолчанию: использование net-setup; </para>
                    </listitem>
                    <listitem>
                        <para>пользователи ADSL — переходите к разделу альтернатива: использование RP-PPPoE; </para>
                    </listitem>
                    <listitem>
                        <para>пользователи PPTP — переходите к разделу альтернатива: использование PPTP; </para>
                    </listitem>
                </orderedlist>
                <section>
                    <title>По умолчанию: использование net-setup</title>
                    <para>Простейший способ настройки сети, если она не произошла автоматически — запуск сценария net-setup: </para>
                    <example>
                        <title>Запуск сценария net-setup</title>
                        <screen><prompt>#</prompt> <userinput>net-setup eth0</userinput></screen>
                    </example>
                    <para>net-setup задаст вам несколько вопросов о вашей сетевой среде. В результате его работы у вас должно появиться работоспособное подключение к сети. Проверьте сетевое подключение, как это описано выше. Если проверка прошла успешно, примите наши поздравления — теперь вы готовы к установке Gentoo. Пропустите оставшуюся часть этого раздела и приступайте к подготовке дисков. </para>
                    <para>Если ваша сеть все еще не заработала, переходите к ручной настройке сети. </para>
                </section>
                <section>
                    <title>Альтернатива: использование RP-PPPoE</title>
                    <para>Для простоты подключения к интернету по PPPoE, в установочный диск (любой версии) включен rp-pppoe. Для настройки соединения используйте сценарий pppoe-setup, входящий в комплект. У вас будет запрошена информация о сетевом устройстве ethernet, подключенном к adsl-модему, имя пользователя, пароль, IP-адреса ваших серверов DNS. Также задается вопрос, нужно ли включать базовый межсетевой экран (firewall). </para>
                    <example>
                        <title>Использование rp-pppoe</title>
                        <screen><prompt>#</prompt> <userinput>pppoe-setup</userinput>
<prompt>#</prompt> <userinput>pppoe-start</userinput></screen>
                    </example>
                    <para>Если что-то пошло не так, проверьте, правильно ли вы ввели имя пользователя и пароль, посмотрев в <filename>/etc/ppp/pap-secrets</filename> или <filename>/etc/ppp/chap-secrets</filename>, и убедитесь, что устройство ethernet указано верно. Если ваше устройство не видно в системе, потребуется загрузить соответствующие сетевые модули. Для этого нужно перейти к разделу ручная настройка сети где мы объясняем, как из загрузить. </para>
                    <para>Если же все заработало, переходите к <link xlink:href="#gnt-hb.prepare-disks">подготовке дисков</link>. </para>
                </section>
                <section>
                    <title>Альтернатива: использование PPTP</title>
                    <note>
                        <para>Поддержка PPTP имеется только для архитектуры x86. </para>
                    </note>
                    <para>Если вам нужна поддержка PPTP, можно использовать pptpclient, который входит в состав нашего установочного диска. Но сначала нужно обеспечить правильность настройки. Отредактируйте файлы <filename>/etc/ppp/pap-secrets</filename> или <filename>/etc/ppp/chap-secrets</filename> так, чтобы в них находилось правильное сочетание имени пользователя и пароля. </para>
                    <example>
                        <title>Редактирование <filename>/etc/ppp/chap-secrets</filename></title>
                        <screen><prompt>#</prompt> <userinput>nano -w /etc/ppp/chap-secrets</userinput></screen>
                    </example>
                    <para>Затем, если нужно, измените параметры PPTP в файле <filename>/etc/ppp/options.pptp</filename>: </para>
                    <example>
                        <title>Редактирование <filename>/etc/ppp/options.pptp</filename></title>
                        <screen><prompt>#</prompt> <userinput>nano -w /etc/ppp/options.pptp</userinput></screen>
                    </example>
                    <para>Когда все будет готово, просто запустите <command>pptp</command> (с параметрами, которые вы не стали прописывать в <filename>options.pptp</filename>), чтобы соединиться с сервером: </para>
                    <example>
                        <title>Подключение к серверу коммутируемого доступа</title>
                        <screen><prompt>#</prompt> <userinput>pptp <replaceable>&lt;server ip&gt;</replaceable></userinput></screen>
                    </example>
                    <para>Теперь переходите к <link xlink:href="#gnt-hb.prepare-disks">подготовке дисков</link>. </para>
                </section>
            </section>
            <section>
                <title>Ручная настройка сети</title>
                <section>
                    <title>Загрузка нужных сетевых модулей</title>
                    <para>При загрузке установочный диск пытается выявить все установленные устройства и загружает подходящие модули ядра (драйверы) для поддержки вашего оборудования. В подавляющем большинстве случаев он очень хорошо справляется с этой работой. Однако, в некоторых случаях он может не справиться с автозагрузкой нужных вам модулей ядра. </para>
                    <para>Если net-setup или pppoe-setup не удалось загрузить нужный модуль, возможно, ваша сетевая плата сразу не обнаружена. При этом вам может потребоваться ручная загрузка необходимых модулей ядра. </para>
                    <para>Чтобы выяснить, какие модули ядра для поддержки сети существуют, используйте <command>ls</command>: </para>
                    <example>
                        <title>Поиск имеющихся модулей</title>
                        <screen><prompt>#</prompt> <userinput>ls /lib/modules/`uname -r`/kernel/drivers/net</userinput></screen>
                    </example>
                    <para>Если вы найдете драйвер для своей сетевой платы, для загрузки модуля ядра используйте <command>modprobe</command>: </para>
                    <example role="">
                        <title>Использование modprobe для загрузки модуля ядра</title>
                        <screen><lineannotation>(для примера загрузим модуль pcnet32)</lineannotation>
<prompt>#</prompt> <userinput>modprobe pcnet32</userinput></screen>
                    </example>
                    <para>Чтобы убедиться, что ваша сетевая плата теперь обнаружена, используйте <command>ifconfig</command>. Если сетевая плата обнаружена, результат выглядит подобным образом: </para>
                    <example>
                        <title>Проверка доступности сетевой платы (удачная)</title>
                        <screen><prompt>#</prompt> <userinput>ifconfig eth0</userinput>
eth0      Link encap:Ethernet  HWaddr FE:FD:00:00:00:00  
          BROADCAST NOARP MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)</screen>
                    </example>
                    <para>Однако, если вы получите такое сообщение об ошибке, сетевая плата не обнаружена: </para>
                    <example>
                        <title>Проверка доступности сетевой платы (неудачная)</title>
                        <screen><prompt>#</prompt> <userinput>ifconfig eth0</userinput>
eth0: error fetching interface information: Device not found</screen>
                    </example>
                    <para>Если в вашей системе установлено несколько сетевых плат, они будут называться eth0, eth1 и т.д. Убедитесь, что сетевая плата, которую вы собираетесь использовать, работает хорошо, и в дальнейшем не забудьте везде подставлять верное имя. Мы предполагаем, что используется сетевая плата eth0. </para>
                    <para>Когда ваша сетевая плата обнаружена, можно попробовать снова запустить net-setup или pppoe-setup (которые теперь должны сработать), но на случай, если вы из крутых, мы опишем, как настроить сеть вручную. </para>
                    <para>Выберите один из следующих разделов, в зависимости от необходимого вида настройки: </para>
                    <orderedlist>
                        <listitem>
                            <para>
                                <link xlink:href="#">использование DHCP для автоматического присвоения IP-адреса;</link>
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <link xlink:href="#">подготовка беспроводного доступа, если у вас есть беспроводная плата;</link>
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <link xlink:href="#">освоение сетевой терминологии: рассказ о том, что нужно знать о подключении к сети;</link>
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <link xlink:href="#">использование ifconfig и route: описание ручной настройки сети;</link>
                            </para>
                        </listitem>
                    </orderedlist>
                </section>
                <section>
                    <title>Использование DHCP</title>
                    <para><indexterm><primary>DHCP</primary></indexterm><acronym>DHCP</acronym> (Dynamic Host Configuration Protocol — протокол динамической настройки хоста) дает возможность автоматически получить параметры сетевого подключения (IP-адрес, маску сети, широковещательный адрес, шлюз, сервера имен и т. д.) Все это работает, только когда в вашей сети есть сервер DHCP (или ваш поставщик предоставляет услугу DHCP). Чтобы сетевой интерфейс получал эти сведения автоматически, используйте <command>dhcpcd</command>: </para>
                    <example>
                        <title>Использование dhcpcd</title>
                        <screen><prompt>#</prompt> <userinput>dhcpcd eth0</userinput>
<lineannotation>Некоторые сетевые администраторы требуют, чтобы вы использовали 
имя хоста и домена, назначенное сервером DHCP.
В этом случае используйте</lineannotation>
<prompt>#</prompt> <userinput>dhcpcd -HD eth0</userinput></screen>
                    </example>
                    <para>Если это сработало (попробуйте «попинговать» какой-нибудь сервер интернета, например, Google), то у вас все настроено, и можно двигаться дальше. Пропустите остаток этого раздела и приступайте к подготовке дисков. </para>
                </section>
                <section>
                    <info>
                        <title>Подготовка беспроводного доступа</title>
                    </info>
                    <note>
                        <para>Поддержка команды <command>iwconfig</command> есть только на установочных дисках для платформ x86, amd64 и ppc. В других случаях вы все же сможете запустить расширения, следуя инструкциям <link xlink:href="ftp://ftp.linux-wlan.org/pub/linux-wlan-ng/README">проекта linux-wlan-ng (англ.)</link>. </para>
                    </note>
                    <para>Если вы используете беспроводную плату (802.11), перед дальнейшими действиями может потребоваться настройка параметров беспроводного подключения. Для просмотра текущей настройки беспроводной платы можете использовать <command>iwconfig</command>. При запуске <command>iwconfig</command> вы увидите подобные сведения: </para>
                    <example>
                        <title>Вывод текущих параметров беспроводного подключения</title>
                        <screen><prompt>#</prompt> <userinput>iwconfig eth0</userinput>
eth0      IEEE 802.11-DS  ESSID:"GentooNode"                                   
          Mode:Managed  Frequency:2.442GHz  Access Point: 00:09:5B:11:CC:F2    
          Bit Rate:11Mb/s   Tx-Power=20 dBm   Sensitivity=0/65535               
          Retry limit:16   RTS thr:off   Fragment thr:off                       
          Power Management:off                                                  
          Link Quality:25/10  Signal level:-51 dBm  Noise level:-102 dBm        
          Rx invalid nwid:5901 Rx invalid crypt:0 Rx invalid frag:0 Tx          
          excessive retries:237 Invalid misc:350282 Missed beacon:84</screen>
                    </example>
                    <note>
                        <para>Некоторые беспроводные платы могут называться подобно wlan0 или ra0, а не eth0. Для определения верного имени устройства запускайте <command>iwconfig</command> без каких-либо параметров командной строки. </para>
                    </note>
                    <para>Для большинства пользователей может потребоваться изменение только двух параметров: ESSID (названия беспроводной сети) и ключа шифрования WEP. Если ESSID и указанный адрес точки доступа уже принадлежат вашей точке доступа, и вы не используете WEP, значит, ваше беспроводное подключение работает. Если вам необходимо изменить свой ESSID или добавить ключ WEP, можно запустить следующие команды: </para>
                    <example>
                        <title>Замена ESSID и/или добавление ключа WEP</title>
                        <screen><lineannotation>(так название сети устанавливается в "GentooNode")</lineannotation>
<prompt>#</prompt> <userinput>iwconfig eth0 essid GentooNode</userinput>
<lineannotation>(так устанавливается шестнадцатиричный ключ WEP)</lineannotation>
<prompt>#</prompt> <userinput>iwconfig eth0 key 1234123412341234abcd</userinput>
<lineannotation>(так устанавливается текстовый ключ (ASCII); вначале нужно добавлять "s:")</lineannotation>
<prompt>#</prompt> <userinput>iwconfig eth0 key s:some-password</userinput></screen>
                    </example>
                    <para>Проверить сделанную настройку можно, снова запустив <command>iwconfig</command>. Как только ваша беспроводная сеть заработает, вы можете перейти к установке параметров сети, относящихся к протоколу IP, которые описываются в следующем разделе (освоение сетевой терминологии), или использовать утилиту <command>net-setup</command>, как описано ранее. </para>
                </section>
                <section>
                    <info>
                        <title>Освоение сетевой терминологии</title>
                    </info>
                    <note>
                        <para>Если вы знаете свой IP-адрес, широковещательный адрес, маску сети и серверы имен, можете пропустить этот подраздел и перейти к разделу использование ifconfig и route. </para>
                    </note>
                    <para>Если все, рассказанное выше, не помогло, вам придется настроить свою сеть вручную. Это совсем нетрудно. Однако, вам понадобится освоить кое-какую сетевую терминологию, знание которой требуется для удовлетворительной настройки сети. Прочитав этот текст, вы узнаете, что такое <emphasis role="italic">шлюз</emphasis>, зачем служит <emphasis role="italic">маска сети</emphasis>, как формируется <emphasis role="italic">широковещательный адрес</emphasis>, и зачем нужны <emphasis role="italic">серверы имен</emphasis>. </para>
                    <para>В сети узлы (хосты, компьютеры) различаются по IP-адресу (адресу протокола интернета). Такой адрес — это сочетание четырех чисел от 0 до 255. Ну, по крайней мере, так мы его воспринимаем. В действительности, IP-адрес состоит из 32 бит (единиц и нулей). Давайте рассмотрим пример: </para>
                    <example>
                        <title>Пример IP-адреса</title>
                        <programlisting>IP-адрес (числа):       192.168.0.2
IP-адрес (биты):        11000000 10101000 00000000 00000010
                        -------- -------- -------- --------
                           192      168       0        2</programlisting>
                    </example>
                    <para>Такой IP-адрес уникален для узла в рамках всех доступных сетей (т. е. каждый узел, с которым вы можете связаться, должен иметь уникальный IP-адрес). Чтобы различать узлы, находящиеся внутри и извне сети, IP-адрес подразделяется на две части: часть <emphasis role="italic">сети</emphasis> и часть <emphasis role="italic">узла</emphasis>. </para>
                    <para>Это разделение записывается с помощью <indexterm><primary>Маска сети</primary></indexterm><firstterm>маски сети</firstterm> — набора единиц, за которым следует набор нулей. Часть IP-адреса, которая попадает на единицы — сетевая, оставшаяся часть — узловая. Как обычно, маска сети может записываться в виде IP-адреса. </para>
                    <example>
                        <title>Пример разделения сети/узла</title>
                        <programlisting>IP-адрес:      192      168      0         2
            11000000 10101000 00000000 00000010
Маска сети: 11111111 11111111 11111111 00000000
               255      255     255        0
           +--------------------------+--------+
                      Сеть               Узел</programlisting>
                    </example>
                    <para>Другими словами, 192.168.0.14 — все еще входит в состав сети из нашего примера, а 192.168.1.2 — уже нет. </para>
                    <para><indexterm><primary>Широковещательный адрес</primary></indexterm><firstterm>Широковещательный адрес</firstterm> — это IP-адрес с такой же сетевой частью, как у вашей сети, но у которого узловая часть состоит только из единиц. Каждый узел вашей сети слушает этот IP-адрес. Он действительно предназначен для широковещательной рассылки пакетов.</para>
                    <example>
                        <title>Широковещательный адрес</title>
                        <programlisting>IP-адрес:             192      168      0         2
                   11000000 10101000 00000000 00000010
Широковещательный  11000000 10101000 00000000 11111111
адрес:                192      168      0        255
                  +--------------------------+--------+
                              Сеть              Узел</programlisting>
                    </example>
                    <para>Чтобы бороздить просторы интернета, вы должны знать, через какой узел происходит подключение к интернету. Этот узел называется <indexterm><primary>Шлюз</primary></indexterm><firstterm>шлюзом</firstterm>. Так как это обычный узел, ему присвоен обычный IP-адрес (например, 192.168.0.1). </para>
                    <para>Выше мы говорили, что каждому узлу присваивается свой собственный IP-адрес. Чтобы связываться с узлом по имени (вместо IP-адреса), нужна служба, которая переводит имя (такое, как <systemitem class="domainname">dev.gentoo.org</systemitem>) в IP-адрес (например, <systemitem class="ipaddress">64.5.62.82</systemitem>). Такая служба называется службой имен. Чтобы пользоваться ей, нужно указать необходимые <indexterm><primary>Сервер имён</primary></indexterm><firstterm>серверы имён</firstterm> в <filename>/etc/resolv.conf</filename>. </para>
                    <para>Иногда ваш шлюз сам является сервером имен. В остальных случаях вам необходимо указывать серверы имен, предоставляемые поставщиком интернета. </para>
                    <para>В итоге, для дальнейшего вам потребуется следующая информация: </para>
                    <informaltable>
                        <tgroup cols="2">
                            <thead>
                                <row>
                                    <entry>Параметр настройки сети</entry>
                                    <entry>Пример</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>Ваш IP-адрес</entry>
                                    <entry>192.168.0.2</entry>
                                </row>
                                <row>
                                    <entry>Маска сети</entry>
                                    <entry>255.255.255.0</entry>
                                </row>
                                <row>
                                    <entry>Широковещательный адрес</entry>
                                    <entry>192.168.0.255</entry>
                                </row>
                                <row>
                                    <entry>Шлюз</entry>
                                    <entry>192.168.0.1</entry>
                                </row>
                                <row>
                                    <entry>Сервер(ы) имен</entry>
                                    <entry>195.130.130.5, 195.130.130.133</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </section>
                <section>
                    <info>
                        <title>Использование ifconfig и route</title>
                    </info>
                    <para>Настройка вашей сети состоит из трех шагов. Сначала мы назначаем себе IP-адрес с помощью <command>ifconfig</command>. Затем мы настраиваем маршрутизацию к шлюзу, пользуясь <command>route</command>. И в завершение мы помещаем IP-адреса серверов имен в <filename>/etc/resolv.conf</filename>. </para>
                    <para>Для назначения IP-адреса потребуется ваш IP-адрес, широковещательный адрес и маска сети. Узнав их, выполните следующую команду, заменив <replaceable>${IP_ADDR}</replaceable> на свой IP-адрес, <replaceable>${BROADCAST}</replaceable> на свой широковещательный адрес, а <replaceable>${NETMASK}</replaceable> на свою маску сети: </para>
                    <example>
                        <title>Использование <command>ifconfig</command></title>
                        <screen><prompt>#</prompt> <userinput>ifconfig eth0 <replaceable>${IP_ADDR}</replaceable> broadcast <replaceable>${BROADCAST}</replaceable> netmask <replaceable>${NETMASK}</replaceable> up</userinput></screen>
                    </example>
                    <para>Теперь настройте маршрутизацию с помощью <command>route</command>. Подставьте IP-адрес своего шлюза вместо <replaceable>${GATEWAY}</replaceable>: </para>
                    <example>
                        <title>Использование <command>route</command></title>
                        <screen><prompt>#</prompt> <userinput>route add default gw <replaceable>${GATEWAY}</replaceable></userinput></screen>
                    </example>
                    <para>Затем откройте <filename>/etc/resolv.conf</filename> в своем любимом редакторе (в нашем примере используется <command>nano</command>): </para>
                    <example>
                        <title>Создание <filename>/etc/resolv.conf</filename></title>
                        <screen><prompt>#</prompt> <userinput>nano -w /etc/resolv.conf</userinput></screen>
                    </example>
                    <para>Заполните данные своих серверов имен по следующему образцу. Обязательно замените <replaceable>${NAMESERVER1}</replaceable> и <replaceable>${NAMESERVER2}</replaceable> на соответствующие адреса серверов имен: </para>
                    <example>
                        <title>Образец <filename>/etc/resolv.conf</filename></title>
                        <programlisting>nameserver <replaceable>${NAMESERVER1}</replaceable>
nameserver <replaceable>${NAMESERVER2}</replaceable></programlisting>
                    </example>
                    <para>Готово. Теперь проверьте свою сеть, «попинговав» какой-либо сервер интернета (например, Google). Если все заработало, примите наши поздравления! Теперь вы готовы к установке Gentoo. Приступайте к <link xlink:href="#gnt-hb.prepare-disks">подготовке дисков</link>. </para>
                </section>
            </section>
        </section>
        <section xreflabel="Подготовка дисков" xml:id="gnt-hb.prepare-disks">
            <title>Подготовка дисков</title>
            <section xreflabel="Общие сведения о блочных устройствах">
                <title>Общие сведения о блочных устройствах</title>
                <section>
                    <title>Блочные устройства</title>
                    <para>Мы достаточно подробно рассмотрим аспекты работы с дисками в Gentoo Linux и Linux вообще, включая файловые системы, разделы и блочные устройства. Позже, когда вы уже освоитесь с дисками и файловыми системами, мы проведем вас через процесс настройки разделов и файловых систем для установки Gentoo Linux. </para>
                    <para>Для начала, давайте познакомимся с <indexterm><primary>Блочные устройства</primary></indexterm><firstterm>блочными устройствами</firstterm>. Вероятно, наиболее известно блочное устройство, соответствующее в системе Linux первому IDE-диску, а именно <filename>/dev/hda</filename>. А если в вашей системе используются диски SCSI или SATA, то первым жестким диском будет <filename>/dev/sda</filename>. </para>
                    <para>Подобные блочные устройства представляют собой абстрактный интерфейс к диску. Прикладные программы могут использовать их для обращения к дискам, не беспокоясь, к какому типу те принадлежат: IDE, SCSI или какому-то еще. Программы могут просто обращаться к накопителю, как к набору смежных 512-байтных блоков с произвольным доступом. </para>
                </section>
                <section>
                    <title>Разделы</title>
                    <para><indexterm><primary>Раздел</primary></indexterm>Хотя теоретически для размещения системы Linux диск можно использовать целиком, так почти никогда не делают на практике. Вместо этого большое физическое блочное устройство разбивают на меньшие блочные устройства, более удобные для обращения. В архитектуре x86 они называются <firstterm>разделами</firstterm>. </para>
                    <para>Существуют разделы трех типов:<firstterm>первичные</firstterm> (primary), <firstterm>расширенные</firstterm> (extended) и <firstterm>логические</firstterm> (logical). </para>
                    <para><indexterm><primary>Первичный раздел</primary></indexterm><firstterm>Первичный раздел</firstterm> — это раздел, информация о котором хранится в <acronym>MBR</acronym> (Master Boot Record — главной загрузочной записи). Так как MBR очень мала (512 байт), можно определять всего четыре первичных раздела (например, от <filename>/dev/hda1</filename> до <filename>/dev/hda4</filename>).</para>
                    <para><indexterm><primary>Расширенный раздел</primary></indexterm><firstterm>Расширенный раздел</firstterm> — это особый первичный раздел (имеется в виду, что расширенный раздел должен быть одним из четырех возможных первичных разделов), в котором содержатся другие разделы. Таких разделов изначально не существовало, но их введение помогло расширить существующую схему разметки без потери совместимости, как только четырех разделов перестало хватать. </para>
                    <para><indexterm><primary>Логический раздел</primary></indexterm><firstterm>Логический раздел</firstterm> — это раздел, входящий в расширенный раздел. Его определение находится не в MBR, а внутри расширенного раздела. </para>
                </section>
                <section>
                    <title>Дополнительные возможности</title>
                    <para>На установочном компакт-диске для х86 предусмотрена поддержка EVMS и LVM2. Использование EVMS и LVM2 повышает гибкость разбиения диска. В ходе установки мы останавливаемся на «обычных» разделах, но стоит запомнить, что EVMS и LVM2 тоже поддерживаются. </para>
                </section>
            </section>
            <section xreflabel="Разработка схемы разбиения диска">
                <title>Разработка схемы разбиения диска</title>
                <section>
                    <title>Схема разбиения по умолчанию</title>
                    <para>Если вам не интересно заниматься разработкой схемы для своей системы, можно воспользоваться схемой, используемой в этой книге: </para>
                    <informaltable>
                        <tgroup cols="4">
                            <thead>
                                <row>
                                    <entry>Раздел</entry>
                                    <entry>Файловая система</entry>
                                    <entry>Размер</entry>
                                    <entry>Описание</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>dev/hda1</entry>
                                    <entry>ext2</entry>
                                    <entry>32МБ</entry>
                                    <entry>загрузочный раздел</entry>
                                </row>
                                <row>
                                    <entry>/dev/hda1</entry>
                                    <entry>(swap)</entry>
                                    <entry>512МБ</entry>
                                    <entry>раздел подкачки</entry>
                                </row>
                                <row>
                                    <entry>/dev/hda3</entry>
                                    <entry>ext3</entry>
                                    <entry>оставшаяся часть диска</entry>
                                    <entry>корневой раздел</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                    <para>Если вам интересно узнать, какого размера должны быть разделы, и сколько их вам вообще может потребоваться, читайте дальше. В противном случае приступайте к созданию разделов, описанному в главе использование fdisk для создания разделов. </para>
                </section>
                <section>
                    <title>Сколько и каких именно?</title>
                    <para>Количество разделов очень сильно зависит от назначения системы. Например, если у вас много пользователей, вам, скорее всего, захочется отделить <filename>/home</filename> для повышения безопасности и упрощения резервного копирования. Если вы устанавливаете Gentoo в роли почтового сервера, следует отделить <filename>/var</filename>, т.к. вся почта хранится там. Затем, правильно выбрав файловую систему, вы добьетесь максимальной производительности. Для игровых серверов потребуется отдельный раздел <filename>/opt</filename>, так как большинство программ для их работы устанавливается туда. Причины выделения те же, что и для /home: безопасность и резервное копирование. Определенно не помешает побольше места для <filename>/usr</filename>: не только потому, что там хранится большинство приложений, а еще из-за того, что лишь дерево Portage, не считая размещенных в нем архивов с исходными кодами, занимает около 500 МБ. </para>
                    <para>Как видите, все зависит от ваших целей. Наличие отдельных разделов или томов имеет следующие плюсы: </para>
                    <orderedlist>
                        <listitem>
                            <para>для каждого раздела или тома можно выбрать наиболее подходящую файловую систему; </para>
                        </listitem>
                        <listitem>
                            <para>свободное место во всей системе не кончится «вдруг» из-за того, что одна-единственная сбойная программа постоянно записывает файлы в раздел или том </para>
                        </listitem>
                        <listitem>
                            <para>необходимая проверка файловых систем будет занимать меньше времени, т.к. проверка разных разделов может выполняться параллельно (еще больший выигрыш времени дает использование нескольких физических дисков) ;</para>
                        </listitem>
                        <listitem>
                            <para>можно повысить безопасность системы, монтируя часть разделов в режиме read-only (только для чтения), nosuid (игнорируется бит setuid), noexec (игнорируется бит исполнения) и т.д.. </para>
                        </listitem>
                    </orderedlist>
                    <para>Однако, у создания множества разделов есть один большой минус: при неправильной настройке можно получить систему, в которой много свободного места на одном разделе, и совершенно нет на другом. Кроме того, на дисках SCSI и SATA возможно создание не более 15 разделов. </para>
                    <para>Для примера мы покажем разбиение диска объемом 20 ГБ, используемого в демонстрационном ноутбуке (с веб-сервером, почтовым сервером, средой Gnome и т.д.): </para>
                    <example>
                        <title>Пример файловой системы</title>
                        <screen><prompt>$</prompt> <userinput>df -h</userinput>
Filesystem    Type    Size   Used   Avail   Use%  Mounted on
/dev/hda5     ext3    509M   132M    351M    28%  /
/dev/hda2     ext3    5.0G   3.0G    1.8G    63%  /home
/dev/hda7     ext3    7.9G   6.2G    1.3G    83%  /usr
/dev/hda8     ext3   1011M   483M    477M    51%  /opt
/dev/hda9     ext3    2.0G   607M    1.3G    32%  /var
/dev/hda1     ext2     51M    17M     31M    36%  /boot
/dev/hda6     swap    516M    12M    504M     2%  &lt;not mounted&gt;
    <lineannotation>(свободное место для будущего использования: 2 ГБ)</lineannotation></screen>
                    </example>
                    <para>Раздел <filename>/usr</filename>, как видим, почти заполнен (использовано 83%), но когда все программы установлены, <filename>/usr</filename> растет не слишком быстро. Хотя отведение нескольких гигабайт дискового пространства для <filename>/var</filename> может показаться расточительством, помните, что этот раздел по умолчанию используется Portage для компиляции пакетов. Если вы захотите удержать <filename>/var</filename> в рамках более разумного размера, например, 1ГБ, вам потребуется изменить переменную <envar>PORTAGE_TMPDIR</envar> в <filename>/etc/make.conf</filename>, чтобы она указывала на раздел, где достаточно свободного места для компиляции чрезвычайно больших пакетов, таких как OpenOffice. </para>
                </section>
            </section>
            <section>
                <info>
                    <title>Использование fdisk для создания разделов</title>
                </info>
                <para>В следующих разделах описывается, как разбить диск в соответствии с примерной схемой, описанной ранее, а именно:</para>
                <informaltable>
                    <tgroup cols="2">
                        <thead>
                            <row>
                                <entry>Раздел</entry>
                                <entry>Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><filename>/dev/hda1</filename></entry>
                                <entry>загрузочный раздел</entry>
                            </row>
                            <row>
                                <entry><filename>/dev/hda2</filename></entry>
                                <entry>раздел подкачки</entry>
                            </row>
                            <row>
                                <entry><filename>/dev/hda3</filename></entry>
                                <entry>корневой раздел</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para>Эту схему вы можете изменять по своему усмотрению. </para>
                <section>
                    <title>Просмотр текущей схемы разбиения диска</title>
                    <para><indexterm><primary>fdisk</primary></indexterm><command>fdisk</command> — это популярная и очень мощная утилита для создания разделов на ваших дисках. Запустите fdisk, указав свой диск в качестве параметра (в примере мы используем <filename>/dev/hda</filename>): </para>
                    <example>
                        <title>Запуск <command>fdisk</command></title>
                        <screen><prompt>#</prompt> <userinput>fdisk /dev/hda</userinput></screen>
                    </example>
                    <para>После запуска fdisk выдаст такое приглашение: </para>
                    <example>
                        <title>Приглашение fdisk</title>
                        <screen>Command (m for help):</screen>
                    </example>
                    <para>Нажмите <userinput>p</userinput>, чтобы вывести текущую схему разбиения диска: </para>
                    <example>
                        <title>Пример схемы разделов диска</title>
                        <screen>Command (m for help): <userinput>p</userinput>
                            
Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help):</screen>
                    </example>
                    <para>В данном случае на диске есть семь разделов Linux (для которых в графе «System» указано «Linux») и один раздел подкачки (в списке показан как «Linux swap»). </para>
                </section>
                <section>
                    <title>Удаление всех разделов</title>
                    <para>Сначала удалим с диска все существующие разделы. Для удаления раздела вводите <userinput>d</userinput>. Например для удаления существующего <filename>/dev/hda1</filename>: </para>
                    <example>
                        <title>Удаление раздела</title>
                        <screen>Command (m for help): <userinput>d</userinput>
Partition number (1-4): <userinput>1</userinput></screen>
                    </example>
                    <para>Удаление раздела будет запланировано. Он больше не будет отображаться при вводе <userinput>p</userinput>, но фактически не будет удалятся до тех пор, пока вы не сохраните внесенные изменения. Если вы ошиблись и хотите прервать разбиение без сохранения изменений, немедленно введите <userinput>q</userinput> и нажмите <keycap>ENTER</keycap>; тогда ваш раздел сохранится в неизменном виде. </para>
                    <para>Теперь, если вы действительно собираетесь удалить в своей системе все разделы, повторяйте ввод <userinput>p</userinput> для показа оставшихся разделов, затем <userinput>d</userinput> и номера удаляемого раздела до тех пор, пока разделы не кончатся. В итоге вы получите пустую таблицу разделов: </para>
                    <example>
                        <title>Пустая таблица разделов</title>
                        <screen>Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):</screen>
                    </example>
                    <para>Теперь, когда мы очистили таблицу разделов, хранящуюся в оперативной памяти, настало время создавать разделы. Мы воспользуемся примерной схемой разбиения, описанной выше. Естественно, не следуйте этим инструкциям буквально, если только вам не нужна таблица разделов, идентичная нашей! </para>
                </section>
                <section>
                    <title>Создание загрузочного раздела</title>
                    <para>Сначала создадим маленький загрузочный раздел. Введите <userinput>n</userinput> для создания нового раздела, затем <userinput>p</userinput>, чтобы выбрать первичный раздел, и <userinput>1</userinput> для указания первого первичного раздела. На вопрос о первом цилиндре нажмите ввод. На вопрос о последнем цилиндре введите <userinput>+32M</userinput>, чтобы создать раздел размером 32МБ: </para>
                    <example>
                        <title>Создание загрузочного раздела</title>
                        <screen>Command (m for help): <userinput>n</userinput>
Command action
  e   extended
  p   primary partition (1-4)
<userinput>p</userinput>
Partition number (1-4): <userinput>1</userinput>
First cylinder (1-3876, default 1): <lineannotation>(нажмите ввод)</lineannotation>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <userinput>+32M</userinput></screen>
                    </example>
                    <para>Теперь, введя <userinput>p</userinput>, вы должны увидеть следующий текст: </para>
                    <example>
                        <title>Созданный загрузочный раздел</title>
                        <screen>Command (m for help): <userinput>p</userinput>
                            
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux</screen>
                    </example>
                    <para>Нам необходимо сделать этот раздел загружаемым. Введите <userinput>a</userinput> для включения признака загрузки с раздела, затем нажмите <userinput>1</userinput>. Если снова ввести <userinput>p</userinput>, можно увидеть, что в столбце «boot» появился знак *. </para>
                </section>
                <section>
                    <title>Создание раздела подкачки</title>
                    <para>Теперь создадим раздел подкачки. Для этого введите <userinput>n</userinput> (создание нового раздела), затем <userinput>p</userinput> для выбора первичного раздела. Потом нажмите <userinput>2</userinput>, чтобы создать второй первичный раздел, в нашем случае <filename>/dev/hda2</filename>. На вопрос о первом цилиндре просто нажмите ввод. На вопрос о последнем — ответьте <userinput>+512M</userinput>, чтобы создать раздел размером 512МБ. Сделав это, введите <userinput>t</userinput> для указания типа раздела, <userinput>2</userinput>, для выбора только что созданного раздела, и <userinput>82</userinput>, чтобы установить тип раздела «Linux Swap». При нажатии <userinput>p</userinput> по завершении этих действий, таблица разделов должна выглядеть примерно так: </para>
                    <example>
                        <title>Список разделов после создания раздела подкачки</title>
                        <screen>Command (m for help): <userinput>p</userinput>
                            
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap</screen>
                    </example>
                </section>
                <section>
                    <title>Создание корневого раздела</title>
                    <para>Теперь создадим корневой раздел. Для этого введите <userinput>n</userinput> (создание нового раздела), затем <userinput>p</userinput> (первичный раздел). После этого нажмите <userinput>3</userinput> для создания третьего первичного раздела, в нашем случае <filename>/dev/hda3</filename>. На вопрос о первом цилиндре нажмите ввод. На вопрос о последнем — также нажмите ввод, чтобы раздел занял все оставшееся свободное место на диске. По завершении этих шагов, при вводе p должна выводиться подобная таблица разделов: </para>
                    <example>
                        <title>Список разделов после создания корневого раздела</title>
                        <screen>Command (m for help): <userinput>p</userinput>
                            
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux</screen>
                    </example>
                </section>
                <section>
                    <title>Сохранение схемы разбиения</title>
                    <para>Для сохранения схемы разбиения и выхода из <command>fdisk</command>, введите <userinput>w</userinput>. </para>
                    <example>
                        <title>Сохранение и выход из <command>fdisk</command></title>
                        <screen>Command (m for help): <userinput>w</userinput></screen>
                    </example>
                    <para>Теперь, создав все разделы, перейдем к созданию файловых систем. </para>
                </section>
            </section>
            <section>
                <info>
                    <title>Создание файловых систем</title>
                </info>
                <section>
                    <title>Введение</title>
                    <para>Разделы созданы, настало время разместить на них файловые системы. Если вам безразлично, какую файловую систему использовать, и вы вполне довольны той, что мы предлагаем в книге по умолчанию, переходите к размещению файловой системы в разделе. Если нет, читайте дальше, чтобы разузнать о существующих файловых системах... </para>
                </section>
                <section>
                    <info>
                        <title>Файловые системы (сравнение !)</title>
                    </info>
                    <para>В ядре Linux поддерживаются различные файловые системы. Мы расскажем о самых распространенных из них: ext2, ext3, ReiserFS, XFS и JFS. </para>
                    <orderedlist>
                        <listitem>
                            <para><indexterm><primary>ext2</primary></indexterm><systemitem class="filesystem">ext2</systemitem> — испытанная файловая система Linux, в которой отсутствуют средства журналирования метаданных. Поэтому ее рядовая проверка при запуске может быть очень долгой. Сегодня существует довольно много журналируемых файловых систем нового поколения, целостность которых проверяется очень быстро, и поэтому обычно есть смысл использовать их. Журналируемые файловые системы позволяют избежать долгих задержек при запуске, когда состояние файловой системы неустойчиво. </para>
                        </listitem>
                        <listitem>
                            <para><indexterm><primary>ext3</primary></indexterm><systemitem class="filesystem">ext3</systemitem> — это журналируемая версия ext2, где для ускорения восстановления появилось журналирование метаданных, а также другие режимы, наподобие полного или упорядоченного журналирования данных. ext3 — очень хорошая и надежная файловая система. В ней есть дополнительная возможность индексации через хэшированные сбалансированные деревья (b-tree), что в большинстве случаев обеспечивает высокую скорость. Такую индексацию можно включить, добавив к команде <command>mke2fs</command> параметр <option>-O <replaceable>dir_index</replaceable></option>. Короче говоря, ext3 — превосходная файловая система. </para>
                        </listitem>
                        <listitem>
                            <para><indexterm><primary>ResierFS</primary></indexterm><systemitem class="filesystem">ReiserFS</systemitem> — файловая система, построенная на B*-деревьях. У нее очень хорошая скорость, и она намного (часто в 10-15 раз) быстрее ext2 и ext3 при работе с маленькими файлами (менее 4КБ). ReiserFS также великолепно масштабируется; в ней есть средства журналирования. На дату выхода ядра 2.4.18, ReiserFS признана стабильной и пригодной как для систем общего назначения, так и для крайних случаев типа создания больших томов, использования множества маленьких файлов, гигантских файлов или же каталогов с десятками тысяч файлов. </para>
                        </listitem>
                        <listitem>
                            <para><indexterm><primary>XFS</primary></indexterm><systemitem class="filesystem">XFS</systemitem> — это файловая система с журналированием метаданных и дополнительными средствами, оптимизированными для работы с максимальным объемом данных. Ее применение рекомендуется только в Linux-системах с высококлассными дисками SCSI или дисками с оптическим подключением (fibre-channel), при наличии источников бесперебойного питания. Из-за того, что XFS выполняет очень агрессивное промежуточное кэширование в оперативной памяти, при внезапном отключении питания очень вероятна потеря небрежно спроектированными программами (не принимающими адекватные меры предосторожности при записи файлов на диск, и таких довольно много) изрядного количества данных. </para>
                        </listitem>
                        <listitem>
                            <para><indexterm><primary>JFS</primary></indexterm><systemitem class="filesystem">JFS</systemitem> — высокопроизводительная журналируемая файловая система производства IBM. Она лишь недавно стала пригодной для широкого применения, и пока слишком мало данных, чтобы сказать что-то хорошее или плохое о ее общей стабильности. </para>
                        </listitem>
                    </orderedlist>
                </section>
                <section>
                    <title>Размещение файловой системы в разделе</title>
                    <para>Для создания в разделе или томе файловой системы каждого типа существуют специальные средства:</para>
                    <informaltable>
                        <tgroup cols="2">
                            <thead>
                                <row>
                                    <entry>Файловая система</entry>
                                    <entry>Команда создания</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>ext2</entry>
                                    <entry><command>mke2fs</command></entry>
                                </row>
                                <row>
                                    <entry>ext3</entry>
                                    <entry><command>mke2fs -j</command></entry>
                                </row>
                                <row>
                                    <entry>reiserfs</entry>
                                    <entry><command>mkreiserfs</command></entry>
                                </row>
                                <row>
                                    <entry>xfs</entry>
                                    <entry><command>mkfs.xfs</command></entry>
                                </row>
                                <row>
                                    <entry>jfs</entry>
                                    <entry><command>mkfs.jfs</command></entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                    <para>Например, чтобы у загрузочного раздела (<filename>/dev/hda1</filename> в наших примерах) была файловая система ext2, а у корневого раздела (<filename>/dev/hda3</filename> в наших примерах) — ext3, требуется выполнить: </para>
                    <example>
                        <title>Создание файловых систем разделов</title>
                        <screen><prompt>#</prompt> <userinput>mke2fs /dev/hda1</userinput>
<prompt>#</prompt> <filename>mke2fs -j /dev/hda3</filename></screen>
                    </example>
                    <para>Теперь самостоятельно создайте файловые системы на своих только что созданных разделах (логических томах). </para>
                </section>
                <section>
                    <title>Подключение раздела подкачки</title>
                    <para><command>mkswap</command> — команда, используемая для инициализации разделов подкачки: </para>
                    <example>
                        <title>Создание идентификатора раздела подкачки</title>
                        <screen><prompt>#</prompt> <userinput>mkswap /dev/hda2</userinput></screen>
                    </example>
                    <para>Для подключения раздела подкачки воспользуйтесь <command>swapon</command>: </para>
                    <example>
                        <title>Подключение раздела подкачки</title>
                        <screen><prompt>#</prompt> <userinput>swapon /dev/hda2</userinput></screen>
                    </example>
                    <para>Теперь командами, приведенными выше, создайте и подключите раздел подкачки в своей системе. </para>
                </section>
            </section>
            <section>
                <info>
                    <title>Монтирование</title>
                </info>
                <para>Теперь, когда разделы созданы, а файловые системы размещены, настало время смонтировать (подключить к системе) эти разделы. Используйте команду <command>mount</command>. Не забудьте создать для каждого раздела соответствующие каталоги монтирования. Например, смонтируем корневой и загрузочный разделы: </para>
                <example>
                    <title>Монтирование разделов</title>
                    <screen><prompt>#</prompt> <userinput>mount /dev/hda3 /mnt/gentoo</userinput>
<prompt>#</prompt> <userinput>mkdir /mnt/gentoo/boot</userinput>
<prompt>#</prompt> <userinput>mount /dev/hda1 /mnt/gentoo/boot</userinput></screen>
                </example>
                <note>
                    <para>Если вы хотите разместить каталог <filename>/tmp</filename> в отдельном разделе, не забудьте изменить права доступа к этому каталогу после монтирования: <command>chmod 1777 /mnt/gentoo/tmp</command>. Это также относится к <filename>/var/tmp</filename>. </para>
                </note>
                <para>Еще нам потребуется смонтировать файловую систему proc (виртуальный интерфейс ядра) в каталог /proc. Но сначала надо поместить в разделы нужные файлы. </para>
                <para>Переходите к установке установочных файлов Gentoo. </para>
            </section>
        </section>
        <section xreflabel="Установка установочных файлов Gentoo">
            <title>Установка установочных файлов Gentoo</title>
            <section>
                <title>Установка архива стадии</title>
                <section>
                    <title>Установка текущей даты и времени</title>
                    <para>Перед тем, как продолжать, убедитесь в правильности системной даты и времени, и при необходимости обновите их. Если часы установлены неверно, это в будущем может привести к странным результатам! </para>
                    <para>Для проверки времени, введите команду <command>date</command>: </para>
                    <example>
                        <title>Проверка даты и времени</title>
                        <screen><prompt>#</prompt> <userinput>date</userinput>
Fri Mar 29 16:21:18 UTC 2007</screen>
                    </example>
                    <para>Если часы установлены неправильно, измените время командой <command>date <replaceable>ММДДччммГГГГГ</replaceable></command> (формат: Месяц, День, часы, минуты и Год). На этом этапе следует указывать время UTC. Позднее вы сможете установить свой часовой пояс. Например, для установки часов на 29 марта, 16:21, 2005 год, выполните: </para>
                    <example>
                        <title>Установка даты и времени</title>
                        <screen><prompt>#</prompt> <userinput>date 032916212007</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Выбор источника</title>
                    <para>Следующий необходимый шаг — установка архива stage3 на вашу систему. Нужный архив можно скачать из интернета, или, если вы загрузились с универсального установочного диска Gentoo, скопировать с самого диска. Если у вас есть универсальный диск, а на нем — нужная стадия, то загрузка из интернета — лишняя трата трафика и времени, т.к. файлы стадии окажутся совершенно одинаковы. В большинстве случаев, определиться с выбором архива стадии вам поможет команда <command>uname -m</command>. </para>
                    <para>по умолчанию: использование файла стадии из интернета </para>
                    <para>альтернатива: использование файла стадии с установочного диска </para>
                </section>
            </section>
            <section>
                <info>
                    <title>По умолчанию: использование файла стадии из интернета</title>
                </info>
                <section>
                    <title>Загрузка архива стадии</title>
                    <para>Перейдите в точку подключения файловой системы Gentoo (обычно — <filename>/mnt/gentoo</filename>): </para>
                    <example>
                        <title>Переход к точке подключения Gentoo</title>
                        <screen><prompt>#</prompt> <userinput>cd /mnt/gentoo</userinput></screen>
                    </example>
                    <para>Для загрузки файла стадии у вас уже есть различные инструменты, зависящие от типа диска, с которого производится установка. Если имеется links, можете сразу открыть список зеркал Gentoo и выбрать ближайшее. </para>
                    <para>Когда links нет, в вашем распоряжении должен оказаться lynx. Если требуется использовать прокси-сервер, экспортируйте переменные <envar>http_proxy</envar> и <envar>ftp_proxy</envar>: </para>
                    <example>
                        <title>Настройка информации о прокси-сервере для lynx</title>
                        <screen><prompt>#</prompt> <userinput>export http_proxy="http://<replaceable>proxy.server.com:port</replaceable>"</userinput>
<prompt>#</prompt> <userinput>export ftp_proxy="http://<replaceable>proxy.server.com:port</replaceable>"</userinput></screen>
                    </example>
                    <para>Предположим, у вас под рукой есть links. </para>
                    <para>Перейдите в каталог <filename>releases/</filename>, в нем откройте каталог, соответствующий вашей архитектуре (например, <filename>x86/</filename>), затем каталог с версией Gentoo (<filename>2006.1/</filename>), и, наконец, каталог <filename>stages/</filename>. Здесь находятся все доступные архивы стадий для вашей архитектуры (они могут располагаться в подкаталогах с названиями разновидностей архитектуры). Выберите один из них и нажмите <keycap>D</keycap> для загрузки. По окончании — нажмите <keycap>Q</keycap>, чтобы выйти из браузера. </para>
                    <example>
                        <title>Открытие списка зеркал в links</title>
                        <screen><prompt>#</prompt> <userinput>links http://www.gentoo.org/main/ru/mirrors.xml</userinput>

<lineannotation>(если в links нужна поддержка прокси-сервера:)</lineannotation>
<prompt>#</prompt> <userinput>links -http-proxy proxy.server.com:8080 http://www.gentoo.org/main/ru/mirrors.xml</userinput></screen>
                    </example>
                    <para>Удостоверьтесь, что вы скачали stage3-архив — установка с использованием файлов stage1 и stage2 более не поддерживается. </para>
                    <para>Если вы хотите проверить целостность загруженного архива стадии, с помощью md5sum сравните результат с контрольной суммой MD5, взятой с зеркала. Например, для проверки целостности архива стадии для x86: </para>
                    <example>
                        <title>Пример проверки целостности архива стадии</title>
                        <screen><prompt>#</prompt> <userinput>md5sum -c stage3-x86-2007.0.tar.bz2.DIGESTS</userinput>
stage3-x86-2007.0.tar.bz2: OK</screen>
                    </example>
                </section>
                <section>
                    <title>Распаковка архива стадии</title>
                    <para>Распакуйте загруженный архив стадии в своей системе. Мы используем tar, т.к. это простейший способ: </para>
                    <example>
                        <title>Распаковка архива стадии</title>
                        <screen><prompt>#</prompt> <userinput>tar xvjpf stage3-*.tar.bz2</userinput></screen>
                    </example>
                    <orderedlist>
                        <listitem>
                            <para>Убедитесь, что вы используете точно такие же параметры командной строки (<option>xvjpf</option>). Значения параметров: </para>
                        </listitem>
                        <listitem>
                            <para><option>x</option> — извлечение; </para>
                        </listitem>
                        <listitem>
                            <para><option>v</option> — подробные сообщения, чтобы видеть, что происходит во время распаковки (необязательный параметр);</para>
                        </listitem>
                        <listitem>
                            <para><option>j</option> — декомпрессия bzip2;</para>
                        </listitem>
                        <listitem>
                            <para><option>p</option> — сохранение прав доступа;</para>
                        </listitem>
                        <listitem>
                            <para><option>f</option> — указывает на то, что мы распаковываем файл, а не то, что подается на стандартный ввод. </para>
                        </listitem>
                    </orderedlist>
                    <note>
                        <para>На установочных компакт-дисках и загрузочных образах для некоторых архитектур (например, MIPS) tar встроен в оболочку BusyBox, которая на данный момент не поддерживает параметр <option>v</option>. Тогда вместо приведенных указывайте параметры <option>xjpf</option>. </para>
                    </note>
                    <para>После развертывания установки стадии переходите к установке дерева портежей.</para>
                </section>
            </section>
            <section>
                <title>Альтернатива: использование файла стадии с установочного диска</title>
                <section>
                    <title>Извлечение архива стадии</title>
                    <para>Важно: Если вы — в x86 и используете «живой диск» с установщиком, на нем нет стадий. Вам понадобится последовать указаниям по использованию файла стадии из интернета. </para>
                    <para>Архивы стадий находятся на компакт-диске в каталоге <filename>/mnt/cdrom/stages</filename>. Для получения списка доступных стадий, воспользуйтесь <command>ls</command>: </para>
                    <example>
                        <title>Список доступных архивов стадий</title>
                        <screen><prompt>#</prompt> <userinput>ls /mnt/cdrom/stages</userinput></screen>
                    </example>
                    <para>Если система сообщает об ошибке, возможно, сначала нужно смонтировать CD-ROM: </para>
                    <example>
                        <title>Монтирование CD-ROM</title>
                        <screen><prompt>#</prompt> <userinput>ls /mnt/cdrom/stages</userinput>
ls: /mnt/cdrom/stages: No such file or directory
<prompt>#</prompt> <userinput>mount /dev/cdroms/cdrom0 /mnt/cdrom</userinput>
<prompt>#</prompt> <userinput>ls /mnt/cdrom/stages</userinput>
</screen>
                    </example>
                    <para>Перейдите в точку подключения Gentoo (обычно — <filename>/mnt/gentoo</filename>): </para>
                    <example>
                        <title>Смена каталога на <filename>/mnt/gentoo</filename></title>
                        <screen><prompt>#</prompt> <userinput>cd /mnt/gentoo</userinput></screen>
                    </example>
                    <para>Теперь утилитой tar распакуем выбранный архив стадии. Убедитесь, что вы используете точно такие же параметры (<option>xvjpf</option>)! Параметр <option>v</option> необязателен и может не работать в некоторых версиях tar. В следующем примере мы распакуем архив стадии <filename>stage3-<replaceable>&lt;архитектура&gt;</replaceable>-2006.1.tar.bz2</filename>. В качестве имени архива обязательно указывайте название файла нужной вам стадии. </para>
                    <example>
                        <title>Распаковка архива стадии</title>
                        <screen><prompt>#</prompt> <userinput>tar xvjpf /mnt/cdrom/stages/stage3-<replaceable>&lt;архитектура&gt;</replaceable>-2007.0.tar.bz2</userinput></screen>
                    </example>
                    <para>После установки стадии переходите к установке дерева портежей. </para>
                </section>
            </section>
            <section>
                <title>Установка дерева портежей</title>
                <section>
                    <title>Распаковка снимка портежей</title>
                    <para>Теперь вам нужно установить снимок дерева портежей — набор файлов, содержащих сведения для Portage о программном обеспечении, доступном для установки, имеющихся профилях и т.д. </para>
                </section>
                <section>
                    <title>Загрузка и установка снимка дерева портежей</title>
                    <para>Перейдите к точке подключения вашей системы (обычно — <filename>/mnt/gentoo</filename>): </para>
                    <example>
                        <title>Переход к точке подключения</title>
                        <screen><prompt>#</prompt> <userinput>cd /mnt/gentoo</userinput></screen>
                    </example>
                    <para>Запустите links (или lynx) и откройте спискок зеркал Gentoo. Выберите ближайшее зеркало и перейдите в каталог <filename>snapshots/</filename>. Оттуда загрузите новейший снимок дерева портежей (<filename>portage-latest.tar.bz2</filename>), выбрав его из списка и нажав <keycap>D</keycap>.</para>
                    <example>
                        <title> Просмотр списка зеркал Gentoo</title>
                        <screen><prompt>#</prompt> <userinput>links http://www.gentoo.org/main/ru/mirrors.xml</userinput></screen>
                    </example>
                    <para>Закройте браузер нажатием <keycap>Q</keycap>. Теперь у вас в <filename>/mnt/gentoo</filename> появился снимок дерева портежей. </para>
                    <para>Если нужно убедиться в целостности загруженного снимка, воспользуйтесь <command>md5sum</command>, и сравните результат с контрольной суммой MD5, имеющейся на зеркале. </para>
                    <example>
                        <title>Checking integrity of a Portage snapshot</title>
                        <screen><prompt>#</prompt> <userinput>md5sum -c portage-latest.tar.bz2.md5sum</userinput>
portage-latest.tar.bz2: OK</screen>
                    </example>
                    <para>Теперь нужно распаковать снимок. Убедитесь в том, что вы используете в точности такие же параметры; последний параметр — заглавная C, а не строчная c. </para>
                    <example>
                        <title>Извлечение снимка дерева портежей</title>
                        <screen><prompt>#</prompt> <userinput>tar xvjf /mnt/gentoo/portage-latest.tar.bz2 -C /mnt/gentoo/usr</userinput></screen>
                    </example>
                </section>
            </section>
            <section>
                <title>Настройка параметров компиляции</title>
                <section>
                    <title>Введение</title>
                    <para>Для оптимизации Gentoo вы можете создать ряд переменных, которые повлияют на поведение Portage. Все их можно создавать как переменные среды (с помощью <command>export</command>), но тогда они будут лишь временными. Для хранения ваших настроек предназначен конфигурационный файл Portage, <filename>/etc/make.conf</filename>. Именно его мы сейчас будем редактировать. </para>
                    <note>
                        <para>Список и описание всех допустимых переменных находятся в файле <filename>/mnt/gentoo/etc/make.conf.example</filename>. Для успешной установки Gentoo, достаточно установить значения только тех переменных, которые описаны ниже. </para>
                    </note>
                    <para>Запустите ваш любимый редактор (в этом руководстве используется <command>nano</command>) для изменения параметров оптимизации, которые обсуждаются далее. </para>
                    <example>
                        <title>Открытие /etc/make.conf</title>
                        <screen><prompt>#</prompt> <userinput>nano -w /mnt/gentoo/etc/make.conf</userinput></screen>
                    </example>
                    <para>Как вы могли заметить, у файла <filename>make.conf.example</filename> обычная структура: строки комментария начинаются со знака «<code>#</code>», а в остальных строках выражениями вида <code>ПЕРЕМЕННАЯ="значение"</code> определяются переменные. У файла <filename>make.conf</filename> такой же формат. Некоторые из переменных мы обсудим ниже. </para>
                </section>
                <section>
                    <title>CHOST</title>
                    <para>В переменной <envar>CHOST</envar> определяется, для какой архитектуры скомпилирована система. В ней уже должно быть установлено правильное значение. Не <emphasis role="bold">изменяйте эту переменную</emphasis>, т.к. это может повредить вашу систему. Если переменная <envar>CHOST</envar>, по-вашему, выглядит неправильно, возможно, вы используете не тот архив stage3. </para>
                </section>
                <section>
                    <title>CFLAGS и CXXFLAGS</title>
                    <para>Переменные <envar>CFLAGS</envar> и <envar>CXXFLAGS</envar> определяют параметры оптимизации компилятора gcc для языков C и C++, соответственно. При том, что общие значения следует устанавливать здесь, максимальная производительность достигается в том случае, когда для каждой компилируемой программы устанавливаются свои собственные оптимальные параметры. Причина в том, что все программы различны. </para>
                    <para>В файле <filename>make.conf</filename> следует указывать параметры оптимизации, которые, на ваш взгляд, повысят скорость системы в целом. Не помещайте сюда экспериментальные значения; излишняя оптимизация может привести к плохому поведению программ (аварийным завершениям, или, что хуже, неправильной работе). </para>
                    <para>Мы не будем описывать все возможные параметры оптимизации. Если вы хотите узнать о них всё, почитайте <link xlink:href="#">онлайновые руководства GNU (англ.)</link> или страницу описания gcc (<command>info gcc</command> — доступна только на работающей системе Linux). Не забудьте прочитать сам файл make.conf.example: в нем также есть немало примеров и полезных сведений. </para>
                    <para>Первый параметр — флаг <option>-march=</option>, где указывается название целевой архитектуры. Возможные варианты описаны в комментариях в файле <filename>make.conf.example</filename>. Например, для архитектуры x86 Athlon XP: </para>
                    <example>
                        <title>Значение <option>-march</option> для GCC</title>
                        <programlisting># пользователям AMD64, желающим получить действительно 64-битную
# систему, следует использовать -march=k8
# пользователи EM64T должны указать -march=nocona
-march=athlon-xp</programlisting>
                    </example>
                    <note>
                        <para>(JohnBat26) (обновлено в 1.5): Если Вы используете компилятор версии 4.2.0 и выше, то вместо указания специфичного типа процессора, можно указывать одно из двух (в параметрах: -march и -mtune):</para>
                        <orderedlist>
                            <listitem>
                                <para>generic: если Вы хотите, чтобы Ваш скомпилированный код запускался на всех процессорах, архитектуры x86;</para>
                            </listitem>
                            <listitem>
                                <para>native: если Вы хотите оптимизировать код только для Вашего процессора. В этом случае компилятор будет брать сведения о процессоре путем вызова cpuid !</para>
                            </listitem>
                        </orderedlist>
                    </note>
                    <para>Следующий — флаг <option>-O</option> (заглавная латинская «O», а не ноль), определяющий класс оптимизации в gcc. Допустимые значения:</para>
                    <orderedlist>
                        <listitem>
                            <para>s — оптимизация по размеру; </para>
                        </listitem>
                        <listitem>
                            <para>0 — ноль, без оптимизации; </para>
                        </listitem>
                        <listitem>
                            <para>1, 2 или 3 — все большая оптимизация по скорости (в каждый класс входят все флаги предыдущего, и некоторые дополнительные). </para>
                        </listitem>
                    </orderedlist>
                    <para>Например, для оптимизации класса 2: </para>
                    <example>
                        <title>Значение -O для GCC</title>
                        <programlisting>-O2</programlisting>
                    </example>
                    <para>Другой популярный флаг оптимизации — <option>-pipe</option> (использование для связи между различными проходами компилятора каналов вместо временных файлов). </para>
                    <para>Заметьте, что использование <option>-fomit-frame-pointer</option> (не хранить в регистре указатель стекового кадра для функций, которым он не нужен) может всерьез помешать отладке программ! </para>
                    <para>При определении переменных <envar>CFLAGS</envar> и <envar>CXXFLAGS</envar>, нужно объединять несколько флагов оптимизации, как в следующем примере: </para>
                    <example>
                        <title>Определение переменных CFLAGS и CXXFLAGS (gcc &lt; 4.2.0)</title>
                        <programlisting>CFLAGS="-march=athlon-xp -pipe -O2"  # для пользователей AMD64: -march=k8
                                     # для пользователей EM64T: -march=nocona
CXXFLAGS="${CFLAGS}"                 # указывайте одинаковые значения  обеих переменных</programlisting>
                    </example>
                </section>
                <section>
                    <title>MAKEOPTS</title>
                    <para>С помощью <envar>MAKEOPTS</envar> определяется, сколько параллельных процессов компиляции можно запускать при установке пакета. Хороший (но не всегда идеальный) вариант — значение, равное количеству процессоров в системе плюс один. </para>
                    <example>
                        <title>MAKEOPTS для обычной однопроцессорной системы</title>
                        <programlisting>MAKEOPTS="-j2"</programlisting>
                    </example>
                </section>
                <section>
                    <title>На старт, внимание, марш!</title>
                    <para>Измените <filename>/mnt/gentoo/etc/make.conf</filename> в соответствии со своими пожеланиями, и сохраните изменения (пользователям nano нужно нажать <keycombo><keycap>CTRL</keycap><keycap>X</keycap></keycombo>). Теперь вы готовы к <link xlink:href="#gnt-hb.install-base">установке базовой системы Gentoo</link>. </para>
                </section>
            </section>
        </section>
        <section xml:id="gnt-hb.install-base" xreflabel="Установка базовой системы Gentoo">
            <title>Установка базовой системы Gentoo</title>
            <section>
                <info>
                    <title>Изменение корневого каталога</title>
                </info>
                <section>
                    <title>Дополнительно: выбор зеркала</title>
                    <para>Для ускорения загрузки исходного кода рекомендуется выбрать быстрое зеркало. Portage ищет переменную <envar>GENTOO_MIRRORS</envar> в файле <filename>make.conf</filename> и использует зеркала, перечисленные в ней. Конечно, можно просмотреть наш список зеркал и выбрать одно или несколько, географически ближайших к вам (чаще всего они и будут самыми быстрыми), но мы предлагаем вам удобную утилиту <command>mirrorselect</command>, которая позволяет выбрать желаемые зеркала более удобным способом. </para>
                    <example>
                        <title>Запуск mirrorselect для установки переменной GENTOO_MIRRORS</title>
                        <screen><prompt>#</prompt> <userinput>mirrorselect -i -o &gt;&gt;/mnt/gentoo/etc/make.conf</userinput></screen>
                    </example>
                    <warning>
                        <para>Не выбирайте зеркала IPv6. Файлы стадий пока не поддерживают протокол IPv6. </para>
                    </warning>
                    <para>Вторая важная настройка — установка значения переменной <envar>SYNC</envar> в файле <filename>make.conf</filename>. Эта переменная указывает на сервер rsync (сервер удаленной синхронизации), выбранный вами для обновления дерева Portage (коллекции файлов ebuild — сборочных сценариев, содержащих все данные, нужные Portage для скачивания и установки программ). Хотя вписать адрес сервера в <envar>SYNC</envar> можно и вручную, <command>mirrorselect</command> позволяет упростить это действие: </para>
                    <example>
                        <title>Выбор зеркала rsync с помощью <command>mirrorselect</command></title>
                        <screen><prompt>#</prompt> <userinput>mirrorselect -i -r -o &gt;&gt; /mnt/gentoo/etc/make.conf</userinput></screen>
                    </example>
                    <para>После выполнения <command>mirrorselect</command>, мы рекомендуем проверить все значения в файле <filename>/mnt/gentoo/etc/make.conf</filename>!</para>
                </section>
                <section>
                    <title>Копирование сведений о DNS</title>
                    <para>Перед тем, как перейти в новую среду, осталось сделать одно дело: скопировать информацию о DNS (системе доменных имен) в файл <filename>/etc/resolv.conf</filename>. Это нужно, чтобы при переходе сохранить работоспособность сети. В файле <filename>/etc/resolv.conf</filename> содержатся адреса серверов имен, используемых в вашей сети. </para>
                    <example>
                        <title>Копирование информации о DNS</title>
                        <screen>(параметр «-L» нужен, чтобы случайно не скопировать
 символьную ссылку)
<prompt>#</prompt> <userinput>cp -L /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Монтирование файловых систем /proc и /dev</title>
                    <para>Смонтируйте файловую систему <filename>/proc</filename> в <filename>/mnt/gentoo/proc</filename>, чтобы после изменения корневого каталога устанавливаемая система смогла обращаться к информации, предоставляемой ядром, а затем создайте привязку монтирования файловой системы <filename>/dev</filename>. </para>
                    <example>
                        <title>Монтирование /proc и /dev</title>
                        <screen><prompt>#</prompt> <userinput>mount -t proc none /mnt/gentoo/proc</userinput>
<prompt>#</prompt> <userinput>mount -o bind /dev /mnt/gentoo/dev</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Переход в новую среду</title>
                    <para>Итак, все разделы подготовлены, а базовая операционная среда установлена. Теперь пора войти в нее, изменив корневой каталог. Таким образом, мы перейдем из текущей установочной среды (с компакт-диска или другого установочного носителя) в свою устанавливаемую систему (находящуюся в недавно размеченных разделах). </para>
                    <para>Изменение выполняется в три этапа:</para>
                    <orderedlist>
                        <listitem>
                            <para>Сначала мы с помощью <command>chroot</command> изменим корневой каталог с <filename>/</filename> (находящийся на  установочном носителе) на <filename>/mnt/gentoo</filename> (находящийся на ваших дисковых разделах).</para>
                        </listitem>
                        <listitem>
                            <para>Затем мы создадим новую среду, пользуясь утилитой <command>env-update</command>, которая, собственно, создает переменные среды. </para>
                        </listitem>
                        <listitem>
                            <para>Наконец, мы загрузим эти переменные в память при помощи <command>source</command>. </para>
                        </listitem>
                    </orderedlist>
                    <example>
                        <title>Изменение корневого каталога для перехода в новую среду</title>
                        <screen><prompt>#</prompt> <userinput>chroot /mnt/gentoo /bin/bash</userinput>
<prompt>#</prompt> <userinput>env-update</userinput>
>> Regenerating /etc/ld.so.cache...
<prompt>#</prompt> <userinput>source /etc/profile</userinput>
<prompt>#</prompt> <userinput>export PS1="(chroot) $PS1"</userinput></screen>
                    </example>
                    <para>Поздравляем! Теперь вы в своей собственной среде Gentoo Linux. Конечно, на этом она далеко еще не готова, поэтому в руководстве еще осталось несколько разделов :-) </para>
                </section>
            </section>
            <section>
                <title>Настройка Portage</title>
                <section>
                    <title>Обновление дерева Portage</title>
                    <para>Теперь надо обновить дерево Portage до самой последней версии с помощью команды <command>emerge --sync</command>: </para>
                    <example>
                        <title>Обновление дерева портежей</title>
                        <screen><prompt>#</prompt> <userinput>emerge --sync</userinput>
<lineannotation>(если вы пользуетесь медленным терминалом, например, последовательным
 терминалом или кадровым буфером, для ускорения процесса можно добавить 
 параметр --quiet :)</lineannotation> 
<prompt>#</prompt> <userinput>emerge --sync --quiet</userinput></screen>
                    </example>
                    <para>Если компьютер подключен к интернету через межсетевой экран, блокирующий прохождение rsync-пакетов, вы можете воспользоваться командой <command>emerge-webrsync</command>, которая скачивает и устанавливает снимок дерева. </para>
                    <para>Если выдано предупреждение, что имеется новая версия Portage и ее нужно обновить, выполните обновление командой <command>emerge portage</command>. </para>
                </section>
                <section>
                    <title>Выбор нужного профиля</title>
                    <para>Сначала дадим небольшое определение. </para>
                    <para><indexterm><primary>Профиль</primary></indexterm>Профиль — конструктивный элемент любой системы Gentoo. В нём указываются не только значения по умолчанию для <envar>CHOST</envar>, <envar>CFLAGS</envar> и других важных переменных, он также привязывает систему к определенному диапазону допустимых версий пакетов. Диапазоны поддерживаются разработчиками Gentoo. </para>
                    <para>Раньше пользователь редко касался профиля. Однако, пользователи х86, hppa и alpha могут выбирать из двух вариантов профиля: одного для ядра 2.4, другого для ядра 2.6. Это вызвано необходимостью улучшения интеграции ядер 2.6. Для архитектур ppc и ppc64 также существует несколько профилей. Мы поговорим о них позже. </para>
                    <para>Узнать, какой профиль используется в системе в данный момент, вы можете командой: </para>
                    <example>
                        <title>Выяснение используемого профиля</title>
                        <screen><prompt>#</prompt> <userinput>ls -FGg /etc/make.profile</userinput>
lrwxrwxrwx  1 48 Apr  8 18:51 /etc/make.profile -> ../usr/portage/profiles/default-linux/x86/2007.0/</screen>
                    </example>
                    <para>Если вы используете одну из трех упомянутых архитектур, профиль по умолчанию даст вам систему с ядром 2.6. Это рекомендуется по умолчанию, но за вами сохраняется и право выбора другого профиля. </para>
                    <para>Для некоторых архитектур также предусмотрены подпрофили desktop и server. Загляните в профиль <filename>2007.0/</filename>, чтобы узнать, есть ли подпрофили для вашей архитектуры. Возможно, вы захотите заглянуть в make.defaults профиля desktop, чтобы определить, подходит ли он вам. </para>
                    <para>Некоторым пользователям, возможно, захочется установить систему, основанную на старом профиле, с ядром 2.4. Если для этого есть веские основания, сначала надо проверить, существует ли такой дополнительный профиль. На системах x86 это можно сделать следующей командой: </para>
                    <example>
                        <title>Выяснение наличия дополнительного профиля</title>
                        <screen><prompt>#</prompt> <userinput>ls -d /usr/portage/profiles/default-linux/x86/no-nptl/2.4</userinput>
/usr/portage/profiles/default-linux/x86/no-nptl/2.4</screen>
                    </example>
                    <para>В приведенном примере дополнительный профиль 2.4 существует (т.е. нет сообщений об отсутствующем файле или каталоге). Рекомендуется использовать профиль по умолчанию, но если вы все же хотите сменить его, это можно сделать так: </para>
                    <example>
                        <title>Переключение профиля на 2.4</title>
                        <screen><lineannotation>(убедитесь, что используете нужную архитектуру; этот пример - для x86)</lineannotation>
<prompt>#</prompt> <userinput>ln -snf /usr/portage/profiles/default-linux/x86/no-nptl/2.4 /etc/make.profile</userinput>
<lineannotation>(вывод списка файлов в профиле 2.4)</lineannotation>
<prompt>#</prompt> <userinput>ls -FGg /etc/make.profile/</userinput>
total 12
-rw-r--r--  1 939 Dec 10 14:06 packages
-rw-r--r--  1 347 Dec  3  2004 parent
-rw-r--r--  1 573 Dec  3  2004 virtuals</screen>
                    </example>
                    <para>Для архитектуры ppc в выпуске 2006.1 появилось несколько новых профилей: </para>
                    <example>
                        <title>Профили для PPC</title>
                        <screen><lineannotation>(базовый профиль PPC, подходит для всех PPC-машин, минимальный)</lineannotation>
<prompt>#</prompt> <userinput>ln -snf /usr/portage/profiles/default-linux/ppc/ppc32/2006.1 /etc/make.profile</userinput>
<lineannotation>(профиль для G3)</lineannotation>
<prompt>#</prompt> <userinput>ln -snf /usr/portage/profiles/default-linux/ppc/ppc32/2006.1/G3 /etc/make.profile</userinput>
(профиль для G3 Pegasos)
<prompt>#</prompt> <userinput>ln -snf /usr/portage/profiles/default-linux/ppc/ppc32/2006.1/G3/Pegasos/ /etc/make.profile</userinput>
<lineannotation>(профиль для G4 (Altivec))</lineannotation>
<prompt>#</prompt> <userinput>ln -snf /usr/portage/profiles/default-linux/ppc/ppc32/2006.1/G4 /etc/make.profile</userinput>
<lineannotation>(профиль для G4 (Altivec) Pegasos)</lineannotation>
<prompt>#</prompt> <userinput>ln -snf /usr/portage/profiles/default-linux/ppc/ppc32/2006.1/G4/Pegasos/ /etc/make.profile</userinput></screen>
                    </example>
                    <para>Для архитектуры ppc64 в выпуске 2006.1 также появилось несколько новых профилей: </para>
                    <example>
                        <title>Профили для PPC64</title>
                        <screen><lineannotation>(базовый профиль PPC64 с 64-битным режимом пользователя, для всех PPC64-машин)</lineannotation>
<prompt>#</prompt> <userinput>ln -snf /usr/portage/profiles/default-linux/ppc/ppc64/2006.1/64bit-userland /etc/make.profile</userinput>
<lineannotation>(базовый профиль PPC64 с 32-битным режимом пользователя, для всех PPC64-машин)</lineannotation>
<prompt>#</prompt> <userinput>ln -snf /usr/portage/profiles/default-linux/ppc/ppc64/2006.1/32bit-userland /etc/make.profile</userinput>
<lineannotation>(для каждого режима пользователя существуют подпрофили, как показано ниже.)
(«userland» необходимо заменять на нужный вариант режима из примеров выше)
(профиль 970 для JS20)</lineannotation>
<prompt>#</prompt> <userinput>ln -snf /usr/portage/profiles/default-linux/ppc/ppc64/2006.1/(userland)/970 /etc/make.profile</userinput>
<lineannotation>(профиль для G5)</lineannotation>
<prompt>#</prompt> <userinput>ln -snf /usr/portage/profiles/default-linux/ppc/ppc64/2006.1/(userland)/970/pmac /etc/make.profile</userinput>
<lineannotation>(профиль для POWER3)</lineannotation>
<prompt>#</prompt> <userinput>ln -snf /usr/portage/profiles/default-linux/ppc/ppc64/2006.1/(userland)/power3 /etc/make.profile</userinput>
<lineannotation>(профиль для POWER4)</lineannotation>
<prompt>#</prompt> <userinput>ln -snf /usr/portage/profiles/default-linux/ppc/ppc64/2006.1/(userland)/power4 /etc/make.profile</userinput>
<lineannotation>(профиль для POWER5)</lineannotation>
<prompt>#</prompt> <userinput>ln -snf /usr/portage/profiles/default-linux/ppc/ppc64/2006.1/(userland)/power5 /etc/make.profile</userinput>
<lineannotation>(многорежимные профили на дату выхода этого выпуска нестабильны)</lineannotation></screen>
                    </example>
                </section>
            </section>
            <section>
                <title>Настройка переменной USE</title>
                <para><indexterm><primary>USE</primary></indexterm><envar>USE</envar> («использовать») — одна из самых мощных переменных, имеющихся в распоряжении пользователей Gentoo. Она позволяет при компиляции программ включать или отключать поддержку определенных необязательных функций. Например, некоторые программы можно компилировать с поддержкой gtk или qt на выбор. Другие можно собирать, включая или отключая поддержку SSL. Некоторые программы можно даже компилировать с поддержкой кадрового буфера (svgalib) вместо поддержки X11 (X-сервера). </para>
                <para>В большинстве дистрибутивов пакеты собраны с поддержкой практически всех мыслимых вариантов. Это увеличивает размер программ и время запуска, не говоря уже о чрезмерных зависимостях. В Gentoo вы сами можете определять, с какими возможностями следует компилировать пакет. Здесь играет роль переменная <envar>USE</envar>. </para>
                <para>В переменной <envar>USE</envar> указываются ключевые слова, которые отражаются на параметрах компиляции. Например, параметр ssl включает компиляцию с поддержкой ssl всех программ, которые способны его поддерживать. -X отключает поддержку X-сервера (обратите внимание на предшествующий знак «минус»). Параметры <code>gnome gtk -kde -qt</code> обеспечивают компиляцию ваших программ с поддержкой Gnome и gtk, но без поддержки KDE и qt, делая систему оптимальной для GNOME. </para>
                <para>Настройки USE по умолчанию хранятся в файлах <filename>make.defaults</filename> вашего профиля. Файлы make.defaults находятся в каталоге, на который указывает <filename>/etc/make.profile</filename>, а также во всех родительских каталогах. Значение <envar>USE</envar> по умолчанию — это сумма всех значений <envar>USE</envar> во всех файлах <filename>make.defaults</filename>. Все, что вы вносите в <filename>/etc/make.conf</filename>, рассчитывается относительно этих значений. Когда вы добавляете что-либо к значению <envar>USE</envar>, оно добавляется в список по умолчанию. Когда удаляете что-либо (указывая ключевое слово с предшествующим знаком минус), оно удаляется из списка по умолчанию (если оно там вообще было). Никогда ничего не меняйте в <filename>/etc/make.profile</filename>. Все, что там находится, перезаписывается при обновлении Portage! </para>
                <para>Полное описание переменной <envar>USE</envar> находится во второй части настольной книги Gentoo в главе <link xlink:href="#">USE-флаги</link>. Полное описание возможных значений признаков использования находится в вашей системе в файле <filename>/usr/portage/profiles/use.desc</filename>. </para>
                <example>
                    <title>Просмотр допустимых USE-флагов</title>
                    <screen><prompt>#</prompt> <userinput>less /usr/portage/profiles/use.desc</userinput>
<lineannotation>(для прокрутки пользуйтесь клавишами стрелок, для выхода нажимайте "q")</lineannotation></screen>
                </example>
                <para>Например, приведем значение <envar>USE</envar> для системы, базирующейся на KDE, с включением поддержки DVD, ALSA и записи CD: </para>
                <example>
                    <title>Открытие файла <filename>/etc/make.conf</filename></title>
                    <screen><prompt>#</prompt> <userinput>nano -w /etc/make.conf</userinput></screen>
                </example>
                <example>
                    <title>Значение <filename>USE</filename></title>
                    <programlisting>USE="-gtk -gnome qt kde dvd alsa cdr"</programlisting>
                </example>
            </section>
            <section>
                <title>Дополнительно: региональные параметры GLIBC</title>
                <para>Скорее всего, вы будете использовать в системе один-два набора региональных параметров. Нужные регионы можно указать в <filename>/etc/locale.gen</filename>. </para>
                <example>
                    <title>Открытие <filename>/etc/locale.gen</filename></title>
                    <screen><prompt>#</prompt> <userinput>nano -w /etc/locale.gen</userinput></screen>
                </example>
                <para>Вот пример одновременного подключения как английского (США), так и немецкого (Германия) с соответствующими кодировками (например, UTF-8). </para>
                <example>
                    <title>Укажите свои региональные настройки</title>
                    <programlisting>en_US/ISO-8859-1
en_US.UTF-8/UTF-8
de_DE/ISO-8859-1
de_DE@euro/ISO-8859-15</programlisting>
                </example>
                <para>Следующий шаг — запустить <command>locale-gen</command>. Это сгенерирует настройки для всех регионов, указанных вами в файле <filename>/etc/locale.gen</filename>. </para>
                <note>
                    <para><command>locale-gen</command> имеется в glibc-2.3.6-r4 и более новой. Если у вас старшая версия glibc, сейчас ее следует обновить. </para>
                </note>
                <note>
                    <para>Настройки, подобной приведенной, для поддержки русского языка недостаточно. За дополнительными сведениями обращайтесь к отдельным руководствам по русификации Gentoo. — <emphasis role="italic">прим. пер.</emphasis>
                    </para>
                </note>
                <para>Теперь приступим к <link xlink:href="#gnt-hb.kernel-konfig">настройке ядра</link>. </para>
            </section>
        </section>
        <section xreflabel="Настройка ядра" xml:id="gnt-hb.kernel-konfig">
            <title>Настройка ядра</title>
            <section>
                <title>Часовой пояс</title>
                <para>Сначала необходимо выбрать часовой пояс (time zone), чтобы система знала, где вы находитесь. Найдите подходящий пояс в <filename>/usr/share/zoneinfo</filename>, затем скопируйте его в <filename>/etc/localtime</filename>. Постарайтесь, пожалуйста, избегать использования часовых поясов <filename>/usr/share/zoneinfo/Etc/GMT*</filename>, т. к. их названия не соответствуют ожидаемым поясам. Например, GMT-8 фактически является поясом GMT+8. </para>
                <example>
                    <title>Установка часового пояса</title>
                    <screen><prompt>#</prompt> <userinput>ls /usr/share/zoneinfo</userinput>
<lineannotation>(допустим, вы хотите использовать GMT)</lineannotation>
<prompt>#</prompt> <userinput>cp /usr/share/zoneinfo/GMT /etc/localtime</userinput></screen>
                </example>
                <note>
                    <para>(JohnBat26): Если возникают проблемы со временем (особенно с часовыми поясами), то выполните следующее (получено с форума):</para>
                    <orderedlist>
                        <listitem>
                            <para>Выставите правильное время.</para>
                        </listitem>
                        <listitem>
                            <para>Удалите файл <filename>/etc/adjtime</filename>. Все, часы идут при перезагрузке нормально.</para>
                        </listitem>
                        <listitem>
                            <para><command>nano -w /etc/conf.d/clock</command>.   Ставьте там вместо UTC Local,и все!!!</para>
                        </listitem>
                    </orderedlist>
                </note>
            </section>
            <section>
                <info>
                    <title>Установка исходных кодов ядра</title>
                </info>
                <section>
                    <title>Выбор ядра</title>
                    <para>Ядро Linux — это то, вокруг чего формируются все дистрибутивы. Это слой между пользовательскими программами и вашим оборудованием. Пользователи Gentoo могут выбирать из нескольких типов ядра. Их полный список и описание находится в <link xlink:href="http://www.gentoo.org/doc/en/gentoo-kernel.xml">руководстве по выбору ядра Gentoo (англ.)</link>. </para>
                    <para>Для x86 систем, помимо прочего, есть такие ядра, как </para>
                    <orderedlist>
                        <listitem>
                            <para>vanilla-sources (ядро по умолчанию от разработчиков linux ядра);</para>
                        </listitem>
                        <listitem>
                            <para>gentoo-sources (ядро с заплатками, улучшающими производительность). </para>
                        </listitem>
                    </orderedlist>
                    <para>С помощью команды <command>emerge</command> выберите и установите ядро. <code>USE="-doc"</code> требуется, чтобы на этом этапе избежать установки xorg-x11 или других связанных пакетов. <code>USE="symlink"</code> при новой установке не требуется, но обеспечивает правильное создание символьной ссылки <filename>/usr/src/linux</filename>: </para>
                    <example>
                        <title>Установка исходных кодов ядра</title>
                        <screen><prompt>#</prompt> <userinput>USE="-doc symlink" emerge gentoo-sources</userinput></screen>
                    </example>
                    <para>Просмотрев содержимое каталога <filename>/usr/src</filename>, вы увидите символьную ссылку <filename>linux</filename>, которая указывает на каталог с исходными кодами ядра. В данном случае, установленный исходный код ядра указывает на <filename>gentoo-sources-2.6.12-r10</filename>. Имейте в виду, что ваша версия может отличаться. </para>
                    <example>
                        <title>Просмотр папки с исходными кодами ядра</title>
                        <screen><prompt>#</prompt> <userinput>ls -l /usr/src/linux</userinput>
lrwxrwxrwx    1 root     root           12 Oct 13 11:04 /usr/src/linux -&gt; linux-2.6.12-gentoo-r10</screen>
                    </example>
                    <para>Теперь настало время настройки и компиляции ядра. Можно использовать сценарий <command>genkernel</command>, который сформирует стандартное ядро, аналогичное используемому на установочном компакт-диске. Однако сначала мы расскажем о «ручной» настройке ядра, так как это лучший из способов оптимизации системы. </para>
                    <para>Если вы собираетесь настроить ядро вручную, то переходите к разделу по умолчанию: <link xlink:href="#">ручная настройка</link>. Если вы хотите использовать <command>genkernel</command>, то читайте <link xlink:href="#">альтернатива: использование genkernel</link>. </para>
                </section>
            </section>
            <section>
                <title>По умолчанию: ручная настройка</title>
                <section>
                    <title>Введение</title>
                    <para>Ручная настройка ядра считается одним из самых сложных вопросов для пользователей Linux. Зато после настройки нескольких вариантов ядра вы и не вспомните, что это когда-то было трудно ;) </para>
                    <para>Однако есть одна непреложная <emphasis role="italic">истина</emphasis>: запуская ручную настройку ядра, следует знать состав аппаратуры своего компьютера. Большую часть информации можно собрать, установив пакет pciutils (<command>emerge pciutils</command>), в который входит <command>lspci</command>. <command>lspci</command> можно использовать, находясь в среде с временным корневым каталогом. Можно не обращать внимания на предупреждения, касающиеся pcilib (например: pcilib: cannot open /sys/bus/pci/devices [pcilib: не могу открыть /sys/bus/pci/devices]), которые выводит на экран <command>lspci</command>. Можно запустить <command>lspci</command> и вне временной среды установки. Результат тот же. Вы также можете запустить <command>lsmod</command> для просмотра модулей ядра, используемых установочным компакт-диском (это даст хорошую подсказку, какие параметры включать). </para>
                    <para>Теперь войдите в каталог с исходными кодами ядра и введите команду <command>make menuconfig</command>. Этой командой вы вызовете меню настройки, использующее ncurses. </para>
                    <example>
                        <title>Вызов меню настройки</title>
                        <screen><prompt>#</prompt> <userinput>cd /usr/src/linux</userinput>
<prompt>#</prompt> <userinput>make menuconfig</userinput></screen>
                    </example>
                    <para>Перед вами появятся несколько разделов настройки. Сначала перечислим пункты, включение которых обязательно (иначе Gentoo не заработает, или для его работы потребуются дополнительные ухищрения). </para>
                </section>
                <section>
                    <title>Включение нужных пунктов</title>
                    <para>Прежде всего, разрешите использование разрабатываемого и экспериментального кода и драйверов. Без этого не появятся некоторые важные пункты: </para>
                    <example>
                        <title>Выбор экспериментальных кодов/драйверов, основные параметры</title>
                        <screen>Code maturity level options ---&gt;
  [*] Prompt for development and/or incomplete code/drivers"
General setup  ---&gt;
  [*] Support for hot-pluggable devices</screen>
                    </example>
                    <para>Удостоверьтесь, что каждый драйвер, жизненно необходимый для загрузки системы (например, SCSI-контроллера), собран внутри ядра, а не как модуль, иначе система совсем не сможет загрузиться. </para>
                    <para>Далее выберите нужное семейство процессоров: </para>
                    <example>
                        <title>Выбор подходящего семейства процессоров</title>
                        <screen>Processor type and features ---&gt;
  <lineannotation>(измените в соответствии со своей системой)</lineannotation>
  (Athlon/Duron/K7) Processor family</screen>
                    </example>
                    <para>Теперь войдите в File Systems и выберите поддержку всех нужных файловых систем. Не компилируйте их как модули, иначе система Gentoo не сможет смонтировать дисковые разделы. Также выберите Virtual memory и /proc file system. При использовании ядра 2.4, вам потребуется включить /dev file system, т.к. это ядро не поддерживает udev. </para>
                    <example>
                        <title>Выбор необходимых файловых систем</title>
                        <screen><lineannotation>(при использовани ядра 2.4.x)</lineannotation>
File systems --->
  [*] Virtual memory file system support (former shm fs)
  [*] /proc file system support
  [*] /dev file system support (EXPERIMENTAL)
  [*]   automatically mount /dev at boot
  [ ] /dev/pts file system for Unix98 PTYs

<lineannotation>(при использовании ядра 2.6.x)</lineannotation>
File systems --->
  Pseudo Filesystems --->
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)

<lineannotation>(включите поддержку всех нужных вам файловых систем)</lineannotation>
  &lt;*&gt; Reiserfs support
  &lt;*&gt; Ext3 journalling file system support
  &lt;*&gt; JFS filesystem support
  &lt;*&gt; Second extended fs support
  &lt;*&gt; XFS filesystem support</screen>
                    </example>
                    <para>Если ваш BIOS не поддерживает жесткие диски большого размера, и вы ограничили перемычками сообщаемый диском объем, то для получения доступа ко всему диску нужно включить следующие параметры ядра: </para>
                    <example>
                        <title>Включение поддержки автокоррекции геометрии</title>
                        <screen><lineannotation>(только в ядре 2.4.x)</lineannotation>
ATA/IDE/MFM/RLL support --->
  IDE, ATA and ATAPI Block devices --->
    &lt;*&gt;   Include IDE/ATA-2 DISK support
    [ ]     Use multi-mode by default
    [*]     Auto-Geometry Resizing support</screen>
                    </example>
                    <para>Не забудьте включить поддержку режима DMA для ваших дисков: </para>
                    <example>
                        <title>Включение DMA</title>
                        <screen>Device Drivers ---&gt;
  ATA/ATAPI/MFM/RLL support ---&gt;
    [*] Generic PCI bus-master DMA support
    [*]   Use PCI DMA by default when available</screen>
                    </example>
                    <para>Если вы используете PPPoE или коммутируемого соединения для соединения с интернетом, потребуется включить в ядре следующие функции: </para>
                    <example>
                        <title>Выбор нужных драйверов PPPoE</title>
                        <screen><lineannotation>(при использовании ядра 2.4.х)</lineannotation>
Network device support ---&gt;
  &lt;*&gt; PPP (point-to-point protocol) support
  &lt;*&gt;   PPP support for async serial ports
  &lt;*&gt;   PPP support for sync tty ports
  
<lineannotation>(при использовании ядра 2.6.x)</lineannotation>
Device Drivers --->
  Networking support --->
    &lt;*&gt; PPP (point-to-point protocol) support
    &lt;*&gt;   PPP support for async serial ports
    &lt;*&gt;   PPP support for sync tty ports</screen>
                    </example>
                    <para>Два параметра сжатия данных не являются обязательными, но и не повредят. То же относится и к параметру PPP over Ethernet который нужен только для rp-pppoe, для поддержки PPPoE в режиме ядра. </para>
                    <para>При необходимости, не забудьте включить в ядре поддержку своей сетевой платы. </para>
                    <para>Если у вас процессор Intel с поддержкой HyperTreading или многопроцессорная система, следует включить «симметричную многопроцессорную обработку»: </para>
                    <example>
                        <title>Включение поддержки SMP</title>
                        <screen>Processor type and features  ---&gt; 
  [*] Symmetric multi-processing support</screen>
                    </example>
                    <para>Если вы пользуетесь устройствами ввода на шине USB, (например, мышью или клавиатурой), не забудьте включить их поддержку: </para>
                    <example>
                        <title>Включение поддержки USB для устройств ввода</title>
                        <screen>USB Support ---&gt;
  &lt;*&gt;   USB Human Interface Device (full HID) support</screen>
                    </example>
                    <para>Владельцам ноутбуков, которым нужна поддержка PCMCIA, не нужно включать драйверы PCMCIA в ядре, выбрав ядро версии 2.4. В пакете pcmcia-cs, который будет устанавливаться позже, есть более свежие драйверы. Пользователям ядра 2.6 следует использовать драйверы PCMCIA, включенные в ядро. </para>
                    <para>Наряду с включением поддержки PCMCIA в ядре 2.6, не забудьте включить поддержку моста PCMCIA своей системы: </para>
                    <example>
                        <title>Включение поддержки PCMCIA для ядра 2.6</title>
                        <screen>Bus options (PCI, PCMCIA, EISA, MCA, ISA)  ---&gt;
  PCCARD (PCMCIA/CardBus) support  ---&gt;
    &lt;*&gt; PCCard (PCMCIA/CardBus) support
(если нужно (обычно нужно), включите поддержку старых 16-битных карт PCMCIA)
    &lt;*&gt;   16-bit PCMCIA support
    [*]   32-bit CardBus support
(выберите наиболее подходящий мост)
    --- PC-card bridges
    &lt;*&gt; CardBus yenta-compatible bridge support (NEW)
    &lt;*&gt; Cirrus PD6729 compatible bridge support (NEW)
    &lt;*&gt; i82092 compatible bridge support (NEW)
    &lt;*&gt; i82365 compatible bridge support (NEW)
    &lt;*&gt; Databook TCIC host bridge support (NEW)</screen>
                    </example>
                    <para>Закончив настройку ядра, приступайте к компиляции и установке. </para>
                </section>
                <section>
                    <title>Компиляция и установка</title>
                    <para>Теперь, когда ядро настроено, настало время его скомпилировать и установить. Выйдите из настройки и запустите процесс компиляции: </para>
                    <example>
                        <title>Компиляция ядра</title>
                        <screen><lineannotation>(для ядра 2.4)</lineannotation>
<prompt>#</prompt> <userinput>make dep &amp;&amp; make bzImage modules modules_install</userinput>

<lineannotation>(для ядра 2.6)</lineannotation>
<prompt>#</prompt> <userinput>make &amp;&amp; make modules_install</userinput></screen>
                    </example>
                    <para>По завершении компиляции, скопируйте образ ядра в каталог <filename>/boot</filename>. Используйте любое имя, которое вам покажется подходящим для избранного ядра, и запомните его, так как позже при настройке начального загрузчика оно потребуется. Не забудьте заменить <replaceable>&lt;версия-ядра&gt;</replaceable> на имя и версию своего ядра. </para>
                    <example>
                        <title>Установка ядра</title>
                        <screen><prompt>#</prompt> <userinput>cp arch/i386/boot/bzImage /boot/&lt;версия-ядра&gt;</userinput></screen>
                    </example>
                    <para>Теперь переходите к модулям ядра. </para>
                </section>
            </section>
            <section>
                <info>
                    <title>Альтернатива: использование genkernel</title>
                </info>
                <para>Если вы читаете эти строки, значит, вы собираетесь использовать наш сценарий <command>genkernel</command> для настройки ядра за вас. </para>
                <para>Теперь когда исходные коды ядра установлены, настало время скомпилировать ядро, собрав его автоматически при помощи сценария <command>genkernel</command>. <command>genkernel</command> выполняет настройку ядра практически так же, как настраивается ядро на установочном компакт-диске. То есть система, ядро которой собрано <command>genkernel</command>, как правило, будет выполнять определение всех устройств при загрузке. Поскольку genkernel не требует никакой ручной настройки ядра, это идеальное решение для тех, кому неуютно от одной мысли, что придется компилировать ядро. </para>
                <para>Рассмотрим, как использовать <command>genkernel</command>. Сначала установите его: </para>
                <example>
                    <title>Установка <command>genkernel</command></title>
                    <screen><prompt>#</prompt> <userinput>emerge genkernel</userinput></screen>
                </example>
                <para>Теперь, если вы собираетесь использовать ядро ветви 2.6, скопируйте настройку ядра, используемую установочным диском, в каталог, где <command>genkernel</command> ищет настройку по умолчанию: </para>
                <example>
                    <title>Копирование файла настройки ядра с установочного диска</title>
                    <screen><lineannotation>(только если вы собираетесь настраивать ядро 2.6.х)</lineannotation>
<prompt>#</prompt> <userinput>zcat /proc/config.gz > /usr/share/genkernel/x86/kernel-config-2.6</userinput></screen>
                </example>
                <para>Теперь скомпилируйте исходный код ядра, запустив <command>genkernel all</command>. Имейте в виду, что компиляция займет приличное время, поскольку <command>genkernel</command> собирает ядро, поддерживающее практически любое оборудование. </para>
                <para>Если в загрузочном разделе не используется файловая система <systemitem>ext2</systemitem> или <systemitem>ext3</systemitem>, то вам придется вручную настроить ядро, запустив <command>genkernel --menuconfig all</command>, добавив поддержку используемой файловой системы в ядро (т.е. не модулем). Пользователям EVMS2 или LVM2, вероятно, захочется также добавить параметр командной строки <option>--evms2</option> или <option>--lvm2</option>. </para>
                <example>
                    <title>Запуск genkernel</title>
                    <screen><prompt>#</prompt> <userinput>genkernel all</userinput></screen>
                </example>
                <para>В итоге работы <command>genkernel</command> будет создано ядро, полный набор модулей и начальный корневой диск (initrd). Ядро и initrd будут использоваться в процессе настройки загрузчика системы, которая описана далее в руководстве. Запишите имена ядра и начального корневого диска, так как они понадобятся при составлении конфигурационного файла загрузчика. initrd запускается сразу при начальной загрузке, выполняя автоматическое определение устройств (точно так же, как при запуске установочного диска), до запуска «настоящей» системы. </para>
                <example>
                    <title>Уточнение названия созданного образа ядра и initrd</title>
                    <screen><prompt>#</prompt> <userinput>ls /boot/kernel* /boot/initramfs*</userinput></screen>
                </example>
                <para>Теперь давайте еще на шаг приблизим нашу систему к установочному диску: соберем coldplug. Если initrd определяет оборудование, необходимое для загрузки системы, coldplug выполняет автоопределение всех остальных устройств. Для установки и подключения coldplug введите команду: </para>
                <example>
                    <title>Установка и подключение coldplug</title>
                    <screen><prompt>#</prompt> <userinput>emerge coldplug</userinput>
<prompt>#</prompt> <userinput>rc-update add coldplug boot</userinput></screen>
                </example>
            </section>
            <section>
                <info>
                    <title>Модули ядра</title>
                </info>
                <section>
                    <title>Настройка модулей</title>
                    <para>Модули, которые требуется загружать автоматически, нужно указать в <filename>/etc/modules.autoload.d/kernel-2.4</filename> (или <filename>kernel-2.6</filename>). Также, при желании, модулям можно сообщить дополнительные параметры. </para>
                    <para>Для просмотра всех доступных модулей запустите команду <command>find</command>, заменив «<replaceable>&lt;версия ядра&gt;</replaceable>» на версию только что собранного ядра: </para>
                    <example>
                        <title>Просмотр перечня доступных модулей</title>
                        <screen><prompt>#</prompt> <userinput>find /lib/modules/&lt;kernel version&gt;/ -type f -iname '*.o' -or -iname '*.ko'</userinput></screen>
                    </example>
                    <para>Например, для автоматической загрузки модуля <filename>3c59x.o</filename> измените файл <filename>kernel-2.4</filename> или <filename>kernel-2.6</filename>, указав в нем имя модуля. </para>
                    <example>
                        <title>Изменение <filename>/etc/modules.autoload.d/kernel-2.4</filename></title>
                        <screen><lineannotation>(показан пример для ядра 2.4.x)</lineannotation>
<prompt>#</prompt> <userinput>nano -w /etc/modules.autoload.d/kernel-2.4</userinput></screen>
                    </example>
                    <example>
                        <title><filename>/etc/modules.autoload.d/kernel-2.4</filename> или <filename>kernel-2.6</filename></title>
                        <programlisting>3c59x</programlisting>
                    </example>
                    <para>Теперь переходите к настройке параметров системы. </para>
                </section>
            </section>
        </section>
        <section xreflabel="Настройка параметров системы">
            <title>Настройка параметров системы</title>
            <section>
                <title>Параметры файловых систем</title>
                <section>
                    <title>Что такое fstab?</title>
                    <para>В Linux все разделы, используемые системой, должны быть перечислены в <filename>/etc/fstab</filename>. В этом файле указываются точки подключения разделов (mountpoints, местоположение разделов в файловой системе), порядок подключения, а также дополнительные параметры (автоматический или ручной режим подключения, достаточность прав пользователя для подключения и т.п.) </para>
                    <para/>
                </section>
                <section>
                    <title>Создание <filename>/etc/fstab</filename></title>
                    <para>В <filename>/etc/fstab</filename> используется специальный формат. Каждая строка состоит из шести полей, разделяемых пробелами, знаками табуляции или их сочетанием. Каждое поле имеет свое назначение:</para>
                    <orderedlist>
                        <listitem>
                            <para>Первое поле обозначает раздел (partition) (путь к файлу устройства). </para>
                        </listitem>
                        <listitem>
                            <para>Второе поле указывает точку подключения (mountpoint), в которую монтируется раздел. </para>
                        </listitem>
                        <listitem>
                            <para>Третье поле задает тип файловой системы (filesystem), используемой в разделе. </para>
                        </listitem>
                        <listitem>
                            <para>В четвертом поле указываются параметры подключения (mountoptions), используемые mount при подключении раздела. Поскольку для каждой файловой системы существуют свои параметры, рекомендуется прочитать страницу справки по <command>mount</command> (<command>man mount</command>), где приведен их полный перечень. При указании нескольких параметров подключения их следует разделять запятыми. </para>
                        </listitem>
                        <listitem>
                            <para>Пятое поле используется dump для определения, требуется ли резервное копирование раздела средствами dump. Обычно это поле можно просто установить в 0 (ноль). </para>
                        </listitem>
                        <listitem>
                            <para>Шестое поле используется <command>fsck</command> для определения порядка проверки (check) файловых систем после некорректного завершения работы системы. Для корневой файловой системы рекомендуется значение 1, а для остальных — 2 (или 0, когда проверка файловой системы не требуется). </para>
                        </listitem>
                    </orderedlist>
                    <important>
                        <para>Вариант файла <filename>/etc/fstab</filename> по умолчанию, входящий в Gentoo, не является работоспособным. Вам потребуется создать свой собственный <filename>/etc/fstab</filename>. </para>
                    </important>
                    <example>
                        <title>Открытие <filename>/etc/fstab</filename></title>
                        <screen><prompt>#</prompt> <userinput>nano -w /etc/fstab</userinput></screen>
                    </example>
                    <para>Укажите правила, соответствующие вашей схеме разбивки, и добавьте правила для <filename>/proc</filename>, для tmpfs, для своих дисководов CD-ROM (если есть другие разделы или устройства, их тоже можно указать). </para>
                    <para>Теперь на основе приведенного примера создайте собственный файл <filename>/etc/fstab</filename>: </para>
                    <para>Параметр <option>auto</option> позволяет <command>mount</command> определять тип файловой системы автоматически (рекомендуется для съемных носителей, которые могут оказаться размечены в одной из множества существующих файловых систем), а <option>user</option> позволяет монтировать компакт-диски обычным пользователям. </para>
                    <para>Чтобы повысить быстродействие, большинству пользователей стоит добавить параметр noatime в параметры подключения, что приведет к ускорению за счет отключения регистрации отметки времени доступа к файлам (обычно в ней все равно нет необходимости): </para>
                    <para>Перепроверьте свой файл <filename>/etc/fstab</filename>, сохраните его, и выйдите из редактора, чтобы продолжить настройку. </para>
                    <note>
                        <title>Примечание (JohnBat26): пример моего /etc/fstab:</title>
                        <example>
                            <title>Пример  <filename>/etc/fstab</filename></title>
                            <programlisting>/dev/sda2    /boot           ext2     defaults,noatime                                    1 2
/dev/sda5    /               xfs      defaults,noatime                                    0 1
/dev/sda3    none            swap     sw                                                  0 0
/dev/sda7    /home           xfs      defaults,noatime                                    0 1
/dev/sr0     /mnt/cdrom      auto     noauto,ro,user,iocharset=utf8                       0 0

# раздел с FAT32
/dev/sda1    /windows/c       vfat    auto,iocharset=utf8,quiet,user,umask=000,noatime    0 0

# раздел NTFS только для чтения
/dev/sda6    /windows/d      ntfs     auto,nls=utf8,umask=0,user,noatime                  0 0
/dev/sda8    /windows/e      vfat     auto,iocharset=utf8,user,quiet,umask=000,noatime    0 0
/dev/sda9    /home/media     xfs      defaults,noatime                                    0 1

# раздел NTFS для чтения и записи при помощи ntfs-3g
/dev/sda10   /mnt/windows/f  ntfs-3g  -o silent,umask=0,locale=ru_RU.utf8 

# NOTE: The next line is critical for boot!
proc         /proc           proc     defaults                                            0 0

# flash drive 
/dev/sdb     /mnt/flash      auto     user,noauto,rw,async,iocharset=utf8                 0 0
shm          /dev/shm        tmpfs    nodev,nosuid,noexec                                 0 0</programlisting>
                        </example>
                    </note>
                </section>
            </section>
            <section>
                <title>Параметры сети</title>
                <section>
                    <title>Hostname, Domainname и т. д.</title>
                    <para>Еще один вопрос, который нужно решить пользователю — как назвать свой компьютер. Он кажется довольно простым, но многие затрудняются дать подходящее имя для своей Linux-системы. Чтобы вам стало легче, запомните, что какое бы имя вы не выбрали, потом его всегда можно изменить. Например, вы могли бы просто назвать свою систему tux, а домен — homenetwork. </para>
                    <example>
                        <title>Установка имени узла</title>
                        <screen><prompt>#</prompt> <userinput>nano -w /etc/conf.d/hostname</userinput>

<lineannotation>(присвойте переменной HOSTNAME имя своего узла)</lineannotation>
HOSTNAME="tux"</screen>
                    </example>
                    <para>Во-вторых, установим имя домена (domainname) в <filename>/etc/conf.d/net</filename>: </para>
                    <example>
                        <title>Установка имени домена</title>
                        <screen><prompt>#</prompt> <userinput>nano -w /etc/conf.d/net</userinput>

<lineannotation>(присвойте переменной DNSDOMAIN имя своего домена)</lineannotation>
dns_domain_lo="homenetwork"</screen>
                    </example>
                    <para>Если у вас есть домен NIS (а если вы не знаете, что это такое, то у вас его точно нет), его также необходимо указать: </para>
                    <example>
                        <title>Установка имени NIS-домена</title>
                        <screen><prompt>#</prompt> <userinput>nano -w /etc/conf.d/net</userinput>

<lineannotation>(укажите название своего домена NIS переменной nis_domain)</lineannotation>
nis_domain_lo="my-nisdomain"</screen>
                    </example>
                </section>
                <section>
                    <title>Настройка сети</title>
                    <para>Прежде, чем возмутиться: «Эй, мы же все это уже делали!» — вспомните, что подключение к сети, настроенное вначале, было предназначено лишь для установки Gentoo. Теперь же вы настраиваете сеть для постоянного использования. </para>
                    <note>
                        <para>Более подробные сведения о сетях, включая дополнительные темы, такие как объединение, образование мостов, настройка виртуальных сетей (VLAN) 802.1Q или беспроводных сетей, представлены в разделе <link xlink:href="#">настройка сети в Gentoo</link>. </para>
                    </note>
                    <para>Все настройки сети собраны в файле <filename>/etc/conf.d/net</filename>. В нем используется простой формат, хотя, если вы не знакомы с ручной настройкой сети, он не слишком очевиден. Но не бойтесь, мы все объясним. В файле <filename>/etc/conf.d/net.example</filename> приведен подробно прокомментированный пример, охватывающий много различных конфигураций. </para>
                    <para>По умолчанию используется DHCP. Чтобы DHCP заработал, требуется установить DHCP-клиент, как описано далее в разделе <link xlink:href="#">Установка нужных системных средств</link>. Не забудьте установить DHCP-клиент. </para>
                    <para>Если настройка сетевого подключения нужна вам для указания специфических параметров DHCP, или из-за того, что вы вообще не используете DHCP, откройте <filename>/etc/conf.d/net</filename> в своем любимом редакторе (в этом примере использован nano): </para>
                    <example>
                        <title>Открытие <filename>/etc/conf.d/net</filename> для изменения</title>
                        <screen><prompt>#</prompt> <userinput>nano -w /etc/conf.d/net</userinput></screen>
                    </example>
                    <para>Вы увидите следующее: </para>
                    <example>
                        <title><filename>/etc/conf.d/net</filename> по умолчанию</title>
                        <programlisting># This blank configuration will automatically use DHCP for any net.*
# scripts in /etc/init.d.  To create a more complete configuration,
# please review /etc/conf.d/net.example and save your configuration
# in /etc/conf.d/net (this file :]!).

<lineannotation>(# Этот пустой файл настройки приводит к автоматическому использованию
 # DHCP всеми сценариями net.* из /etc/init.d. Для создания более полной
 # настройки, пожалуйста, просмотрите /etc/conf.d/net.example, а свою
 # настройку сохраните в /etc/conf.d/net (в этом файле :]!).            )</lineannotation></programlisting>
                    </example>
                    <para>Чтобы указать свой собственный адрес IP, маску сети и шлюз, потребуется настроить как <varname>config_eth0</varname>, так и <varname>routes_eth0</varname>: </para>
                    <example>
                        <title>Ручная настройка параметров IP для eth0</title>
                        <programlisting>config_eth0=( "192.168.0.2 netmask 255.255.255.0 brd 192.168.0.255" )
routes_eth0=( "default gw 192.168.0.1" )</programlisting>
                    </example>
                    <para>Чтобы при использовании DHCP указать специфические параметры, определите config_eth0 и dhcp_eth0: </para>
                    <example>
                        <title>Автоматическое получение адреса IP для eth0</title>
                        <programlisting>config_eth0=( "dhcp" )
dhcp_eth0="nodns nontp nonis"</programlisting>
                    </example>
                    <para>Список допустимых параметров дан в файле <filename>/etc/conf.d/net.example</filename>. </para>
                    <para>Если у вас несколько сетевых интерфейсов, повторите эти шаги для config_eth1, config_eth2 и т.д. </para>
                    <para>Теперь сохраните параметры и выйдите из редактора, чтобы продолжить настройку. </para>
                </section>
                <section>
                    <title>Автоматический запуск сетевого подключения при загрузке</title>
                    <para>Для запуска сетевых интерфейсов при загрузке необходимо добавить их в уровень запуска по умолчанию. Если у вас интерфейсы типа PCMCIA, пропустите этот шаг, поскольку интерфейсы PCMCIA запускаются сценарием инициализации PCMCIA. </para>
                    <example>
                        <title>Добавление net.eth0 в уровень запуска default</title>
                        <screen><prompt>#</prompt> <userinput>rc-update add net.eth0 default</userinput></screen>
                    </example>
                    <para>Если у вас несколько сетевых интерфейсов, потребуется создать для них соответствующие сценарии инициализации net.eth1, net.eth2 и т.д. Для этого можно использовать <command>ln</command>: </para>
                    <example>
                        <title>Создание дополнительных сценариев инициализации</title>
                        <screen><prompt>#</prompt> <userinput>cd /etc/init.d</userinput>
<prompt>#</prompt> <userinput>ln -s net.lo net.eth1</userinput>
<prompt>#</prompt> <userinput>rc-update add net.eth1 default</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Указание сетевых узлов</title>
                    <para>Теперь расскажем системе Linux о вашей сети. Эти сведения указываются в <filename>/etc/hosts</filename>, и помогают разрешению имен в IP-адреса для узлов, не обрабатываемых сервером имен. Требуется определить вашу систему. Также можно определить другие системы в сети, если вы не собираетесь устанавливать собственную систему DNS. </para>
                    <example>
                        <title>Открытие <filename>/etc/hosts</filename></title>
                        <screen><prompt>#</prompt> <userinput>nano -w /etc/hosts</userinput></screen>
                    </example>
                    <example>
                        <title>Указание сведений об узлах сети</title>
                        <programlisting><lineannotation>(определение текущей системы)</lineannotation>
127.0.0.1     tux.homenetwork tux localhost

<lineannotation>(определите другие машины в своей сети,
для этого у них должен быть статический IP-адрес.)</lineannotation>

192.168.0.5   jenny.homenetwork jenny
192.168.0.6   benny.homenetwork benny</programlisting>
                    </example>
                    <para>Чтобы продолжить настройку, сохраните файл и выйдите из редактора. </para>
                </section>
            </section>
            <section>
                <title>Параметры системы</title>
                <section>
                    <title>Пароль root</title>
                    <para>Прежде всего, нужно установить пароль root (администратора), набрав: </para>
                    <example>
                        <title>Установка пароля <systemitem class="username">root</systemitem></title>
                        <screen><prompt>#</prompt> <userinput>passwd</userinput></screen>
                    </example>
                    <para>Если вы хотите, чтобы root мог входить в систему через последовательный терминал, добавьте tts/0 в <filename>/etc/securetty</filename>: </para>
                    <example>
                        <title>Добавление tts/0 to <filename>/etc/securetty</filename></title>
                        <screen><prompt>#</prompt> <userinput>echo "tts/0" &gt;&gt; /etc/securetty</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Параметры системы</title>
                    <para>Для общей настройки системы в Gentoo используется <filename>/etc/rc.conf</filename>. Откройте <filename>/etc/rc.conf</filename> и с удовольствием прочитайте все комментарии, находящиеся в этом файле :) </para>
                    <example>
                        <title>Открытие <filename>/etc/rc.conf</filename></title>
                        <screen><prompt>#</prompt> <userinput>nano -w /etc/rc.conf</userinput></screen>
                    </example>
                    <para>Завершив изменение <filename>/etc/rc.conf</filename> сохраните файл и выйдите из редактора. </para>
                    <para>Как видите, этот файл подробно прокомментирован, что поможет вам в настройке необходимых конфигурационных переменных. Можно настроить систему на использование unicode, а также указать редактор по умолчанию и диспетчер отображения (например, gdm или kdm). </para>
                    <para>Для управления раскладками клавиатуры в Gentoo используется <filename>/etc/conf.d/keymaps</filename>. Для настройки своей клавиатуры измените его. </para>
                    <example>
                        <title>Открытие <filename>/etc/conf.d/keymaps</filename></title>
                        <screen><prompt>#</prompt> <userinput>nano -w /etc/conf.d/keymaps</userinput></screen>
                    </example>
                    <para>Будьте особенно тщательны при установке переменной раскладки клавиатуры (KEYMAP): выбрав неверную раскладку, вы можете получить непредсказуемый результат при попытке ввода с клавиатуры. </para>
                    <para>По завершении изменения <filename>/etc/conf.d/keymaps</filename> сохраните файл и выйдите из редактора. </para>
                    <para>Для настройки параметров часов в Gentoo используется <filename>/etc/conf.d/clock</filename>. Изменяйте его в соответствии со своими потребностями. </para>
                    <para>Если аппаратные часы вашей системы настроены не на часовой пояс UTC (Гринвич), в файл необходимо добавить строку <code>CLOCK="local"</code>. В противном случае вы заметите сдвиг часового пояса. </para>
                    <para>После завершения настройки <filename>/etc/conf.d/clock</filename> сохраните файл и выйдите из редактора. </para>
                    <para>Переходите к <link xlink:href="#">установке нужных системных средств</link>. </para>
                </section>
            </section>
        </section>
        <section xreflabel="Установка нужных системных средств">
            <title>Установка нужных системных средств</title>
            <section>
                <title>Диспетчер устройств</title>
                <para>Если вы используете ядро 2.4, <emphasis role="italic">и при этом</emphasis> устанавливаете Gentoo из файла третьей стадии (stage3), вам <emphasis role="italic">необходимо</emphasis> еще кое-что сделать. Так как теперь в Gentoo по умолчанию используется udev, а ядром 2.4 udev не поддерживается, вам потребуется установить devfsd, и убрать udev. </para>
                <example>
                    <title>Установка devfsd</title>
                    <screen><lineannotation>(для тех, кто использует ядро 2.4.x при установке c третьей стадии)</lineannotation>
<prompt>#</prompt> <userinput>emerge --unmerge udev</userinput>
<prompt>#</prompt> <userinput>emerge devfsd</userinput></screen>
                </example>
            </section>
            <section>
                <title>Системные службы журналирования</title>
                <para>Некоторые средства не включены в архив stage3, поскольку одинаковые возможности можно обеспечить различными пакетами. Теперь вы сами выберете, какие именно установить. </para>
                <para>Первый инструмент, который вам необходимо выбрать, должен дать системе возможность журналирования. У Unix и Linux превосходная история развития журналирования — при желании в файлах журналов можно регистрировать любой чих, происходящий в вашей системе. Это обеспечивается системной службой журналирования. </para>
                <para>В Gentoo предлагается несколько служб журналирования на выбор. Это sysklogd, традиционный набор журналирующих демонов, syslog-ng, расширенная служба журналирования, и metalog — служба журналирования с очень гибкими возможностями настройки. Возможно, в Portage имеются и другие службы журналирования: количество доступных пакетов растет день ото дня. </para>
                <para>Если вы планируете использовать sysklogd или syslog-ng, позднее может потребоваться установка logrotate, поскольку в этих службах журналирования не предусмотрен никакой механизм ротации системных журналов. </para>
                <para>Чтобы установить выбранную службу журналирования, воспользуйтесь emerge, а затем добавьте ее в уровень запуска по умолчанию с помощью <command>rc-update</command>. В следующем примере показана установка syslog-ng. Вместо нее вы можете подставить другую службу журналирования: </para>
                <example>
                    <title>Установка системной службы журналирования</title>
                    <screen><prompt>#</prompt> <userinput>emerge syslog-ng</userinput>
<prompt>#</prompt> <userinput>rc-update add syslog-ng default</userinput></screen>
                </example>
            </section>
            <section>
                <title>Дополнительно: демон cron</title>
                <para>Следующий демон — cron. Хотя он является дополнительным, и не обязателен для работы вашей системы, будет благоразумным установить его. Но что же такое демон cron? Демон cron выполняет команды по расписанию. Это очень удобно, когда нужно выполнять какие-либо команды регулярно (например, ежедневно, еженедельно или ежемесячно). </para>
                <para>В Gentoo предлагаются три варианта демона cron на выбор: dcron, fcron и vixie-cron. Установка любого из них подобна установке системной службы журналирования. Однако, при установке dcron или fcron для настройки требуется выполнение дополнительной команды, а именно <command>crontab /etc/crontab</command>. Если вы не знаете, что выбрать, используйте vixie-cron. </para>
                <para>При бессетевой установке доступен только vixie-cron. Если вам нужен другой демон cron, его можно установить позже. </para>
                <example>
                    <title>Установка демона cron</title>
                    <screen><prompt>#</prompt> <userinput>emerge vixie-cron</userinput>
<prompt>#</prompt> <userinput>rc-update add vixie-cron default</userinput>
<lineannotation>(только если выбран dcron или fcron)</lineannotation> <prompt>#</prompt> <userinput>crontab /etc/crontab</userinput></screen>
                </example>
            </section>
            <section>
                <title>Дополнительно: индексация файлов</title>
                <para/>
                <para>Если вы хотите индексировать файлы в своей системе, чтобы быстро находить их с помощью <command>locate</command>, нужно установить sys-apps/slocate: </para>
                <example>
                    <title>Установка slocate</title>
                    <screen><prompt>#</prompt> <userinput>emerge slocate</userinput></screen>
                </example>
            </section>
            <section>
                <title>Утилиты для обслуживания файловых систем</title>
                <para>Для проверки целостности файловых систем, создания дополнительных файловых систем, и т.п., вам потребуются определенные утилиты, состав которых зависит от используемых файловых систем. </para>
                <para>В следующей таблице перечислены утилиты, которые необходимо устанавливать для обслуживания файловых систем различных типов: </para>
                <informaltable>
                    <tgroup cols="3">
                        <thead>
                            <row>
                                <entry>Файловая система</entry>
                                <entry>Утилиты</entry>
                                <entry>Команда установки</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>XFS</entry>
                                <entry>xfsprogs</entry>
                                <entry><command>emerge xfsprogs</command></entry>
                            </row>
                            <row>
                                <entry>ReiserFS</entry>
                                <entry>reiserfsprogs</entry>
                                <entry><command>emerge reiserfsprogs</command></entry>
                            </row>
                            <row>
                                <entry>JFS</entry>
                                <entry>xfsprogs</entry>
                                <entry><command>emerge jfsutils</command></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para>Если вы используете EVMS, также необходимо установить evms: </para>
                <example>
                    <title>Установка утилит EVMS</title>
                    <screen><prompt>#</prompt> <userinput>USE="-gtk" emerge evms</userinput></screen>
                </example>
                <para><code>USE="-gtk"</code> предотвратит установку пакетов, от которых зависит данный. При желании включить графические средства evms, потом можно перекомпилировать evms. </para>
                <para>Если вам не нужны никакие дополнительные сетевые средства (типа rp-pppoe или клиента dhcp), переходите к <link xlink:href="#">настройке начального загрузчика</link>. </para>
            </section>
            <section>
                <title>Сетевые средства</title>
                <section>
                    <title>Дополнительно: установка клиента DHCP</title>
                    <para>Если требуется, чтобы Gentoo автоматически получала IP-адрес для ваших сетевых интерфейсов, необходимо установить dhcpcd (или любой другой клиент DHCP, список имеющихся клиентов DHCP см. в главе <link xlink:href="#">Модульное построение сети</link>). Если не сделать этого сейчас, то после завершения установки вы не сможете подключиться к интернету! </para>
                    <example>
                        <title>Установка dhcpcd</title>
                        <screen><prompt>#</prompt> <userinput>emerge dhcpcd</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Дополнительно: установка клиента PPPoE</title>
                    <para>Если для выхода в сеть требуется rp-pppoe, его нужно установить. </para>
                    <example>
                        <title>Установка rp-pppoe</title>
                        <screen><prompt>#</prompt> <userinput>USE="-X" emerge rp-pppoe</userinput></screen>
                    </example>
                    <para><code>USE="-X"</code> запрещает установку xorg-x11 в порядке зависимости (в rp-pppoe есть графические средства; если их нужно подключить, можно перекомпилировать rp-pppoe позже, или же установить xorg-x11 сейчас: при его установке потребуется много времени на компиляцию). </para>
                </section>
                <section>
                    <title>Дополнительно: утилиты RAID для оборудования IBM</title>
                    <para>Если в составе системы на базе POWER5 вы используете RAID-массивы SCSI, стоит задуматься об установке iprutils, которые, среди прочего, позволяют работать с дисковыми массивами, выяснять состояние дисков в составе массива и обновлять микрокод. </para>
                    <example>
                        <title>Установка iprutils</title>
                        <screen><prompt>#</prompt> <userinput>emerge iprutils</userinput></screen>
                    </example>
                    <para>Теперь переходите к настройке начального загрузчика. </para>
                </section>
            </section>
        </section>
        <section xreflabel="Настройка начального загрузчика">
            <title>Настройка начального загрузчика</title>
            <section>
                <title>Выбор загрузчика</title>
                <section>
                    <title>Введение</title>
                    <para>Теперь, когда ядро настроено и собрано, а нужные конфигурационные файлы заполнены как надо, пришло время установить программу, которая будет запускать ваше ядро при старте системы. Такого рода программа называется загрузчиком. Для архитектуры x86 в Gentoo Linux есть загрузчики GRUB и LILO. Но прежде, чем приступить к установке одного из двух загрузчиков, мы расскажем, как настроить кадровый буфер (естественно, если вы захотите). С помощью кадрового буфера можно работать в командной строке Linux на фоне графических элементов (например, симпатичного изображения из загрузочной заставки Gentoo). </para>
                </section>
                <section>
                    <title>Дополнительно: кадровый буфер</title>
                    <para>Если вы настроили в ядре поддержку кадрового буфера (или оставили настройки по умолчанию при использовании genkernel), вы можете включить буфер, добавив параметр vga и/или video в файл конфигурации своего загрузчика. </para>
                    <para>Для начала, вам надо узнать тип используемого кадрового буфера. При использовании исходных кодов ядра, доработанных для Gentoo (таких как gentoo-sources), у вас есть возможность выбрать vesafb-tng в качестве типа драйвера VESA (в этих исходных кодах ядра он используется по умолчанию). При использовании vesafb-tng параметр vga указывать не нужно. В других случаях используется драйвер vesafb, а параметр vga необходимо указывать. </para>
                    <para>Параметр vga устанавливает разрешение и глубину цвета, используемые кадровым буфером vesafb. Как отмечено в <filename>/usr/src/linux/Documentation/fb/vesafb.txt</filename> (который устанавливается в составе пакета с деревом исходных кодов ядра), кадровому буферу необходимо передавать код режима VESA, соответствующий нужному разрешению и цветности. </para>
                    <para>В следующей таблице приведены коды режимов для указания в параметре vga, а также соответствующие им значения разрешения и цветности.</para>
                    <informaltable frame="none">
                        <tgroup cols="5">
                            <colspec colname="c1" colnum="1"/>
                            <colspec colname="c2" colnum="2"/>
                            <colspec colname="c3" colnum="3"/>
                            <colspec colname="c4" colnum="4"/>
                            <colspec colname="c5" colnum="5"/>
                            <tbody>
                                <row>
                                    <entry/>
                                    <entry>640x480</entry>
                                    <entry>800x600</entry>
                                    <entry>1024x768</entry>
                                    <entry>1280x1024</entry>
                                </row>
                                <row>
                                    <entry>256</entry>
                                    <entry>0x301</entry>
                                    <entry>0x303</entry>
                                    <entry>0x305</entry>
                                    <entry>0x307</entry>
                                </row>
                                <row>
                                    <entry>32 тыс</entry>
                                    <entry>0x310</entry>
                                    <entry>0x313</entry>
                                    <entry>0x316</entry>
                                    <entry>0x319</entry>
                                </row>
                                <row>
                                    <entry>64 тыс</entry>
                                    <entry>0x311</entry>
                                    <entry>0x314</entry>
                                    <entry>0x317</entry>
                                    <entry>0x31A</entry>
                                </row>
                                <row>
                                    <entry>16 млн</entry>
                                    <entry>0x312</entry>
                                    <entry>0x315</entry>
                                    <entry>0x318</entry>
                                    <entry>0x31B</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                    <para>Параметр video отвечает за порядок отображения кадрового буфера. В нем указывается название драйвера кадрового буфера (vesafb для ядра 2.6 или vesa для ядра 2.4), а затем режимы, которые нужно включить. Все режимы приведены в <filename>/usr/src/linux/Documentation/fb/vesafb.txt</filename>, а здесь мы расскажем о трех самых используемых:</para>
                    <orderedlist>
                        <listitem>
                            <para><option>ywrap</option> считать, что видеоплата может закольцовывать свою память (продолжать выборку с начального адреса, когда достигнут конечный); </para>
                        </listitem>
                        <listitem>
                            <para><option>mtrr:n</option> установка регистров MTRR; допустимые значения n: 0 - отключено 1 - без кэширования 2 - отложенная запись (write-back) 3 - объединенная запись (write-combining) 4 - сквозная запись (write-through); </para>
                        </listitem>
                        <listitem>
                            <para><option>mode</option> (только для vesafb-tng) Установить разрешение, цветность и частоту кадров. Например, 1024x768-32@85 для разрешения 1024x768, 32-битного цвета и частоты кадров 85 Гц. </para>
                        </listitem>
                    </orderedlist>
                    <para>В результате должно получиться что-то вроде <code>vga=0x318 video=vesafb:mtrr:3,ywrap</code> или <code>video=vesafb:mtrr:3,ywrap,1024x768-32@85</code>. Запомните (или запишите) составленное значение, скоро оно понадобится.</para>
                    <para>Перейдем к установке <link xlink:href="#">GRUB</link> или <link xlink:href="#">LILO</link>.</para>
                </section>
            </section>
            <section>
                <title>По умолчанию: использование GRUB</title>
                <section>
                    <title>Введение в терминологию GRUB</title>
                    <para><indexterm><primary>GRUB</primary></indexterm>Самое сложное в освоении GRUB — освоиться с тем, как в нем именуются жесткие диски и разделы. Ваш Linux-раздел <filename>/dev/hda1</filename>, скорее всего, в GRUB станет называться <code>(hd0,0)</code>. Обратите внимание на круглые скобки вокруг <code>hd0,0</code> — они обязательны. </para>
                    <para>Жесткие диски нумеруются, начиная с нуля, а не с «а»; разделы — c нуля, а не с единицы. Нужно помнить, что в виде hd нумеруются только жесткие диски, но не устройства atapi-ide, такие как приводы компакт-дисков. Та же нумерация используется для устройств SCSI (обычно им присваиваются номера большие, чем устройствам IDE, кроме случаев, когда BIOS настроен на загрузку с устройства SCSI). Когда BIOS настроен на загрузку с другого жесткого диска (например, с первичного ведомого), именно этот жесткий диск и становится hd0. </para>
                    <para>Например, если у вас есть жесткий диск <filename>/dev/hda</filename>, привод CD-ROM <filename>/dev/hdb</filename>, записывающий CD /dev/hdc, второй жесткий диск <filename>/dev/hdd</filename>, а устройств SCSI нет, то разделу <filename>/dev/hdd7</filename> будет соответствовать <code>(hd1,6)</code>. Возможно, это покажется запутанным (так и есть), но, как мы увидим, в GRUB есть механизм автодополнения по <keycap>TAB</keycap>, облегчающий жизнь обладателям множества жестких дисков и разделов, а также тем, кто теряется в схеме нумерации устройств GRUB. </para>
                    <para>Почувствовав, что к чему, пора установить GRUB. </para>
                </section>
                <section>
                    <title>Установка GRUB</title>
                    <para>Для установки GRUB сначала добавим его в систему: </para>
                    <example>
                        <title>Установка GRUB</title>
                        <screen><prompt>#</prompt> <userinput>emerge grub</userinput></screen>
                    </example>
                    <para>Хотя GRUB уже установлен, нам еще потребуется подправить его файл конфигурации, и поместить GRUB в MBR, чтобы он автоматически загружал ядро. С помощью nano (или другого редактора) создайте <filename>/boot/grub/grub.conf</filename>: </para>
                    <example>
                        <title>Создание <filename>/boot/grub/grub.conf</filename></title>
                        <screen><prompt>#</prompt> <userinput>nano -w /boot/grub/grub.conf</userinput></screen>
                    </example>
                    <para>Теперь заполним <filename>grub.conf</filename> своими значениями. Ниже приведены два варианта <filename>grub.conf</filename> для показанного примера разбиения дисков. Первый вариант <filename>grub.conf</filename> мы подробно прокомментировали. Удостоверьтесь, что у себя вы указываете имя своего файла образа ядра, и при необходимости имя своего образа начального корневого диска (initrd). </para>
                    <para>первый вариант grub.conf — для тех, кто при сборке ядра обходился без genkernel </para>
                    <para>второй вариант grub.conf — для тех, кто при сборке ядра пользовался genkernel </para>
                    <note>
                        <para>Если ваша корневая файловая система — JFS, необходимо добавить «ro» в строку kernel, поскольку JFS «накатывает» свой журнал перед тем, как разрешить монтирование раздела на чтение-запись. </para>
                    </note>
                    <example>
                        <title><filename>grub.conf</filename> для тех, кто обошелся без genkernel</title>
                        <programlisting>Листинг 3: grub.conf для тех, кто обошелся без genkernel
# какой пункт загружать по умолчанию: 0 - первый, 1 - второй и т.д.
default 0
# сколько секунд ждать до начала загрузки пункта по умолчанию
timeout 30
# симпатичная заставка, добавить по вкусу :)
# закомментируйте, если у вас не установлена графическая видеоплата
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=Gentoo Linux 2.6.12-r10
# раздел с файлом образа ядра (или операционной системой)
root (hd0,0)
kernel /boot/kernel-2.6.12-gentoo-r10 root=/dev/hda3

# следующие четыре строки нужны только для двойной загрузки с Windows
# в этом примере Windows находится на /dev/hda6
title=Windows XP
rootnoverify (hd0,5)
makeactive
chainloader +1</programlisting>
                    </example>
                    <example>
                        <title><filename>grub.conf</filename> для тех, кто пользовался genkernel</title>
                        <programlisting>default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=Gentoo Linux 2.6.12-r10
root (hd0,0)
kernel /boot/kernel-genkernel-x86-2.6.12-gentoo-r10 root=/dev/ram0 init=/linuxrc ramdisk=8192 real_root=/dev/hda3 udev
initrd /boot/initramfs-genkernel-x86-2.6.12-gentoo-r10

# нужно только для двойной загрузки
title=Windows XP
rootnoverify (hd0,5)
makeactive
chainloader +1</programlisting>
                    </example>
                    <note>
                        <para>Параметр udev, указанный в конце строки kernel, необходим для обхода ошибки в некоторых версиях genkernel, если вы вообще используете udev (по умолчанию — используется). </para>
                    </note>
                    <note>
                        <para>Если вы разбили жесткий диск по-другому, или у вас другое ядро, внесите необходимые изменения. При этом убедитесь, что все пути, следующие за упоминанием устройства GRUB (например (hd0,0)), приведены относительно точки подключения, а не корня файловой системы. Другими словами, <code>(hd0,0)/grub/splash.xpm.gz</code> — на самом деле <filename>/boot/grub/splash.xpm.gz</filename>, так как <code>(hd0,0)</code> — это <filename>/boot</filename>. </para>
                    </note>
                    <para>Кроме того, если вы избрали другую схему разбиения диска, и не выделяли для <filename>/boot</filename> отдельный раздел, префикс <filename>/boot</filename>, использованный в примерах выше, обязателен. Если же вы следовали рекомендованному нами плану разбиения, префикс <filename>/boot</filename> не требуется, но все работает благодаря символьной ссылке <filename>boot</filename>. Короче говоря, приведенные примеры должны работать независимо от того, есть у вас отдельный раздел для <filename>/boot</filename> или нет. </para>
                    <para>Если вам надо передать ядру дополнительные параметры, просто добавьте их в конец строки kernel. Один параметр мы уже передаем ядру (<parameter>root=/dev/hda3</parameter> или <parameter>real_root=/dev/hda3</parameter>); можно добавлять и другие, например, такие как параметры <parameter>video</parameter> и/или <parameter>vga</parameter> для кадрового буфера, обсуждавшиеся выше. </para>
                    <para>Если вы используете ядро 2.6.7 или выше, а объем жесткого диска ограничили перемычками из-за того, что BIOS не в состоянии работать с дисками большого размера, вам потребуется добавить <parameter>hdx=stroke</parameter>. </para>
                    <para>Тем, кто использует genkernel, нужно помнить, что их ядро использует такие же загрузочные параметры, как на установочном компакт-диске. Например, если у вас есть устройства SCSI, следует передать ядру параметр <parameter>doscsi</parameter>. </para>
                    <para>Теперь сохраните <filename>grub.conf</filename> и выйдите из редактора. Вам по-прежнему необходимо записать GRUB в MBR (Master Boot Record), чтобы GRUB автоматически запускался при загрузке системы. </para>
                    <para>Разработчики GRUB рекомендуют использовать grub-install. Однако, на случай некорректной работы grub-install есть возможность записать GRUB вручную. </para>
                    <para>Переходите к разделу <link xlink:href="#">по умолчанию: установка GRUB с помощью grub-install</link> или <link xlink:href="#">альтернатива: установка GRUB вручную</link>. </para>
                </section>
                <section>
                    <title>По умолчанию: установка GRUB с помощью grub-install</title>
                    <para>Для установки GRUB вам надо выполнить команду <command>grub-install</command>. Однако, <command>grub-install</command> не заработает сам по себе, т.к. мы находимся в среде с измененным корневым каталогом. Нам нужно создать файл <filename>/etc/mtab</filename>, перечислив в нем все смонтированные файловые системы. К счастью, для этого есть очень легкий способ: просто скопируйте содержимое <filename>/proc/mounts</filename> поверх <filename>/etc/mtab</filename>, исключив строку rootfs, если вы не создавали отдельный загрузочный раздел. Следующая команда подойдет в обоих случаях: </para>
                    <example>
                        <title>Создание <filename>/etc/mtab</filename></title>
                        <screen><prompt>#</prompt> <userinput>grep -v rootfs /proc/mounts &gt; /etc/mtab</userinput></screen>
                    </example>
                    <para>Теперь мы можем установить GRUB, используя <command>grub-install</command>: </para>
                    <example>
                        <title>Выполнение <command>grub-install</command></title>
                        <screen><prompt>#</prompt> <userinput>grub-install /dev/hda</userinput></screen>
                    </example>
                    <para>Если у вас есть вопросы о GRUB, пожалуйста, обратитесь к <link xlink:href="http://www.gnu.org/software/grub/grub-faq.html">GRUB FAQ (англ.)</link> или <link xlink:href="http://www.gnu.org/software/grub/manual/">руководству по GRUB (англ.)</link>. </para>
                    <para>Переходите к <link xlink:href="#">перезагрузке системы</link>. </para>
                </section>
                <section>
                    <title>Альтернатива: установка GRUB вручную</title>
                    <para>Для начала настройки, введите <command>grub</command>. Вы увидите приглашение <prompt>grub&gt;</prompt> — это командная строка grub. Теперь потребуется набрать команды, нужные для установки загрузочной записи GRUB на ваш жесткий диск. </para>
                    <example>
                        <title>Запуск оболочки GRUB</title>
                        <screen><prompt>#</prompt> <userinput>grub</userinput></screen>
                    </example>
                    <note>
                        <para>Если у вас нет приводов для дискет, к приведенной команде добавьте <option>--no-floppy</option>, чтобы grub зря не опрашивал несуществующие дисководы. </para>
                    </note>
                    <para>В приводимом примере мы хотим установить GRUB так, чтобы он считывал нужную информацию с загрузочного раздела <filename>/dev/hda1</filename>, а загрузочная запись GRUB находилась в MBR (Master Boot Record) жесткого диска, чтобы первое, что мы видели после включения компьютера — это приглашение GRUB. Естественно, если вы при установке отклонялись от предлагаемой схемы, внесите необходимые поправки. </para>
                    <para>Находясь в GRUB, можно использовать автодополнение по клавише <keycap>TAB</keycap>. К примеру, если ввести «<code>root (</code>», а затем <keycap>TAB</keycap>, появится список устройств (таких как hd0). Если ввести «<code>root (hd0,</code>» и нажать <keycap>TAB</keycap>, появится список для выбора раздела из возможных (такого как hd0,0). </para>
                    <para>Благодаря автодополнению установка GRUB не так сложна. Теперь приступим к настройке GRUB. </para>
                    <example>
                        <title>Установка GRUB в MBR</title>
                        <screen><prompt>grub></prompt> <userinput>root (hd0,0)</userinput>        <lineannotation>(указание расположения раздела с /boot)</lineannotation>
<prompt>grub></prompt> <userinput>setup (hd0)</userinput>         <lineannotation>(установка GRUB в MBR)</lineannotation>
<prompt>grub></prompt> <userinput>quit</userinput>                <lineannotation>(выход из оболочки GRUB)</lineannotation></screen>
                    </example>
                    <note>
                        <para>Если вы хотите установить GRUB в определенный раздел вместо MBR, команду setup потребуется исправить так, чтобы она указывала на нужный раздел. Например, команда для установки GRUB в <filename>/dev/hda3</filename> — <command>setup (hd0,2)</command>. Однако, так поступают немногие. </para>
                    </note>
                    <para>С дополнительными вопросами о GRUB, пожалуйста, обращайтесь к <link xlink:href="http://www.gnu.org/software/grub/grub-faq.html">GRUB FAQ (англ.)</link> или <link xlink:href="http://www.gnu.org/software/grub/manual/">руководству по GRUB (англ.)</link>. </para>
                    <note>
                        <para>В случае переустановки ядра в будущем, вам больше не потребуется копировать содержимое файлов. После компиляции ядра просто запускайте <command>make install</command>: копирование файлов и изменение конфигурации GRUB произойдет автоматически. </para>
                    </note>
                    <para>Переходите к <link xlink:href="#">перезагрузке системы</link>. </para>
                </section>
            </section>
            <section>
                <title>Альтернатива: использование LILO</title>
                <section>
                    <title>Установка LILO</title>
                    <para><indexterm><primary>LILO</primary></indexterm>LILO (сокращение от LInux LOader) — это проверенная временем рабочая лошадка среди загрузчиков Linux-систем. Но ей недостает ряда возможностей, которые есть в GRUB (и в том числе в этом заключается причина растущей популярности GRUB). LILO все еще используется, потому что на некоторых системах он работает, а GRUB — нет. Конечно же, он используется еще и потому, что многие просто знакомы с LILO и сроднились с ним. Так или иначе, в Gentoo поддерживаются оба загрузчика, и вы, видимо, решили использовать LILO. </para>
                    <para>Установка LILO в систему проста как пробка: просто используйте emerge. </para>
                    <example>
                        <title>Установка LILO</title>
                        <screen><prompt>#</prompt> <userinput>emerge lilo</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Настройка LILO</title>
                    <para>Для настройки LILO нужно создать файл <filename>/etc/lilo.conf</filename>. Запустите свой любимый редактор (в руководстве мы для единообразия используем nano) и создайте файл. </para>
                    <example>
                        <title>Создание <filename>/etc/lilo.conf</filename></title>
                        <screen><prompt>#</prompt> <userinput>nano -w /etc/lilo.conf</userinput></screen>
                    </example>
                    <para>Несколькими разделами раньше мы попросили вас запомнить название созданного файла образа ядра. В следующем примере используется предложенная нами схема разделения диска. </para>
                    <para>Пример разделен на две части: </para>
                    <orderedlist>
                        <listitem>
                            <para>одна — для тех, кто не пользовался для сборки ядра genkernel; </para>
                        </listitem>
                        <listitem>
                            <para>другая — для тех, кто при сборке ядра пользовался genkernel;</para>
                        </listitem>
                    </orderedlist>
                    <para>Удостоверьтесь, что у себя вы указываете имя своего файла образа ядра, и при необходимости имя <emphasis role="italic">своего</emphasis> образа начального корневого диска (initrd).</para>
                    <note>
                        <para>Если ваша корневая файловая система — JFS, необходимо добавить «ro» в строку kernel, поскольку JFS «накатывает» свой журнал перед тем, как разрешить монтирование раздела на чтение-запись. </para>
                    </note>
                    <example>
                        <title>Пример <filename>/etc/lilo.conf</filename></title>
                        <programlisting>boot=/dev/hda         # установка LILO в MBR
prompt                # предоставление шанса выбора другого варианта
timeout=50            # ожидание пять секунд до загрузки варианта по умолчанию
default=gentoo        # по истечении времени загрузка варианта gentoo

# для тех, кто не использует genkernel
image=/boot/kernel-2.6.12-gentoo-r10
  label=gentoo        # название этого варианта
  read-only           # запуск с корневой ФС только для чтения; не менять!
  root=/dev/hda3      # расположение корневой файловой системы

# для тех, кто использует genkernel
image=/boot/kernel-genkernel-x86-2.6.12-gentoo-r10
  label=gentoo
  read-only
  root=/dev/ram0
  append="init=/linuxrc ramdisk=8192 real_root=/dev/hda3 udev"
  initrd=/boot/initramfs-genkernel-2.6.12-gentoo-r10

# следующие две строки нужны только для двойной загрузки с Windows
# в этом примере Windows находится на /dev/hda6
other=/dev/hda6
  label=windows</programlisting>
                    </example>
                    <note>
                        <para>Параметр <parameter>udev</parameter>, указанный в конце строки kernel, необходим для обхода ошибки в некоторых версиях genkernel, <emphasis role="italic">если</emphasis> вы вообще используете udev (по умолчанию — используется). </para>
                    </note>
                    <note>
                        <para>Если вы разбили жесткий диск по-другому, или у вас другое ядро, внесите необходимые изменения. </para>
                    </note>
                    <para>Если нужно передать ядру дополнительные параметры, добавьте в соответствующий раздел файла выражение append. Например, добавим параметр <parameter>video</parameter> для включения кадрового буфера: </para>
                    <example>
                        <title>Использование append для добавления параметров ядра</title>
                        <programlisting>image=/boot/kernel-2.6.12-gentoo-r10
  label=gentoo
  read-only
  root=/dev/hda3
  <emphasis role="bold">append="video=vesafb:mtrr,ywrap,1024x768-32@85"</emphasis></programlisting>
                    </example>
                    <para>Если вы используете ядро 2.6.7 или выше, а объем жесткого диска ограничили перемычками из-за того, что BIOS не в состоянии работать с дисками большого размера, вам потребуется добавить <parameter>hdx=stroke</parameter>. </para>
                    <para>Тем, кто использует genkernel, нужно помнить, что их ядро использует такие же загрузочные параметры, как на установочном компакт-диске. Например, если у вас есть устройства SCSI, следует передать ядру параметр <parameter>doscsi</parameter>.</para>
                    <para>Теперь сохраните файл и выйдите из редактора. Для окончания установки нужно запустить <command>/sbin/lilo</command>, чтобы LILO смог отразить настройки, сделанные в <filename>/etc/lilo.conf</filename>, в вашей системе (т.е. записался на диск). Имейте в виду, что при каждой установке нового ядра или изменении меню вам потребуется выполнять <command>/sbin/lilo</command> заново.</para>
                    <example>
                        <title>Завершение установки LILO</title>
                        <screen><prompt>#</prompt> <userinput>/sbin/lilo</userinput></screen>
                    </example>
                    <note>
                        <para>При переустановке ядра вам больше не придется копировать файлы. Просто запустите make install после компиляции ядра; копирование файлов и изменение конфигурации LILO выполнится автоматически. </para>
                    </note>
                    <para>Переходите к <link xlink:href="#">перезагрузке системы</link>. </para>
                </section>
            </section>
            <section>
                <title>Перезагрузка системы</title>
                <para>Выйдите из изолированной среды и размонтируйте все смонтированные разделы. Затем введите ту самую волшебную команду, которую вы так заждались: <command>reboot</command>. </para>
                <example>
                    <title>Размонтирование всех разделов и перезагрузка</title>
                    <screen><prompt>#</prompt> <userinput>exit</userinput>
<prompt>cdimage ~#</prompt> <userinput>cd</userinput>
<prompt>cdimage ~#</prompt> <userinput>umount /mnt/gentoo/boot /mnt/gentoo/dev /mnt/gentoo/proc /mnt/gentoo</userinput>
<prompt>cdimage ~#</prompt> <userinput>reboot</userinput></screen>
                </example>
                <para>Естественно, не забудьте вынуть загрузочный компакт-диск, иначе он загрузится сам вместо вашей новой системы Gentoo. </para>
                <para>Загрузив вновь установленную систему, переходите к завершению установки Gentoo. </para>
            </section>
        </section>
        <section xreflabel="Завершение установки Gentoo">
            <title>Завершение установки Gentoo</title>
            <section>
                <title>Управление учетными записями</title>
                <section>
                    <title>Добавление учетной записи для повседневной работы</title>
                    <para>Работа в учетной записи root (администратора) в системе Unix/Linux <emphasis role="italic">опасна</emphasis>, и ее следует всячески избегать. Поэтому <emphasis role="italic">настоятельно</emphasis> рекомендуется добавить учетную запись пользователя для повседневной работы. </para>
                    <para>Членством пользователя в группах определяется, какие действия он сможет выполнять. В следующей таблице перечислено несколько важных групп, в которые вы, возможно, захотите включать пользователей. </para>
                    <informaltable frame="none">
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1"/>
                            <colspec colname="c2" colnum="2"/>
                            <thead>
                                <row>
                                    <entry>Группа</entry>
                                    <entry>Описание</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>audio</entry>
                                    <entry>возможность доступа к аудиоустройствам</entry>
                                </row>
                                <row>
                                    <entry>cdrom</entry>
                                    <entry>возможность прямого доступа к оптическим накопителям</entry>
                                </row>
                                <row>
                                    <entry>floppy</entry>
                                    <entry>возможность прямого доступа к гибким дискам</entry>
                                </row>
                                <row>
                                    <entry>games</entry>
                                    <entry>возможность играть в игры</entry>
                                </row>
                                <row>
                                    <entry>portage</entry>
                                    <entry>возможность использования <command>emerge --pretend</command> с правами пользователя</entry>
                                </row>
                                <row>
                                    <entry>usb</entry>
                                    <entry>возможность доступа к устройствам USB</entry>
                                </row>
                                <row>
                                    <entry>plugdev</entry>
                                    <entry>возможность монтирования и использования подключаемых устройств типа камер и USB-брелков</entry>
                                </row>
                                <row>
                                    <entry>video</entry>
                                    <entry>возможность доступа к средствам видеозахвата и выполнения                             аппаратного ускорения видео</entry>
                                </row>
                                <row>
                                    <entry>wheel</entry>
                                    <entry>возможность использования команды <command>su</command></entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                    <para>Например, для создания учетной записи пользователя по имени john, входящего в группы wheel, users и audio, сначала войдите в систему как root (только root может создавать учетные записи пользователей), а затем запустите <command>useradd</command>: </para>
                    <example>
                        <title>Создание учетной записи на каждый день</title>
                        <screen>Login: <userinput>root</userinput>
Password: <userinput><replaceable>(ваш пароль root)</replaceable></userinput>

<prompt>#</prompt> <userinput>useradd -m -G users,wheel,audio -s /bin/bash john</userinput>
<prompt>#</prompt> <userinput>passwd john</userinput>
Password: <userinput><replaceable>(введите пароль для john)</replaceable></userinput>
Re-enter password: <userinput><replaceable>(повторно введите пароль для подтверждения)</replaceable></userinput></screen>
                    </example>
                    <para>Если пользователю потребуется выполнить задачу от имени root, для временного получения привилегий root можно использовать <command>su -</command>. Другой способ — пользоваться пакетом sudo, который при правильной настройке вполне безопасен. </para>
                </section>
            </section>
        </section>
        <section xreflabel="Чем заняться дальше?">
            <title>Чем заняться дальше?</title>
            <section>
                <title>Документация</title>
                <para>Примите поздравления! У вас теперь появилась работающая система Gentoo. И что же делать дальше? Какие у вас появились возможности? На что стоит взглянуть прежде всего? Gentoo дает своим пользователям богатый выбор возможностей, а следовательно — и множество документированных (или не очень) свойств. </para>
                <para>Вам обязательно нужно прочитать следующую часть настольной книги Gentoo, <link xlink:href="#">работа в Gentoo</link>, в которой рассказывается, как поддерживать программное обеспечение в актуальном состоянии, как до устанавливать программы, что такое «USE-флаги», как происходит инициализация в Gentoo и т.д. </para>
                <para>Если вас интересует оптимизация системы с точки зрения пользователя, или вы хотите узнать, как настроить полноценный «рабочий стол», обратитесь к более подробной <link xlink:href="#">документации по графической среде Gentoo</link>. Кроме того, вы, возможно захотите прочитать наше <link xlink:href="http://www.gentoo.org/doc/en/guide-localization.xml">руководство по локализации (англ.)</link>, что бы чувствовать себя более уютно.</para>
                <note>
                    <para>В настоящее время для русификации рекомендуется пользоваться альтернативными руководствами по локализации Gentoo. — <emphasis role="italic">прим. пер.</emphasis>
                    </para>
                </note>
                <para>Также имеется <link xlink:href="http://www.gentoo.org/doc/ru/security/">настольная книга по безопасности в Gentoo (англ.)</link>, которую определенно стоит прочитать. </para>
                <para>Полный список существующих материалов имеется <link xlink:href="http://www.gentoo.org/doc/ru/index.xml">на странице документации</link>. </para>
            </section>
            <section>
                <title>Gentoo в интернете</title>
                <para>Естественно, мы всегда рады видеть вас на <link xlink:href="http://forums.gentoo.org">форумах Gentoo (англ.)</link>, как и на любом из множества <link xlink:href="http://www.gentoo.org/main/en/irc.xml">IRC-каналов Gentoo (англ.)</link>. </para>
                <para>Кроме того, мы можем предложить вашему вниманию несколько <link xlink:href="http://www.gentoo.org/main/ru/lists.xml">списков рассылки</link>, открытых для всех наших пользователей. Сведения о порядке подписки находятся на той же странице. </para>
                <para>На этом мы замолкаем, чтобы позволить вам в полной мере насладиться результатом установки :) </para>
            </section>
        </section>
    </section>
    <section xml:id="gnt-hb.working" xreflabel="Работа с Gentoo">
        <title>Работа с Gentoo</title>
        <section xreflabel="Введение в Portage">
            <title>Введение в Portage</title>
            <section>
                <title>Добро пожаловать в Portage</title>
                <para>Система Portage — вероятно, самое известное нововведение Gentoo в управлении программным обеспечением. Благодаря высокой гибкости и чрезвычайно богатым возможностям, она зачастую считается лучшим средством управления программным обеспечением из существующих в Linux. </para>
                <para>Portage полностью написана на <link xlink:href="http://www.python.org">Python</link> и <link xlink:href="http://www.gnu.org/software/bash">Bash</link>, и в результате полностью прозрачна для пользователей, поскольку оба — языки сценариев. </para>
                <para>Большинство пользователей взаимодействует с Portage с помощью команды emerge. Эта глава не призвана заменить страницу справки emerge. Для просмотра всех возможных параметров команды emerge, обращайтесь к странице справки: </para>
                <example>
                    <title>Чтение страницы справки emerge</title>
                    <screen><prompt>$</prompt> <userinput>man emerge</userinput></screen>
                </example>
            </section>
            <section>
                <title>Дерево портежей</title>
                <section>
                    <title>Сборочные файлы ebuild</title>
                    <para><indexterm><primary>Дерево портежей</primary></indexterm>Говоря о пакетах, мы часто имеем в виду программы, доступные пользователям Gentoo через дерево портежей. Дерево портежей — это набор сборочных файлов ebuild, содержащих всю информацию, необходимую Portage для управления программным обеспечением (установки, поиска, извлечения и т.п.) По умолчанию сборочные файлы находятся в <filename>/usr/portage</filename>. </para>
                    <para>Когда Portage по вашему поручению выполняет любые действия над пакетами программ, эти действия опираются на сборочные файлы, имеющиеся в системе. Поэтому необходимо регулярно обновлять сборочные файлы, чтобы Portage знала о новых программах, обновлениях, связанных с безопасностью и т.д. </para>
                </section>
                <section>
                    <title>Обновление дерева портежей</title>
                    <para>Дерево портежей обычно обновляется с помощью <link xlink:href="http://rsync.samba.org/">rsync (англ.)</link>, средства быстрой разностной передачи файлов. Обновление выполнить довольно просто, так как запуск rsync обеспечивается командой emerge : </para>
                    <example>
                        <title>Обновление дерева портежей</title>
                        <screen><prompt>#</prompt> <userinput>emerge --sync</userinput></screen>
                    </example>
                    <para>Если rsync выполнить невозможно из-за ограничений межсетевого экрана, дерево портежей все-таки можно обновить из ежедневных «снимков», создаваемых нами. Для автоматического извлечения и установки в системе новейшего снимка служит утилита <command>emerge-webrsync</command>: </para>
                    <example>
                        <title>Запуск <command>emerge-webrsync</command></title>
                        <screen><prompt>#</prompt> <userinput>emerge-webrsync</userinput></screen>
                    </example>
                </section>
            </section>
            <section>
                <info>
                    <title>Обслуживание программного обеспечения</title>
                </info>
                <section>
                    <title>Поиск программ</title>
                    <para>Для поиска программ в дереве портежей по названию можно использовать встроенные возможности команды <command>emerge</command>. По умолчанию команда <command>emerge --search</command> выдает названия пакетов, соответствующих (как полностью, так и частично) заданному условию поиска. </para>
                    <para>Например, чтобы найти все пакеты, содержащие «pdf» в названии: </para>
                    <example>
                        <title>Поиск пакетов с pdf в названии</title>
                        <screen><prompt>$</prompt> <userinput>emerge --search pdf</userinput></screen>
                    </example>
                    <para>Для поиска пакетов еще и по тексту описания можно использовать параметр <parameter>--searchdesc</parameter> (или <parameter>-S</parameter>): </para>
                    <example>
                        <title>Поиск пакетов, связанных с pdf</title>
                        <screen><prompt>$</prompt> <userinput>emerge --searchdesc pdf</userinput></screen>
                    </example>
                    <para>Посмотрев на сообщения команды, вы отметите, что вам дается множество информации. Поля четко обозначены, поэтому мы не будем вдаваться в подробности их значения: </para>
                    <example>
                        <title>Пример вывода <command>emerge --search</command></title>
                        <screen>  *  net-print/cups-pdf
      Latest version available: 1.5.2
      Latest version installed: [ Not Installed ]
      Size of downloaded files: 15 kB
      Homepage:    http://cip.physik.uni-wuerzburg.de/~vrbehr/cups-pdf/
      Description: Provides a virtual printer for CUPS to produce PDF files.
      License:     GPL-2

<lineannotation>(
*  net-print/cups-pdf
      Последняя доступная версия: 1.5.2
      Последняя установленная версия: [ не установлен ]
      Размер загружаемых файлов: 15 kB
      Веб-страница:  http://cip.physik.uni-wuerzburg.de/~vrbehr/cups-pdf/
      Описание:      Снабжает CUPS виртуальным принтером для печати PDF-файлов.
      Лицензия:      GPL-2 )</lineannotation></screen>
                    </example>
                    <note>
                        <para>(JohnBat26): Для более быстрого поиска программ используйте утилиту: eix (установка <command>emerge eix</command>). Она работает быстрее благодаря индексированию. Не забывайте запускать <command>update-eix</command> после <command>emerge —sync </command>;)</para>
                    </note>
                </section>
                <section>
                    <title>Установка программ</title>
                    <para>После того, как вы нашли нужное программное обеспечение, его можно легко установить с помощью команды emerge. Вот пример установки пакета gnumeric: </para>
                    <example>
                        <title>Установка gnumeric</title>
                        <screen><prompt>#</prompt> <userinput>emerge gnumeric</userinput></screen>
                    </example>
                    <para>Так как множество приложений зависит друг от друга, любая попытка установить какой-либо пакет программ может повлечь за собой также установку дополнительных пакетов. Не беспокойтесь, Portage справится и с этим. Если вы захотите выяснить, что именно Portage собирается установить вместе с нужным вам пакетом, добавьте параметр <parameter>--pretend</parameter>. Например: </para>
                    <example>
                        <title>Проверка зависимостей пакета gnumeric</title>
                        <screen><prompt>#</prompt> <userinput>emerge --pretend gnumeric</userinput></screen>
                    </example>
                    <para>После команды на установку пакета, Portage загружает из интернета необходимый исходный код (при необходимости), и по умолчанию сохраняет его в каталоге <filename>/usr/portage/distfiles</filename>. После этого пакет распаковывается, компилируется и устанавливается. Если вы хотите, чтобы Portage только загрузила исходный код без его установки, добавьте к команде <command>emerge</command> параметр <parameter>--fetchonly</parameter>: </para>
                    <example>
                        <title>Загрузка исходного кода пакета gnumeric</title>
                        <screen><prompt>#</prompt> <userinput>emerge --fetchonly gnumeric</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Обнаружение документации к пакету</title>
                    <para>Многие пакеты содержат собственную документацию. Иногда USE-флаг doc определяет, следует ли устанавливать документацию к пакету. Проверить наличие USE-флага doc можно командой <command>emerge -vp <replaceable>&lt;название пакета&gt;</replaceable></command>. </para>
                    <example>
                        <title>Проверка наличия USE-флага doc</title>
                        <screen><lineannotation>(alsa-lib - это всего лишь пример)</lineannotation>
<prompt>#</prompt> <userinput>emerge -vp alsa-lib</userinput>
[ebuild  N    ] media-libs/alsa-lib-1.0.9_rc3  +doc -jack 674 kB</screen>
                    </example>
                    <para>USE-флаг doc можно включить или отключить как глобально в файле <filename>/etc/make.conf</filename>, так и для отдельных пакетов в файле <filename>/etc/portage/package.use</filename>. Также можно, создав каталог с названием <filename>/etc/portage/package.use</filename>, указать флаг в файле внутри этого каталога. В главе USE-флаги этот вопрос описывается более подробно. </para>
                    <para>Документация от вновь установленного пакета обычно находится в подкаталоге каталога <filename>/usr/share/doc</filename>, соответствующем названию пакета. Кроме того, можно вывести список всех установленных файлов утилитой equery, которая входит в <link xlink:href="http://www.gentoo.org/doc/en/gentoolkit.xml">пакет gentoolkit (англ.)</link> — app-portage/gentoolkit. </para>
                    <example>
                        <title>Обнаружение документации пакета</title>
                        <screen><prompt>#</prompt> <userinput>ls -l /usr/share/doc/alsa-lib-1.0.9_rc3</userinput>
total 28
-rw-r--r--  1 root root  669 May 17 21:54 ChangeLog.gz
-rw-r--r--  1 root root 9373 May 17 21:54 COPYING.gz
drwxr-xr-x  2 root root 8560 May 17 21:54 html
-rw-r--r--  1 root root  196 May 17 21:54 TODO.gz

<lineannotation>(или используйте для поиска интересных файлов команду equery :)</lineannotation>
<prompt>#</prompt> <userinput>equery files alsa-lib | less</userinput>
media-libs/alsa-lib-1.0.9_rc3
* Contents of media-libs/alsa-lib-1.0.9_rc3:
/usr
/usr/bin
/usr/bin/alsalisp
<lineannotation>(выдача обрезана)</lineannotation></screen>
                    </example>
                </section>
                <section>
                    <title>Удаление пакета</title>
                    <para>Когда вы захотите удалить пакет из системы, используйте команду <command>emerge --unmerge</command>. Это приведет к удалению из системы всех файлов, установленных пакетом, кроме конфигурационных файлов приложения, изменявшихся после установки. Сохранение конфигурационных файлов позволяет вернуться к работе с пакетом, если вы когда-нибудь решите снова его установить.</para>
                    <warning>
                        <para>Portage не проверяет, зависят ли другие пакеты от удаляемого! Однако вы получите предупреждение, если удаление пакета приведет к неработоспособности системы. </para>
                    </warning>
                    <example>
                        <title>Удаление пакета gnumeric из системы</title>
                        <screen><prompt>#</prompt> <userinput>emerge --unmerge gnumeric</userinput></screen>
                    </example>
                    <para>После удаления пакета из системы, пакеты, установленные автоматически, потому что от них зависел удаленный пакет, остаются. Чтобы Portage выявила все когда-то нужные пакеты, которые теперь можно удалить, используйте команду <command>emerge --depclean</command>. Мы вернемся к этому ниже. </para>
                </section>
                <section>
                    <title>Обновление системы</title>
                    <para>Чтобы система сохранялась в отличной форме (не говоря уже об установке свежайших обновлений, связанных с безопасностью), ее нужно регулярно обновлять. Так как Portage просматривает сборочные файлы только в локальном дереве портежей, сперва потребуется обновить его. Обновив дерево портежей, вы сможете обновить систему командой <command>emerge --update world</command>. В следующем примере мы также пользуемся параметром <parameter>--ask</parameter>, который поручает Portage вывести список пакетов, которые она собирается обновить, и спросить вас, можно ли продолжать:</para>
                    <example>
                        <title>Обновление системы</title>
                        <screen><prompt>#</prompt> <userinput>emerge --update --ask world</userinput></screen>
                    </example>
                    <para>Portage будет искать более новые версии установленных приложений. Однако проверяется только версии приложений, явно установленных вами, а не тех, от которых они зависят. Если вы хотите обновить каждый пакет в системе, добавьте аргумент <parameter>--deep</parameter>: </para>
                    <example>
                        <title>Обновление всей системы</title>
                        <screen><prompt>#</prompt> <userinput>emerge --update --deep world</userinput></screen>
                    </example>
                    <para>Поскольку обновления, относящиеся к безопасности, случаются и в пакетах, явным образом не устанавливались (но были «подтянуты» из-за того, что он них зависят другие программы), рекомендуется изредка запускать эту команду. </para>
                    <para>Если вы меняли какие-либо из USE-флагов, возможно, потом вы также захотите добавить параметр <parameter>--newuse</parameter>. Тогда Portage проверит, требует ли изменение установки новых пакетов или перекомпиляции существующих: </para>
                    <example>
                        <title>Выполнение полного обновления</title>
                        <screen><prompt>#</prompt> <userinput>emerge --update --deep --newuse world</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Метапакеты</title>
                    <para>У некоторых пакетов в дереве портежей нет содержимого как такового, и они используются для установки набора других пакетов. Например, пакет kde полностью устанавливает среду KDE в вашей системе, привлекая различные KDE-пакетов в качестве зависимостей. </para>
                    <para>Если вы когда-либо захотите удалить из системы такой пакет, запуск <command>emerge --unmerge</command> не возымеет должного эффекта, так как пакеты, от которых он зависит, останутся в системе. </para>
                    <para>В Portage существует возможность удаления остаточных зависимостей, но так как зависимости программ меняются со временем, доступность программного обеспечения, прежде всего требуется полностью обновить всю систему, включая реализацию изменений, произведенных путем модификации USE-флагов. После этого можно запустить <command>emerge --depclean</command>, чтобы удалить остаточные зависимости. Когда это сделано, вам потребуется пересобрать приложения, ранее динамически связанные с удаленными пакетами, в которых они теперь не нуждаются. </para>
                    <para>Со всем этим управляются следующие три команды: </para>
                    <example>
                        <title>Удаление ненужных зависимостей</title>
                        <screen><prompt>#</prompt> <userinput>emerge --update --deep --newuse world</userinput>
<prompt>#</prompt> <userinput>emerge --depclean</userinput>
<prompt>#</prompt> <userinput>revdep-rebuild</userinput></screen>
                    </example>
                    <para><command>revdep-rebuild</command> входит в пакет gentoolkit; не забудьте сначала его установить: </para>
                    <example>
                        <title>Установка пакета gentoolkit</title>
                        <screen><prompt>#</prompt> <userinput>emerge gentoolkit</userinput></screen>
                    </example>
                </section>
            </section>
            <section>
                <title>Когда Portage жалуется...</title>
                <section>
                    <title>Слоты, виртуалы, ветви, архитектуры и профили</title>
                    <para>Как уже сказано, Portage — чрезвычайно мощная система, поддерживающая множество возможностей, не хватающих другим системам управления программами. Чтобы это стало понятно, разберем несколько аспектов Portage, не вникая в подробности. </para>
                    <para><indexterm><primary>SLOT</primary></indexterm><indexterm><primary>Слот</primary></indexterm>С помощью Portage разные версии отдельного пакета могут сосуществовать в одной системе. В то время, как другие системы управления стремятся называть пакеты в соответствии с версией (например freetype и freetype2), в Portage используется технология <firstterm>слотов</firstterm> (SLOT), или областей. Пакет присваивает определенный слот своей версии. Пакеты с разными слотами способны сосуществовать в одной системе. Например, у пакета freetype есть ebuild как со SLOT="1", так и со SLOT="2". </para>
                    <para><indexterm><primary>Виртуальный пакет</primary></indexterm>Существуют также пакеты, выполняющие одни и те же функции, но отличающиеся в реализации. Например metalogd, sysklogd и syslog-ng являются системными службами журналирования. Приложения, использующие «системный журнал», не могут зависеть от одной конкретной программы, например от metalogd, так как остальные программы ничем не хуже. В Portage предусмотрены <firstterm>виртуальные пакеты</firstterm>: каждая служба журналирования предоставляет virtual/syslog, и в результате в приложениях можно указывать зависимость от virtual/syslog. </para>
                    <para>Программное обеспечение может располагаться в различных ветвях дерева портежей. По умолчанию в системе разрешено только использование стабильных пакетов. Большинство новых программ при поступлении включаются в тестовую ветвь, что указывает на необходимость дополнительного тестирования перед тем, как включить их в стабильные. Хотя в дереве портежей и видны сборочные файлы для таких программ, Portage не станет обновлять их до тех пор, пока они не будут помещены в стабильную ветвь. </para>
                    <para>Некоторые программы имеются не для всех архитектур. Либо они не работают в определенных архитектурах, либо требуют дополнительного тестирования, или у разработчика нет возможности проверить, работает ли пакет в различных архитектурах. </para>
                    <para>Каждая установка Gentoo придерживается определенного профиля, который содержит, помимо прочего, список пакетов, необходимых для работоспособности системы. </para>
                </section>
                <section>
                    <title>Блокировка пакетов</title>
                    <example>
                        <title>Предупреждение о заблокированных пакетах (с <parameter>--pretend</parameter>)</title>
                        <screen>[blocks B     ] mail-mta/ssmtp (is blocking mail-mta/postfix-2.2.2-r1)</screen>
                    </example>
                    <example>
                        <title>Предупреждение о заблокированных пакетах (без <parameter>--pretend</parameter>)</title>
                        <screen>!!! Error: the mail-mta/postfix package conflicts with another package.
!!!        both can't be installed on the same system together.
!!!        Please use 'emerge --pretend' to determine blockers.

<lineannotation>( !!! Ошибка: пакет mail-mta/postfix конфликтует с другим пакетом.
  !!! оба не могут находиться в системе одновременно. Пожалуйста,
  !!! запустите 'emerge --pretend' для выявления блокирующих пакетов. )</lineannotation></screen>
                    </example>
                    <para>В файлах ebuild есть специальные поля, сообщающие Portage о зависимостях. Возможны два вида зависимости: зависимость сборки, объявленная в <varname>DEPEND</varname>, и зависимость выполнения, объявленная в <varname>RDEPEND</varname>. Когда одна из этих зависимостей явно указывает на <emphasis role="italic">несовместимость</emphasis> пакета или виртуального пакета, это вызывает блокировку. </para>
                    <para>Для разблокировки можно отказаться от установки пакета или предварительно удалить конфликтующего пакета. В данном примере можно отказаться от установки postfix или сначала удалить ssmtp. </para>
                    <para>Также возможно, что два пакета, подлежащие установке, блокируют друг друга. В этом редчайшем случае следует определить, зачем вам устанавливать оба пакета. В большинстве случаев можно обойтись одним. Если это окажется не так, то, пожалуйста, заведите отчет об ошибке в <link xlink:href="http://bugs.gentoo.org">системе распределения запросов Gentoo</link>. </para>
                </section>
                <section>
                    <title>Маскировка пакетов</title>
                    <example>
                        <title>Предупреждение о замаскированных пакетах</title>
                        <screen>!!! all ebuilds that could satisfy "bootsplash" have been masked.

<lineannotation>(!!! все сборки, удовлетворяющие "bootsplash", замаскированы.)</lineannotation></screen>
                    </example>
                    <example>
                        <title>Предупреждение о замаскированных пакетах с указанием причины</title>
                        <screen>!!! possible candidates are:

- gnome-base/gnome-2.8.0_pre1 (masked by: ~x86 keyword)
- lm-sensors/lm-sensors-2.8.7 (masked by: -sparc keyword)
- sys-libs/glibc-2.3.4.20040808 (masked by: -* keyword)
- dev-util/cvsd-1.0.2 (masked by: missing keyword)
- media-video/ati-gatos-4.3.0 (masked by: package.mask)
- sys-libs/glibc-2.3.2-r11 (masked by: profile)

<lineannotation>( !!! возможные кандидаты:

- gnome-base/gnome-2.8.0_pre1 (маскировка: ключ ~x86)
- lm-sensors/lm-sensors-2.8.7 (маскировка: ключ -sparc)
- sys-libs/glibc-2.3.4.20040808 (маскировка: ключ -*)
- dev-util/cvsd-1.0.2 (маскировка: ключ отсутствует)
- media-video/ati-gatos-4.3.0 (маскировка: package.mask)
- sys-libs/glibc-2.3.2-r11 (маскировка: profile) )</lineannotation></screen>
                    </example>
                    <para>Когда вы собираетесь установить пакет, не предназначенный для вашей системы, выдается ошибка маскировки. Нужно попытаться установить другую программу, существующую для вашей системы, или дождаться, пока пакет станет доступным. Всегда есть причина, по которой пакет замаскирован: </para>
                    <orderedlist>
                        <listitem>
                            <para><emphasis role="bold">ключ ~arch</emphasis>: пакет недостаточно проверен для помещения в стабильную ветвь. Подождите несколько дней или недель и попробуйте установить его еще раз; </para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">ключ -arch</emphasis> или <emphasis role="bold">ключ -*</emphasis>: пакет не работоспособен в вашей архитектуре. Если вы полагаете, что он работает, сообщите об этом в bugzilla;</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">ключ отсутствует</emphasis>: пакет еще не тестировался в вашей архитектуре. Попросите группу портирования в архитектуру проверить пакет, или протестируйте его за них и сообщите о своих изысканиях в bugzilla;</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">package.mask</emphasis>: обнаружено повреждение пакета, нестабильность или что-то худшее, и пакет заблокирован специально; </para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">profile</emphasis>: пакет считается не предназначенным для вашего профиля. В случае установки приложение может вызвать сбой системы или просто несовместимо с используемым профилем. </para>
                        </listitem>
                    </orderedlist>
                </section>
                <section>
                    <title>Отсутствие нужных пакетов</title>
                    <example>
                        <title>Предупреждение об отсутствии пакета</title>
                        <screen>emerge: there are no ebuilds to satisfy ">=sys-devel/gcc-3.4.2-r4".

!!! Problem with ebuild sys-devel/gcc-3.4.2-r2
!!! Possibly a DEPEND/*DEPEND problem.

<lineannotation>( emerge: нет сборок, удовлетворяющих ">=sys-devel/gcc-3.4.2-r4".

  !!! Проблема с ebuild sys-devel/gcc-3.4.2-r2
  !!! Возможно, ошибка в DEPEND/*DEPEND. )</lineannotation></screen>
                    </example>
                    <para>Приложение, которое вы пытаетесь установить, зависит от другого пакета, недоступного вашей системе. Пожалуйста, проверьте, есть ли такой запрос в bugzilla, а если нет, сообщите об ошибке. Если вы не смешиваете ветви, такого не должно происходить, и это — явная ошибка.</para>
                </section>
                <section>
                    <title>Неоднозначность названия пакета</title>
                    <example>
                        <title>Предупреждение о повторяющихся именах ebuild</title>
                        <screen>!!! The short ebuild name "aterm" is ambiguous.  Please specify
!!! one of the following fully-qualified ebuild names instead:

    dev-libs/aterm
    x11-terms/aterm

<lineannotation>( !!! Короткое название ebuild "aterm" неоднозначно. Пожалуйста, 
  !!! вместо него укажите одно из полных названий ebuild:

      dev-libs/aterm
      x11-terms/aterm )</lineannotation></screen>
                    </example>
                    <para>Название приложения, которое вы собираетесь установить, соответствует более чем одному пакету. Требуется также указать название категории. Portage предложит вам возможные варианты. </para>
                </section>
                <section>
                    <title>Циклические зависимости</title>
                    <example>
                        <title>Предупреждение Portage о циклических зависимостях</title>
                        <screen>!!! Error: circular dependencies:

ebuild / net-print/cups-1.1.15-r2 depends on ebuild /
app-text/ghostscript-7.05.3-r1
ebuild / app-text/ghostscript-7.05.3-r1 depends on ebuild /
net-print/cups-1.1.15-r2

<lineannotation>( !!! Ошибка: циклические зависимости:

  ebuild / net-print/cups-1.1.15-r2 зависит от ebuild /
  app-text/ghostscript-7.05.3-r1
  ebuild / app-text/ghostscript-7.05.3-r1 зависит от ebuild /
  net-print/cups-1.1.15-r2   )</lineannotation></screen>
                    </example>
                    <para>Два или более пакета, которые вы хотите установить, взаимно зависимы, и в результате их установка невозможна. Скорее всего, это ошибка в дереве портежей. Пожалуйста, выждав время, обновите дерево портежей, и попытайтесь снова. Вы можете также проверить, есть ли эта ошибка в bugzilla, и если нет, сообщить о ней. </para>
                </section>
                <section>
                    <title>Ошибка извлечения</title>
                    <example>
                        <title>Предупреждение Portage об ошибке извлечения</title>
                        <screen>!!! Fetch failed for sys-libs/ncurses-5.4-r5, continuing...
<lineannotation>(...)</lineannotation>
!!! Some fetch errors were encountered.  Please see above for details.

<lineannotation>( !!! Ошибка при извлечении sys-libs/ncurses-5.4-r5, продолжение...
  (...)
!!! При извлечении произошли ошибки.  Подробности выше. )</lineannotation></screen>
                    </example>
                    <para>Portage не смогла загрузить исходный код данного приложения и попытается продолжить установку других приложений (если запланирована). Эта ошибка может произойти из-за неправильно синхронизированного зеркала, или из-за того, что ebuild указывает на неверное место. Сервер, где находятся исходные коды, также может почему-либо не работать. </para>
                    <para>Повторите действие через час, чтобы посмотреть, повторится ли эта ошибка. </para>
                </section>
                <section>
                    <title>Защита системного профиля</title>
                    <example>
                        <title>Предупреждение Portage о пакете, защищенном профилем</title>
                        <screen>!!! Trying to unmerge package(s) in system profile. 'sys-apps/portage'
!!! This could be damaging to your system.

<lineannotation>( !!! Попытка удаления пакетов из системного профиля. 'sys-apps/portage'
  !!! Это может повредить вашей системе. )</lineannotation></screen>
                    </example>
                    <para>Вы попросили удалить пакет, входящий в состав базовых пакетов вашей системы. Он отмечен в вашем профиле как обязательный, и его не следует удалять из системы. </para>
                </section>
            </section>
        </section>
        <section xreflabel="USE-флаги">
            <title>USE-флаги</title>
            <section>
                <title>Что такое USE-флаги?</title>
                <section>
                    <title>Смысл USE-флагов</title>
                    <para>Устанавливая Gentoo (или любой другой дистрибутив, или даже операционную систему вообще), вы выбираете те или иные возможности в зависимости от среды, с которой работаете. Установка сервера отличается от установки рабочей станции, а установка игровой станции — от платформы 3D-рендеринга. </para>
                    <para>Это касается не только того, какие пакеты устанавливать, но и какие функции определенных пакетов должны поддерживаться. Если вам не нужен OpenGL, то зачем вам его ставить и встраивать поддержку OpenGL в большинство программ? Если вы не собираетесь использовать KDE, зачем собирать пакеты с его поддержкой, если они работают и без этого? </para>
                    <para>Чтобы помочь пользователям в выборе того, что устанавливать/активировать, а что — нет, мы захотели дать им простой способ описания рабочей среды. Это позволяет пользователю решить, что же ему на самом деле надо, и облегчить работу с Portage, нашей системой управления пакетами. </para>
                </section>
                <section>
                    <title>Определение USE-флагов</title>
                    <para>Рассмотрим USE-флаги. USE-флаг — это ключевое слово, включающее сведения о поддержке и зависимостях определенного понятия или функции. При определении какого-либо USE-флага, Portage узнает, что вам нужна поддержка соответствующей функции. Конечно, это также влияет на сведения о зависимостях пакета. </para>
                    <para>Давайте рассмотрим конкретный пример — ключевое слово kde. Если в вашей переменной USE нет этого слова, то все пакеты, где поддержка KDE является <emphasis role="italic">необязательной</emphasis>, собираются <emphasis role="italic">без</emphasis> нее. Все пакеты, где зависимость от KDE является <emphasis role="italic">необязательной</emphasis>, устанавливаются <emphasis role="italic">без</emphasis> установки библиотек KDE (по зависимости). Если же вы определите ключевое слово kde, то эти пакеты будут собираться с <emphasis role="italic">поддержкой</emphasis> KDE, а KDE будет установлен в качестве необходимого. </para>
                    <para>Правильно определяя ключевые слова, вы создаете систему, подогнанную специально для ваших нужд. </para>
                </section>
                <section>
                    <title>Какие USE-флаги существуют?</title>
                    <para>Есть два типа USE-флагов: <emphasis role="italic">глобальные</emphasis> и <emphasis role="italic">локальные</emphasis>.</para>
                    <itemizedlist>
                        <listitem>
                            <para>Глобальный USE-флаг используется несколькими пакетами и является системным. Это то, что большинство видит в качестве USE-флагов.</para>
                        </listitem>
                        <listitem>
                            <para>Локальный USE-флаг используется единичным пакетом для настройки определенных параметров самого пакета.</para>
                        </listitem>
                    </itemizedlist>
                    <para>Список доступных глобальных USE-флагов можно найти в сети или локально в <filename>/usr/portage/profiles/use.desc</filename>.</para>
                    <para>Список локальных USE-флагов находится в вашей системе в <filename>/usr/portage/profiles/use.local.desc</filename>.</para>
                    <note>
                        <para>(JohnBat26): Для удобной установки и чтения описаний <envar>USE</envar> флагов используйте программу: Use Flag  EDitor или ufed (<command>emerge ufed</command>)</para>
                    </note>
                </section>
            </section>
            <section>
                <title>Использование USE-флагов</title>
                <section>
                    <title>Объявление постоянных USE-флагов</title>
                    <para>В надежде, что вы убедились в важности USE-флагов, теперь мы расскажем, как их объявлять. </para>
                    <para>Как сказано ранее, все USE-флаги объявляются в переменной USE. Чтобы упростить пользователям поиск и выбор флагов, мы предлагаем значение USE <emphasis role="italic">по умолчанию</emphasis>, которое представляют собой список USE-флагов, как нам кажется, наиболее часто используемых пользователями Gentoo. Это значение приведено в файле make.defaults вашего профиля. </para>
                    <para>Профиль, на который ориентируется ваша система, указывается символьной ссылкой <filename>/etc/make.profile</filename>. Каждый профиль основывается на предыдущем, более крупном, а итоговый складывается из всех профилей. Верхним является базовый профиль (<filename>/usr/portage/profiles/base</filename>). </para>
                    <para>Давайте взглянем на значение по умолчанию для профиля 2004.3: </para>
                    <example>
                        <title>Итоговая переменная <envar>USE</envar>
                            <filename>make.defaults</filename> для профиля 2004.3</title>
                        <programlisting><lineannotation>(в этом примере объединяются значения из base, default-linux,
default-linux/x86 и default-linux/x86/2004.3)</lineannotation>
USE="x86 oss apm arts avi berkdb bitmap-fonts crypt cups encode fortran f77
     foomaticdb gdbm gif gpm gtk imlib jpeg kde gnome libg++ libwww mad
     mikmod motif mpeg ncurses nls oggvorbis opengl pam pdflib png python qt
     quicktime readline sdl spell ssl svga tcpd truetype X xml2 xmms xv zlib"</programlisting>
                    </example>
                    <para>Как видите, эта переменная уже содержит достаточно много ключевых слов. Не меняйте файл <filename>make.defaults</filename> для настройки переменной <envar>USE</envar> под свои нужды: изменения в этом файле аннулируются при обновлении Portage! </para>
                    <para>Для изменения значения по умолчанию, нужно добавлять или удалять ключевые слова из переменной <envar>USE</envar>. Это делается глобально, определением переменной <envar>USE</envar> в <filename>/etc/make.conf</filename>. В эту переменную можно добавить нужные вам USE-флаги, или удалить ненужные. Для удаления флага, его надо указывать со знаком минус в виде приставки («<code>-</code>»). </para>
                    <para>Например, чтобы убрать поддержку KDE и QT, но добавить поддержку ldap, можно определить в <filename>/etc/make.conf</filename> переменную USE следующего вида: </para>
                    <example>
                        <title>Пример значения USE в <filename>/etc/make.conf</filename></title>
                        <programlisting>USE="-kde -qt ldap"</programlisting>
                    </example>
                </section>
                <section>
                    <title>Объявление USE-флагов для отдельных пакетов</title>
                    <para>Иногда нужно определить некоторые USE-флаги только для одного или нескольких пакетов, не трогая системных настроек. Для этого необходимо создать каталог <filename>/etc/portage</filename> (если его еще нет) и отредактировать файл <filename>/etc/portage/package.use</filename>. </para>
                    <para>Например, вам не нужна глобальная поддержка berkdb, но она необходима в mysql: </para>
                    <example>
                        <title>Пример <filename>/etc/portage/package.use</filename></title>
                        <programlisting>dev-db/mysql berkdb</programlisting>
                    </example>
                    <para>Естественно, можно в явном виде отключить USE-флаги для определенного пакета. Например, если вам не нужна поддержка java в PHP: </para>
                    <example>
                        <title>Второй пример <filename>/etc/portage/package.use</filename></title>
                        <programlisting>dev-php/php -java</programlisting>
                    </example>
                </section>
                <section>
                    <title>Объявление временных USE-флагов</title>
                    <para>Иногда необходимо установить какой-то USE-флаг только на один раз. Вместо того, чтобы дважды редактировать <filename>/etc/make.conf</filename> (сначала добавить изменения <envar>USE</envar>, а потом удалить), можно просто объявить USE как переменную среды. Помните, что при переустановке или обновлении приложения (явном или в составе обновления системы) ваши изменения будут утеряны! </para>
                    <para>Например, уберем java из значения USE на время установки mozilla. </para>
                    <example>
                        <title>Использование <envar>USE</envar> в виде переменной среды</title>
                        <screen><prompt>#</prompt> <userinput>USE="-java" emerge mozilla</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Наследование</title>
                    <para>Конечно же, существует определенная последовательность формирования значения USE. Вы же не хотите объявить <code>USE="-java"</code> только для того, чтобы узнать, что java все еще включена из-за значения с более высоким приоритетом. Последовательность установки значения <envar>USE</envar> в порядке приоритета (от меньшего к большему) такова: </para>
                    <orderedlist>
                        <listitem>
                            <para>значение <envar>USE</envar> по умолчанию, объявленное в файлах <filename>make.defaults</filename> в составе вашего профиля; </para>
                        </listitem>
                        <listitem>
                            <para>значение, определенное пользователем в <filename>/etc/make.conf </filename>;</para>
                        </listitem>
                        <listitem>
                            <para>значение, указанное пользователем в <filename>/etc/portage/package.use </filename>;</para>
                        </listitem>
                        <listitem>
                            <para>значение, определенное пользователям в переменной среды.</para>
                        </listitem>
                    </orderedlist>
                    <para>Чтобы узнать, какие же настройки <envar>USE</envar> в конечном счете видит Portage, запустите <command>emerge --info</command>. Эта команда выводит значения всех переменных (включая <envar>USE</envar>), используемые Portage. </para>
                    <example>
                        <title>Запуск <command>emerge --info</command></title>
                        <screen><prompt>#</prompt> <userinput>emerge --info</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Адаптация всей системы под новые USE-флаги</title>
                    <para>Если вы изменили свои USE-флаги и хотите обновить всю систему в соответствии с новым значением <envar>USE</envar>, запустите <command>emerge</command> с параметром <parameter>--newuse</parameter>: </para>
                    <example>
                        <title>Пересборка всей системы</title>
                        <screen><prompt>#</prompt> <userinput>emerge --update -deep --newuse world</userinput></screen>
                    </example>
                    <para>Теперь запустите функцию Portage depclean, чтобы удалить условные зависимости, присутствующие в «старой» системе, но больше не нужные при новом составе USE-флагов. </para>
                    <warning>
                        <para>Запуск <command>emerge --depclean</command> является опасной операцией, которую следует использовать с осторожностью. Дважды проверьте список «ненужных» пакетов и убедитесь, что не удалятся нужные пакеты. В следующем примере мы добавляем ключ <parameter>-p</parameter>, чтобы depclean только перечислил пакеты, не удаляя их. </para>
                    </warning>
                    <example>
                        <title>Удаление ненужных пакетов</title>
                        <screen><prompt>#</prompt> <userinput>emerge -p --depclean</userinput></screen>
                    </example>
                    <para>Когда depclean закончит свою работу, запустите <command>revdep-rebuild</command>, чтобы пересобрать программы, динамически связанные с библиотеками, входящими в потенциально удаленные пакеты. <command>revdep-rebuild</command> входит в пакет gentoolkit, так что не забудьте сначала установить его. </para>
                    <example>
                        <title>Запуск revdep-rebuild</title>
                        <screen><prompt>#</prompt> <userinput>revdep-rebuild</userinput></screen>
                    </example>
                    <para>После выполнения всех этих действий, ваша система будет полностью использовать новые значения USE-флагов. </para>
                </section>
            </section>
            <section>
                <title>USE-флаги отдельных пакетов</title>
                <section>
                    <title>Просмотр доступных USE-флагов</title>
                    <para>Возьмем, к примеру, mozilla — какие USE-флаги она может использовать? Чтобы это выяснить, запустим <command>emerge</command> с параметрами <parameter>--pretend</parameter> и <parameter>--verbose</parameter>: </para>
                    <example>
                        <title>Просмотр используемых USE флагов</title>
                        <screen><prompt>#</prompt> <userinput>emerge --pretend --verbose mozilla</userinput>
These are the packages that I would merge, in order:

Calculating dependencies ...done!
[ebuild   R   ] www-client/mozilla-1.7.12-r2  USE="crypt gnome java mozsvg ssl
truetype xprint -debug -ipv6 -ldap -mozcalendar -mozdevelop -moznocompose
-moznoirc -moznomail -moznoxft -postgres -xinerama" 0 kB
</screen>
                    </example>
                    <para>emerge — не единственное средство для решения этой задачи. Существует программа, специально предназначенная для вывода информация о пакетах. Она называется equery и находится в пакете gentoolkit. Для начала установим этот пакет: </para>
                    <example>
                        <title>Установка gentoolkit</title>
                        <screen><prompt>#</prompt> <userinput>emerge gentoolkit</userinput></screen>
                    </example>
                    <para>Теперь для просмотра USE-флагов какого-нибудь пакета запустим equery с аргументом uses. Пусть это будет пакет gnumeric: </para>
                    <example>
                        <title>Запуск equery для просмотра доступных USE-флагов</title>
                        <screen># equery uses =gnumeric-1.6.3 -a
[ Searching for packages matching =gnumeric-1.6.3... ]
[ Colour Code : set unset ]
[ Legend        : Left column  (U) - USE flags from make.conf  ]
[               : Right column (I) - USE flags packages was installed with ]
[ Found these USE variables for app-office/gnumeric-1.6.3 ]
 U I
- - debug   : Tells configure and the makefiles to build for debugging.
                     Effects vary across packages, but generally it will at
                     least add -g to CFLAGS.  Remember to set FEATURES=nostrip too 
- - gnome   : Adds GNOME support
+ + python   : Adds support/bindings for the Python language
- - static   : !!do not set this during bootstrap!! Causes binaries to be
                     statically linked instead of dynamically</screen>
                    </example>
                </section>
            </section>
        </section>
        <section xreflabel="Возможности Portage">
            <title>Возможности Portage</title>
            <section>
                <title>Возможности Portage</title>
                <para>В Portage есть несколько дополнительных возможностей (features), которые значительно улучшат ваше впечатление от Gentoo. Многие из этих возможностей полагаются на определенные программы, повышающие производительность, надежность, безопасность и т.п.</para>
                <para>Для включения и выключения определенных возможностей Portage нужно редактировать в файле <filename>/etc/make.conf</filename> переменную <envar>FEATURES</envar>, в которой перечислены ключевые слова, разделенные пробелами, обозначающие различные возможности. Иногда для использования соответствующих возможностей потребуется установка дополнительных утилит.</para>
                <para>Здесь перечислены не все возможности, поддерживаемые Portage. Полный перечень представлен на странице справки <filename>make.conf</filename>:</para>
                <example>
                    <title>Вызов страницы справки <filename>make.conf</filename></title>
                    <screen><prompt>$</prompt> <userinput>man make.conf</userinput></screen>
                </example>
                <para>Чтобы узнать, какие возможности включены по умолчанию, запустите <command>emerge --info</command> и найдите переменную <envar>FEATURES</envar> (или отфильтруйте ее с помощью <command>grep</command>): </para>
                <example>
                    <title>Выявление уже включенных возможностей</title>
                    <screen><prompt>$</prompt> <userinput>emerge --info | grep FEATURES</userinput></screen>
                </example>
            </section>
            <section>
                <title>Распределенная компиляция</title>
                <section>
                    <title>Использование distcc</title>
                    <para><indexterm><primary>distcc</primary></indexterm>distcc — программа, распределяющая компиляцию по нескольким, не обязательно одинаковым, машинам в сети. Клиент distcc посылает всю необходимую информацию на доступные серверы distcc (на которых выполняется distccd), чтобы они могли компилировать для клиента части исходного кода. Чистый выигрыш — более быстрая компиляция. </para>
                    <para>Подробная информация о distcc (и как заставить его заработать в Gentoo) находится в нашем описании distcc в Gentoo. </para>
                </section>
                <section>
                    <title>Установка distcc</title>
                    <para>Distcc поставляется с графическим монитором (средством контроля), позволяющим отслеживать задачи, которые ваш компьютер отсылает на компиляцию. Если вы используете Gnome, тогда добавьте «gnome» к переменной USE. А если вы не пользуетесь Gnome, но при этом хотите пользоваться монитором, добавьте «gtk» к переменной USE. </para>
                    <example>
                        <title>Установка distcc</title>
                        <screen><prompt>#</prompt> <userinput>emerge distcc</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Подключение поддержки Portage</title>
                    <para>Добавьте distcc к переменной <envar>FEATURES</envar> в файле <filename>/etc/make.conf</filename>. Затем отредактируйте переменную <envar>MAKEOPTS</envar>, как вам нравится. Известная рекомендация — указывать директиву «<parameter>-j<replaceable>X</replaceable></parameter>», где <replaceable>X</replaceable> — число центральных процессоров, на которых работает distccd (включая текущий компьютер) плюс один; у вас могут получиться лучшие результаты и с другими значениями. </para>
                    <para>Теперь запустите <command>distcc-config</command> и введите список доступных серверов distcc. Для простоты примера, предположим, что доступные серверы DistCC — 192.168.1.102 (текущий компьютер), 192.168.1.103 и 192.168.1.104 (два «удаленных» компьютера): </para>
                    <example>
                        <title>Настройка distcc для использования трех доступных серверов distcc</title>
                        <screen><prompt>#</prompt> <userinput>distcc-config --set-hosts "192.168.1.102 192.168.1.103 192.168.1.104"</userinput></screen>
                    </example>
                    <para>Не забудьте также запустить демон <systemitem class="daemon">distccd</systemitem>: </para>
                    <example>
                        <title>Запуск демонов distccd</title>
                        <screen><prompt>#</prompt> <userinput>rc-update add distccd default</userinput>
<prompt>#</prompt> <userinput>/etc/init.d/distccd start</userinput></screen>
                    </example>
                </section>
            </section>
            <section>
                <title>Кэширование компиляции</title>
                <section>
                    <title>О средстве ccache</title>
                    <para><indexterm><primary>ccache</primary></indexterm>ccache — это быстрый кэш компилятора. Когда вы компилируете программу, он кэширует промежуточные результаты так, что всякий раз, когда вы перекомпилируете ту же самую программу, время компиляции значительно сокращается. В типичных случаях общее время компиляции может сокращаться в 5—10 раз. </para>
                    <para>Если вы интересуетесь подробностями ccache, пожалуйста, посетите <link xlink:href="http://ccache.samba.org">домашнюю страницу ccache</link>. </para>
                </section>
                <section>
                    <title>Установка ccache</title>
                    <para>Для установки ccache, выполните <command>emerge ccache</command>: </para>
                    <example>
                        <title>Установка ccache</title>
                        <screen><prompt>#</prompt> <userinput>emerge ccache</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Подключение поддержки Portage</title>
                    <para>Откройте <filename>/etc/make.conf</filename> и добавьте <code>ccache</code> к переменной <envar>FEATURES</envar>. Затем добавьте новую переменную по имени <envar>CCACHE_SIZE</envar> (размер кэша), и установите её равной «2G»: </para>
                    <example>
                        <title>Редактирование <envar>CCACHE_SIZE</envar> в <filename>/etc/make.conf</filename></title>
                        <programlisting>CCACHE_SIZE="2G"</programlisting>
                    </example>
                    <para>Для проверки работоспособности ccache, запросите статистику ccache. Из-за того, что Portage использует другой домашний каталог ccache, вам также потребуется установить переменную <envar>CCACHE_DIR</envar>: </para>
                    <example>
                        <title>Просмотр статистики ccache</title>
                        <screen><prompt>#</prompt> <userinput>CCACHE_DIR="/var/tmp/ccache" ccache -s</userinput></screen>
                    </example>
                    <para>Домашний каталог ccache по умолчанию — <filename>/var/tmp/ccache</filename>; изменить это назначение можно, определив переменную <envar>CCACHE_DIR</envar> в <filename>/etc/make.conf</filename>. </para>
                    <para>Однако, при запуске ccache используется каталог по умолчанию, <filename>${HOME}/.ccache</filename>, вот почему при запросе статистики (Portage) ccache требуется определять переменную <envar>CCACHE_DIR</envar>. </para>
                </section>
                <section>
                    <title>Использование ccache для компиляции Си не в Portage</title>
                    <para>Если вы хотите использовать ccache для компиляций не в Portage, добавьте <filename>/usr/lib/ccache/bin</filename> в начало вашей переменной <envar>PATH</envar> (перед <filename>/usr/bin</filename>). Это можно сделать, отредактировав <filename>/etc/env.d/00basic</filename>, который является первым файлом среды, где определяется переменная <envar>PATH</envar>: </para>
                    <example>
                        <title>Редактирование <filename>/etc/env.d/00basic</filename></title>
                        <programlisting>PATH="/usr/lib/ccache/bin:/opt/bin"</programlisting>
                    </example>
                </section>
            </section>
            <section>
                <title>Поддержка двоичных пакетов</title>
                <section>
                    <title>Создание готовых (заранее собранных) пакетов</title>
                    <para>Portage поддерживает установку заранее собранных готовых пакетов. Несмотря на то, что в саму Gentoo не входят заранее собранные пакеты (за исключением снимков GRP), Portage можно настроить на полноценное управление готовыми пакетами. </para>
                    <para>Чтобы создать двоичный пакет, можно использовать quickpkg, если пакет уже установлен в вашей системе, или emerge с параметрами <parameter>--buildpkg</parameter> или <parameter>--buildpkgonly</parameter>.</para>
                    <para>Если вы хотите, чтобы Portage создавал двоичные пакеты из каждого пакета, который вы будете устанавливать, добавьте <code>buildpkg</code> к переменной <envar>FEATURES</envar>.</para>
                    <para>Расширенная поддержка создания наборов готовых пакетов имеются в catalyst. Для получения подробной информации о catalyst, пожалуйста, прочитайте <link xlink:href="http://www.gentoo.org/proj/en/releng/catalyst/2.x/reference.xml">справочное руководство по catalyst (англ.)</link> и <link xlink:href="http://www.gentoo.org/proj/en/releng/catalyst/faq.xml">распространенные вопросы о catalyst (англ.)</link>. </para>
                </section>
                <section>
                    <title>Установка двоичных пакетов</title>
                    <para>Хотя в Gentoo такого хранилища нет, вы можете создать централизованное хранилище для заранее скомпилированных двоичных пакетов. Чтобы использовать такое хранилище, потребуется указать Portage путь к нему с помощью переменной <envar>PORTAGE_BINHOST</envar>. Например, если двоичные пакеты находятся на ftp://buildhost/gentoo: </para>
                    <example>
                        <title>Установка <envar>PORTAGE_BINHOST</envar> в <filename>/etc/make.conf</filename></title>
                        <programlisting>PORTAGE_BINHOST="ftp://buildhost/gentoo"</programlisting>
                    </example>
                    <para>При установке двоичных пакетов, указывайте в команде <command>emerge</command> параметр <parameter>--getbinpkg</parameter> вместе с параметром <parameter>--usepkg</parameter>. Первый указывает emerge загрузить двоичный пакет c сервера, определенного раньше, а второй сообщает emerge, что до загрузки исходных кодов и их компиляции сначала нужно попытаться установить этот двоичный пакет. </para>
                    <para>Например, чтобы установить gnumeric из двоичных пакетов: </para>
                    <example>
                        <title>Установка двоичного пакета gnumeric</title>
                        <screen><prompt>#</prompt> <userinput>emerge --usepkg --getbinpkg gnumeric</userinput></screen>
                    </example>
                    <para>Подробную информацию о параметрах установки двоичных пакетов можно найти на странице справки emerge: </para>
                    <example>
                        <title>Чтение справки по emerge</title>
                        <screen><prompt>$</prompt> <userinput>man emerge</userinput></screen>
                    </example>
                </section>
            </section>
        </section>
        <section xreflabel="Сценарии инициализации">
            <title>Сценарии инициализации</title>
            <section>
                <title>Уровни запуска</title>
                <section>
                    <title>Процесс загрузки системы</title>
                    <para>При загрузке вашей системы по экрану пробегает много текста. Если присмотреться, заметно, что этот текст не меняется от загрузки к загрузке. Последовательность всех этих действий называется последовательностью загрузки и в той или иной степени постоянна. </para>
                    <para>Во-первых, загрузчик размещает в памяти образ ядра, который вы указали в файле его конфигурации. После этого ядро запускается. Когда ядро загружено и запущено, оно инициализирует относящиеся к ядру структуры и задания, и запускает процесс init. </para>
                    <para>Этот процесс удостоверяется, что все файловые системы (определенные в <filename>/etc/fstab</filename>) смонтированы и готовы к использованию. Затем он выполняет несколько сценариев, находящихся в каталоге <filename>/etc/init.d</filename>, которые запускают службы, необходимые для нормального запуска системы. </para>
                    <para>И, наконец, когда все сценарии выполнены, init подключает терминалы (чаще всего просто виртуальные консоли, которые видны при нажатии <keycombo><keycap>ALT</keycap><keycap>F1</keycap></keycombo>, <keycombo><keycap>ALT</keycap><keycap>F2</keycap></keycombo> и т.д.), прикрепляя к каждой консоли специальный процесс под названием agetty. Этот процесс впоследствии обеспечивает возможность входа в систему с помощью login. </para>
                </section>
                <section>
                    <title>Сценарии инициализации</title>
                    <para>Сейчас процесс init запускает сценарии из каталога <filename>/etc/init.d</filename> не просто в случайном порядке. Более того, запускаются не все сценарии из <filename>/etc/init.d</filename>, а только те, которые предписано исполнять. Решение о запуске сценария принимается в результате просмотра каталога <filename>/etc/runlevels</filename>.</para>
                    <para>Во-первых, init запускает все сценарии из <filename>/etc/init.d</filename>, на которые есть символьные ссылки из <filename>/etc/runlevels/boot</filename>. Обычно сценарии запускаются в алфавитном порядке, но в некоторых сценариях имеется информация о зависимостях от других сценариев, указывающая системе на необходимость их предварительного запуска. </para>
                    <para>Когда все сценарии, указанные в <filename>/etc/runlevels/boot</filename>, будут выполнены, init переходит к запуску сценариев, на которые есть символьные ссылки из <filename>/etc/runlevels/default.</filename> И снова запуск происходит в алфавитном порядке, пока в сценарии не встретится информация о зависимостях; тогда порядок изменяется для обеспечения правильного порядка запуска. </para>
                </section>
                <section>
                    <title>Как работает init</title>
                    <para>Конечно, init не принимает решений сам по себе. Ему необходим конфигурационный файл, где описаны необходимые действия. Этот файл — <filename>/etc/inittab</filename>. </para>
                    <para>Если вы запомнили последовательность загрузки, описанную чуть ранее, вы вспомните, что первое действие init — это монтирование всех файловых систем. Это определяется в строке <filename>/etc/inittab</filename>, приведенной ниже: </para>
                    <example>
                        <title>Строка инициализации системы из <filename>/etc/inittab</filename></title>
                        <programlisting>si::sysinit:/sbin/rc sysinit</programlisting>
                    </example>
                    <para>Этой строкой процессу init предписывается выполнить <command>/sbin/rc sysinit</command> для инициализации системы. Самой инициализацией занимается сценарий <command>/sbin/rc</command>, так что можно сказать, что init делает не слишком много — он просто делегирует задачу по инициализации системы другому процессу. </para>
                    <para>Во-вторых, init выполняет все сценарии, на которые есть символьные ссылки из <filename>/etc/runlevels/boot</filename>. Это определяется следующей строкой: </para>
                    <example>
                        <title>Инициализация системы, продолжение</title>
                        <programlisting>rc::bootwait:/sbin/rc boot</programlisting>
                    </example>
                    <para>И снова все необходимые действия выполняются сценарием rc. Заметьте, что параметр, переданный rc (boot), совпадает с названием используемого подкаталога в <filename>/etc/runlevels</filename>. </para>
                    <para>Теперь init проверяет свой конфигурационный файл, чтобы определить, какой уровень запуска использовать. Для этого из <filename>/etc/inittab</filename> считывается строка: </para>
                    <example>
                        <title>Строка initdefault</title>
                        <programlisting>id:3:initdefault:</programlisting>
                    </example>
                    <para>В приведенном примере (который подходит для подавляющего большинства пользователей Gentoo) номер уровня запуска — 3. Пользуясь этой информацией, init проверяет, что нужно выполнить для запуска уровня запуска 3: </para>
                    <example>
                        <title>Определение уровней запуска</title>
                        <programlisting>l0:0:wait:/sbin/rc shutdown
l1:S1:wait:/sbin/rc single
l2:2:wait:/sbin/rc nonetwork
l3:3:wait:/sbin/rc default
l4:4:wait:/sbin/rc default
l5:5:wait:/sbin/rc default
l6:6:wait:/sbin/rc reboot</programlisting>
                    </example>
                    <para>В строке, определяющей уровень 3, для запуска служб снова используется сценарий rc (на этот раз с аргументом default). Опять-таки, обратите внимание, что аргумент, передаваемый сценарию rc, совпадает с названием подкаталога из <filename>/etc/runlevels</filename>. </para>
                    <para>По окончании работы rc, init принимает решение о том, какие виртуальные консоли включить и какие команды выполнить в каждой из них: </para>
                    <example>
                        <title>Определение виртуальных консолей</title>
                        <programlisting>c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux</programlisting>
                    </example>
                </section>
                <section>
                    <title>Что такое уровень запуска?</title>
                    <para><indexterm><primary>Initscript</primary></indexterm><indexterm><primary>Сценарий инициализации</primary></indexterm><indexterm><primary>Уровень запуска</primary></indexterm>Как вы заметили, init применяет нумерацию для определения уровня запуска, который надо использовать. <firstterm>Уровень запуска</firstterm> — это то состояние, в котором запускается ваша система, он содержит набор сценариев (сценариев уровня запуска или <firstterm>сценариев инициализации</firstterm> [<firstterm>initscript</firstterm>]), которые следует выполнять, при входе и выходе из определенного уровня запуска. </para>
                    <para>В Gentoo определено семь уровней запуска: три служебных и четыре определяемых пользователем. Служебные называются <firstterm>sysinit</firstterm>, <firstterm>shutdown</firstterm> и <firstterm>reboot</firstterm>. Действия, совершаемые ими, в точности соответствуют их названиям: инициализация системы, выключение системы и ее перезагрузка. </para>
                    <para>Определяемые пользователем уровни — это те, которым соответствуют подкаталоги в <filename>/etc/runlevels</filename>: <filename>boot</filename>, <filename>default</filename>, <filename>nonetwork</filename> и <filename>single</filename>. Уровень <filename>boot</filename> запускает все службы, необходимые системе и используемые всеми остальными уровнями. Остальные уровни отличаются друг от друга запускаемыми службами: <filename>default</filename> используется для повседневной работы, <filename>nonetwork</filename> — для тех случаев, когда не требуется сеть, а <filename>single</filename> — при необходимости восстановления системы. </para>
                </section>
                <section>
                    <title>Работа со сценариями инициализации</title>
                    <para>Сценарии, запускаемые процессом rc, называются сценариями инициализации. Каждый сценарий из <filename>/etc/init.d</filename> может запускаться с аргументами <parameter>start</parameter>, <parameter>stop</parameter>, <parameter>restart</parameter>, <parameter>pause</parameter>, <parameter>zap</parameter>, <parameter>status</parameter>, <parameter>ineed</parameter>, <parameter>iuse</parameter>, <parameter>needsme</parameter>, <parameter>usesme</parameter> и <parameter>broken</parameter>. </para>
                    <para>Для запуска, остановки или перезапуска службы (и всех, зависящих от нее) следует использовать <parameter>start</parameter>, <parameter>stop</parameter> и <parameter>restart</parameter>:</para>
                    <example>
                        <title>Запуск postfix</title>
                        <screen><prompt>#</prompt> <userinput>/etc/init.d/postfix start</userinput></screen>
                    </example>
                    <note>
                        <para>Останавливаются или перезапускаются только те службы, которым необходима данная служба. Остальные зависимые службы (те, которые используют службу, но не нуждаются в ней) эта операция не затрагивает. </para>
                    </note>
                    <para>Если вы хотите остановить службу, но оставить зависимые от нее работающими, можно использовать аргумент <parameter>pause</parameter>: </para>
                    <example>
                        <title>Остановка postfix без остановки зависимых служб</title>
                        <screen><prompt>#</prompt> <userinput>/etc/init.d/postfix pause</userinput></screen>
                    </example>
                    <para>Чтобы узнать текущее состояние службы (запущена, остановлена, приостановлена и т.д.), можно использовать аргумент <parameter>status</parameter>: </para>
                    <example>
                        <title>Информация о состоянии postfix</title>
                        <screen><prompt>#</prompt> <userinput>/etc/init.d/postfix status</userinput></screen>
                    </example>
                    <para>Если указано, что служба работает, но вы знаете, что это не так, можно сбросить состояние на stopped (остановлена), используя аргумент <parameter>zap</parameter>: </para>
                    <example>
                        <title>Сброс информации о состоянии postfix</title>
                        <screen><prompt>#</prompt> <userinput>/etc/init.d/postfix zap</userinput></screen>
                    </example>
                    <para>Для того, чтобы выяснить зависимости службы, можно использовать аргументы <parameter>iuse</parameter> или <parameter>ineed</parameter>. С помощью <parameter>ineed</parameter> вы увидите те службы, которые действительно необходимы для правильного функционирования интересующей вас службы. С другой стороны, <parameter>iuse</parameter> покажет те службы, которые могут использоваться нашей службой, но не обязательны для ее работы. </para>
                    <example>
                        <title>Запрос списка всех необходимых служб, от которых зависит Postfix</title>
                        <screen><prompt>#</prompt> <userinput>/etc/init.d/postfix ineed</userinput></screen>
                    </example>
                    <para>Аналогично вы можете узнать, какие службы нуждаются в данной службе (needsme) или могут ее использовать (<parameter>usesme</parameter>): </para>
                    <example>
                        <title>Запрос списка всех служб, которым необходим Postfix</title>
                        <screen><prompt>#</prompt> <userinput>/etc/init.d/postfix needsme</userinput></screen>
                    </example>
                    <para>Наконец, можно просмотреть список служб, требующихся для данной, но отсутствующих в системе: </para>
                    <example>
                        <title>Запрос списка служб, необходимых Postfix, но отсутствующих</title>
                        <screen><prompt>#</prompt> <userinput>/etc/init.d/postfix broken</userinput></screen>
                    </example>
                </section>
            </section>
            <section>
                <title>Использование rc-update</title>
                <section>
                    <title>Что такое rc-update?</title>
                    <para>Система инициализации Gentoo использует дерево зависимостей для определения служб, которые запускаются в первую очередь. Т. к. это очень утомительное занятие, и мы не хотели, чтобы пользователь занимался этим вручную, мы разработали инструменты, упрощающие управление уровнями запуска и сценариями инициализации. </para>
                    <para>Используя <command>rc-update</command>, можно включать и исключать сценарии инициализации из уровней запуска. Из <command>rc-update</command> автоматически запускается сценарий <filename>depscan.sh</filename> для перестроения дерева зависимостей. </para>
                </section>
                <section>
                    <title>Добавление и удаление служб</title>
                    <para>В процессе установки Gentoo вы уже добавляли сценарии инициализации в уровень запуска «default». В тот момент вы, возможно, не имели понятия, что такое «default» и зачем он нужен, но теперь вы все это знаете. Сценарию <command>rc-update</command> требуется второй аргумент, определяющий действие: <parameter>add</parameter> (добавить), <parameter>del</parameter> (удалить) или <parameter>show</parameter> (показать). </para>
                    <para>Для того, чтобы добавить или удалить сценарий, просто введите <command>rc-update</command> с аргументом <parameter>add</parameter> или <parameter>del</parameter>, затем название сценария и уровня запуска. Например: </para>
                    <example>
                        <title>Удаление Postfix из уровня запуска default</title>
                        <screen><prompt>#</prompt> <userinput>rc-update del postfix default</userinput></screen>
                    </example>
                    <para>По команде <command>rc-update show</command> выводится список всех доступных сценариев с указанием соответствующих уровней запуска: </para>
                    <example>
                        <title>Получение информации о сценариях инициализации</title>
                        <screen><prompt>#</prompt> <userinput>rc-update show</userinput></screen>
                    </example>
                </section>
            </section>
            <section>
                <title>Настройка служб</title>
                <section>
                    <title>Почему нужна дополнительная настройка?</title>
                    <para>Сценарии инициализации могут быть весьма сложны. Поэтому нежелательно допускать непосредственное редактирование сценария пользователями, т.к. это может привнести в систему множество ошибок. Но, с другой стороны, необходимо правильно настроить службу. Например, может понадобиться передать службе дополнительные параметры. </para>
                    <para>Вторая причина, по которой настройки хранятся отдельно от самого сценария — это возможность обновления сценария без опасения, что все ваши настройки будут утеряны. </para>
                </section>
                <section>
                    <title>Каталог <filename>/etc/conf.d</filename></title>
                    <para>В Gentoo предусмотрен очень простой способ настройки служб: для каждого сценария, предполагающего настройку, в каталоге <filename>/etc/conf.d</filename> есть конфигурационный файл. Например, у сценария, запускающего apache2 (под названием <filename>/etc/init.d/apache2</filename>) есть конфигурационный файл <filename>/etc/conf.d/apache2</filename>, где могут храниться нужные вам параметры, передаваемые серверу Apache 2 при запуске: </para>
                    <example>
                        <title>Переменная, определенная в <filename>/etc/conf.d/apache2</filename></title>
                        <programlisting>APACHE2_OPTS="-D PHP4"</programlisting>
                    </example>
                    <para>Такие файлы настроек содержат одни переменные (наподобие <filename>/etc/make.conf</filename>), облегчая настройку служб. Это также позволяет нам давать больше информации о переменных (в комментариях). </para>
                </section>
            </section>
            <section>
                <title>Написание сценариев инициализации</title>
                <section>
                    <title>Мне тоже придется?..</title>
                    <para>Нет, написание сценариев инициализации обычно не требуется, т.к. Gentoo содержит готовые сценарии для всех поддерживаемых служб. Однако, вы можете установить какую-либо службу, не используя систему Portage; в таком случае, вероятно, вам придется создавать сценарий инициализации самостоятельно. </para>
                    <warning>
                        <para>не используйте сценарий, идущий со службой, если он не написан специально для Gentoo: сценарии инициализации Gentoo не совместимы со сценариями, используемыми в других дистрибутивах! </para>
                    </warning>
                </section>
                <section>
                    <title>Структура</title>
                    <para>Основная структура сценария инициализации показана ниже. </para>
                    <example>
                        <title>Основная структура сценария</title>
                        <programlisting>#!/sbin/runscript

depend() {
  <lineannotation>(информация о зависимостях)</lineannotation>
}

start() {
  <lineannotation>(команды, необходимые для запуска службы)</lineannotation>
}

stop() {
  <lineannotation>(команды, необходимые для остановки службы)</lineannotation>
}

restart() {
  <lineannotation>(команды, необходимые для перезапуска службы)</lineannotation>
}</programlisting>
                    </example>
                    <para>В любом сценарии должна быть определена функция <function>start()</function>. Все остальные разделы необязательны. </para>
                </section>
                <section>
                    <title>Зависимости</title>
                    <para>Можно определять два типа зависимостей: <code>use</code> (использую) и <code>need</code> (нуждаюсь). Как упоминалось ранее, need-зависимость более строга, чем use-зависимость. Вслед за типом зависимости указывается название службы, от которой существует зависимость, или ссылка на <emphasis role="italic">виртуальную</emphasis> (virtual) зависимость. </para>
                    <para><indexterm><primary>Виртуальная зависимость</primary></indexterm><emphasis role="italic">Виртуальная</emphasis> зависимость — это зависимость от функций, предоставляемых службой, но не какой-то единственной службой. Сценарий может зависеть от службы системного журнала, но таких достаточно много (metalogd, syslog-ng, и и т.п.). Поскольку нельзя нуждаться в каждой из них (ни в одной вразумительной системе они не запущены все сразу), мы обеспечили предоставление виртуальной зависимости всеми этими службами. </para>
                    <para>Давайте взглянем на информацию о зависимостях postfix. </para>
                    <example>
                        <title>Информация о зависимостях Postfix</title>
                        <programlisting>depend() {
  need net
  use logger dns
  provide mta
}</programlisting>
                    </example>
                    <para>Как можно увидеть, postfix: </para>
                    <orderedlist>
                        <listitem>
                            <para>требует сеть (net): виртуальная зависимость, удовлетворяемая, например, <filename>/etc/init.d/net.eth0</filename>; </para>
                        </listitem>
                        <listitem>
                            <para>использует журнал (logger): виртуальная зависимость, удовлетворяемая, например, <filename>/etc/init.d/syslog-ng</filename>;</para>
                        </listitem>
                        <listitem>
                            <para>использует службу имен (dns): виртуальная зависимость, удовлетворяемая, например, <filename>/etc/init.d/named</filename>); </para>
                        </listitem>
                        <listitem>
                            <para>предоставляет почтовый агент (mta): виртуальная зависимость, общая для всех программ — почтовых серверов. </para>
                        </listitem>
                    </orderedlist>
                </section>
                <section>
                    <title>Порядок запуска</title>
                    <para>Иногда вам нужна не сама служба, а запуск вашей службы до (или после) другой службы, если та присутствует в системе (обратите внимание на условие: это уже не зависимость) и запускается на том же уровне запуска (отметьте условие: это относится только к службам из одинакового уровня запуска). Такую очередность можно указать, используя значения before (до) или after (после). </para>
                    <para>Например, рассмотрим значения для службы Portmap: </para>
                    <example>
                        <title>Функция <function>depend()</function> службы Portmap</title>
                        <programlisting>depend() {
  need net
  before inetd
  before xinetd
}</programlisting>
                    </example>
                    <para>Также можно использовать знак «*», чтобы охватить все службы данного уровня запуска, хотя это не рекомендуется. </para>
                    <example>
                        <title>Запуск сценария первым на уровне запуска</title>
                        <programlisting>depend() {
  before *
}</programlisting>
                    </example>
                </section>
                <section>
                    <title>Стандартные функции</title>
                    <para>Следом за разделом <function>depend()</function> вам потребуется определить функцию <function>start()</function>. В ней содержатся все команды, необходимые для запуска вашей службы. Рекомендуется применять функции <function>ebegin</function> и <function>eend</function> для сообщений пользователю о том, что происходит: </para>
                    <example>
                        <title>Пример функции <function>start()</function></title>
                        <programlisting>start() {
  ebegin "Запуск - моя_служба"
  start-stop-daemon --start --quiet --exec /path/to/my_service
  eend $?
}</programlisting>
                    </example>
                    <para>Если вам нужны дополнительные примеры функции <function>start()</function>, пожалуйста, прочитайте исходные коды сценариев инициализации, находящихся в каталоге <filename>/etc/init.d</filename>. Что касается команды <command>start-stop-daemon</command>, то на случай, если вам нужны дополнительные сведения, есть превосходная страница справки: </para>
                    <example>
                        <title>Вызов страницы справки по start-stop-daemon</title>
                        <screen><prompt>#</prompt> <userinput>man start-stop-daemon</userinput></screen>
                    </example>
                    <para>Другими функциями, которые можно определить — <function>stop()</function> и <function>restart()</function>. От вас не требуется определение этих функций! Система инициализации, применяемая нами, достаточно развита и в состоянии самостоятельно заполнить эти функции, если вы используете <command>start-stop-daemon</command>. </para>
                    <para>Синтаксис сценариев инициализации, применяемых в Gentoo, основан на оболочке Борна (Bourne Again Shell — bash), поэтому вы можете свободно использовать внутри своих сценариев bash-совместимые конструкции. </para>
                </section>
                <section>
                    <title>Добавление дополнительных параметров</title>
                    <para>Если вы хотите ввести в сценарий дополнительные параметры, кроме упоминавшихся, нужно добавить к переменной opts название параметра и создать функцию с названием, соответствующим параметру. Например, для поддержки параметра <parameter>restartdelay</parameter>: </para>
                    <example>
                        <title>Создание дополнительной функции <function>restartdelay</function></title>
                        <programlisting>opts="${opts} restartdelay"

restartdelay() {
  stop
  sleep 3    <lineannotation># пауза в 3 секунды перед повторным запуском</lineannotation>
  start
}</programlisting>
                    </example>
                </section>
                <section>
                    <title>Переменные для настройки служб</title>
                    <para>Для поддержки конфигурационного файла в каталоге <filename>/etc/conf.d</filename> ничего дополнительно делать не нужно: при запуске вашего сценария инициализации автоматически включаются следующие файлы (т.е., переменные из них становятся доступны): </para>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para><filename>/etc/conf.d/<replaceable>&lt;ваш сценарий инициализации&gt;</replaceable></filename></para>
                            </listitem>
                            <listitem>
                                <para><filename>/etc/conf.d/basic</filename></para>
                            </listitem>
                            <listitem>
                                <para><filename>/etc/rc.conf</filename></para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <para>Если ваш инициализационный сценарий предоставляет виртуальную зависимость (например, net), то также включается файл, соответствующий этой зависимости (например, <filename>/etc/conf.d/net</filename>). </para>
                </section>
            </section>
            <section>
                <title>Изменение поведения уровней запуска</title>
                <section>
                    <title>Кто от этого выиграет?</title>
                    <para/>
                    <para>Большинству пользователей ноутбуков знакома ситуация: дома вам нужен запуск <code>net.eth0</code>, и наоборот, в дороге запуск <code>net.eth0</code> не нужен (так как сеть недоступна). В Gentoo можно изменять поведение уровней запуска по своему усмотрению. </para>
                    <para>Например вы можете создать второй загружаемый уровень запуска «по умолчанию», в котором будут другие сценарии. Затем при загрузке вы сможете выбрать, какой из уровней по умолчанию следует использовать. </para>
                </section>
                <section>
                    <title>Использование программного уровня (softlevel)</title>
                    <para>Прежде всего, создайте каталог для своего второго уровня запуска «по умолчанию». Например, создадим уровень запуска offline: </para>
                    <example>
                        <title>Создание каталога уровня запуска</title>
                        <screen><prompt>#</prompt> <userinput>mkdir /etc/runlevels/offline</userinput></screen>
                    </example>
                    <para>Добавьте необходимые сценарии инициализации в только что созданный уровень запуска. Например, чтобы получить точную копию уровня default, за исключением net.eth0: </para>
                    <example>
                        <title>Добавление нужных сценариев инициализации</title>
                        <screen><lineannotation>(копирование всех служб с уровня default в уровень offline)</lineannotation>
<prompt>#</prompt> <userinput>cd /etc/runlevels/default</userinput>
<prompt>#</prompt> <userinput>for service in *; do rc-update add $service offline; done</userinput>
<lineannotation>(удаление ненужных сценариев с уровня offline)</lineannotation>
<prompt>#</prompt> <userinput>rc-update del net.eth0 offline</userinput>
<lineannotation>(просмотр сценариев, запускаемых на уровне offline)</lineannotation>
<prompt>#</prompt> <userinput>rc-update show offline</userinput>
<lineannotation>(часть выведенного списка)</lineannotation>
               acpid | offline
          domainname | offline
               local | offline
            net.eth0 |</screen>
                    </example>
                    <para>Теперь необходимо отредактировать конфигурацию загрузчика, добавив запись об уровне offline. Например, в файле <filename>/boot/grub/grub.conf</filename>: </para>
                    <example>
                        <title>Добавление записи об уровне offline</title>
                        <programlisting>  title Автономное использование Gentoo Linux
  root (hd0,0)
  kernel (hd0,0)/kernel-2.4.25 root=/dev/hda3 <emphasis role="bold">softlevel=offline</emphasis></programlisting>
                    </example>
                    <para>Вуаля, все готово. Теперь, если при загрузке вы выберете вновь созданную запись, то вместо default будет использоваться уровень offline. </para>
                </section>
                <section>
                    <title>Использование загрузочного уровня (bootlevel)</title>
                    <para>Использование загрузочного уровня полностью аналогично использованию программного уровня. Единственная разница состоит в том, что вы определяете второй уровень «boot» вместо «default». </para>
                </section>
            </section>
        </section>
        <section xreflabel="Переменные среды">
            <title>Переменные среды</title>
            <section>
                <title>Переменные среды</title>
                <section>
                    <title>Что это такое?</title>
                    <para><indexterm><primary>Переменная среды</primary></indexterm>Переменная среды — это именованный объект, который содержит информацию, используемую одним или несколькими приложениями. </para>
                    <para>Многие пользователи (особенно новички в Linux) находят этот подход несколько странным или неуправляемым. Но это впечатление ошибочно: используя переменные среды, можно очень легко изменить настройку разнообразных программ. </para>
                </section>
                <section>
                    <title>Важные примеры</title>
                    <para>В следующей таблице описывается ряд переменных, используемых в системе Linux. Примеры их значений приведены далее. </para>
                    <informaltable frame="all">
                        <tgroup cols="2">
                            <thead>
                                <row>
                                    <entry>
                                        <para>Переменная</para>
                                    </entry>
                                    <entry>
                                        <para>Описание</para>
                                    </entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>
                                        <para><envar>PATH</envar></para>
                                    </entry>
                                    <entry>
                                        <para>В этой переменной содержится список каталогов, разделенных   двоеточиями, в которых система ищет исполняемые файлы. Если вы вводите имя исполняемого файла например, <command>ls</command>, <command>rc-update</command> или <command>emerge</command>), который не находится ни в одной из перечисленных здесь каталогов, этот файл не запустится (если, конечно, вы не указали полный путь, например, <filename>/bin/ls</filename>). </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para><envar>ROOTPATH</envar></para>
                                    </entry>
                                    <entry>
                                        <para>У этой переменной такое же значение, что и у <envar>PATH</envar>, но в ней перечисляются только те каталоги, которые нужно просматривать при вводе команды пользователем с правами root.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para><envar>LDPATH</envar></para>
                                    </entry>
                                    <entry>
                                        <para>В этой переменной содержится список каталогов, разделенных двоеточиями, в которых динамический компоновщик ищет библиотеки. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para><envar>MANPATH</envar></para>
                                    </entry>
                                    <entry>
                                        <para>В этой переменной содержится список каталогов, разделенных двоеточиями, в которых команда <command>man</command> ищет страницы справки. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para><envar>INFODIR</envar></para>
                                    </entry>
                                    <entry>
                                        <para>В этой переменной содержится список каталогов, разделенных двоеточиями, в которых команда <command>info</command> ищет info-страницы. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para><envar>PAGER</envar></para>
                                    </entry>
                                    <entry>
                                        <para>В этой переменной содержится путь к программе, позволяющей постранично просматривать содержимое файлов, например <command>less</command> или <command>more</command>. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para><envar>EDITOR</envar></para>
                                    </entry>
                                    <entry>
                                        <para>В этой переменной содержится путь к программе, используемой для изменения файлов, например <command>vi</command> или <command>nano</command>. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para><envar>KDEDIRS</envar></para>
                                    </entry>
                                    <entry>
                                        <para>В этой переменной содержится список каталогов, разделенных двоеточиями, в которых находятся ресурсы KDE. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para><envar>CLASSPATH</envar></para>
                                    </entry>
                                    <entry>
                                        <para>В этой переменной содержится список каталогов, разделенных двоеточиями, в которых находятся классы Java. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para><envar>CONFIG_PROTECT</envar></para>
                                    </entry>
                                    <entry>
                                        <para>В этой переменной содержится список каталогов, защищаемых Portage при обновлении, разделенных пробелами. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para><envar>CONFIG_PROTECT_MASK</envar></para>
                                    </entry>
                                    <entry>
                                        <para>В этой переменной содержится список каталогов, исключаемых из защиты Portage при обновлении, разделенных пробелами </para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                    <para>Ниже представлен пример определения всех этих переменных: </para>
                    <example>
                        <title>Пример определения</title>
                        <programlisting>PATH="/bin:/usr/bin:/usr/local/bin:/opt/bin:/usr/games/bin"
ROOTPATH="/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin"
LDPATH="/lib:/usr/lib:/usr/local/lib:/usr/lib/gcc-lib/i686-pc-linux-gnu/3.2.3"
MANPATH="/usr/share/man:/usr/local/share/man"
INFODIR="/usr/share/info:/usr/local/share/info"
PAGER="/usr/bin/less"
EDITOR="/usr/bin/vim"
KDEDIRS="/usr"
CLASSPATH="/opt/blackdown-jre-1.4.1/lib/rt.jar:."
CONFIG_PROTECT="/usr/X11R6/lib/X11/xkb /opt/tomcat/conf \
                /usr/kde/3.1/share/config /usr/share/texmf/tex/generic/config/ \
                /usr/share/texmf/tex/platex/config/ /usr/share/config"
CONFIG_PROTECT_MASK="/etc/gconf"</programlisting>
                    </example>
                </section>
            </section>
            <section>
                <title>Глобальное определение переменных</title>
                <section>
                    <title>Каталог <filename>/etc/env.d</filename></title>
                    <para>Для того, чтобы определить эти переменные централизованно, в Gentoo появился каталог <filename>/etc/env.d</filename>. В нём находится ряд файлов, например, <filename>00basic</filename>, <filename>05gcc</filename> и так далее, в которых определяются переменные, необходимые программам, указанным в названии файлов. </para>
                    <para>Например, при установке gcc ebuild создает файл <filename>05gcc</filename>, содержащий следующие определения переменных: </para>
                    <example>
                        <title><filename>/etc/env.d/05gcc</filename></title>
                        <programlisting>PATH="/usr/i686-pc-linux-gnu/gcc-bin/3.2"
ROOTPATH="/usr/i686-pc-linux-gnu/gcc-bin/3.2"
MANPATH="/usr/share/gcc-data/i686-pc-linux-gnu/3.2/man"
INFOPATH="/usr/share/gcc-data/i686-pc-linux-gnu/3.2/info"
CC="gcc"
CXX="g++"
LDPATH="/usr/lib/gcc-lib/i686-pc-linux-gnu/3.2.3"</programlisting>
                    </example>
                    <para>В других дистрибутивах вам предлагается изменять или добавлять определения переменных среды в <filename>/etc/profile</filename> или где-нибудь еще. Gentoo, с другой стороны, облегчает вам (и Portage) поддержку и управление переменными среды, избавляя от необходимости уделять внимание многочисленным файлам, содержащим определения переменных. </para>
                    <para>Например, когда обновляется gcc, также без малейшего участия пользователя обновляется и <filename>/etc/env.d/05gcc</filename>. </para>
                    <para>От этого выигрывает не только Portage, но и вы, пользователь. Иногда от вас может потребоваться глобальная установка какой-нибудь переменной. Возьмем, к примеру, переменную <envar>http_proxy</envar>. Вместо того, чтобы возиться с <filename>/etc/profile</filename>, теперь можно просто создать файл (<filename>/etc/env.d/99local</filename>) и добавить нужные определения туда: </para>
                    <example>
                        <title>/etc/env.d/99local</title>
                        <programlisting>http_proxy="proxy.server.com:8080"</programlisting>
                    </example>
                    <para>Используя один и тот же файл для всех своих переменных, вы можете быстро увидеть все определенные вами переменные вместе. </para>
                </section>
                <section>
                    <title>Сценарий <command>env-update</command></title>
                    <para>Переменная <envar>PATH</envar> определяется в нескольких файлах в <filename>/etc/env.d</filename>. Нет, нет это не ошибка: при запуске <command>env-update</command> различные определения объединяются перед обновлением переменных среды, позволяя пакетам (или пользователям) добавлять собственные значения переменных, не влияя на уже существующие. </para>
                    <para>Сценарий <command>env-update</command> объединяет значения переменных из файлов, находящихся в <filename>/etc/env.d</filename>, в алфавитном порядке. Имена файлов должны начинаться с двух десятичных цифр. </para>
                    <example>
                        <title>Порядок обновления, используемый env-update</title>
                        <programlisting>         00basic        99kde-env       99local
     +-------------+----------------+-------------+
PATH="/bin:/usr/bin:/usr/kde/3.2/bin:/usr/local/bin"</programlisting>
                    </example>
                    <warning>
                        <para>объединение выполняется не всегда, а только для следующих переменных: <envar>KDEDIRS</envar>, <envar>PATH</envar>, <envar>CLASSPATH</envar>, <envar>LDPATH</envar>, <envar>MANPATH</envar>, <envar>INFODIR</envar>, <envar>INFOPATH</envar>, <envar>ROOTPATH</envar>, <envar>CONFIG_PROTECT</envar>, <envar>CONFIG_PROTECT_MASK</envar>, <envar>PRELINK_PATH</envar> и <envar>PRELINK_PATH_MASK</envar>. Для всех остальных переменных используется значение, определенное в последнем из файлов (по алфавиту в каталоге <filename>/etc/env.d</filename>). </para>
                    </warning>
                    <para>При запуске сценария <command>env-update</command> создаются все переменные среды, и помещаются в /etc/profile.env (используемый файлом <filename>/etc/profile</filename>). Кроме того, на основе значения <envar>LDPATH</envar> создается <filename>/etc/ld.so.conf</filename>. После этого запускается <command>ldconfig</command>, чтобы вновь создать файла <filename>/etc/ld.so.cache</filename>, используемый динамическим компоновщиком. </para>
                    <para>Если вы хотите, чтобы результаты работы <command>env-update</command> вступили в силу немедлено, для обновления среды выполните следующую команду. Пользователи, самостоятельно устанавливавшие Gentoo, возможно, помнят ее из указаний по установке: </para>
                    <example>
                        <title>Обновление среды</title>
                        <screen><prompt>#</prompt> <userinput>env-update &amp;&amp; source /etc/profile</userinput></screen>
                    </example>
                    <note>
                        <para>Эта команда обновляет переменные только в текущем терминале, в новых консолях и их потомках. То есть, если вы работаете в X11, потребуется или набирать <command>source /etc/profile</command> в каждом открываемом терминале, или перезапустить X, чтобы все новые терминалы обращались к новым переменным. Если вы используете диспетчер входа в систему, станьте пользователем с правами root и наберите <command>/etc/init.d/xdm restart</command>. Если нет, вам придется выйти и снова войти в систему, чтобы X порождала потомков, использующих новые значения переменных. </para>
                    </note>
                </section>
            </section>
            <section>
                <title>Локальное определение переменных</title>
                <section>
                    <title>Пользовательские переменные</title>
                    <para>Далеко не всегда нужно определять переменные глобально. Например, вам может понадобиться добавить <filename>/home/my_user/bin</filename> и текущий рабочий каталог (где вы находитесь) к переменной <envar>PATH</envar>, но при этом не нужно, чтобы это добавление появилось и в переменной <envar>PATH</envar> у всех остальных пользователей. Если вы хотите определить переменную среды локально, используйте <filename>~/.bashrc</filename> или <filename>~/.bash_profile</filename>: </para>
                    <example>
                        <title>Расширение <envar>PATH</envar> в <filename>~/.bashrc</filename> для локальных нужд</title>
                        <programlisting><lineannotation>(двоеточие без последующего указания каталога означает текущий рабочий каталог)</lineannotation>
PATH="${PATH}:/home/my_user/bin:"</programlisting>
                    </example>
                    <para>Обновление вашей переменной <envar>PATH</envar> произойдет, когда вы выйдете и снова войдете в систему. </para>
                </section>
                <section>
                    <title>Сеансовые переменные</title>
                    <para>Иногда нужны еще более жесткие ограничения. Вам может потребоваться возможность запуска исполняемых файлов из специально созданного временного каталога без указания полного пути к ним, и без изменения файла <filename>~/.bashrc</filename> ради нескольких минут. </para>
                    <para>В этом случае можно просто определить переменную <envar>PATH</envar> для текущего сеанса командой <envar>export</envar>. Переменной будет присвоено временное значение до тех пор, пока вы не завершите сеанс. </para>
                    <example>
                        <title>Определение сеансовой переменной среды</title>
                        <screen><prompt>#</prompt> <userinput>export PATH="${PATH}:/home/my_user/tmp/usr/bin"</userinput></screen>
                    </example>
                </section>
            </section>
        </section>
    </section>
    <section xml:id="gnt-hb.portage" xreflabel="Работа с Portage">
        <title>Работа с Portage</title>
        <section xreflabel="Файлы и каталоги">
            <title>Файлы и каталоги</title>
            <section>
                <title>Файлы Portage</title>
                <section>
                    <title>Директивы настройки</title>
                    <para>Настройки Portage по умолчанию хранятся в <filename>/etc/make.globals</filename>. Когда вы откроете этот файл, вы увидите, что все настройки представляют собой переменные. Что означает каждая из переменных, описано ниже. </para>
                    <para>Так как многие директивы отличаются в зависимости от используемой архитектуры, к Portage прилагаются настройки по умолчанию, которые входят в ваш профиль. На ваш профиль указывает символическая ссылка <filename>/etc/make.profile</filename>. Настройка Portage выполняется c помощью файлов <filename>make.defaults</filename> вашего профиля и всех родительских профилей. Более подробно о профилях и каталоге <filename>/etc/make.profile</filename> мы расскажем позже. </para>
                    <para>Если вы планируете вносить изменения в конфигурационные переменные, не изменяйте <filename>/etc/make.globals</filename> или <filename>make.defaults</filename>. Вместо этого пользуйтесь файлом <filename>/etc/make.conf</filename>, который имеет приоритет перед вышеуказанными файлами. Вы также обнаружите файл <filename>/etc/make.conf.example</filename>. Как понятно из его названия, это просто пример — Portage не использует этот файл. </para>
                    <para>Переменные Portage также можно устанавливать как переменные среды, но мы не рекомендуем этого делать. </para>
                </section>
                <section>
                    <title>Конфигурация, определяемая профилем</title>
                    <para>Мы уже встречались с каталогом <filename>/etc/make.profile</filename>. На самом деле это не каталог, а символическая ссылка на профиль, по умолчанию на тот, что содержится в <filename>/usr/portage/profiles</filename>, однако вы можете создавать свои собственные профили где угодно и ссылаться на них. Профиль, указанный ссылкой, является профилем, к которому принадлежит ваша система. </para>
                    <para>В профиле содержатся сведения для Portage, специфичные для архитектуры, такие как список пакетов, принадлежащих соответствующей системе, список неработоспособных (или замаскированных) пакетов, и т.д. </para>
                </section>
                <section>
                    <title>Конфигурация, задаваемая пользователем</title>
                    <para>Если вам необходимо изменить поведение Portage относительно установки программного обеспечения, вам потребуется отредактировать файлы, находящиеся в <filename>/etc/portage</filename>. Мы настоятельно рекомендуем вам пользоваться файлами из <filename>/etc/portage</filename>, всеми силами отговариваем от настройки поведения Portage через переменные среды! </para>
                    <para>Внутри <filename>/etc/portage</filename> вы можете создать следующие файлы: </para>
                    <orderedlist>
                        <listitem>
                            <para><filename>package.mask</filename>, в котором перечислены пакеты, которые Portage никогда не следует устанавливать; </para>
                        </listitem>
                        <listitem>
                            <para><filename>package.unmask</filename>, со списком пакетов, для которых вы хотите иметь возможность установки, даже если разработчики Gentoo отговаривают вас от этого; </para>
                        </listitem>
                        <listitem>
                            <para><filename>package.keywords</filename>, где перечислены пакеты, которые должны быть доступны для установки, несмотря на то, что они не подходят для вашей системы или архитектуры (пока); </para>
                        </listitem>
                        <listitem>
                            <para><filename>package.use</filename>, где перечислены значения USE-флагов, которые необходимо указывать для конкретных пакетов, а не для всей системы. </para>
                        </listitem>
                    </orderedlist>
                    <para>Дополнительные сведения о каталоге <filename>/etc/portage</filename>, а также список всех файлов, которые там можно создавать, находятся на справочной странице Portage: </para>
                    <example>
                        <title>Вызов справки по Portage</title>
                        <screen><prompt>$</prompt> <userinput>man portage</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Изменение файлов Portage и размещения каталогов</title>
                    <para>Ранее упомянутые конфигурационные файлы нельзя хранить где угодно — Portage всегда ищет свои настроечные файлы в строго определенных местах. Однако Portage также использует множество каталогов для других целей: каталог для сборки, место для хранения исходных кодов, место для дерева Portage, и т.д. </para>
                    <para>Для этих целей существуют хорошо известные каталоги по умолчанию, положение которых можно изменить на свой вкус, внеся изменения в <filename>/etc/make.conf</filename>. Оставшаяся часть этой главы посвящена описанию того, какие специальные места Portage использует для своих целей, и как изменить их расположение в файловой системе. </para>
                    <para>Этот документ не претендует на статус справочника. Если вам необходим полный объем информации, пожалуйста, обратитесь к страницам справки по Portage и make.conf: </para>
                    <example>
                        <title>Вызов справки по Portage и make.conf</title>
                        <screen><prompt>$</prompt> <userinput>man portage</userinput>
<prompt>$</prompt> <userinput>man make.conf</userinput></screen>
                    </example>
                </section>
            </section>
            <section>
                <title>Хранение файлов</title>
                <section>
                    <title>Дерево Portage</title>
                    <para>Дерево Portage размещается, по умолчанию, в <filename>/usr/portage</filename>. Это определяется значением переменной <envar>PORTDIR</envar>. Когда вы храните дерево Portage где-либо в другом месте (изменив эту переменную), не забывайте соответственно изменить символическую ссылку <filename>/etc/make.profile</filename>. </para>
                    <para>Если вы измените переменную <envar>PORTDIR</envar>, вам может потребоваться изменить и следующие переменные: <envar>PKGDIR</envar>, <envar>DISTDIR</envar>, <envar>RPMDIR</envar>, так как они не замечают изменений <envar>PORTDIR</envar>. Это связано с особенностями их обработки Portage. </para>
                </section>
                <section>
                    <title>Двоичные пакеты</title>
                    <para>Несмотря на то, что Portage по умолчанию не использует прекомпилированное программное обеспечение, для него предусмотрена очень мощная поддержка. Если вы укажете Portage работать с прекомпилированными пакетами, они будут разыскиваться в <filename>/usr/portage/packages</filename>. Это расположение определяется переменной <envar>PKGDIR</envar>. </para>
                </section>
                <section>
                    <title>Исходные коды</title>
                    <para>Исходные коды приложений хранятся в <filename>/usr/portage/distfiles</filename> по умолчанию. Это определяется переменной <envar>DISTDIR</envar>.</para>
                </section>
                <section>
                    <title>Файлы RPM</title>
                    <para>Несмотря на то, что Portage не может использовать RPM-файлы, есть возможность их создания командой ebuild (см. <link xlink:href="#">Приложение Ebuild</link>). По умолчанию Portage хранит RPM файлы в каталоге <filename>/usr/portage/rpm</filename>, как определяется переменной <envar>RPMDIR</envar>. </para>
                </section>
                <section>
                    <title>База данных Portage</title>
                    <para>Portage хранит состояние вашей системы (какие пакеты установлены, какие файлы относятся к определенным пакетам и т. п.) в <filename>/var/db/pkg</filename>. Не изменяйте эти файлы вручную! Это может разрушить знание вашей системы Portage. </para>
                </section>
                <section>
                    <title>Кэш Portage</title>
                    <para>Кэш Portage (включая сведения о времени изменения, виртуальные пакеты, информацию дерева зависимостей и т. д.) хранится в <filename>/var/cache/edb</filename>. Это место действительно является кэшем: вы можете его очистить в любой момент, когда не запущены приложения, связанные с Portage. </para>
                </section>
            </section>
            <section>
                <title>Сборка программного обеспечения</title>
                <section>
                    <title>Временные файлы Portage</title>
                    <para>По умолчанию Portage хранит временные файлы в <filename>/var/tmp</filename>. За это отвечает переменная <envar>PORTAGE_TMPDIR</envar>. </para>
                    <para>Если вы измените переменную <envar>PORTAGE_TMPDIR</envar>, вам может потребоваться изменить и переменную <envar>BUILD_PREFIX</envar>, так как она не замечает изменений <envar>PORTAGE_TMPDIR</envar>. Это связано с особенностями ее обработки Portage. </para>
                </section>
                <section>
                    <title>Каталог сборки</title>
                    <para>Portage создает специфичные каталоги сборки для каждого пакета внутри <filename>/var/tmp/portage</filename>. Это расположение задается переменной <envar>BUILD_PREFIX</envar>. </para>
                </section>
                <section>
                    <title>Размещение «живой файловой системы»</title>
                    <para>По умолчанию Portage устанавливает все файлы в текущую файловую систему (<filename>/</filename>), но это можно изменить, установив переменную окружения <envar>ROOT</envar>. Это может оказаться полезным при построении новых образов системы. </para>
                </section>
            </section>
            <section>
                <title>Ведение журнала</title>
                <section>
                    <title>Журнал Ebuild</title>
                    <para>Portage может создавать отдельные файлы журнала для каждого файла ebuild, но только тогда, когда переменная <envar>PORT_LOGDIR</envar> указывает на место, доступное для записи для Portage (пользователя portage). По умолчанию эта переменная не установлена. </para>
                </section>
            </section>
        </section>
        <section xreflabel="Настройка с помощью переменных">
            <title>Настройка с помощью переменных</title>
            <section>
                <title>Настройка Portage</title>
                <para>Как отмечалось ранее, Portage настраивается с помощью множества переменных, которые задаются в файле <filename>/etc/make.conf</filename>. За более полной и подробной информацией обращайтесь к странице справки по <filename>make.conf</filename>: </para>
                <example>
                    <title>Чтение страницы справки по make.conf</title>
                    <screen><prompt>$</prompt> <userinput>man make.conf</userinput></screen>
                </example>
            </section>
            <section>
                <title>Параметры сборки</title>
                <section>
                    <title>Параметры конфигурирования и компиляции</title>
                    <para>Когда Portage собирает приложения, компилятору и сценарию конфигурации передаются значения следующих переменных: </para>
                    <orderedlist>
                        <listitem>
                            <para><envar>CFLAGS</envar> и <envar>CXXFLAGS</envar> определяют желаемые флаги компилятора для C и C++; </para>
                        </listitem>
                        <listitem>
                            <para><envar>CHOST</envar> определяет информацию об используемой платформе для сценария конфигурации приложения; </para>
                        </listitem>
                        <listitem>
                            <para><envar>MAKEOPTS</envar> передается команде <command>make</command> и обычно применяется для установки степени распараллеливания компиляции. Более подробная информация о параметрах команды make находится на странице справки по <command>make</command>. </para>
                        </listitem>
                    </orderedlist>
                    <para>Переменная <envar>USE</envar> также используется при конфигурировании и компиляции, но о ней уже много и подробно говорилось в предыдущих главах. </para>
                </section>
                <section>
                    <title>Параметры установки</title>
                    <para>Когда Portage устанавливает (merge) новую версию программного продукта, файлы более старых версий удаляются из системы. Portage дает пользователю 5-ти секундную задержку перед стиранием старых версий. Эти 5 секунд задаются переменной <envar>CLEAN_DELAY</envar>. </para>
                </section>
            </section>
            <section>
                <title>Защита конфигурационных файлов</title>
                <section>
                    <title>Места, защищаемые Portage</title>
                    <para>Portage записывает файлы, предоставляемые новой версией программы, поверх старых, если только эти файлы не расположены в защищенном месте. Защищенные каталоги определяются переменной <envar>CONFIG_PROTECT</envar>. Обычно, это места расположения файлов конфигурации. Каталоги в списке разделяются пробелами. </para>
                    <para>Файл, который должен быть записан в такой защищенный каталог, переименовывается, а пользователь получает предупреждение о наличии новой версии (обычно) файла конфигурации. </para>
                    <para>Узнать текущее значение <envar>CONFIG_PROTECT</envar> можно из сообщений <command>emerge --info</command>:</para>
                    <example>
                        <title>Получение значения <envar>CONFIG_PROTECT</envar></title>
                        <screen><prompt>$</prompt> <userinput>emerge --info | grep 'CONFIG_PROTECT='</userinput></screen>
                    </example>
                    <para>Более подробная информация о защите конфигурационных файлов, осуществляемой системой Portage, доступна по команде <command>emerge</command>: </para>
                    <example>
                        <title>Подробная информация о защите конфигурационных файлов</title>
                        <screen><prompt>$</prompt> <userinput>emerge --help config</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Исключение каталогов</title>
                    <para>Чтобы снять защиту с определенных подкаталогов защищенного каталога, можно использовать переменную <envar>CONFIG_PROTECT_MASK</envar>. </para>
                </section>
            </section>
            <section>
                <title>Параметры скачивания</title>
                <section>
                    <title>Расположение сервера</title>
                    <para>Если запрошенная информация или данные отсутствуют в вашей системе, Portage обращается за ними в интернет. Расположение серверов для различных каналов получения информации задается следующими переменными: </para>
                    <itemizedlist>
                        <listitem>
                            <para><envar>GENTOO_MIRRORS</envar> определяет список адресов серверов, содержащих исходный код (distfiles); </para>
                        </listitem>
                        <listitem>
                            <para><envar>PORTAGE_BINHOST</envar> указывает расположение определенного сервера, содержащего двоичные пакеты (prebuilt packages) для вашей системы; </para>
                        </listitem>
                    </itemizedlist>
                    <para>Третья переменная содержит расположение сервера rsync, который используется при обновлении вашего дерева портежей: </para>
                    <itemizedlist>
                        <listitem>
                            <para><envar>SYNC</envar> указывает сервер, с которого Portage извлекает дерево портежей. </para>
                        </listitem>
                    </itemizedlist>
                    <para>Переменные <envar>GENTOO_MIRRORS</envar> и <envar>SYNC</envar> можно установить автоматически программой <command>mirrorselect</command>. Перед тем, как использовать, ее нужно установить, выполнив <command>emerge mirrorselect</command>. За дополнительной информацией обращайтесь к оперативной справке <command>mirrorselect</command>: </para>
                    <example>
                        <title>Дополнительные сведения о mirrorselect</title>
                        <screen><prompt>#</prompt> <userinput>mirrorselect --help</userinput></screen>
                    </example>
                    <para>Если вы вынуждены использовать прокси-сервер, для его указания можно использовать переменные <envar>HTTP_PROXY</envar>, <envar>FTP_PROXY</envar> и <envar>RSYNC_PROXY</envar>.</para>
                </section>
                <section>
                    <title>Команды для извлечения</title>
                    <para>Когда Portage требуется извлечь исходный код, по умолчанию используется <envar>wget</envar>. Вы можете это изменить с помощью переменной <envar>FETCHCOMMAND</envar>. </para>
                    <para>Portage может возобновлять скачивание частично загруженного исходного кода. По умолчанию используется <command>wget</command>, но это можно переопределить переменной <envar>RESUMECOMMAND</envar>. </para>
                    <para>Удостоверьтесь, что ваши команды <envar>FETCHCOMMAND</envar> и R<envar>ESUMECOMMAND</envar> сохраняют исходный код в нужном месте. Внутри этих переменных следует использовать <code>\${URI}</code> и <code>\${DISTDIR}</code>, для указания расположения исходных кодов и distfiles, соответственно. </para>
                    <para>Также существует возможность определить индивидуальные настройки для различных протоколов, используя <envar>FETCHCOMMAND_HTTP</envar>, <envar>FETCHCOMMAND_FTP</envar>, <envar>RESUMECOMMAND_HTTP</envar>, <envar>RESUMECOMMAND_FTP</envar>, и т.п. </para>
                </section>
                <section>
                    <title>Настройки rsync</title>
                    <para>Вы не можете заменить команду <command>rsync</command>, которую Portage использует для обновления дерева портежей, но можно установить несколько переменных, определяющих ее поведение: </para>
                    <orderedlist>
                        <listitem>
                            <para><envar>RSYNC_EXCLUDEFROM</envar> указывает на файл, где перечислены пакеты и/или категории, которые rsync должна игнорировать во время обновления. </para>
                        </listitem>
                        <listitem>
                            <para><envar>RSYNC_RETRIES</envar> определяет, сколько раз rsync должна пытаться соединиться с зеркалом, на которое указывает переменная <envar>SYNC</envar>. По умолчанию равна 3. </para>
                        </listitem>
                        <listitem>
                            <para><envar>RSYNC_TIMEOUT</envar> определяет количество секунд, в течение которого rsync соединение может бездействовать, перед тем как rsync сочтет его превысившим время ожидания. По умолчанию равна 180, но если вы используете соединение по модему или у вас медленный компьютер, возможно, следует установить значение этой переменной равным 300 или большим. </para>
                        </listitem>
                    </orderedlist>
                </section>
            </section>
            <section>
                <title>Настройка Gentoo</title>
                <section>
                    <title>Выбор ветви</title>
                    <para>Используемую ветвь можно изменить переменной <envar>ACCEPT_KEYWORDS</envar>. По умолчанию используется стабильная ветвь для вашей архитектуры. Дополнительная информация о ветвях Gento находится в следующей главе. </para>
                </section>
                <section>
                    <title>Возможности Portage</title>
                    <para>Вы можете включить отдельные функции Portage с помощью переменной <envar>FEATURES</envar>. Возможности Portage рассматривались в предыдущих главах. </para>
                </section>
            </section>
            <section>
                <title>Поведение Portage</title>
                <section>
                    <title>Распределение ресурсов</title>
                    <para>С помощью переменной <envar>PORTAGE_NICENESS</envar> можно увеличивать или уменьшать значение nice, с которым выполняется Portage. Значение <envar>PORTAGE_NICENESS</envar> прибавляется к текущему значению nice. </para>
                    <para>Более подробно о значениях nice написано в странице справки: </para>
                    <example>
                        <title>Дополнительные сведения о nice</title>
                        <screen><prompt>$</prompt> <userinput>man nice</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Настройки вывода</title>
                    <para>Переменная <envar>NOCOLOR</envar> (по умолчанию «false») определяет, следует ли Portage отключить цветовую раскраску своих сообщений. </para>
                </section>
            </section>
        </section>
        <section xreflabel="Смешение ветвей программного обеспечения">
            <title>Смешение ветвей программного обеспечения</title>
            <section>
                <title>Использование одной ветви</title>
                <section>
                    <title>Стабильная ветвь</title>
                    <para>Переменная <envar>ACCEPT_KEYWORDS</envar> определяет, какую из ветвей использовать в вашей системе. По умолчанию используется стабильная ветвь для вашей архитектуры, например x86 </para>
                    <para>Мы рекомендуем использовать только стабильную ветвь. Однако, если для вас стабильность не критична и вы хотите помочь Gentoo, отсылая отчеты об ошибках на http://bugs.gentoo.org, читайте дальше. </para>
                </section>
                <section>
                    <title>Тестовая ветвь</title>
                    <para>Если вы желаете использовать наиболее свежее ПО, подумайте над использованием тестовой ветви. Чтобы Portage начала использовать тестовую ветвь, добавьте «<code>~</code>» перед названием вашей архитектуры. </para>
                    <para>Тестовая ветвь полностью соответствует своему названию: для тестирования. Если пакет находится в стадии тестирования, это означает, что разработчики считают, что пакет работоспособен, но тщательно он не протестирован. Вы можете оказаться первым, кто столкнется с какой-либо ошибкой. В этом случае вы можете создать отчет об ошибке, чтобы разработчики узнали о ней. </para>
                    <para>Однако будьте готовы к тому, что могут возникнуть проблемы со стабильностью, неудовлетворительной поддержкой пакетов (например неправильные/отсутствующие зависимости), слишком частыми обновлениями (а в результате — частыми сборками) или невозможностью собрать пакет. Если вы не знаете, как работает Gentoo и как разрешать возникающие проблемы, мы рекомендуем не отходить от стабильной и оттестированной ветви. </para>
                    <para>К примеру, для выбора тестовой ветви на архитектуре x86, отредактируйте <filename>/etc/make.conf</filename> и укажите в нем: </para>
                    <example>
                        <title>Установка значения переменной <envar>ACCEPT_KEYWORDS</envar></title>
                        <programlisting>ACCEPT_KEYWORDS="~x86"</programlisting>
                    </example>
                    <para>Если вы запустите обновление системы, то увидите, что многие пакеты нуждаются в обновлении. Обратите внимание, что после перехода на тестовую ветвь и обновления системы, как правило, нет простого пути назад к стабильной официальной ветви (конечно, кроме использования резервной копии). </para>
                </section>
            </section>
            <section>
                <title>Одновременное использование стабильной и тестовой ветвей</title>
                <section>
                    <title>Местоположение <filename>package.keywords</filename></title>
                    <para>Вы можете указать, чтобы Portage использовала тестовую ветвь только для определенных пакетов, а для остальной системы — стабильную ветвь. Для этого добавьте категорию и имя пакета, для которого вы желаете использовать тестовую ветвь, в файл /etc/portage/package.keywords. Вместо этого можно создать каталог (с таким же именем) и указывать пакеты в файлах, находящихся внутри этого каталога. Например, для использования тестовой ветви для gnumeric: </para>
                    <example>
                        <title>Настройка /etc/portage/package.keywords для gnumeric, вся строка</title>
                        <programlisting>app-office/gnumeric ~x86</programlisting>
                    </example>
                </section>
                <section>
                    <title>Тестирование определенных версий</title>
                    <para>Если вы желаете использовать конкретную версию ПО из тестовой ветви, но не хотите, чтобы Portage использовала тестовую ветвь для последующих версий этого ПО, можно указать в местоположении package.keywords номер необходимой версии. В этом случае вы обязаны использовать оператор =. Также можно указать диапазон версий, используя операторы &lt;=, &lt;, &gt; или &gt;=. </para>
                    <para>В любом случае, добавляя информацию о версии, вы должны использовать один из этих операторов. Если вы не указываете версию, эти операторы использовать нельзя. </para>
                    <para>В следующем примере мы просим Portage разрешить установку gnumeric-1.2.13: </para>
                    <example>
                        <title>Использование конкретной тестовой версии gnumeric</title>
                        <programlisting>=app-office/gnumeric-1.2.13 ~x86</programlisting>
                    </example>
                </section>
            </section>
            <section>
                <title>Использование заблокированных пакетов</title>
                <section>
                    <title>Расположение <filename>package.unmask</filename></title>
                    <para>Разработчики Gentoo <emphasis role="bold">не</emphasis> поддерживают использование этого места расположения. Пожалуйста, используйте их на свой страх и риск. Просьбы о помощи, связанные с использованием <filename>package.unmask</filename> и/или <filename>package.mask</filename>, останутся без ответа. Вы предупреждены. </para>
                    <para>Если использование пакета было заблокировано разработчиками Gentoo, но вы желаете его использовать несмотря на причины блокировки, указанные в файле <filename>package.mask</filename> (по умолчанию он находится в <filename>/usr/portage/profiles</filename>), добавьте для него точно такую же строку в файл <filename>/etc/portage/package.unmask</filename> (или в файл в этом каталоге, если это каталог). </para>
                    <para>Например, если <code>=net-mail/hotwayd-0.8</code> заблокирован, то разблокировать его можно, прописав в <filename>package.unmask</filename> точно такую же строчку: </para>
                    <example>
                        <title><filename>/etc/portage/package.unmask</filename></title>
                        <programlisting>=net-mail/hotwayd-0.8</programlisting>
                    </example>
                </section>
                <section>
                    <title>Местоположение <filename>package.mask</filename></title>
                    <para>Если вы не хотите, чтобы Portage использовала какое-то конкретное ПО или конкретные версии ПО, вы можете его самостоятельно заблокировать, добавив соответствующую запись в <filename>/etc/portage/package.mask</filename> (в такой файл либо в файл внутри такого каталога). </para>
                    <para>Если, к примеру, вы не хотите, чтобы Portage устанавливала исходные коды ядра новее, чем gentoo-sources-2.6.8.1, добавьте такую строку в местоположение <filename>package.mask</filename>: </para>
                    <example>
                        <title>Пример использования файла <filename>/etc/portage/package.mask</filename></title>
                        <programlisting>&gt;sys-kernel/gentoo-sources-2.6.8.1</programlisting>
                    </example>
                </section>
            </section>
        </section>
        <section xreflabel="Дополнительные средства Portage">
            <title>Дополнительные средства Portage</title>
            <section>
                <title>etc-update</title>
                <para><command>etc-update</command> — это утилита, предназначенная для обновления в системе файлов <filename>._cfg0000_<replaceable>&lt;имя&gt;</replaceable></filename>. Она обеспечивает интерактивную настройку установки и может также автоматически устанавливать тривиальные изменения. Файлы создаются <filename>._cfg0000_<replaceable>&lt;имя&gt;</replaceable></filename> Portage, когда нужно заменить файл в каталоге, защищенном переменной <filename>CONFIG_PROTECT</filename>. </para>
                <para>Выполнить <command>etc-update</command> довольно просто: </para>
                <example>
                    <title>Запуск <command>etc-update</command></title>
                    <screen><prompt>#</prompt> <userinput>etc-update</userinput></screen>
                </example>
                <para>После выполнения тривиальных обновлений, вы увидите запрос со списком защищенных файлов, ожидающих обновления. Внизу вам предложат следующие варианты: </para>
                <example>
                    <title>Запрос <command>etc-update</command></title>
                    <screen>Please select a file to edit by entering the corresponding number.
              (-1 to exit) (-3 to auto merge all remaining files)
                           (-5 to auto-merge AND not use 'mv -i'):

<lineannotation>(Пожалуйста, выберите файл для правки, введя соответствующее число.
         (-1 - выход) (-3 - автоустановка всех оставшихся файлов)
                 (-5 для автоустановки БЕЗ использования 'mv -i'): )</lineannotation></screen>
                </example>
                <para>При вводе <userinput>-1</userinput>, <command>etc-update</command> выходит, прекращая последующие изменения. Если вы введете <userinput>-3</userinput> или <userinput>-5</userinput>, все перечисленные файлы конфигурации заменяются более новыми версиями. Следовательно, очень важно сначало отобрать файлы, которые не следует автоматически обновлять. Для этого надо только вводить номер, указанный слева от файлов. </para>
                <para>Например, выбираем файл конфигурации <filename>/etc/pear.conf</filename>: </para>
                <example>
                    <title>Обновление конкретного конфигурационного файла</title>
                    <screen>Beginning of differences between /etc/pear.conf and /etc/._cfg0000_pear.conf
<lineannotation>[...]</lineannotation>
End of differences between /etc/pear.conf and /etc/._cfg0000_pear.conf
1) Replace original with update 
2) Delete update, keeping original as is 
3) Interactively merge original with update 
4) Show differences again</screen>
                </example>
                <para>Теперь можно увидеть различия между двумя файлами. Если вы считаете, что обновленный файл конфигурации можно использовать без проблем, введите <userinput>1</userinput>. Если вы считаете, что обновленный файл конфигурации не нужен, или не содержит новую или полезную информацию, введите <userinput>2</userinput>. Если вы хотите обновить текущий файл в интерактивном режиме, введите <userinput>3</userinput>. </para>
                <para>Нет никакого смысла в подробном описании интерактивного обновления. Для полноты изложения, мы перечислим возможные команды, которые можно использовать при интерактивном слиянии двух файлов. Вас встречают две строки (одна исходная, вторая измененная) и запрос, в ответ на который можно ввести одну из следующих команд: </para>
                <example>
                    <title>Команды, доступные при интерактивном слиянии</title>
                    <screen>ed:     редактировать и использовать оба варианта, каждый пометить заголовком
eb:     редактировать и использовать оба варианта
el:     редактировать и использовать левый вариант
er:     редактировать и использовать правый вариант
e:      редактировать новую версию
l:      использовать левую версию
r:      использовать правую версию
s:      молча включить общие строки
v:      включить общие строки, сообщив подробности
q:      выход</screen>
                </example>
                <para>Завершив обновление важных файлов конфигурации, вы можете автоматически обновить оставшиеся файлы конфигурации. <command>etc-update</command> выйдет, если не найдет других файлов, подлежащих обновлению. </para>
            </section>
            <section>
                <title>dispatch-conf</title>
                <para>С помощью <command>dispatch-conf</command> можно обновлять файлы конфигурации, сохраняя при этом историю изменений. <command>dispatch-conf</command> хранит различия между файлами конфигурации в виде заплаток или в системе управления версиями RCS. </para>
                <para>Как и с <command>etc-update</command>, вы можете попросить сохранить файл конфигурации как есть, использовать новый файл конфигурации, редактировать текущий или объединить изменения интерактивно. Однако, у <command>dispatch-conf</command> также есть приятные дополнительные возможности: </para>
                <orderedlist>
                    <listitem>
                        <para>автоматическое обновление файлов, в которых обновились только комментарии; </para>
                    </listitem>
                    <listitem>
                        <para>автоматическое обновление файлов, которые отличаются только количеством пробелов. </para>
                    </listitem>
                </orderedlist>
                <para>Убедитесь, что вы сначала отредактировали <filename>/etc/dispatch-conf.conf</filename> и создали каталог, прописанный в archive-dir. </para>
                <para>За дополнительными сведениями обращайтесь к странице справки <command>dispatch-conf</command>: </para>
                <example>
                    <title>Чтение справки по <command>dispatch-conf</command></title>
                    <screen><prompt>$</prompt> <userinput>man dispatch-conf</userinput></screen>
                </example>
            </section>
            <section>
                <title>quickpkg</title>
                <para>С <command>quickpkg</command> вы можете создавать архивы пакетов, уже установленных в системе. Эти архивы можно использовать в качестве двоичных пакетов. Запуск <command>quickpkg</command> прост: только укажите имена пакетов, которые нужно заархивировать. </para>
                <para>Например, чтобы поместить в архив curl, arts и procps: </para>
                <example>
                    <title>Пример использования quickpkg</title>
                    <screen><prompt>#</prompt> <userinput>quickpkg curl arts procps</userinput></screen>
                </example>
                <para>Двоичные пакеты будут храниться в <filename>$PKGDIR/All</filename> (по умолчанию — <filename>/usr/portage/packages/All</filename>). Символьные ссылки, указывающие на эти пакеты, помещаются в <filename>$PKGDIR/<replaceable>&lt;категория&gt;</replaceable></filename>. </para>
            </section>
        </section>
        <section xreflabel="Отступление от официального дерева">
            <title>Отступление от официального дерева</title>
            <section>
                <title>Использование собственного дерева Portage</title>
                <section>
                    <title>Исключение пакета/категории</title>
                    <para>Вы можете выборочно обновлять определенные категории/пакеты, игнорируя обновление других категорий/пакетов. Это достигается путем исключения таких категорий/пакетов программой rsync на этапе выполнения <command>emerge --sync</command>. </para>
                    <para>Вам потребуется определить имя файла, содержащего шаблоны исключаемых пакетов, в переменной <envar>RSYNC_EXCLUDEFROM</envar> в своем файле <filename>/etc/make.conf</filename>. </para>
                    <para>
                        <example>
                            <title>Указание файла исключаемых пакетов в <filename>/etc/make.conf</filename></title>
                            <programlisting>RSYNC_EXCLUDEFROM=/etc/portage/rsync_excludes</programlisting>
                        </example>
                    </para>
                    <example>
                        <title>Исключение всех игр в файле <filename>/etc/portage/rsync_excludes</filename></title>
                        <programlisting>games-*/*</programlisting>
                    </example>
                    <para>Заметьте, однако, что это может привести к проблемам с зависимостями, так как новые разрешенные пакеты могут зависеть от других новых, но исключенных из обновления пакетов. </para>
                </section>
            </section>
            <section>
                <title>Добавление неофициального сборочного файла ebuild</title>
                <section>
                    <title>Определение оверлейного каталога портежей</title>
                    <para>Вы можете указать Portage использовать сборочные файлы, не входящие в официальное дерево Portage. Создайте новый каталог (к примеру, <filename>/usr/local/portage</filename>), в котором будут находиться файлы ebuild сторонних разработчиков. Используйте в точности такую же структуру каталогов, как и в официальном дереве портежей! </para>
                    <para>Затем определите переменную <envar>PORTDIR_OVERLAY</envar> в <filename>/etc/make.conf</filename>, чтобы она указывала на ранее созданный каталог. Теперь при использовании Portage, эти сборочные файлы будут рассматриваться как часть системы, и не будут удаляться/перезаписываться при последующих запусках <command>emerge --sync</command>. </para>
                </section>
                <section>
                    <title>Работа с несколькими оверлейными каталогами</title>
                    <para>Для продвинутых пользователей, ведущих разработку в нескольких оверлейных каталогах, тестирующих пакеты перед включением в основное дерево портежей или просто желающих использовать неофициальные сборочные файлы ebuild из разных источников, в пакете app-portage/gentoolkit-dev есть утилита <command>gensync</command>, которая поможет поддерживать ваши оверлейные репозитории в актуальном состоянии. </para>
                    <para>Используя gensync, вы можете обновить сразу все репозитории или выбрать для обновления только некоторые из них. В каждом репозитории в каталоге <filename>/etc/gensync/</filename> должен находиться файл .syncsource, в котором содержится информация о местоположении репозитория, его имени, идентификаторе и т.д. </para>
                    <para>Предположим, что у вас есть два дополнительных репозитория с названиями java (для сборочных файлов разработок, ведущихся на java) и entapps (для внутренних приложений, разработанных на вашем предприятии). Вы можете обновить эти репозитории следующей командой: </para>
                    <example>
                        <title>Запуск <command>gensync</command> для обновления нескольких репозиториев</title>
                        <screen><prompt>#</prompt> <userinput>gensync java entapps</userinput></screen>
                    </example>
                </section>
            </section>
            <section>
                <title>Программы, поддерживаемые не Portage</title>
                <section>
                    <title>Использование Portage с пакетами самостоятельной сборки</title>
                    <para>Иногда вам может потребоваться сконфигурировать, установить и поддерживать программное обеспечение самостоятельно, без автоматизации со стороны Portage, не смотря на то, что оно поддерживается Portage. Наиболее известные случаи — это исходные коды ядра и драйверы от nVidia. Вы можете настроить Portage так, чтобы системе стало известно, что определенные пакеты установлены вручную. Этот процесс называется внедрение, и поддерживается Portage посредством файла <filename>/etc/portage/profile/package.provided</filename>. </para>
                    <para>Например, если вы захотите сообщить Portage, что пакет vanilla-sources-2.6.11.6 установлен вручную, нужно добавить следующую строку в <filename>/etc/portage/profile/package.provided</filename>: </para>
                    <example>
                        <title>Пример строки из файла <filename>package.provided</filename></title>
                        <programlisting>sys-kernel/vanilla-sources-2.6.11.6</programlisting>
                    </example>
                </section>
            </section>
        </section>
        <section xreflabel="Использование ebuild">
            <title>Использование ebuild</title>
            <section>
                <title>Emerge и Ebuild</title>
                <para>Программа <command>ebuild</command> — это низкоуровневый интерфейс системы Portage. С ее помощью можно выполнять определенные действия над заданными сборками ebuild. Например, вы можете самостоятельно выполнить отдельные этапы установки. </para>
                <para>Программа <command>ebuild</command> предназначена в основном для разработчиков, поэтому более подробная информация находится в <link xlink:href="http://www.gentoo.org/proj/en/devrel/handbook/handbook.xml">настольной книге разработчика (англ.)</link>. Однако, мы расскажем, какие экземпляры ebuild вызываются системой Portage на разных этапах установки, и как выполнить пост-конфигурационные шаги, которые допускаются некоторыми пакетами. </para>
            </section>
            <section>
                <title>Ручная установка программ</title>
                <section>
                    <title>Извлечение исходных кодов и проверка контрольных сумм</title>
                    <para>Каждый раз, когда вы вызываете <command>ebuild</command> для какого-то ebuild-файла, проверяется совпадение контрольной суммы всех задействованных файлов с указанной в файлах Manifest или <filename>files/digest-<replaceable>&lt;имя&gt;</replaceable>-<replaceable>&lt;версия&gt;</replaceable></filename>. Проверка выполняется после загрузки исходных кодов. </para>
                    <para>Чтобы загрузить исходные коды с помощью <command>ebuild</command>, запустите: </para>
                    <example>
                        <title>Загрузка исходных кодов</title>
                        <screen><prompt>#</prompt> <userinput>ebuild <replaceable>путь/к/файлу-ebuild</replaceable> fetch</userinput></screen>
                    </example>
                    <para>Если контрольная сумма md5 сборочного файла не совпадает с той, что указана в файле <filename>Manifest</filename>, или же один из загруженных файлов не совпадает с описанием в файле <filename>files/digest<replaceable>&lt;пакет&gt;</replaceable></filename>, вы получите сообщение об ошибке, похожее на такое: </para>
                    <para>
                        <example>
                            <title>Ошибка контрольной суммы ebuild</title>
                            <screen>!!! File is corrupt or incomplete. (Digests do not match)
>>> our recorded digest: db20421ce35e8e54346e3ef19e60e4ee
>>>  your file's digest: f10392b7c0b2bbc463ad09642606a7d6

<lineannotation>(!!! Файл поврежден или усечен. (Контрольные суммы не совпадают) )</lineannotation></screen>
                        </example>
                    </para>
                    <para>На следующей строке указывается проблемный файл. </para>
                    <para>Если вы абсолютно уверены, что загруженные исходные коды и сам сборочный файл ebuild именно те, что вам нужны, можете пересоздать файлы <filename>Manifest</filename> и <filename>digest-<replaceable>&lt;пакетe&gt;</replaceable></filename>, используя фукцию <parameter>digest</parameter> программы <command>ebuild</command>: </para>
                    <example>
                        <title>Создание новых файлов <filename>Manifest</filename> и <filename>digest</filename></title>
                        <screen><prompt>#</prompt> <userinput>ebuild путь/к/файлу-ebuild digest</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Распаковка исходных кодов</title>
                    <para>Чтобы рапаковать исходные коды в <filename>/var/tmp/portage</filename> (или любой другой каталог, указанный в <filename>/etc/make.conf</filename>), запустите функцию <parameter>unpack</parameter> программы <command>ebuild</command>:</para>
                    <para>
                        <example>
                            <title>Распаковка исходных кодов</title>
                            <screen><prompt>#</prompt> <userinput>ebuild <replaceable>путь/к/файлу-ebuild</replaceable> unpack</userinput></screen>
                        </example>
                    </para>
                    <para>Эта команда выполнит функцию <function>src_unpack()</function> программы <command>ebuild</command> (которая по умолчанию просто выполняет распаковку, если функция <function>src_unpack()</function> не определена). Все необходимые заплатки накладываются также на этом этапе. </para>
                </section>
                <section>
                    <title>Компиляция исходных кодов</title>
                    <para>Следующий шаг в процессе установки — компиляция исходных кодов. Для этого выполняется функция src_compile() вашего сборочного файла. Если нужно, заодно выполняется конфигурация. </para>
                    <para>
                        <example>
                            <title>Компиляция исходных кодов</title>
                            <screen><prompt>#</prompt> <userinput>ebuild <replaceable>путь/к/файлу-ebuild</replaceable> compile</userinput></screen>
                        </example>
                    </para>
                    <para>Если вы хотите изменить инструкции компиляции, советуем отредактировать функцию <function>src_compile()</function>. Однако, вы можете также обмануть Portage, заставив ее поверить, что программа ebuild уже завершила компиляцию. Запустите нужные команды самостоятельно и создайте пустой файл <filename>.compile</filename> в рабочем каталоге. </para>
                    <example>
                        <title>Сообщение Portage о завершении задания компиляции</title>
                        <screen><prompt>#</prompt> <userinput>touch .compiled</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Установка файлов во временное место</title>
                    <para>Следующий шаг — установка всех необходимых файлов во временный каталог. В него помещаются все файлы, подлежащие включению в рабочую файловую систему. Вы можете выполнить этот этап, запустив функцию установки программы <command>ebuild</command>, которая исполняет функцию <function>src_install()</function> сборочного файла. </para>
                    <example>
                        <title>Установка файлов</title>
                        <screen><prompt>#</prompt> <userinput>ebuild <replaceable>путь/к/файлу-ebuild</replaceable> install</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Помещение файлов в рабочую файловую систему</title>
                    <para>Последний этап — перенос всех файлов в рабочую файловую систему и их регистрация в системе Portage. В ebuild этот этап называется «qmerge», и включает следующие действия: </para>
                    <orderedlist>
                        <listitem>
                            <para>выполняется функция <function>pkg_preinst()</function>, если она определена;</para>
                        </listitem>
                        <listitem>
                            <para>все файлы копируются в рабочую файловую систему;</para>
                        </listitem>
                        <listitem>
                            <para>файлы регистрируются в системе Portage;</para>
                        </listitem>
                        <listitem>
                            <para>выполняется функция <function>pkg_postinst()</function>, если она определена;</para>
                        </listitem>
                    </orderedlist>
                    <para>Запустите функцию <parameter>qmerge</parameter> программы <command>ebuild</command>, чтобы выполнить этот этап: </para>
                    <example>
                        <title>Помещение файлов в рабочую файловую систему</title>
                        <screen><prompt>#</prompt> <userinput>ebuild <replaceable>путь/к/файлу-ebuild</replaceable> qmerge</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Очистка временного каталога</title>
                    <para>Наконец, можно очистить временный каталог, используя команду <parameter>clean</parameter> программы <command>ebuild</command>: </para>
                    <para>
                        <example>
                            <title>Очистка временного каталога</title>
                            <screen><prompt>#</prompt> <userinput>ebuild путь/к/файлу-ebuild clean</userinput></screen>
                        </example>
                    </para>
                </section>
            </section>
            <section>
                <title>Дополнительные возможности Ebuild</title>
                <section>
                    <title>Запуск всех команд установки</title>
                    <para>С помощью функции <parameter>merge</parameter> программы <command>ebuild</command>, можно запустить команды извлечения, распаковки, компиляции, установки и помещения за один раз: </para>
                    <example>
                        <title>Установка программы</title>
                        <screen><prompt>#</prompt> <userinput>ebuild <replaceable>путь/к/файлу-ebuild</replaceable> merge</userinput></screen>
                    </example>
                </section>
                <section>
                    <title>Выполнение действий по настройке</title>
                    <para>В некоторых приложениях содержатся инструкции по дальнейшей настройке установленного пакета. Эти инструкции могут потребовать участия пользователя, и, следовательно, не выполняться автоматически. Для запуска шагов настройки, указанных в необязательной функции <function>config()</function> сборочного файла, используйте команду config программы <command>ebuild</command>:</para>
                    <para>
                        <example>
                            <title>Настройка пакета</title>
                            <screen><prompt>#</prompt> <userinput>ebuild <replaceable>путь/к/файлу-ebuild</replaceable> config</userinput></screen>
                        </example>
                    </para>
                </section>
                <section>
                    <title>Сборка пакета (RPM)</title>
                    <para>Вы можете попросить Portage создать двоичный пакет или даже RPM из вашего сборочного файла, воспользовавшись командами <command>package</command> и <command>rpm</command>, соответственно. Эти команды несколько различаются: </para>
                    <orderedlist>
                        <listitem>
                            <para>команда <command>package</command> во многом похожа на merge, выполняя все необходимые шаги (извлечение, распаковку, компиляцию, установку) перед созданием пакета; </para>
                        </listitem>
                        <listitem>
                            <para>команда <command>rpm</command> собирает пакет RPM из файлов созданных после запуска окончания функции <parameter>install</parameter> программы <command>ebuild</command>. </para>
                        </listitem>
                    </orderedlist>
                    <example>
                        <title>Создание пакетов</title>
                        <screen><lineannotation>(cоздание двоичного пакета, совместимого с Portage)</lineannotation>
<prompt>#</prompt> <userinput>ebuild <replaceable>путь/к/файлу-ebuild</replaceable> package</userinput>

<lineannotation>(создание пакета RPM)</lineannotation>
<prompt>#</prompt> <userinput>ebuild <replaceable>путь/к/файлу-ebuild</replaceable> rpm</userinput></screen>
                    </example>
                    <para>Созданный RPM, однако, не будет содержать информацию о зависимостях из сборочного файла ebuild. </para>
                </section>
            </section>
            <section>
                <title>Дополнительная информация</title>
                <para>За дополнительными сведениями о системе Portage, программе ebuild и сценариях ebuild обращайтесь к следующим страницам справки man: </para>
                <example>
                    <title>Страницы справки</title>
                    <screen><prompt>$</prompt> <userinput>man portage</userinput>    <lineannotation>(сама система Portage)</lineannotation>
<prompt>$</prompt> <userinput>man emerge</userinput>     <lineannotation>(команда emerge)</lineannotation>
<prompt>$</prompt> <userinput>man ebuild</userinput>     <lineannotation>(команда ebuild)</lineannotation>
<prompt>$</prompt> <userinput>man 5 ebuild</userinput>   <lineannotation>(синтаксис файлов ebuild)</lineannotation>
</screen>
                </example>
                <para>Кроме того, дополнительные сведения, относящиеся к разработке, находятся в <link xlink:href="http://www.gentoo.org/proj/en/devrel/handbook/handbook.xml">настольной книге разработчика (англ.)</link>.</para>
            </section>
        </section>
    </section>
    <section xml:id="gnt-hb.network" xreflabel="Настройка сети в Gentoo">
        <title>Настройка сети в Gentoo</title>
        <section xreflabel="Начальная настройка">
            <title>Начальная настройка</title>
            <section>
                <title>Приступаем к настройке</title>
                <note>
                    <para>В документе предполагается, что вы правильно сконфигурировали свое ядро и модули для оборудования, и вам известно интерфейсное имя устройств. Мы также предполагаем, что вы настраиваете <code>eth0</code>, хотя на самом деле это может оказаться <code>eth1</code>, <code>wlan0</code> и т.д. </para>
                </note>
                <note>
                    <para>Требуется, чтобы у вас использовался baselayout-1.11.11 или более свежий. </para>
                </note>
                <para>Для начала настройки своей сетевой платы, нужно рассказать о ней системе Gentoo RC. Это делается созданием символической ссылки с <filename>net.lo</filename> на <filename>net.eth0</filename> в <filename>/etc/init.d</filename>.</para>
                <para>
                    <example>
                        <title>Создание символической ссылки с <filename>net.lo</filename> на <filename>net.eth0</filename></title>
                        <screen><prompt>#</prompt> <userinput>cd /etc/init.d</userinput>
<prompt>#</prompt> <userinput>ln -s net.lo net.eth0</userinput></screen>
                    </example>
                </para>
                <para>Теперь система Gentoo RC знает об этом интерфейсе. Ей также нужно знать, как настраивать новый интерфейс. Конфигурация всех сетевых интерфейсов находится в <filename>/etc/conf.d/net</filename>. Вот простая настройка для использования DHCP или статического адреса. </para>
                <para>
                    <example>
                        <title>Примеры для <filename>/etc/conf.d/net</filename></title>
                        <programlisting># использование DHCP
config_eth0=( "dhcp" )

# статический IP-адрес, используется запись CIDR
config_eth0=( "192.168.0.7/24" )
routes_eth0=( "default via 192.168.0.1" )

# статический IP-адрес, запись с маской подсети
config_eth0=( "192.168.0.7 netmask 255.255.255.0" )
routes_eth0=( "default gw 192.168.0.1" )</programlisting>
                    </example>
                </para>
                <note>
                    <para>Если конфигурация для интерфейса не указывается, предполагается использование DHCP. </para>
                </note>
                <note>
                    <para>CIDR расшифровывается как Classless InterDomain Routing (бесклассовая междоменная маршрутизация). Первоначально, адреса IPv4 были разделены на классы A, B и C. Ранняя система классификации не была рассчитана на массовую популярность интернета, и попала под угрозу исчерпания новых уникальных адресов. CIDR — это схема адресации, позволяющая одному IP-адресу обозначать множество IP-адресов. IP-адрес CIDR выглядит как обычный IP-адрес с добавлением косой черты и числа; например, 192.168.0.0/16. CIDR описывается в RFC 1519. </para>
                </note>
                <para>Теперь, настроив интерфейс, мы можем запускать и останавливать его следующими командами: </para>
                <para>
                    <example>
                        <title>Сценарии запуска и остановки сети</title>
                        <screen><prompt>#</prompt> <userinput>/etc/init.d/net.eth0 start</userinput>
<prompt>#</prompt> <userinput>/etc/init.d/net.eth0 stop</userinput></screen>
                    </example>
                </para>
                <important>
                    <para>При поиске неисправностей сети рекомендуется установить <code>RC_VERBOSE="yes"</code> в <filename>/etc/conf.d/rc</filename> для получения более подробной информации о происходящем. </para>
                </important>
                <para>Теперь, успешно запустив и остановив сетевой интерфейс, вы можете захотеть, чтобы он запускался при каждой загрузке Gentoo. Вот как это сделать. Последняя команда «rc» указывает Gentoo, что нужно запускать в текущем уровне запуска любые еще не запущенные сценарии. </para>
                <example>
                    <title>Настройка запуска сетевого интерфейса при загрузке</title>
                    <screen><prompt>#</prompt> <userinput>rc-update add net.eth0 default</userinput>
<prompt>#</prompt> <userinput>rc</userinput></screen>
                </example>
            </section>
        </section>
        <section xreflabel="Расширенная настройка">
            <title>Расширенная настройка</title>
            <section>
                <title>Расширенная настройка</title>
                <para>Переменная <varname>config_eth0</varname> служит основой конфигурации интерфейса. Она содержит список высокоуровневых инструкций по настройке интерфейса (в данном случае, eth0). Все команды списка выполняются последовательно. Интерфейс считается работоспособным, если хотя бы одна команда выполнена успешно. </para>
                <para>Вот список встроенных инструкций: </para>
                <informaltable frame="all">
                    <tgroup cols="2">
                        <thead>
                            <row>
                                <entry>
                                    <para>Команда</para>
                                </entry>
                                <entry>
                                    <para>Описание</para>
                                </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>
                                    <para>null</para>
                                </entry>
                                <entry>
                                    <para>Не выполнять никаких действий</para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <para>noop</para>
                                </entry>
                                <entry>
                                    <para>Если интерфейс включен и существует адрес, успешно завершить настройку. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <para>an IPv4 or IPv6 address</para>
                                </entry>
                                <entry>
                                    <para>Добавить адрес к интерфейсу</para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <para>dhcp, adsl or apipa(или команда запуска модуля стороннего изготовителя)</para>
                                </entry>
                                <entry>
                                    <para>Запустить модуль, реализующий команду. Например, dhcp запускает модуль, реализующий команду. Например, dhcp запускает модуль, реализующий DHCP, которым может быть dhcpcd, udhcpc, dhclient или pump. </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para>На случай неудачного выполнения команды можно указать запасную команду. Запасной вариант должен строго соответствовать структуре конфигурации. </para>
                <para>Команды можно сцеплять. Вот несколько практических примеров. </para>
                <para>
                    <example>
                        <title>Примеры настройки</title>
                        <programlisting># Задание трех адресов IPv4
config_eth0=(
  "192.168.0.2/24"
  "192.168.0.3/24"
  "192.168.0.4/24"
)

# Задание одного адреса IPv4 и двух адресов IPv6
config_eth0=(
  "192.168.0.2/24"
  "4321:0:1:2:3:4:567:89ab"
  "4321:0:1:2:3:4:567:89ac"
)

# Сохранять адрес, присвоенный ядром, до отключения интерфейса.
# При этом назначить другой через DHCP. Если DHCP не работает, 
# задать статический адрес, определяемый APIPA
config_eth0=(
  "noop"
  "dhcp"
)
fallback_eth0=(
  "null"
  "apipa"
)</programlisting>
                    </example>
                </para>
                <note>
                    <para>При использовании модуля ifconfig для назначения нескольких адресов, для каждого дополнительного адреса создаются псевдонимы интерфейса. Так, в двух примерах, приведенных выше, создаются интерфейсы eth0, eth0:1 и eth0:2. С этими интерфейсами нельзя сделать ничего особенного, так как и ядро, и другие программы обрабатывают eth0:1 и eth0:2 просто как eth0. </para>
                </note>
                <important>
                    <para>Порядок настройки запасного режима имеет значение! Если бы мы не указали инструкцию null, то команда apipa запускалась бы только при неудачном выполнении команды noop. </para>
                </important>
                <note>
                    <para>APIPA и DHCP обсуждаются позже. </para>
                </note>
            </section>
            <section>
                <title>Сетевые зависимости</title>
                <para>Сценарии инициализации в <filename>/etc/init.d</filename> могут находиться в зависимости от определенного сетевого интерфейса или просто от службы сети (net). Определив переменную <envar>RC_NET_STRICT_CHECKING</envar> в <filename>/etc/conf.d/rc</filename>, службе net можно придать различный смысл. </para>
                <informaltable frame="all">
                    <tgroup cols="2">
                        <thead>
                            <row>
                                <entry>
                                    <para>Значение</para>
                                </entry>
                                <entry>
                                    <para>Описание</para>
                                </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>
                                    <para>none</para>
                                </entry>
                                <entry>
                                    <para>Служба net считается всегда работающей</para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <para>no</para>
                                </entry>
                                <entry>
                                    <para>В основном это означает, что по крайней мере одна служба net.*, кроме net.lo, должна работать. Это может пригодиться пользователям ноутбуков, у которых есть WIFI и статическое проводное подключение, когда нужно, чтобы при включении хотя бы одного интерфейса служба сети выглядела включенной. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <para>lo</para>
                                </entry>
                                <entry>
                                    <para>То же, что и no, но с учетом net.lo. Может быть полезно для тех, кого не волнует, чтобы определенный интерфейс включался при загрузке.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <para>yes</para>
                                </entry>
                                <entry>
                                    <para>В этом случае ВСЕ сетевые интерфейсы ДОЛЖНЫ работать, чтобы служба net считалась работающей. </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para>Но как насчет net.br0, зависимого от net.eth0 и net.eth1? net.eth1 может быть беспроводным или РРР-устройством, требующим предварительной настройки для возможности включения в мост. Это невозможно сделать в <filename>/etc/init.d/net.br0</filename>, так как он является символьной ссылкой на net.lo. </para>
                <para>Ответом является создание своей собственной функции <function>depend()</function> в <filename>/etc/conf.d/net</filename>.</para>
                <para>
                    <example>
                        <title>Зависимость net.br0 в <filename>/etc/conf.d/net</filename></title>
                        <programlisting># Можно использовать любую зависимость (use, after, before),
# как видно в текущих сценариях
depend_br0() {
  need net.eth0 net.eth1
}</programlisting>
                    </example>
                </para>
                <para>Более подробно зависимости обсуждаются в разделе <link xlink:href="#">Написание сценариев инициализации</link> Настольной книги Gentoo. </para>
            </section>
            <section>
                <title>Имена и значения переменных</title>
                <para>Имена переменных являются динамическими. Обычно они следуют структуре <varname>variable_${interface|mac|essid|apmac}</varname>. Например, значение переменной <varname>dhcpcd_eth0</varname> хранит параметры dhcpcd для eth0, а переменной <varname>dhcpcd_essid</varname> — параметры dhcpcd, используемые при подключении любого интерфейса к ESSID «essid». </para>
                <para>Однако, не существует твердого простого правила, устанавливающего, что интерфейсы должны называться ethx. На деле, имена многих беспроводных выглядят как wlanx, rax и ethx. Кроме того, некоторые пользовательские интерфейсы, например, мосты, можно называть как угодно, например, foo. Для пущего разнообразия, в именах беспроводных точек доступа также допускаются знаки, не входящие в алфавитно-цифровые; это имеет значение, потому что есть возможность настройки сетевых параметров для отдельных ESSID. </para>
                <para>Оборотная сторона всего этого в том, что для настройки сети в Gentoo используются переменные bash, а bash не в состоянии использовать что-либо кроме знаков английского алфавита и цифр. Чтобы обойти такое ограничение, мы заменяем каждый символ, не являющийся английским буквенно-цифровым, на знак подчеркивания: _. </para>
                <para>Другая особенность bash — это значения переменных: некоторые символы требуют специальной записи, перед ними помещается знак \. Им необходимо предварять следующие символы: ", ' и \. </para>
                <para>В следующем примере мы используем беспроводные ESSID, так как в них может содержаться самое широкое множество символов. Мы воспользуемся ESSID My "\ NET: </para>
                <para>
                    <example>
                        <title>Пример имени переменной</title>
                        <programlisting>  # Этот пример работает, но домен не существует
dns_domain_My____NET="My \"\\ NET"

# Предыдущая строка устанавливает домен dns в My "\ NET при 
# подключении беспроводной платы к точке доступа с ESSID My "\ NET.</programlisting>
                    </example>
                </para>
            </section>
        </section>
        <section xreflabel="Модульное построение сети">
            <title>Модульное построение сети</title>
            <section>
                <title>Сетевые модули</title>
                <para>Сейчас мы поддерживаем модульные сетевые сценарии. Это значит, что мы можем легко добавлять поддержку для новых типов интерфейсов и конфигурационных модулей, сохраняя совместимость с существующими. </para>
                <para>По умолчанию, модули загружаются только если пакет, нужный им, установлен. Если отметить модуль, для которого не установлен пакет, будет выдана ошибка с указанием, какой пакет нужно установить. В идеале, настройка модулей требуется только тогда, когда установленно несколько пакетов, представляющих одну и ту же службу, а вам установить приоритет одного из них. </para>
                <note>
                    <para>Все обсуждаемые значения хранятся в <filename>/etc/conf.d/net</filename>, если явно не указано иное. </para>
                </note>
                <para>
                    <example>
                        <title>Предпочтение модуля</title>
                        <programlisting>  # выбор iproute2, а не ifconfig
modules=( "iproute2" )

# можно также указать другие модули для отдельного интерфейса
# здесь мы выбираем udhcpc, а не dhcpcd
modules_eth0=( "udhcpc" )

# также можно указать, какие модули не надо использовать: например,
# возможно, вы используете supplicant или linux-wlan-ng для управления
# параметрами беспроводной сети, но при этом желаете настраивать сетевые
# параметры раздельно для каждого связанного ESSID
modules=( "!iwconfig" )</programlisting>
                    </example>
                </para>
            </section>
            <section>
                <title>Обработчики интерфейса</title>
                <para>Сейчас мы предоставляем два обработчика интерфейса: ifconfig и iproute2. Для настройки сети вам нужен только один из них. </para>
                <orderedlist>
                    <listitem>
                        <para>ifconfig в текущем Gentoo используется по умолчанию, и включен в системный профиль. </para>
                    </listitem>
                    <listitem>
                        <para>iproute2 — более мощный и гибкий пакет, который не включен в системный профиль по умолчанию. </para>
                    </listitem>
                </orderedlist>
                <para>
                    <example>
                        <title>Установка iproute2</title>
                        <screen><prompt>#</prompt> <userinput>emerge sys-apps/iproute2</userinput>

<lineannotation># выбор iproute2, а не ifconfig, когда установлены оба</lineannotation>
modules=( "iproute2" )</screen>
                    </example>
                </para>
                <para>Так как и ifconfig и iproute2 делают очень сходные вещи, то мы сделали их базовую настройку взаимозаменяемой. Например, оба приведенных ниже примера работают не зависимо от того, какой модуль используется. </para>
                <para>
                    <example>
                        <title>Примеры ifconfig и iproute2</title>
                        <programlisting>  config_eth0=( "192.168.0.2/24" )
config_eth0=( "192.168.0.2 netmask 255.255.255.0" )

# также можно указать широковещательный адрес
config_eth0=( "192.168.0.2/24 brd 192.168.0.255" )
config_eth0=( "192.168.0.2 netmask 255.255.255.0 broadcast 192.168.0.255" )</programlisting>
                    </example>
                </para>
            </section>
            <section>
                <title>DHCP</title>
                <para><indexterm><primary>DHCP</primary></indexterm>DHCP — это способ получения сетевой информации (адреса IP, сервера DNS, шлюза и т.д.) с сервера. Это значит, что если в сети запущен сервер DHCP, вам остается только сказать каждому клиенту, чтобы он использовал DHCP, и сеть настроится сама собой. Конечно, вам придется настраивать все остальное (бесроводную сеть, подключение точка-точка и т.д.), если они должны работать до использования DHCP. </para>
                <para>Поддержка DHCP обеспечивается dhclient, dhcpcd, pump или udhcpc. У каждого модуля DHCP есть свои плюсы и минусы: здесь мы быстренько рассмотрим их.</para>
                <informaltable frame="all">
                    <tgroup cols="4">
                        <thead>
                            <row>
                                <entry>
                                    <para> Модуль DHCP</para>
                                </entry>
                                <entry>
                                    <para>Пакет</para>
                                </entry>
                                <entry>
                                    <para>Плюсы</para>
                                </entry>
                                <entry>
                                    <para>Минусы</para>
                                </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>
                                    <para>dhclient</para>
                                </entry>
                                <entry>
                                    <para>net-misc/dhcp</para>
                                </entry>
                                <entry>
                                    <para>Сделан ISC, теми же людьми, кто делает BIND DNS. Гибок в настройке. </para>
                                </entry>
                                <entry>
                                    <para>Настройка чрезмерно сложна, программа довольно «распухшая», не может получать данные о серверах NTP с DHCP, по умолчанию не отправляет имя узла. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <para>dhcpcd</para>
                                </entry>
                                <entry>
                                    <para>net-misc/dhcpcd</para>
                                </entry>
                                <entry>
                                    <para>Давно в Gentoo по умолчанию, не зависит от внешних утилит. </para>
                                </entry>
                                <entry>
                                    <para>Более не поддерживается разработчиком, может быть временами медленным, не становится демоном при неограниченном сроке аренды адреса.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <para>pump</para>
                                </entry>
                                <entry>
                                    <para>net-misc/pump</para>
                                </entry>
                                <entry>
                                    <para>Компактный, не зависит от внешних утилит. </para>
                                </entry>
                                <entry>
                                    <para>Более не поддерживается разработчиком, ненадежен, особенно по модему, не может получать данные о серверых NIS по DHCP.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <para>udhcpc</para>
                                </entry>
                                <entry>
                                    <para>net-misc/udhcp</para>
                                </entry>
                                <entry>
                                    <para>Компактный; наименьший существующий клиент DHCP, сделан для встроенных систем.</para>
                                </entry>
                                <entry>
                                    <para>Не зарекомендовал себя — ни в одном дистрибутиве не используется по умолчанию; не поддерживает длительность таймаута более 3 секунд. </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para>Если у вас установлено больше одного DHCP клиента, вам нужно указать, какой использовать; иначе по умолчанию используется dhcpcd, если есть. </para>
                <para>Чтобы передать определенные параметры модулю DHCP, используйте <code><replaceable>модуль</replaceable>_eth0="..."</code> (замените модуль на имя используемого модуля DHCP, например, <code>dhcpcd_eth0</code>). </para>
                <para>Мы попытались сделать DHCP относительным агностиком: по существу, мы поддерживаем следующие команды, с использованием переменной dhcp_eth0. По умолчанию не включена ни одна из них. </para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>release — освобождать IP-адрес для повторного использования </para>
                        </listitem>
                        <listitem>
                            <para>nodns — не замещать <filename>/etc/resolv.conf</filename>
                            </para>
                        </listitem>
                        <listitem>
                            <para>nontp — не замещать <filename>/etc/ntp.conf </filename></para>
                        </listitem>
                        <listitem>
                            <para>nonis — не замещать <filename>/etc/yp.conf </filename></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <example>
                    <title>Простая настройка DHCP в <filename>/etc/conf.d/net</filename></title>
                    <programlisting># требуется только если у вас несколько модулей DHCP
modules=( "dhcpcd" )

config_eth0=( "dhcp" )
dhcpcd_eth0="-t 10" # прекращение после 10 секунд
dhcp_eth0="release nodns nontp nonis" # только получать адрес</programlisting>
                </example>
                <note>
                    <para>По умолчанию, dhcpcd, udhcpc и pump передают текущее узла на сервер DHCP, поэтому его больше не требуется указывать. </para>
                </note>
            </section>
            <section>
                <title>Модем ADSL</title>
                <para>Сначала нужно установить программное обеспечение для ADSL. </para>
                <para>
                    <example>
                        <title>Установка пакета rp-pppoe</title>
                        <screen><prompt>#</prompt> <userinput>emerge net-dialup/rp-pppoe</userinput></screen>
                    </example>
                </para>
                <warning>
                    <para>В baselayout-1.11.x поддерживается только PPPoE. Надеемся, что в будущих версиях появится поддержка PPPoA. </para>
                </warning>
                <para>Сейчас нам нужно указать, что на eth0 будет ADSL-интерфейс, и ввести наше имя пользователя, обновив <filename>/etc/conf.d/net</filename>. </para>
                <para>
                    <example>
                        <title>Настройка eth0 для ADSL в /etc/conf.d/net</title>
                        <programlisting>config_eth0=( "adsl" )
adsl_user_eth0="<replaceable>имя-пользователя</replaceable>"</programlisting>
                    </example>
                </para>
                <para>Наконец, нужно указать ваше имя и пароль в <filename>/etc/ppp/pap-secrets</filename>. </para>
                <para>
                    <example>
                        <title>Пример <filename>/etc/ppp/pap-secrets</filename></title>
                        <programlisting># * обязательна
"<replaceable>пользователь</replaceable>"  *  "<replaceable>пароль</replaceable>"</programlisting>
                    </example>
                </para>
            </section>
            <section>
                <title>APIPA (автоматическая частная IP-адресация)</title>
                <para>2APIPA пытается найти свободный адрес в диапазоне 169.254.0.0-169.254.255.255, проверяя отклик на интерфейсе произвольного адреса из этого диапазона по протоколу arp. Если отклика нет, адрес назначается интерфейсу. </para>
                <para>Это полезно только в локальных сетях, где нет сервера DHCP, нет прямого подключения к интернету, и все другие компьютеры используют APIPA. </para>
                <para>Для поддержки APIPA установите net-misc/iputils или net-analyzer/arping. </para>
                <example>
                    <title>Настройка APIPA в <filename>/etc/conf.d/net</filename></title>
                    <programlisting># сначала пробуем DHCP, при неудаче переходим на APIPA
config_eth0=( "dhcp" )
fallback_eth0=( "apipa" )

# использование только APIPA
config_eth0=( "apipa" )</programlisting>
                </example>
            </section>
            <section>
                <title>Объединение интерфейсов</title>
                <para>Для объединения каналов в ствол (bonding) установите net-misc/ifenslave. </para>
                <para>Объединение используется для повышения пропускной способности сети. Если у вас есть две сетевых карты, выходящих в одну и ту же сеть, можно объединить их, так что ваши приложения увидят только один интерфейс, но реально будут пользоваться двумя сетевыми платами. </para>
                <para>
                    <example>
                        <title>Настройка объединения в <filename>/etc/conf.d/net</filename></title>
                        <programlisting>  # объединение интерфейсов
slaves_bond0="eth0 eth1 eth2"

# вы можете не захотеть назначать адрес IP объединенному интерфейсу
config_bond0=( "null" )

# указание зависимости от eth0, eth1 и eth2, так как им может требоваться
# дополнительная настройка
depend_bond0() {
need net.eth0 net.eth1 net.eth2
}</programlisting>
                    </example>
                </para>
            </section>
            <section>
                <title>Образование моста (поддержка 802.1d)</title>
                <para>Для поддержки мостов установите net-misc/bridge-utils. </para>
                <para>Мосты используются для объединения сетей. Например, у вас может быть сервер, подсоединенный к интернету через ADSL-модем, и плата беспроводного доступа для предоставления доступа в интернет через ADSL модем другим компьютерам. Чтобы соединить оба интерфейса, можно создать «мост». </para>
                <para>
                    <example>
                        <title>Настройка моста в <filename>/etc/conf.d/net</filename></title>
                        <programlisting># настройка моста: подробности в "man btctl"
brctl_br0=( "setfd 0" "sethello 0" "stp off" )

# включаем порты в мост br0
bridge_br0="eth0 eth1"

# устанавливаем порты в "null", чтобы не запускался dhcp
config_eth0=( "null" )
config_eth1=( "null" )

# наконец, даем мосту адрес; можно использовать и DHCP
config_br0=( "192.168.0.1/24" )

# указываем зависимость от eth0 и eth1, так как им может требоваться
# дополнительная настройка
depend_br0() {
need net.eth0 net.eth1
}</programlisting>
                    </example>
                </para>
                <important>
                    <para>Для использования некоторых вариантов моста вам может потребоваться обращение к документации по именам переменных. </para>
                </important>
            </section>
            <section>
                <title>MAC-адрес</title>
                <para>Для изменения MAC-адреса своего интерфейса вам не потребуется ничего устанавливать, если у вас sys-apps/baselayout-1.11.14 или новее, и вы собираетесь сменить MAC-адрес на какой-то определенный. Однако, если вам нужно сменить MAC-адрес на случайный, или ваш baselayout старше указанной версии, для смены адреса потребуется установить пакет командой <command>emerge net-analyzer/macchanger</command>. </para>
                <para>
                    <example>
                        <title>Пример изменения MAC-адреса</title>
                        <programlisting># установка MAC-адреса интерфейса
mac_eth0="00:11:22:33:44:55"

# случайная установка последних 3 байт адреса
mac_eth0="random-ending"

# установка случайного адреса из диапазона для физического соединения
# того же типа (оптического, медного, беспроводного) любого изготовителя
mac_eth0="random-samekind"

# установка случайного адреса из диапазона для любого типа физического
# соединения (оптического, медного, беспроводного) любого изготовителя
mac_eth0="random-anykind"

# полностью случайный; ВНИМАНИЕ, некоторые MAC-адреса, сгенерированные
# таким образом, могут вести себя НЕ ТАК, как предполагается
mac_eth0="random-full"</programlisting>
                    </example>
                </para>
            </section>
            <section>
                <title>Образование тоннеля</title>
                <para>Для образования тоннеля вам не нужно ничего устанавливать, поскольку на это способен сам обработчик интерфейса. </para>
                <para>
                    <example>
                        <title>Настройка тоннеля в <filename>/etc/conf.d/net</filename></title>
                        <programlisting># для тоннелей GRE
iptunnel_vpn0="mode gre remote 207.170.82.1 key 0xffffffff ttl 255"

# для тоннелей IPIP
iptunnel_vpn0="mode ipip remote 207.170.82.2 ttl 255"

# для настройки интерфейса
config_vpn0=( "192.168.0.2 peer 192.168.1.1" )</programlisting>
                    </example>
                </para>
            </section>
            <section>
                <title>Виртуальные сети (поддержка 802.1q)</title>
                <para>Для поддержки VLAN, установите net-misc/vconfig. </para>
                <para><indexterm><primary>Виртуальная локальная сеть</primary></indexterm><indexterm><primary>VLAN</primary></indexterm>Виртуальная локальная сеть (VLAN) — это группа сетевых устройств, которые ведут себя, как будто подключены к одному сегменту сети, даже когда это не так. Членам VLAN видны только члены той же VLAN даже если в той же физической сети присутствуют другие. </para>
                <example>
                    <title>VLAN configuration in <filename>/etc/conf.d/net</filename></title>
                    <programlisting># указание номеров VLAN для интерфейса
# пожалуйста, убедитесь, что ваши номера VLAN НЕ дополнены нулем
vlans_eth0="1 2"

# можно также настроить VLAN
# за подробностями обращайтесь к man vconfig
vconfig_eth0=( "set_name_type VLAN_PLUS_VID_NO_PAD" )
vconfig_vlan1=( "set_flag 1" "set_egress_map 2 6" )

# настройка интерфейса как обычно
config_vlan1=( "172.16.3.1 netmask 255.255.254.0" )
config_vlan2=( "172.16.2.1 netmask 255.255.254.0" )</programlisting>
                </example>
                <important>
                    <para>Для использования некоторых вариантов VLAN вам может потребоваться обращение к документации по именам переменных. </para>
                </important>
            </section>
        </section>
        <section xreflabel="Беспроводная сеть">
            <title>Беспроводная сеть</title>
            <section>
                <title>Введение</title>
                <para>В настоящее время поддерживается подключение к беспроводной сети с помощью wireless-tools или wpa_supplicant. Важно помнить, что подключение к беспроводным сетям настраивается глобально, а не для определённого интерфейса. </para>
                <orderedlist>
                    <listitem>
                        <para>wpa_supplicant — лучший выбор, но он поддерживает не все драйверы. Список поддерживаемых драйверов находится на сайте wpa_suppliant. Кроме того, сейчас wpa_supplicant может подключаться только к тем сетям, на SSID которых настроен. </para>
                    </listitem>
                    <listitem>
                        <para>wireless-tools поддерживает практически все платы и драйверы, но не способен подключаться к точкам доступа, работающим исключительно с WPA.</para>
                    </listitem>
                </orderedlist>
                <warning>
                    <para>Драйвер linux-wlan-ng в данный момент не поддерживается в baselayout. Это из-за того, что в linux-wlan-ng своя собственная программа установки и настройки, которая ни на что не похожа. Разработчики linux-wlan-ng, по слухам, собираются перейти на установку как в wireless-tools; когда это произойдет, вы сможете использовать linux-wlan-ng с baselayout. </para>
                </warning>
            </section>
            <section>
                <title>Запросчик WPA</title>
                <para><indexterm><primary>Запросчик WPA</primary></indexterm><indexterm><primary>WPA Supplicant</primary></indexterm>Запросчик WPA (WPA Supplicant) — пакет, позволяющий подсоединяться к точкам доступа с протоколом WPA. Его настройка проходит достаточно гладко, и пакет работает достаточно стабильно, хотя находится на стадии бета-тестирования. </para>
                <example>
                    <title>Установка wpa_supplicant</title>
                    <screen><prompt>#</prompt> <userinput>emerge net-wireless/wpa_supplicant</userinput></screen>
                </example>
                <important>
                    <para>Для работы wpa_supplicant в ядре должен быть включен параметр <envar>CONFIG_PACKET</envar>. </para>
                </important>
                <para>Теперь нам необходимо настроить <filename>/etc/conf.d/net</filename> для предпочтения wpa_supplicant по отношению к wireless-tools (по умолчанию, если обе программы установлены, работает wireless-tools). </para>
                <example>
                    <title>Настройка <filename>/etc/conf.d/net</filename> для wpa_supplicant</title>
                    <programlisting># выбор wpa_supplicant
modules=( "wpa_supplicant" )

# важно указать wpa_supplicant, какой драйвер нужно использовать,
# так как программа пока не слишком хорошо угадывает сама

wpa_supplicant_eth0="-Dбезумный-wifi"</programlisting>
                </example>
                <para>Примечание: Если вы используете драйвер host-ap, то вам потребуется перевести плату в ведомый режим (managed mode), прежде чем она сможет правильно работать с wpa_supplicant. Для этого можно указать <code>iwconfig_eth0="mode managed"</code> в <filename>/etc/conf.d/net</filename>.</para>
                <para>Это довольно просто, не так ли? Однако, нужно настроить саму программу wpa_supplicant, что значительно сложнее. Сложность зависит от степени защиты точек доступа, к которым вы собираетесь подключаться. Следующий упрощенный пример взят из <filename>/etc/wpa_supplicant.conf.example</filename>, поставляемого в составе wpa_supplicant. </para>
                <para>
                    <example>
                        <title>Пример <filename>/etc/wpa_supplicant.conf</filename></title>
                        <programlisting># следующую строку нельзя изменять, иначе программа не сможет работать
ctrl_interface=/var/run/wpa_supplicant

# ограничим доступ к настройкам WPA только для root
ctrl_interface_group=0

# пусть wpa_supplicant заботится о сканировании и выборе точки доступа
ap_scan=1

# простой случай: WPA-PSK, согласованный ключ - текстовая строка,
# принимать любой допустимый шифр
network={
  ssid="просто"
  psk="очень тайный пароль"
  # чем выше приоритет, тем скорее выбор
  priority=5
}

# как в предыдущем, но с запросом сканирования по определенному SSID
# (для точек доступа, отклоняющих широковешательный SSID)
network={
  ssid="второй ssid"
  scan_ssid=1
  psk="очень тайный пароль"
  priority=2
}

# использовать только WPA-PSK; принимать любое допустимое сочетание шифров

network={
  ssid="пример"
  proto=WPA
  key_mgmt=WPA-PSK
  pairwise=CCMP TKIP
  group=CCMP TKIP WEP104 WEP40
  psk=06b4be19da289f475aa46a33cb793029d4ab3db7a23ee92382eb0106c72ac7bb
  priority=2
}

# открытое подключение без шифрования (не WPA, не IEEE #802.1X)

network={
  ssid="тест-открытого-текста"
  key_mgmt=NONE
}

# подключение с общим ключом WEP (не WPA, не IEEE #802.1X)
network={
  ssid="тест-статического-wep"
  key_mgmt=NONE
  wep_key0="abcde"
  wep_key1=0102030405
  wep_key2="1234567890123"
  wep_tx_keyidx=0
  priority=5
}

# подключение с общим ключом WEP (не WPA, не IEEE #802.1X),
# допуск c использованим общего ключа IEEE 802.11
network={
  ssid="тест2-статического-wep"
  key_mgmt=NONE
  wep_key0="abcde"
  wep_key1=0102030405
  wep_key2="1234567890123"
  wep_tx_keyidx=0
  priority=5
  auth_alg=SHARED
}

# сеть IBSS/ad-hoc с WPA-None/TKIP
network={
  ssid="тест adhoc"
  mode=1
  proto=WPA
  key_mgmt=WPA-NONE
  pairwise=NONE
  group=TKIP
  psk="тайный пароль"
}</programlisting>
                    </example>
                </para>
            </section>
            <section>
                <title>Утилиты Wireless tools</title>
                <section>
                    <title>Начальная установка и режим ведомого</title>
                    <para>Wireless Tools обеспечивают общий способ настройки базовых беспроводных интерфейсов, вплоть до защиты WEP. Хотя WEP является слабым методом защиты, он наиболее распространен. </para>
                    <para>Для настройки Wireless Tools служат несколько основных переменных. В примере файла настроек, приведенном ниже, описано все, что вам потребуется. Нужно помнить, что отсутствие настройки означает «подключаться к нешифрующей точке доступа с самым сильным сигналом». Программа будет всегда пытаться подключить вас к чему-нибудь. </para>
                    <para>
                        <example>
                            <title>Установка wireless-tools</title>
                            <screen><prompt>#</prompt> <userinput>emerge net-wireless/wireless-tools</userinput></screen>
                        </example>
                    </para>
                    <note>
                        <para>Хотя вы можете хранить свои параметры настройки беспроводной сети в /etc/conf.d/wireless, это руководство рекомендует хранить их в /etc/conf.d/net. </para>
                    </note>
                    <important>
                        <para>Вам понадобится обратиться к документации по именам переменных. </para>
                    </important>
                    <para>
                        <example>
                            <title>Пример настройки iwconfig <filename>/etc/conf.d/net</filename></title>
                            <programlisting># приоритет использования iwconfig над wpa_supplicant
modules=( "iwconfig" )

# Настройка ключей WEP для точек доступа ESSID1 и ESSID2
# Можно указывать до 4 ключей WEP, но только 1 может работать в каждый
# момент, поэтому мы указываем индекс по умолчанию [1], чтобы сделать ключ [1],
# а впоследствии снова, чтобы изменить активный ключ на [1].
# Это нужно, если вы настраиваете другие ESSID на использование WEP-ключей, 
# отличающихся от [1].
#
# Приставка s: перед ключом означает, что ключ текстовый, иначе - 
# шестнадцатиричный
#
# enc open указывает открытую защиту (более безопасно)
# enc restricted указывает ограниченную защиту (менее безопасно)
key_ESSID1="[1] s:ваш-ключ-здесь key [1] enc open"
key_ESSID2="[1] aaaa-bbbb-cccc-dd key [1] enc restricted"
#
# Нижеследующее работает только при поиске доступных точек доступа.

# Иногда видны несколько точек доступа, и требуется задать
# предпочтительный порядок подключения
preferred_aps=( "ESSID1" "ESSID2" )</programlisting>
                        </example>
                    </para>
                </section>
                <section>
                    <title>Настройка порядка выбора точки доступа</title>
                    <para>Можно указать несколько дополнительных параметров для уточнения порядка выбора точки доступа, но обычно этого не требуется. </para>
                    <para>Вам решать, подключаться ли только к указанным точкам доступа, или нет. По умолчанию, если подключение ко всем настроенным точкам доступа не удалось, и есть возможность подключиться к не шифрующей точке доступа, такое соединение произойдет. Этот порядок зависит от переменной <varname>associate_order</varname>. Ниже приводится таблица значений и с описанием их действия:</para>
                    <informaltable frame="all">
                        <tgroup cols="2">
                            <thead>
                                <row>
                                    <entry>
                                        <para>Значение</para>
                                    </entry>
                                    <entry>
                                        <para>Описание</para>
                                    </entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>
                                        <para>any</para>
                                    </entry>
                                    <entry>
                                        <para>поведение по умолчанию</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>preferredonly</para>
                                    </entry>
                                    <entry>
                                        <para>соединяться только с видимыми точками доступа из списка</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>forcepreferred</para>
                                    </entry>
                                    <entry>
                                        <para>принудительно подключаться к точкам доступа в заданной последовательности, если они не обнаружены при сканировании </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>forcepreferredonly</para>
                                    </entry>
                                    <entry>
                                        <para>не сканировать точки доступа, просто пытаться подключиться к каждой по списку </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>forceany</para>
                                    </entry>
                                    <entry>
                                        <para>так же, как в forcepreferred + подключаться к любой доступной точке доступа </para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                    <para>Наконец, мы можем указать <varname>blacklist_aps</varname> и <varname>unique_ap</varname>. <varname>blacklist_aps</varname> работает подобно <varname>preferred_aps</varname>. <varname>unique_ap</varname> устанавливается в <code>yes</code> или <code>no</code>, указывая, можно ли подключать второй беспроводной интерфейс к той же точке доступа, что и первый. </para>
                    <para>
                        <example>
                            <title>Пример blacklist_aps и unique_ap</title>
                            <programlisting># иногда требуется полностью исключить возможность подключения
# к определенным точкам доступа
blacklist_aps=( "ESSID3" "ESSID4" )

# если у вас несколько беспроводных плат, можно указать, можно ли им
# подключаться к одной и той же точке доступа
# значение - "yes" или "no"
# по умолчанию - "yes"
unique_ap="yes"</programlisting>
                        </example>
                    </para>
                </section>
                <section>
                    <title>Режим отдельного и ведущего узла</title>
                    <para>Если вы хотите становиться отдельным узлом (ad hoc), когда не удается подключиться ни к какой точке доступа в ведомом режиме, это тоже возможно. </para>
                    <example>
                        <title>Откат к режиму отдельного узла</title>
                        <programlisting>adhoc_essid_eth0="Этот отдельный узел"</programlisting>
                    </example>
                    <para>Как насчет подключения к сетям Ad-Hoc или запуска в режиме ведущего (master), чтобы стать точкой доступа? Есть конфигурация и для такой работы! Вам может потребоваться определить WEP-ключи, как показано выше. </para>
                    <para>
                        <example>
                            <title>Пример настройки ad-hoc/master</title>
                            <programlisting># установка режима: допускается managed (ведомый, по умолчанию),
# ad-hoc (отдельный) или или master (ведущий). Не все драйверы поддерживают 
# каждый режим 
mode_eth0="ad-hoc"

# установка ESSID интерфейса
# в ведомом режиме заставляет интерфейс пытаться подключиться к указанному
# ESSID, и больше ничего
essid_eth0="Этот отдельный узел"

# если не указан, используется канал 3
channel_eth0="9"</programlisting>
                        </example>
                    </para>
                    <important>
                        <para>Следующий текст взят дословно из документации BSD wavelan, входящей в документацию NetBSD. «Существуют 14 каналов. Нам сообщили, что использование каналов с 1 по 11 является законным в Северной Америке, каналов с 1 по 13 — в большинстве стран Европы, каналов с 10 по 13 — во Франции, и только канала 14 — в Японии. Если у вас есть сомнения, обратитесь к документации от вашей платы или точки доступа. Убедитесь что выбранный канал совпадает с каналом точки доступа (или другой платы в сети ad-hoc). По умолчанию на платах, продаваемых в Северной Америке и большинстве стран Европы, настроен канал 3; на платах, продаваемых во Франции — канал 11; на платах, продаваемых в Японии — канал 14.» </para>
                    </important>
                </section>
                <section>
                    <title>Устранение неполадок в wireless tools</title>
                    <para>Существуют дополнительные переменные, которые можно использовать для запуска своего беспроводного оборудования и устранения неполадок, возникших из-за драйвера или проблем с сетевым окружением. Ниже приведена таблица прочих функций, которые можно перепробовать:</para>
                    <informaltable frame="all">
                        <tgroup cols="3">
                            <thead>
                                <row>
                                    <entry>
                                        <para>Переменная</para>
                                    </entry>
                                    <entry>
                                        <para>Значение по умолчанию</para>
                                    </entry>
                                    <entry>
                                        <para>Описание</para>
                                    </entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>
                                        <para>iwconfig_eth0</para>
                                    </entry>
                                    <entry>
                                        <para/>
                                    </entry>
                                    <entry>
                                        <para>За подробными сведениями о параметрах iwconfig обращайтесь к странице справки iwconfig. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>iwpriv_eth0</para>
                                    </entry>
                                    <entry>
                                        <para/>
                                    </entry>
                                    <entry>
                                        <para>За подробными сведениями о параметрах iwpriv обращайтесь к странице справки iwpriv </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>sleep_scan_eth0</para>
                                    </entry>
                                    <entry>
                                        <para>0</para>
                                    </entry>
                                    <entry>
                                        <para>Время задержки в секундах перед попыткой сканирования. Требуется, когда драйверу или прошивке нужно дополнительное время для перехода в рабочий режим.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>sleep_associate_eth0</para>
                                    </entry>
                                    <entry>
                                        <para>5</para>
                                    </entry>
                                    <entry>
                                        <para>Время ожидания связи интерфейса с точкой доступа (в секундах) перед переходом к опросу следующей</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>associate_test_eth0</para>
                                    </entry>
                                    <entry>
                                        <para>MAC</para>
                                    </entry>
                                    <entry>
                                        <para>Некоторые драйверы не сбрасывают MAC-адрес, связанный с недоступной точкой доступа, при потере или попытки связи. Некоторые драйверы не сбрасывают значение качества сигнала при потере или попытке соединения. Допустимые значения: MAC, quality и all. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>scan_mode_eth0</para>
                                    </entry>
                                    <entry>
                                        <para/>
                                    </entry>
                                    <entry>
                                        <para>Некоторым драйверам необходимо сканировать в режиме ad-hoc. Если сканирование не удается, попробуйте указать здесь ad-hoc.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>iwpriv_scan_pre_eth0</para>
                                    </entry>
                                    <entry>
                                        <para/>
                                    </entry>
                                    <entry>
                                        <para>Посылать интерфейсу некоторые команды iwpriv перед сканированием. За дополнительными сведениями обращайтесь к странице справки iwpriv. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>iwpriv_scan_post_eth0</para>
                                    </entry>
                                    <entry>
                                        <para/>
                                    </entry>
                                    <entry>
                                        <para>Посылать интерфейсу некоторые команды iwpriv после сканирования. За дополнительными сведениями обращайтесь к странице справки iwpriv. </para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </section>
            </section>
            <section>
                <title>Раздельная настройка сети по ESSID</title>
                <para>Иногда необходим статический IP при соединении с ESSID1, и DHCP при соединении с ESSID2. На деле, большинство переменных модуля можно определять раздельно по ESSID. Вот как это сделать: </para>
                <note>
                    <para>Примечание: Это работает при использовании WPA Supplicant или Wireless Tools. </para>
                </note>
                <important>
                    <para>Вам потребуется свериться с документацией по именам переменных. </para>
                </important>
                <para>
                    <example>
                        <title>Назначение сетевых настроек для ESSID</title>
                        <programlisting>config_ESSID1=( "192.168.0.3/24 brd 192.168.0.255" )
routes_ESSID1=( "default via 192.168.0.1" )

config_ESSID2=( "dhcp" )
fallback_ESSID2=( "192.168.3.4/24" )
fallback_route_ESSID2=( "default via 192.168.3.1" )

# можно также указать сервера имен и др.
# ПРЕДУПРЕЖДЕНИЕ: DHCP переопределит настройки, если не указано иное
dns_servers_ESSID1=( "192.168.0.1" "192.168.0.2" )
dns_domain_ESSID1="some.domain"
dns_search_domains_ESSID1="search.this.domain search.that.domain"

# перенастройка производится по МАС-адресу точки доступа;
# это полезно, когда в разных местах есть точки доступа с одинаковым ESSID
config_001122334455=( "dhcp" )
dhcpcd_001122334455="-t 10"
dns_servers_001122334455=( "192.168.0.1" "192.168.0.2" )</programlisting>
                    </example>
                </para>
            </section>
        </section>
        <section xreflabel="Дополнительные возможности">
            <title>Дополнительные возможности</title>
            <section>
                <title>Стандартные функции-обработчики</title>
                <para>Можно определить четыре функции, которые вызываются при операциях запуска (start) и останова (stop). При вызове функциям передается название интерфейса, так что одна и та же функция может управлять несколькими адаптерами. </para>
                <para>Для указания на то, что запуск или останов интерфейса может продолжаться, возвращаемое значение функций <function>preup()</function> и <function>predown()</function> должно быть нулевым (успешным). Если preup() возвращает ненулевое значение, запуск интерфейса прерывается. Если <function>predown()</function> возвращает ненулевое значение, не допускается продолжение останова интерфейса. </para>
                <para>Возвращаемые значение функций <function>postup()</function> и <function>postdown()</function> игнорируется, так как показываемая ими ошибка не обрабатывается. </para>
                <orderedlist>
                    <listitem>
                        <para><varname>${IFACE}</varname> присваивается название запускаемого/останавливаемого интерфейса. </para>
                    </listitem>
                    <listitem>
                        <para><varname>${IFVAR}</varname> — это значение <varname>${IFACE}</varname>, преобразованное в имя переменной, разрешенное в bash. </para>
                    </listitem>
                </orderedlist>
                <para>
                    <example>
                        <title>Примеры функций до/после запуска/останова</title>
                        <programlisting>preup() {
  # Проверка соединения интерфейса перед его запуском. Она
  # работает лишь с некоторыми сетевыми адаптерами и требует наличия
  # установленного пакета mii-diag.
  if mii-tool ${IFACE} 2> /dev/null | grep -q 'no link'; then
    ewarn "Интерфейс ${IFACE} не подключен, прерывание запуска"
    return 1
  fi

  # Проверка соединения интерфейса перед его запуском. Она
  # работает лишь с некоторыми сетевыми адаптерами и требует наличия
  # установленного пакета ethtool.
  if ethtool ${IFACE} | grep -q 'Link detected: no'; then
    ewarn "Интерфейс ${IFACE} не подключен, прерывание запуска"
    return 1
  fi

  # Не забываем вернуть 0 при успехе
  return 0
}

predown() {
  # Назначение этого сценария - проверить наличие корня NFS
  # и в этом случае предотвратить останов интерфейсов. Заметьте, что
  # определяя функцию predown(), вы отменяете существующую логику. 
  # Вот она, на случай если все же понадобится...
  if is_net_fs /; then
    eerror "Корневая ФС смонтирована в сети - останов ${IFACE} невозможен"
    return 1
  fi

  # Не забываем вернуть 0 при успехе
  return 0
}

postup() {
  # Эту функцию можно использовать, например, для регистрации в
  # службе динамического DNS. Другой пример - отправка/прием почты после
  # запуска интерфейса.
       return 0
}

postdown() {
  # Эта функция приводится в основном для полноты... Я не придумал,
  # что бы ценное в нее поместить ;-)
  return 0
}</programlisting>
                    </example>
                </para>
            </section>
            <section>
                <title>Функции-обработчики wireless tools</title>
                <note>
                    <para>Это не работает вместе с WPA Supplicant, но переменные <varname>${ESSID}</varname> и <varname>${ESSIDVAR}</varname> доступны в функции <function>postup()</function>. </para>
                </note>
                <para>Можно определить две функции, вызываемые до и после функции подключения (associate). При вызове им сначала передается название интерфейса, так что одна и та же функция может управлять несколькими адаптерами. </para>
                <para>Для указания на то, что запуск или останов интерфейса можно продолжать, возвращаемое значение функции <function>preassociate()</function> должно быть нулевым (успешным). Если preassociate() возвращает ненулевое значение, запуск интерфейса прерывается. </para>
                <para>Возвращаемое значение функции postassociate() игнорируется, так как показываемая ей ошибка не обрабатывается. </para>
                <para><varname>${ESSID}</varname> присваивается точный ESSID точки доступа, к которой вы подключаетесь. <varname>${ESSIDVAR}</varname> — это <varname>${ESSID}</varname>, преобразованный в имя переменной, разрешенное в bash. </para>
                <example>
                    <title>Функции до/после соединения</title>
                    <programlisting>preassociate() {
  # Ниже добавляются две конфигурационных переменных, leap_user_ESSID
  # и leap_pass_ESSID. Когда они обе настроены на подключаемый ESSID,
  # мы запускаем сценарий CISCO LEAP

  local user pass
  eval user=\"\$\{leap_user_${ESSIDVAR}\}\"
  eval pass=\"\$\{leap_pass_${ESSIDVAR}\}\"

  if [[ -n ${user} &amp;&amp; -n ${pass} ]]; then
    if [[ ! -x /opt/cisco/bin/leapscript ]]; then
      eend "Для поддержки LEAP, выполните emerge net-misc/cisco-aironet-client-utils"
      return 1
    fi
    einfo "Ожидание допуска LEAP на \"${ESSID//\\\\//}\""
    if /opt/cisco/bin/leapscript ${user} ${pass} | grep -q 'Login incorrect'; then
      ewarn "Вход пользователя ${user} не удался"
      return 1
    fi
  fi

  return 0
}

postassociate() {
  # Эта функция приводится в основном для полноты... Я не придумал,
  # что бы ценное в нее поместить ;-)

  return 0
}</programlisting>
                </example>
                <note>
                    <para><varname>${ESSID}</varname> и <varname>${ESSIDVAR}</varname> недоступны в функциях <function>predown()</function> и <function>postdown()</function>.</para>
                </note>
            </section>
        </section>
        <section xreflabel="Управление сетью">
            <title>Управление сетью</title>
            <section>
                <title>Управление сетью</title>
                <para>Если вы часто берете компьютер в поездки, то у вас не всегда может быть возможность подключения к сети Ethernet или к беспроводной точке доступа. Но мы можем захотеть, чтобы сеть заработала автоматически, как только к компьтеру подключен кабель Ethernet или найдена беспроводная точка доступа. </para>
                <para>Здесь вы найдете некоторые инструменты, которые помогут это организовать. </para>
                <note>
                    <para>В этом документе рассказывается только о ifplugd, но есть и альтернативные решения, например, quickswitch. </para>
                </note>
            </section>
            <section>
                <title>ifplugd</title>
                <para><indexterm><primary>ifplugd</primary></indexterm>ifplugd — это программа, которая запускает и останавливает интерфейс при подключении или отключении кабеля к сети Ethernet. Также она может обработать подключение к беcпроводной точке доступа или появление новых точек доступа. </para>
                <para>
                    <example>
                        <title>Установка ifplugd</title>
                        <screen><prompt>#</prompt> <userinput>emerge sys-apps/ifplugd</userinput></screen>
                    </example>
                </para>
                <para>Настройка ifplugd — довольно простая задача. Файл конфигурации расположен по адресу: <filename>/etc/conf.d/ifplugd</filename>. Для просмотра подробного описания переменных запустите <command>man ifplugd</command>. </para>
                <example>
                    <title>Пример конфигурации ifplug</title>
                    <programlisting># назначение интерфейса для слежения
INTERFACES="eth0"

AUTO="no"
BEEP="yes"
IGNORE_FAIL="yes"
IGNORE_FAIL_POSITIVE="no"
IGNORE_RETVAL="yes"
POLL_TIME="1"
DELAY_UP="0"
DELAY_DOWN="0"
API_MODE="auto"
SHUTDOWN="no"
WAIT_ON_FORK="no"
MONITOR="no"
ARGS=""

# дополнителные параметры ifplugd для указанного интерфейса.
# учтите, установки глобальных переменных игнорируются, если указаны значения
# для конкретного интерфейса
MONITOR_wlan0="yes"
DELAY_UP_wlan0="5"
DELAY_DOWN_wlan0="5"</programlisting>
                </example>
            </section>
        </section>
    </section>
</article>
