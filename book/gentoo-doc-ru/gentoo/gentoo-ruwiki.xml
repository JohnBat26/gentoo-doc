<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbookxi.rng" type="xml"?>
<article xmlns="http://docbook.org/ns/docbook" 
        xmlns:xi="http://www.w3.org/2001/XInclude"
        xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
<info><title>Русское WIKI</title></info>
<para>Ссылка на оригинал: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/">http://ru.gentoo-wiki.com</link>
</para>
<para>С версии: 1.0</para>
<para>Обновлено: 1.5</para>
<para/><section><info><title>HOWTO hal и устройства ввода</title></info>
<para>Дата:  28.01.2008</para><section><info><title>hal-0.5.10 </title></info>
<para>В связи с выходом hal-0.5.10 и включении поддержки hal в xorg возникло много вопросов: где раскладки, где мышка, где тачпад, и прочее. </para>
<para>Сейчас xorg использует hal для устройств ввода и xorg.conf игнорирует Данное руководство предназначенно для безболезненного перехода на новую систему </para>
<para>В данном руководстве используются пакеты из ~x86(~amd64) ветки. Посему заботу о keywords оставляю на вашей совести. </para></section><section><info><title>Обновляем portage </title></info>
<para># emerge --sync</para>
<para>(# eix-sync -v) </para></section><section><info><title>Обновляем установку xorg </title></info>
<para>#emerge -avDNt  xorg-x11</para>
<para>убеждаемся в наличии флага hal. При отсутствии — включаем. / В окончании сборки пакета xorg-server выведется список пакетов для пересборки, их надо пересобрать. Если не заметили или пропустили вот комманда для получения списка пакетов: </para>
<para>emerge portage-utils; qlist -I -C x11-drivers/</para></section><section><info><title>Клавиатура </title></info>
<para>Правила(rules) пользователя можно разместить в каталогах: </para>
<para>/usr/share/hal/fdi/policy/20thirdparty/</para>
<para>или аналогичном /etc/hal/fdi/policy</para>
<para>получить список устройств "узнанных" hal можно командой lshal у меня системе(ноутбук с мультимедийными клавишами) оказалось несколько устройств которые совместимы с понятием "клавиатура", но основная была описана так: </para>
<para>udi = '/org/freedesktop/Hal/devices/platform_i8042_i8042_KBD_port_logicaldev_input'</para>
<para> info.addons.singleton = {'hald-addon-input'} (string list)</para>
<para> info.capabilities = {'input', 'input.keyboard', 'input.keypad', 'input.keys', 'button'} (string list)</para>
<para> info.category = 'input'  (string)</para>
<para> info.parent = '/org/freedesktop/Hal/devices/platform_i8042_i8042_KBD_port' (string)</para>
<para> info.product = 'AT Translated Set 2 keyboard'  (string)</para>
<para> info.udi = '/org/freedesktop/Hal/devices/platform_i8042_i8042_KBD_port_logicaldev_input'  (string)</para>
<para> input.device = '/dev/input/event2'  (string)</para>
<para> input.originating_device = '/org/freedesktop/Hal/devices/platform_i8042_i8042_KBD_port'  (string)</para>
<para> input.physical_device = '/org/freedesktop/Hal/devices/platform_i8042_i8042_KBD_port'  (string)</para>
<para> input.product = 'AT Translated Set 2 keyboard'  (string)</para>
<para> input.x11_driver = 'evdev'  (string)</para>
<para> input.xkb.layout = 'us'  (string)</para>
<para> input.xkb.model = 'evdev'  (string)</para>
<para> input.xkb.rules = 'base'  (string)</para>
<para> input.xkb.variant =   (string)</para>
<para> linux.device_file = '/dev/input/event2'  (string)</para>
<para> linux.hotplug_type = 2  (0x2)  (int)</para>
<para> linux.subsystem = 'input'  (string)</para>
<para> linux.sysfs_path = '/sys/devices/platform/i8042/serio0/input/input2/event2'  (string)</para>
<para>Заметно что </para>
<para>input.xkb.layout = 'us'</para>
<para>input.xkb.rules = 'base'</para>
<para>input.xkb.variant = </para>
<para>нас не устраивает </para>
<para>Создаём новый файл </para>
<para>nano /usr/share/hal/fdi/policy/20thirdparty/10russian-layout.fdi</para>
<para>со следующим содержимым: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /usr/share/hal/fdi/policy/20thirdparty/10russian-layout.fdi </para>
</entry>
</row>
<row>
<entry>
<para>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;&lt;!-- -*- SGML -*- --&gt; &lt;match key="input.product" contains="AT Translated Set 2 keyboard"&gt;&lt;merge key="input.xkb.layout" type="string"&gt;us,ru&lt;/merge&gt;&lt;merge key="input.xkb.variant" type="string"&gt;,winkeys&lt;/merge&gt; &lt;merge key="input.xkb.options" type="string"&gt;grp:alt_shift_toggle,grp_led:scroll&lt;/merge&gt;&lt;/match&gt; </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>если у вас одно устройство ввода типа "клавиатура",то можно сточку </para>
<para>&lt;match key="input.product" contains="AT Translated Set 2 keyboard"&gt;</para>
<para>заменить на </para>
<para>&lt;match key="info.capabilities" contains="input.keyboard"&gt;</para>
<para>Так мы получим более универсальное правило. Можно заметить что названия опций перекликается с аналогами xorg.conf. Так и есть, в принципе здесь можно записать все те параметры которые вы использовали в xorg.conf только в приложении к XML. </para>
<para>ВАЖНО: Если у вас остались проблемы с расположением клавиш, то возможно так и следует сделать? </para>
<para>например: </para>
<para>Option "XkbRules" "xorg"</para>
<para>тоже самое что </para>
<para>       &lt;merge key="input.xkb.rules" type="string"&gt;xorg&lt;/merge&gt;</para>
<para/>
<para>Driver "kbd" </para>
<para>= </para>
<para>    &lt;merge key="input.x11_driver" type="string"&gt;kbd&lt;/merge&gt;</para>
<para>Сохраняем файл. </para>
<para>#/etc/init.d/hald restart</para>
<para>Проверяем системный лог и убеждаемся, что правило успешно добавленно. </para>
<para>#lshal </para>
<para>должно вывести следующие строчки: </para>
<para>...</para>
<para> input.x11_driver = 'evdev'  (string)</para>
<para> input.xkb.layout = 'us,ru'  (string)</para>
<para> input.xkb.model = 'evdev'  (string)</para>
<para> input.xkb.options = 'grp:alt_shift_toggle,grp_led:scroll'  (string)</para>
<para> input.xkb.rules = 'base'  (string)</para>
<para> input.xkb.variant = ',winkeys'  (string)</para>
<para>...</para>
<para>Если так и есть, то дело сделано. Если нет--внимательно перечитываем до просветления. </para></section><section><info><title>Перезапускаем X-ы </title></info>
<para>После чего можно перезапустить X-ы(перезагрузить компьтер, перезапустить xdm). Проверяем. Радуемся. Если не получаеться, то внимательно читаем лог Xorg, Скорее всего там можно найти ответ. </para></section><section><info><title>Мышка</title></info>
<para>Пока проблема одна. Hal по умолчанию использует драйвер evdev,которые не всегда корректно работает в полноэкранных приложениях(игры) </para>
<para>#echo "SDL_VIDEO_X11_DGAMOUSE=0" &gt;&gt;/etc/env.d/02locale</para>
<para>#env-update</para>
<para>#source /etc/profile</para>
<para>Должно решить эту проблему. </para></section><section><info><title>Touchpad</title></info>
<para>Пока в разработке. </para></section></section><section><info><title>HOWTO Ivman</title></info><section><info><title>Цель</title></info>
<para>Целью статьи является установка <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ivman.sourceforge.net/">ivman</link> для автомонтирования устройств. </para>
<para>Внимание: часть информации может быть недействительна для старых версий Ivman, особенно Ivman 0.5.x. Пожалуйста, используйте последние стабильные версии Ivman. </para></section><section><info><title>Требуемые программы</title></info>
<orderedlist>
<listitem>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/HOWTO_Udev">UDEV</link> </para>
</listitem>
<listitem>
<para>HAL </para>
</listitem>
<listitem>
<para>D-BUS </para>
</listitem>
<listitem>
<para>pmount </para>
</listitem>
<listitem>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ivman.sourceforge.net/">ivman</link> </para>
</listitem>
</orderedlist>
<para/>
<para>Все требуемые пакеты есть в портежах, поэтому минимальным действием будет: </para>
<para>emerge -av ivman</para>
<para>Размаскируйте требуемые пакеты, если необходимо. </para>
<para>Если установка HAL выдаёт предупреждения, что не установлены "u64" или "BLKGETSIZE64"и вы используете ядро 2.6, обновите пакет linux-headers: </para>
<para>emerge --oneshot linux-headers</para>
<para>Когда linux-headers полностью обновится, пересоберите glibc: </para>
<para>emerge --oneshot glibc</para></section><section><info><title>Использование</title></info>
<para>Есть два пути использования Ivman: от root, или от обычного пользователя. У любого из методов имеются как преимущества, так и недостатки. </para><section><info><title>Запуск Ivman от root</title></info>
<orderedlist>
<listitem>
<para>Для запуска Ivman выполните: /etc/init.d/ivman start </para>
</listitem>
<listitem>
<para>Чтобы Ivman стартовал при каждом запуске выполните: rc-update add ivman default </para>
</listitem>
<listitem>
<para>Все действия Ivman после запуска выполняются с привилегиями пользователя «ivman» и группы «plugdev». </para>
</listitem>
<listitem>
<para>По умолчанию, сменные устройства будут монтироваться для доступа на чтение/запись только входящим в группу «plugdev» (группа пользователей, которым разрешено использовать pmount). Это более безопасно, чем запуск Ivman от обычного пользователя. </para>
</listitem>
<listitem>
<para>Размонтирование дисков обычным пользователем может быть затруднено. Вам может потребоваться использование sudo pumount или sudo umount. Размонтирование используя 'media:/' ioslave в KDE может не работать. </para>
</listitem>
<listitem>
<para>Для легкого размонтирования дисков обычными пользователями отредактируйте файл /usr/share/hal/fdi/policy/10osvendor/10-storage-policy.fdi, изменив user на users в строке &lt;merge key="storage.policy.default.mount_option.user" type="bool"&gt;true&lt;/merge&gt;. Если у вас нет такого файла, поищите похожий в /usr/share/hal. (Внимание: это работает для ivman 0.5.x, но не для последних версий ivman.) </para>
</listitem>
</orderedlist></section><section><info><title>Запуск Ivman от обычного пользователя</title></info>
<orderedlist>
<listitem>
<para>Для начала, у вас должен быть запущен HAL. Выполните как root: /etc/init.d/hald start </para>
</listitem>
<listitem>
<para>Для запуска HAL каждый раз при загрузке выполните: rc-update add hald default </para>
</listitem>
<listitem>
<para>Для запуска Ivman единично выполните команду ivman под вашим пользовательским аккаунтом. Чтобы Ivman запускался автоматически, когда вы входите в систему, вы должны сделать следующее: </para>
</listitem>
<listitem>
<para>Ivman запустится под вашим пользовательским аккаунтом. </para>
</listitem>
</orderedlist>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Вы можете не находиться в группе plugdev, потому что сейчас устройства монтируются так, что только вы имеете к ним доступ. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<orderedlist>
<listitem>
<para>По умолчанию сменные устройства будут монтироваться на запись/чтение для вас и не допускать больше никого. </para>
</listitem>
<listitem>
<para>Размонтирование работает как обычно. Работает стандартный pumount. Размонтирование используя 'media:/' ioslave в KDE работает. </para>
</listitem>
<listitem>
<para>Когда возможно (а, как правило, это возможно), запускайте Ivman одновременно от root и от обычного пользователя. В этом случае автомонтирование будет произведено от пользовательского запуска Ivman, а если пользовательский Ivman отсутствует, автомонтирование будет автоматически передано запуску Ivman от root. Не запускайте более одного пользовательского Ivman, даже под различающимися пользовательскими аккаунтами – это приведёт к войне за ресурсы. </para>
</listitem>
</orderedlist>
<para>Ivman не требует дополнительной конфигурации для автомонтирования. Данные fstab игнорируются, сменные устройства/диски будут смонтированы в /media. Однако, Ivman может быть использован не только для монтирования. Обретите свободу для добавления ваших супер-правил на этой странице  :-) </para></section><section><info><title> Примеры некоторых правил</title></info>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Смонтировать всё, что есть </para>
</entry>
</row>
<row>
<entry>
<para>    &lt;ivm:Match name="ivm.mountable" value="true"&gt;</para>
<para>        &lt;ivm:Option name="mount" value="true" /&gt;</para>
<para>    &lt;/ivm:Match&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Открыть мой MP3-плеер в mc, когда он подключен </para>
</entry>
</row>
<row>
<entry>
<para>    &lt;ivm:Match name="hal.info.product" value="IAUDIO"&gt;</para>
<para>        &lt;ivm:Option name="exec" value="xterm -e mc /home/share/music /media/IAUDIO" /&gt;</para>
<para>    &lt;/ivm:Match&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Открыть мою камеру в mc, когда она подключена </para>
</entry>
</row>
<row>
<entry>
<para>    &lt;ivm:Match name="hal.info.vendor" value="FUJIFILM"&gt;</para>
<para>        &lt;ivm:Option name="exec" value="xterm -e mc /home/share/pics /media/usbdisk/DCIM/100_FUJI" /&gt;</para>
<para>    &lt;/ivm:Match&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Для KDE </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Выводит всплывающее окошко, когда что-нибудь подключено </para>
</entry>
</row>
<row>
<entry>
<para>    &lt;ivm:Match name="hal.info.category" value="storage"&gt;</para>
<para>      &lt;ivm:Match name="hal.storage.bus" value="usb"&gt;</para>
<para>         &lt;ivm:Option name="exec" value="kdialog --passivepopup 'USB storage device detected: $hal.info.vendor$ $hal.info.product$' 4" /&gt;</para>
<para>      &lt;/ivm:Match&gt;</para>
<para>   &lt;/ivm:Match&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable></section></section><section><info><title> Проблемы </title></info>
<para> Использование записей в fstab (ivman 0.6.x или более новый)</para>
<para>Ivman 0.6.x или более новый использует pmount для монтирования устройств, и не нуждается в записях fstab. Но если хочеться, то можно. </para>
<para>pmount (и Ivman, таким образом) будет автоматически учитывать записи fstab. С версии 0.6.0, на каждую символьную ссылку будет создано правило, без использования IvmConfigMappings.xml. Устройства, не отмеченные в fstab, будут монтироваться в /media. </para>
<para>Использование записей в fstab (ТОЛЬКО ivman 0.5.x!)</para>
<para>Ivman 0.5.x может использовать ваш /etc/fstab. Если вы до этого пользовались supermount, вам необходимо изменить записи для использования ivman. Например: </para>
<para>/dev/cdroms/cdrom0      /mnt/cdrom      iso9660   noauto,ro     0 0</para>
<para>Может также потребоваться отключение devfs. </para>
<para/>
<para>Монтирование устройств с размонтированием от обычного пользователя (ТОЛЬКО ivman 0.5.x!)</para>
<para>Когда вы подключаете USB-носитель, ivman, запущеный от root монтирует его автоматически, но вы не можете размонтировать его иначе, чем от root. Это можно устранить, настроив HAL на монтирование всех устройств хранения данных с опцией "users", чего вам может очень не хотеться. </para>
<para>Создайте файл с названием whatever.fdi в директории /usr/share/hal/fdi/95userpolicy/ со следующим содержимым: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: whatever.fdi </para>
</entry>
</row>
<row>
<entry>
<para> &lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; &lt;!-- -*- SGML -*- --&gt; </para>
<para>  &lt;deviceinfo version="0.2"&gt; </para>
<para>    &lt;!-- Append users to default mount options --&gt; </para>
<para>   &lt;device&gt; </para>
<para>     &lt;merge key="storage.policy.default.mount_option.users" type="bool"&gt;true&lt;/merge&gt; </para>
<para>   &lt;/device&gt; </para>
<para>  &lt;/deviceinfo&gt;</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Для дополнительной информации смотрите <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://cvs.freedesktop.org/*checkout*/hal/hal/doc/spec/hal-spec.html">HAL Specifications</link>. </para>
<para/>
<para>Решение проблемы неразмонитирования флешки после ее физического удаления</para>
<para>Иногда может возникать ситуация что после удаления флешки команда mount выдает что она подмонтирована, в результате следующие подсоединение флешки приводит к тому что ей присваевается следующая буква и в резульатет чего возникает множество мертвых точек монтирования </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Пример ситуации когда два раза вынута и вставлена одна и таже флешка </para>
</entry>
</row>
<row>
<entry>
<para>#mount</para>
<para>/dev/sdb1 on /media/sdb1 type vfat (rw,noexec,nosuid,nodev,quiet,shortname=mixed,uid=104,gid=412,umask=007,fmask=0117,dmask=0007,iocharset=utf8)</para>
<para>/dev/sdc1 on /media/sdc1 type vfat (rw,noexec,nosuid,nodev,quiet,shortname=mixed,uid=104,gid=412,umask=007,fmask=0117,dmask=0007,iocharset=utf8)</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>это происходит из за того что по умолчанию ivman для размонтирования вызывает команду pumount /dev/sdb1, которая нечего не выполняет выдавая что /dev/sdb1 нет (udev успевает удалить это устройсво) </para>
<para>решение проблемы следующее правим /etc/ivman/IvmConfigBase.xml таким образом </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/ivman/IvmConfigBase.xml </para>
</entry>
</row>
<row>
<entry>
<para>    &lt;!-- mount command.  default is autodetected.  Must be specified with</para>
<para>         umountcommand. --&gt;</para>
<para>    &lt;ivm:Option name="mountcommand" value="/usr/bin/pmount -u 007 '$hal.block.device$'" /&gt;</para>
<para/>
<para>    &lt;!-- umount command.  default is autodetected.  Must be specified with</para>
<para>         mountcommand. --&gt;</para>
<para>    &lt;ivm:Option name="umountcommand" value="/usr/bin/sudo /bin/umount -l '$hal.block.device$'" /&gt;</para>
<para/>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>а так же добавляя в /etc/sudoers строчку </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/sudoers </para>
</entry>
</row>
<row>
<entry>
<para>   ivman   ALL = NOPASSWD: /bin/umount</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>sudo конечно же должен быть установлен. </para></section><section><info><title>Разное</title></info>
<para>HAL может потребовать добавление coldplug на уровень загрузки boot для работы распознавания USB-устройств. </para>
<para>Если у вас проблемы с пользовательскими запусками ivman для автомонтирования USB flash, вам может потребоваться включить поддержку utf-8 в вашем ядре. Смотрите это <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://forums.gentoo.org/viewtopic-p-3283175.html#3283175">обсуждение на форуме</link> для подробностей. </para></section><section><info><title>Другие проблемы</title></info>
<para>Если ivman не работает, для начала остановите его: </para>
<para>/etc/init.d/ivman stop </para>
<para>Отредактируйте базовые настройки: </para>
<para>nano -w /etc/ivman/IvmConfigBase.xml </para>
<para>Отключите fork, и включите отладку. Потом запустите ivman из консоли. Смотрите сообщения. </para>
<para>Источник — «<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/HOWTO_Ivman">http://ru.gentoo-wiki.com/HOWTO_Ivman</link>»</para>
<para/>
<para/>
<para/></section></section><section><info><title>Настройка дисковой подсистемы</title></info><section><info><title>Всеобщий ликбез</title></info>
<para/>
<para>Под IDE понимаются устройства, подключаемые к IDE-интерфейсу. Обычно это жесткие диски и дисководы CD-ROM. Эти устройства должны быть документированы, как:</para>
<para/>
<orderedlist>
<listitem>
<para>IDE </para>
</listitem>
<listitem>
<para>ATA </para>
</listitem>
<listitem>
<para>ATAPI </para>
</listitem>
<listitem>
<para>Enhanced IDE (EIDE) </para>
</listitem>
<listitem>
<para>Fast ATA или Fast ATA-2 </para>
</listitem>
</orderedlist>
<para/>
<para>IDE устройства могут передавать данные по шине в двух режимах - PIO и DMA. Учтите, что это именно передача данных по шине, с пластины данные читаются медленнее, а вот из аппаратного кеша на полной скорости. </para>
<para/>
<para>PIO - Программный ввод/вывод, метод передачи данных между двумя устройствами, использующий процессор как часть маршрута данных (процессор выполняет команду чтения порта, считывает байт или слово данных в свой регистр, после чего переписывает его в память, затем повторяет эту процедуру до тех пор, пока вся необходимая информация не будет считана из устройства в память). </para>
<para/>
<para>Бывает PIO Mode 0 1 2 3 4. Чем больше номер режима, тем быстрее. IDE ZIP100 приводы от Iomega например умеют только PIO mode 0. Старые CD-ROM обычно умеют PIO mode 4, если не могут DMA.</para>
<para/>
<orderedlist>
<listitem>
<para>PIO Mode 0 = 3.3 Mb/s </para>
</listitem>
<listitem>
<para>PIO Mode 1 = 5.2 Mb/s </para>
</listitem>
<listitem>
<para>PIO Mode 2 = 8.3 Mb/s </para>
</listitem>
<listitem>
<para>PIO Mode 4 = 11.1 Mb/s </para>
</listitem>
<listitem>
<para>PIO Mode 5 = 16.7 Mb/s </para>
</listitem>
</orderedlist>
<para/>
<para>DMA - Direct Memory Access - прямой доступ к памяти - собирательное название протоколов, позволяющих периферийному устройству передавать информацию непосредственно в системную память без участия центрального процессора, жесткие диски используют эту возможность в сочетании с возможностью перехватывать управление шиной и самостоятельно управлять передачей информации (bus mastering), что уменьшает нагрузку на процессор и повышает скорость передачи данных. </para>
<para/>
<para>DMA встречается двух типов: UDMA и MDMA. </para>
<para/>
<para>UDMA - ultra DMA - наиболее предпочитаемый тип, основной на сегодня. Бывает UDMA 0 1 2 3 4 5 6. Реально встречаются:</para>
<para/>
<orderedlist>
<listitem>
<para>UDMA 2 = 33 mb/s </para>
</listitem>
<listitem>
<para>UDMA 4 = 66 mb/s </para>
</listitem>
<listitem>
<para>UDMA 5 = 100 mb/s </para>
</listitem>
<listitem>
<para>UDMA 6 = 133 mb/s </para>
</listitem>
</orderedlist>
<para/>
<para>Последний встречается на не Intel матерях и не все винты его умеют. Кстати SATA винчестеры используют UDMA = 150 Mb/s. </para>
<para>Для UDMA 66 - 100 - 133 необходим 80-жильный шлейф, кроме того старые матери умеют его не на всех каналах, смотрите в инструкцию. Форсирование этих режимов с 40-жильным шлейфом может убить Ваши данные. </para>
<para>MDMA - multiword dma, более древний режим, предпочтителен для старых винчестеров и CD-ROM.</para>
<para/>
<orderedlist>
<listitem>
<para>MDMA0 = 4.2 mb/s </para>
</listitem>
<listitem>
<para>MDMA1 = 13.3 mb/s </para>
</listitem>
<listitem>
<para>MDMA2 = 16.7 mb/s </para>
</listitem>
</orderedlist>
<para/>
<para>На большинстве современных систем ядро автоматически определяет и настраивает IDE подсистему на максимальную производительность, если правильно его сконфигурировать. Но настроить что-нибудь всё равно можно. </para>
<para/>
<para>ОЧЕНЬ ВАЖНО </para>
<para>Всё нижеописанное может убить Ваши данные, сломать Вам винчестер, спалить Вашу машину, удивить Вашу кошку и т.п. отмазы :) </para>
<para>Всё нижеописанное тестировалось, работало и работает на пяти машинах с ядром 2.6.9-gentoo-r4 и hdparm-5.7-r1, ACCEPT_KEYWORDS="~x86". </para>
<para/>
<para>У Вас что-нибудь может не работать, работать не так. </para>
<para/>
<para>ВАЖНО </para>
<para>Всё нижеописанное не относится к SATA дискам работающим через libata интерфейс (то есть видимым как sdX а не hdX). Поскольку sata интерфейс гораздо ближе к scsi чем к pata, разработчики вполне обоснованно используют scsi подсистему для работы с sata. Поэтому на текущий момент настройка sata винчестеров средствами hdparm невозможна, так как в libata не реализована специфичная для подобных програм функциональность. </para>
<para/>
<para>В Сети есть патчик на ядро, добавляющий нужный функционал, но он ОЧЕНЬ сыр и с вероятностью в 100% убьёт вам раздел. Даже ссылку давать не буду, если Вы камикадзе, сами найдёте. </para><section><info><title>Для начала</title></info>
<para>Убедитесь, что Ваши IDE диски используют DMA интерфейс, и ядро правильно настроено. </para>
<para>Для этого сделайте :</para>
<para>dmesg | less </para>
<para>или загляните в логи. </para>
<para>Нас будут интересовать сообщения о настройке ide контроллера и дисков. Мой кусок kern.log выглядит так (с моими комментариями): </para>
<para>Nov 14 17:45:54 tsoptimus kernel: ide: Assuming 33MHz system bus speed for PIO modes; override with idebus=xx</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Можно при загрузке сказать ядру idebus=66, но это работает только для                                        не использующих DMA винчестеров и сидиромов. Подробности в /usr/src/linux/Documentation/ide.txt</para>
<para>Nov 14 17:45:54 tsoptimus kernel: ICH2: IDE controller at PCI slot 0000:00:1f.1</para>
<para>Nov 14 17:45:54 tsoptimus kernel: ICH2: chipset revision 2</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Определили первый контроллер.</para>
<para>Nov 14 17:45:54 tsoptimus kernel: ICH2: not 100%% native mode: will probe irqs later</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Это из-за того что интеловский контроллер использует разные прерывания для</para>
<para>каждого из каналов. Это нормально.</para>
<para>Nov 14 17:45:54 tsoptimus kernel:     ide0: BM-DMA at 0xf000-0xf007, BIOS settings: hda:DMA, hdb:pio</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>контроллер работает в busmaster режиме, dma для первого диска включен в BIOS. </para>
<para>Nov 14 17:45:54 tsoptimus kernel:     ide1: BM-DMA at 0xf008-0xf00f, BIOS settings: hdc:pio, hdd:DMA</para>
<para>Nov 14 17:45:54 tsoptimus kernel: Probing IDE interface ide0...</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hda: ST340016A, ATA DISK drive</para>
<para>Nov 14 17:45:54 tsoptimus kernel: ide0 at 0x1f0-0x1f7,0x3f6 on irq 14</para>
<para>Nov 14 17:45:54 tsoptimus kernel: Probing IDE interface ide1...</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hdd: DV-516E, ATAPI CD/DVD-ROM drive</para>
<para>Nov 14 17:45:54 tsoptimus kernel: ide1 at 0x170-0x177,0x376 on irq 15</para>
<para>Nov 14 17:45:54 tsoptimus kernel: PDC20265: IDE controller at PCI slot 0000:02:0a.0</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Определили интегрированный promise контроллер</para>
<para>Nov 14 17:45:54 tsoptimus kernel: ACPI: PCI interrupt 0000:02:0a.0[A] -&gt; GSI 17 (level, low) -&gt; IRQ 17</para>
<para>Nov 14 17:45:54 tsoptimus kernel: PDC20265: chipset revision 2</para>
<para>Nov 14 17:45:54 tsoptimus kernel: PDC20265: 100%% native mode on irq 17</para>
<para>Nov 14 17:45:54 tsoptimus kernel: PDC20265: (U)DMA Burst Bit ENABLED Primary MASTER Mode Secondary MASTER Mode.</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>BIOS этого уродца не включает DMA, поэтому его включило ядро :)</para>
<para>Nov 14 17:45:54 tsoptimus kernel:     ide2: BM-DMA at 0xac00-0xac07, BIOS settings: hde:pio, hdf:pio</para>
<para>^^^^^^^</para>
<para>Что мы собственно и наблюдаем.</para>
<para>Nov 14 17:45:54 tsoptimus kernel:     ide3: BM-DMA at 0xac08-0xac0f, BIOS settings: hdg:pio, hdh:pio</para>
<para>Nov 14 17:45:54 tsoptimus kernel: Probing IDE interface ide2...</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hde: FUJITSU MPG3204AT E, ATA DISK drive</para>
<para>Nov 14 17:45:54 tsoptimus kernel: ide2 at 0x9c00-0x9c07,0xa002 on irq 17</para>
<para>Nov 14 17:45:54 tsoptimus kernel: Probing IDE interface ide3...</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hda: max request size: 128KiB</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hda: 78165360 sectors (40020 MB) w/2048KiB Cache, CHS=65535/16/63, UDMA(100)</para>
<para>^^^^^^^^</para>
<para>Говорит само за себя</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hda: cache flushes not supported</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>А вот это странно :( Ядро не сможет принудительно синхронизировать аппаратный кеш винчестера, в случае panic или oops будет не сладко. До этого было supported, разберусь...</para>
<para>Nov 14 17:45:54 tsoptimus kernel:  /dev/ide/host0/bus0/target0/lun0: p1 p2 p3 p4</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hde: max request size: 128KiB</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hde: 40031712 sectors (20496 MB) w/512KiB Cache, CHS=39714/16/63, UDMA(100)</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hde: cache flushes not supported</para>
<para>Nov 14 17:45:54 tsoptimus kernel:  /dev/ide/host2/bus0/target0/lun0: p1 p2</para>
<para>Nov 14 17:45:54 tsoptimus kernel: hdd: ATAPI 48X DVD-ROM drive, 256kB Cache, UDMA(33)</para>
<para>Nov 14 17:45:54 tsoptimus kernel: Uniform CD-ROM driver Revision: 3.20 </para>
<para>Проверьте настройки ядра. Мой кусок касающийся IDE выглядит так (с моими комментариями) </para>
<para># ATA/ATAPI/MFM/RLL support</para>
<para>#</para>
<para>CONFIG_IDE=y</para>
<para>CONFIG_BLK_DEV_IDE=y</para>
<para/>
<para>#</para>
<para># Please see Documentation/ide.txt for help/info on IDE drives</para>
<para>#</para>
<para># CONFIG_BLK_DEV_IDE_SATA is not set</para>
<para># CONFIG_BLK_DEV_HD_IDE is not set</para>
<para>CONFIG_BLK_DEV_IDEDISK=y</para>
<para>#CONFIG_IDEDISK_MULTI_MODE is not set</para>
<para>CONFIG_BLK_DEV_IDECD=y</para>
<para># CONFIG_BLK_DEV_IDETAPE is not set</para>
<para># CONFIG_BLK_DEV_IDEFLOPPY is not set</para>
<para># CONFIG_BLK_DEV_IDESCSI is not set</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Был нужен для пишущих cdrom, сейчас не нужен (даже вреден)</para>
<para/>
<para>CONFIG_IDE_TASK_IOCTL=y</para>
<para>CONFIG_IDE_TASKFILE_IO=y</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Не разбирался :)</para>
<para>#</para>
<para># IDE chipset support/bugfixes</para>
<para>#</para>
<para># CONFIG_IDE_GENERIC is not set</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Не нужен если Ваши IDE контроллеры известны ядру. У 99% людей они известны. Посему выключен.</para>
<para># CONFIG_BLK_DEV_CMD640 is not set</para>
<para>CONFIG_BLK_DEV_IDEPCI=y</para>
<para>CONFIG_IDEPCI_SHARE_IRQ=y</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Разрешает устройству совместно использовать одно прерывание с другими устройствами. </para>
<para>В случае проблем можно выключить.</para>
<para># CONFIG_BLK_DEV_OFFBOARD is not set</para>
<para># CONFIG_BLK_DEV_GENERIC is not set</para>
<para># CONFIG_BLK_DEV_OPTI621 is not set</para>
<para># CONFIG_BLK_DEV_RZ1000 is not set</para>
<para>CONFIG_BLK_DEV_IDEDMA_PCI=y</para>
<para># CONFIG_BLK_DEV_IDEDMA_FORCED is not set</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>ОПАСНО!!!! Если ваш винт или контроллер совсем никак не умеет DMA</para>
<para>или blacklisted, то есть риск потерять раздел.</para>
<para>CONFIG_IDEDMA_PCI_AUTO=y</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>А вот это значительно нежнее :) Если с винтом и контроллером всё в порядке, ядро само включит Вам DMA.</para>
<para># CONFIG_IDEDMA_ONLYDISK is not set</para>
<para>Ежели ваш CDROM глючит с DMA или работает медленне чем в PIO режиме, ядро включит DMA только для винчестеров.</para>
<para># CONFIG_BLK_DEV_AEC62XX is not set</para>
<para># CONFIG_BLK_DEV_ALI15X3 is not set</para>
<para># CONFIG_BLK_DEV_AMD74XX is not set</para>
<para># CONFIG_BLK_DEV_ATIIXP is not set</para>
<para># CONFIG_BLK_DEV_CMD64X is not set</para>
<para># CONFIG_BLK_DEV_TRIFLEX is not set</para>
<para># CONFIG_BLK_DEV_CY82C693 is not set</para>
<para># CONFIG_BLK_DEV_CS5520 is not set</para>
<para># CONFIG_BLK_DEV_CS5530 is not set</para>
<para># CONFIG_BLK_DEV_HPT34X is not set</para>
<para># CONFIG_BLK_DEV_HPT366 is not set</para>
<para># CONFIG_BLK_DEV_SC1200 is not set</para>
<para>CONFIG_BLK_DEV_PIIX=y</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Контроллер моей материнки</para>
<para># CONFIG_BLK_DEV_NS87415 is not set</para>
<para>CONFIG_BLK_DEV_PDC202XX_OLD=y</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Второй контроллер моей материнки</para>
<para>CONFIG_PDC202XX_BURST=y</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Форсируем DMA для promise, так как его биос DMA не включает. Странный он.</para>
<para># CONFIG_BLK_DEV_PDC202XX_NEW is not set</para>
<para># CONFIG_BLK_DEV_SVWKS is not set</para>
<para># CONFIG_BLK_DEV_SIIMAGE is not set</para>
<para># CONFIG_BLK_DEV_SIS5513 is not set</para>
<para># CONFIG_BLK_DEV_SLC90E66 is not set</para>
<para># CONFIG_BLK_DEV_TRM290 is not set</para>
<para># CONFIG_BLK_DEV_VIA82CXXX is not set</para>
<para># CONFIG_IDE_ARM is not set</para>
<para>CONFIG_BLK_DEV_IDEDMA=y</para>
<para># CONFIG_IDEDMA_IVB is not set</para>
<para>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>Форсирование UDMA4 5 6 если ядро само его не включает. </para>
<para>ОПАСНО - если у Вас 40-жильный или повреждённый шлейф, вы можете убить данные.</para>
<para>CONFIG_IDEDMA_AUTO=y</para>
<para># CONFIG_BLK_DEV_HD is not set</para>
<para/>
</section>
    <section><info><title>Ускоряемся :)</title></info>
<para>Сделайте, если ещё не сделали, </para>
<para>emerge hdparm </para>
<para>На одной консоли сделайте:</para>
<para>man hdparm </para>
<para>А на другой мы начнём играться :) </para>
<para>Делайте: </para>
<para>hdparm -tT /dev/hdX </para>
<para/>
<para>Где X - буква вашего винчестера </para>
<para>Мы запустили тест скорости чтения из кеша и с пластины. Для усреднения результатов запустите его несколько раз. </para>
<para>Должны увидеть следующее:</para>
<para/>
<para>/dev/hda:</para>
<para>Timing cached reads:   616 MB in  2.00 seconds = 307.74 MB/sec</para>
<para>Timing buffered disk reads:   74 MB in  3.04 seconds =  42.33 MB/sec</para>
<para/>
<para>Первый результат с учётом программного кеширования, он у всех большой :) </para>
<para/>
<para>Второй - собственно чтение с диска с учётом аппаратного кеширования. </para>
<para/>
<para>Второй результат мы собственно и будем улучшать :) Цифры в районе 35-55 mb/s хороший результат, выше 50 без raid контроллера вы на парралельном интерфейсе вряд ли получите (хотя... кто знает...). Но в любом случае кроме скорости можно </para>
<para>Разбираемся с железом на железном уровне</para>
<para/>
<para>Имеет смысл заглянуть в BIOS и в корпус. </para>
<para/>
<para>ВНИМАНИЕ!!! Если вы страдаете хронической неуверенностью, криворукостью, боитесь потерять гарантию, пропустите этот раздел! </para>
<para/>
<para>Иногда сборщики компьютеров страдают излишней жадностью или криворукостью, поэтому всегда имеет смысл проверить, всё ли внутри корпуса как надо. </para>
<para/>
<para>Каждый канал IDE/AТА интерфейса поддерживает подключение двух устройств - master и slave. Конфигурация обычно задается перемычкой на устройстве. Кроме этих двух позиций там обычно присутствует и третья - cable select. Для работы устройств в положении перемычки cable select требуется специальный Y-образный шлейф, центральный разъем которого подключается к материнской плате. Крайние разъемы такого кабеля неравноправны - устройство, подключенное к одному разъему, автоматически становится master, к другому - slave. </para>
<para>Проверьте, чтобы шлейфы были 80-жильные, на 40-жильных вы не сильно ускоритесь :). </para>
<para>Каждый канал в каждый момент времени может обрабатывать только один запрос к одному устройству. Следующий запрос, пусть даже к другому устройству, будет ожидать завершения текущего. Разные каналы при этом могут работать независимо. Поэтому не стоит подключать два активно используемых устройства (например, два жестких диска), к одному каналу. </para>
<para>В идеале каждое IDE-устройство стоит подключать к отдельному каналу (в этом заключается основное преимущество SATA). </para>
<para>Практически все современные чипсеты поддерживают возможность использования различных режимов передачи данных для устройств, подключенных к одному каналу. Однако злоупотреблять этим все-таки не стоит. Два устройства, существенно различающихся по скорости, лучше все-таки разнести по разным каналам. </para>
<para>Не рекомендуется подключать к одному каналу жесткий диск и ATAPI-устройство (например, CD-ROM). Как было сказано выше, протокол ATAPI использует другую систему команд, и, кроме того, даже самые быстрые ATAPI-устройства намного медленнее жесткого диска, что может замедлить работу последнего.</para>
<para/>
<para/>
<para>Идеальная конфигурация. </para>
<para>Каждый винт и CD-ROM на отдельном шлейфе. </para>
<para/>
<para>Приемлемая конфигурация. </para>
<para>На первом канале основной винт, на втором дополнительный master и CD-ROM slave</para>
<para/>
<para>Тоже неплохо. </para>
<para>На первом канале два винчестера одного поколения, CD-ROM на втором.</para>
<para/>
<para>Плохо!!! </para>
<para>На одном канале современный винт и древняя древность на полтора гига :) </para>
<para/>
<para>Смотрим в BIOS. Включаем UDMA где только можно, включаем Bus master для контроллеров IDE, включаем IDE Block mode. </para>
<para/></section><section><info><title>Разбираемся с железом на софтварном уровне</title></info>
<para>А что умеет наш винчестер? И что у него включено сейчас?</para>
<para/>
<para>Делаем: </para>
<para>hdparm -iIv /dev/hdX | less </para>
<para/>
<para>Получаем длинный листинг с описанием возможностей нашего винчестера. Пример моего с комментариями приведён ниже. </para>
<para>Эта секция коротко описывает, что у нас включено прямо сейчас.</para>
<para/>
<para>/dev/hda:</para>
<para>multcount    = 16 (on)</para>
<para>IO_support   =  1 (32-bit)</para>
<para>unmaskirq    =  1 (on)</para>
<para>using_dma    =  1 (on)</para>
<para>keepsettings =  0 (off)</para>
<para>readonly     =  0 (off)</para>
<para>readahead    = 256 (on)</para>
<para>geometry     = 65535/16/63, sectors = 40020664320, start = 0</para>
<para>Эта секция показывает необработанные для читабельности данные, прочитанные напрямую с винчестера. </para>
<para>Model=ST340016A, FwRev=3.19, SerialNo=3HS9R2GG</para>
<para>Config={ HardSect NotMFM HdSw&gt;15uSec Fixed DTR&gt;10Mbs RotSpdTol&gt;.5% }</para>
<para>RawCHS=16383/16/63, TrkSize=0, SectSize=0, ECCbytes=4</para>
<para>BuffType=unknown, BuffSize=2048kB, MaxMultSect=16, MultSect=16</para>
<para>CurCHS=4047/16/255, CurSects=16511760, LBA=yes, LBAsects=78165360</para>
<para>IORDY=on/off, tPIO={min:240,w/IORDY:120}, tDMA={min:120,rec:120}</para>
<para>PIO modes:  pio0 pio1 pio2 pio3 pio4</para>
<para>DMA modes:  mdma0 mdma1 mdma2</para>
<para>UDMA modes: udma0 udma1 udma2 udma3 udma4 *udma5</para>
<para>AdvancedPM=no WriteCache=enabled</para>
<para>Drive conforms to: device does not report version:</para>
<para/>
<para>* signifies the current active mode</para>
<para>А вот это более интересно. Читайте комментарии в ней самой. </para>
<para>ATA device, with non-removable media</para>
<para>       Model Number:       ST340016A</para>
<para>       Serial Number:      3HS9R2GG</para>
<para>       Firmware Revision:  3.19</para>
<para>Standards:</para>
<para>       Supported: 5 4 3 2</para>
<para>       Likely used: 6</para>
<para>Configuration:</para>
<para>       Logical         max     current</para>
<para>       cylinders       16383   4047</para>
<para>       heads           16      16</para>
<para>       sectors/track   63      255</para>
<para>       --</para>
<para>       CHS current addressable sectors:   16511760</para>
<para>       LBA    user addressable sectors:   78165360</para>
<para>       device size with M = 1024*1024:       38166 MBytes</para>
<para>       device size with M = 1000*1000:       40020 MBytes (40 GB)</para>
<para>Capabilities:</para>
<para>       LBA, IORDY(can be disabled)</para>
<para>       bytes avail on r/w long: 4      Queue depth: 1</para>
<para>       Standby timer values: spec'd by Standard</para>
<para>       R/W multiple sector transfer: Max = 16  Current = 16</para>
<para>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>       Аппаратное блочное чтение. Может читать зараз 16 блоков. Так и делает.</para>
<para/>
<para>       Recommended acoustic management value: 128, current value: 254</para>
<para>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>       Управление акустикой. Чем больше значение, тем шумнее и быстрее.</para>
<para/>
<para>       DMA: mdma0 mdma1 mdma2 udma0 udma1 udma2 udma3 udma4 *udma5</para>
<para>            Cycle time: min=120ns recommended=120ns</para>
<para>       PIO: pio0 pio1 pio2 pio3 pio4</para>
<para>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</para>
<para>       Поддерживаемые режимы передачи. Звёздочка показывает текущий. </para>
<para> </para>
<para>            Cycle time: no flow control=240ns  IORDY flow control=120ns</para>
<para>Commands/features:</para>
<para>       Enabled Supported:</para>
<para>          *    READ BUFFER cmd</para>
<para>          *    WRITE BUFFER cmd</para>
<para>          *    Host Protected Area feature set</para>
<para>          *    Look-ahead</para>
<para>          *    Write cache</para>
<para>          *    Power Management feature set</para>
<para>               Security Mode feature set</para>
<para>          *    SMART feature set</para>
<para>               Device Configuration Overlay feature set</para>
<para>          *    Automatic Acoustic Management feature set</para>
<para>               SET MAX security extension</para>
<para>          *    DOWNLOAD MICROCODE cmd</para>
<para>Security:</para>
<para>       Master password revision code = 65534</para>
<para>               supported</para>
<para>       not     enabled</para>
<para>       not     locked</para>
<para>       not     frozen</para>
<para>       not     expired: security count</para>
<para>       not     supported: enhanced erase </para>
<para>HW reset results:</para>
<para>       CBLID- above Vih</para>
<para>       Device num = 1</para>
<para>Checksum: correct</para>
<para/>
<para>Имея эту информацию, мы можем ручками настраивать наш винчестер. Те параметры, которые и так настроены, настраивать не обязательно :). Сверяйтесь с man для hdparm, я расскажу про наиболее интересные параметры. \</para>
<para>Собственно настраиваем</para>
<para>Итак, параметры мы передаём как:</para>
<para> </para>
<para>hdparm -параметр /имя/диска</para>
<para/>
<para>Если hdparm ругается, значит или режим не поддерживается, или параметр не верный. Если режим не поддерживается, команда dmesg покажет нам последней строчкой ругань драйвера.</para>
<para/></section><section><info><title>Интересные параметры </title></info>
<para/>
<para>-a Количество секторов упреждающего чтения для файловой системы, то есть софтварное упреждающее чтение. Обычно значение по дефолту приемлемое, а наличие аппаратного упреждающего чтения смазывает эффект. Чем меньше, тем лучше в случае чтения кучи мелких файлов разбросанных хаотично по диску. Чем больше число, тем лучше для копирования фильмов и mp3. </para>
<para/>
<para>-A Включение аппаратного упреждающего чтения винчестером. Обычно всегда включено по дефолту. Изменять следует, если в вышеописаном информационном выводе не стоит звёздочка перед Look-ahead в разделе Enabled Supported. 1 - включено, 0 - выключено. </para>
<para/>
<para>-B Имеет смысл для нотебуков, управляет настройкой энергосбережения. Чем значение ниже, тем больше у винта желание остановить блин и заснуть :), от чего растёт время отклика. Значение 255 вырубает управление питанием, соответственно уменьшая время отклика. Не все винчестеры имеют собственное управление питанием. Проверьте параметр AdvancedPM= в коротком листинге с сырыми данными. </para>
<para/>
<para>-c Значение 1 включает 32 битную передачу по внутренней шине, по шлейфу возможно только 16 бит. Значение 3 включает то-же самое с контролем чётности. Это более надёжно, но чуть медленне чем 1. По умолчанию всегда выключено, имеет смысл включить. разницы между 1 и 3 не заметил ни по скорости, ни по надёжности. </para>
<para/>
<para>-d 1 - включено, 0 - нет. Признак использования DMA. Если у Вас стоит звёздочка напротив одного из dma режимов в вышеприведённых листингах, значит Вам этот параметр не нужен. Если не стоит, можно попробовать включить. ВНИМАНИЕ!!! Машина может зависнуть, раздел может навернуться!!! Если это случилось, что-то крепко не в порядке с железом или ядром!!! </para>
<para/>
<para>-E Скорость cdrom. Если сильно воет... Просто укажите желаемую скорость. Для винтов бесполезен :) </para>
<para/>
<para>-k и -K Сохранение настроек и опций винчестером. Это не означает что они автоматически сохранятся после перезагрузки. Это означает, что они сохранятся, если драйвер сделает reset контроллеру, или после спячки, но не гибернации (aka suspend to disk). 1 - сохранять. 0 - нет. </para>
<para/>
<para>-m Количество секторов для аппаратного упреждающего чтения. Не может быть больше чем умеет винт. Смотреть в диагностический листинг, параметр MaxMultSect=. По дефолту обычно всегда максимум. </para>
<para/>
<para>-M Управление акустикой. 254 - шумно и быстро. 0 - медленно и тихо. Многие драйвы умеют только 128 и 254. Многие вообще нисколько не умеют :) </para>
<para/>
<para>-P Ещё одна ручка для регулирования аппаратного упреждающего чтения. Не работает ни на одном виденном мною винте. Может у Вас заработает? </para>
<para/>
<para>-u Включить размаскирование прерываний. Если значение 1, то контроллер разрешает другие прерывания во время операции ввода-вывода. Это снижает нагрузку на систему и повышает отклик. Нужно включать. По умолчанию выключено. На оччень древних контроллерах система может повиснуть. </para>
<para/>
<para>-W 1 - включает кеширование записи. Включено по дефолту у всех виденных мною винтов. Но пригодится может. </para>
<para/>
<para>-X Самый мощный параметр. Позволяет вам принудительно выставить режим работы DMA. В последних версиях hdparm задаётся буквенно, например -X udma5. Внимание!!! Не включайте режимы, не поддерживаемые Вашим контроллером, или с плохим (40-жильным) шлейфом!!! Обычно ядро само выбирает максимальный режим DMA, и если оно не смогло, или выбрало как Вам кажется меньший режим чем можно, ПОДУМАЙТЕ!!! Вдруг тому есть ОБЪЕКТИВНЫЕ причины?.</para>
<para/>
<para>Пробуйте параметры по одному, запускайте hdparm -tT, смотрите в dmesg. </para>
<para>Сидиромы понимают не все параметры из указанных выше. У разных винчестеров понимание тоже может отличаться :)</para>
<para>После того как наиграетесь, будем закреплять. </para></section><section><info><title>Закрепляем</title></info>
<para>В /etc/conf.d/hdparm заносим понравившиеся параметры. У меня это выглядит так: </para>
<para>hda_args="-u1c3M254Kk"</para>
<para>hde_args="-u1c3M254Kk"</para>
<para>#hdd - cdrom</para>
<para>hdd_args="-u1c3Kk"</para>
<para/>
<para>Делаем: rc-update add hdparm default </para>
<para>Затем: /etc/init.d/hdparm start </para>
<para/></section><section><info><title>Выбор планировщика ввода-вывода</title></info>
<para/>
<para>В ядрах 2.6 появилась возможность выбирать между четырьмя планировщиками ввода-вывода. У каждого планировщика есть свои достоинства и недостатки. По дефолту в ядро всунуты все четыре, и выбран anticipatory io cheduler. Кратенько опишу их. </para>
<para>no-op - очень мелкий и лёгкий планировщик. Мало чего умеет. Для винтов не пригоден. В основном используется если вместо винта - флеш. </para>
<para>anticipatory - выбирается по дефолту. Середина-наполовину для всего на свете. И там хорош, и тут хорош. </para>
<para>deadline - более лёгкий и простой чем anticipatory, лучше себя ведёт при "взрывных" нагрузках. При равномерной нагрузке имеет особенность задумываться и притормаживать. </para>
<para>CFQ - размазывает ввод-вывод равномерно между всеми процессами. Ввод-вывод медленный, но плавный и равномерный независимо от загрузки. Это мой выбор на сегодня. </para></section><section><info><title>Как попробовать?</title></info>
<para>Передайте ядру в строке загрузки GRUB или другого загрузчика параметр elevator=[cfq|as|deadline|noop], поработайте, сравните. Ненужные планировщики ввода/вывода можно убрать из конфигурации ядра перед его компиляцией. Подробней можно узнать в статье "Компиляция ядра Linux". Они в </para>
<para>general setup -&gt;</para>
<para>   Configure standart kernel features...</para>
<para/>
<para>Как нибудь потом расскажу про тюнинг vm и свопа ... </para>
<para/>
<para/></section></section></section><section><info><title>Работа с CD/DVD</title></info><section><info><title>Основные программы </title></info>
<para/>
<para>Для начала, убедитесь что у вас установлены программы cdrecord и mkisofs, которые входят в пакет cdrtools. Если нет -- установите его: </para>
<para/>
<para>emerge cdrtools </para>
<para/>
<para>Конфигурация ядра и загрузчика </para>
<para/>
<para>Убедитесь, что у вас ядро настроено соответствующим образом. </para>
<para/>
<para>Ядра серии 2.4.x </para>
<para/>
<para>Для ядер серии 2.4.x в ядро необходимо включить поддержку SCSI эмуляции: Linux Kernel Configuration: </para>
<para/>
<para>Конфигурация ядра 2.4.x </para>
<para>ATA/IDE/MFM/RLL Support --&gt;</para>
<para>    IDE, ATA, and ATAPI Block Devices --&gt;</para>
<para>        &lt;M&gt; SCSI Emulation Support</para>
<para>SCSI Support --&gt;</para>
<para>    &lt;M&gt; SCSI Support</para>
<para>    &lt;M&gt; SCSI CDROM Support</para>
<para>    &lt;M&gt; SCSI Generic Support</para>
<para/>
<para/>
<para>Теперь, еще необходимо ядру при загрузке передать параметр hdc=ide-scsi (в данном случае предполагается, что ваш CD привод - это hdc). </para>
<para/>
<para>Т.е. если вы используете grub, то его конфиг должен выглядеть примерно так: </para>
<para/>
<para>Файл: /boot/grub/grub.conf </para>
<para>title Gentoo Linux</para>
<para> root (hd#,#)</para>
<para> kernel (hd#,#)/YOUR_KERNEL_NAME_HERE root=/dev/hdx# hdc=ide-scsi ANY_OTHER_KERNEL_OPTIONS_NEEDED</para>
<para/>
<para>Т.е. если вы используете grub, то его конфиг должен выглядеть примерно так: </para>
<para>Файл: /boot/grub/grub.conf </para>
<para>title Gentoo Linux</para>
<para> root (hd#,#)</para>
<para> kernel (hd#,#)/YOUR_KERNEL_NAME_HERE root=/dev/hdx# hdc=ide-scsi ANY_OTHER_KERNEL_OPTIONS_NEEDED</para>
<para/>
<para>Если вы ипользуете lilo, то соответсвующая часть конфига: </para>
<para>Файл: /etc/lilo.conf </para>
<para># Linux bootable partition config</para>
<para>    image  = /boot/YOUR_KERNEL_NAME_HERE</para>
<para>    append = "hdc=ide-scsi"</para>
<para>    root   = /dev/hdx#</para>
<para>    label  = Gentoo</para>
<para>    read-only</para>
<para/>
<para>Ядра серии 2.6.x </para>
<para/>
<para>В ядрах серии 2.6.x вам уже нет необходимости включать SCSI (и, следовательно, не надо переконфигурировать загрузчик). Вместо этого, надо указать поддержку ATAPI CDROM: Linux Kernel Configuration:</para>
<para> Конфигурация ядра 2.6.x </para>
<para>Device Drivers  --&gt;</para>
<para>    ATA/ATAPI/MFM/RLL support --&gt;</para>
<para>        &lt;*&gt; Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support</para>
<para>            &lt;*&gt; Include IDE/ATAPI CDROM support</para>
<para/>
<para/>
<para>Подготовка ISO образа </para>
<para>Для начала, создайте папку: </para>
<para>mkdir /tmp/iso </para>
<para>а затем скопируйте все файлы, которые вы хотите записать, в созданную папку. cp *.doc /tmp/iso </para>
<para>Затем создайте image.iso mkisofs -o /tmp/image.iso /tmp/iso </para>
<para/>
<para>Дополнительные опции при создании ISO образа </para>
<para>-r : добавляет (частично) поддержку так называемых расширений Rock Ridge, т.е. сохраняет специфичные для unix аттрибуты файлов. Например, добавляет поддержку длинных имён (до 255 символов, но не для MS Windows), символических ссылок. В отличие от опции -R, которая полностью соответсвует Rock Ridge, права доступа на файлы не сохраняются, они становятся доступны для чтения любому пользователю. </para>
<para>-jcharset=koi8-r: подразумевает под собой 2 опции: 1) -J включает поддержку Joliet, которая используется для распознавания длинных имён файлов под MS Windows; 2) -input-charset: устанавливает перекодировку символов для корректного отображения русских имён файлов. ("koi8-r" здесь дано для примера - замените на кодироку, используемую в вашей системе) </para>
<para>-joliet-long: Позволяет, чтобы имена Joliet могли быть установлены в 103 Unicode сивволы.  Это нарушает Joliet спецификацию - но работает. Используйте с осторожностью.</para>
<para>-f : следование символическим ссылкам. Если вместо копирования файлов в /tmp/iso, вы просто создаёте в этой директории симлинки на них, то вы должны включить эту опцию. </para>
<para>-C : эта опция необходима, если вы хотите дописать мультисессионный диск (см. раздел [Как дописывать диски]) </para><section><info><title>Определение ATAPI-приводов </title></info>
<para/>
<para>Выполните cdrecord --dev=ATAPI --scanbus </para>
<para/>
<para>Вы должны увидеть нечто похожее на следующее: </para>
<para/>
<para>Cdrecord-Clone 2.01a25 (i686-pc-linux-gnu) Copyright (C) 1995-2004 J?rg Schilling</para>
<para>scsidev: 'ATAPI'</para>
<para>devname: 'ATAPI'</para>
<para>scsibus: -2 target: -2 lun: -2 </para>
<para>Warning: Using ATA Packet interface.</para>
<para>Warning: The related libscg interface code is in pre alpha. </para>
<para>Warning: There may be fatal problems. </para>
<para>Using libscg version 'schily-0.8'.</para>
<para>scsibus0:</para>
<para>       0,0,0     0) 'SONY    ' 'CD-RW  CRX175A1 ' '5YS2' Removable CD-ROM</para>
<para>       0,1,0     1) *</para>
<para>       0,2,0     2) *</para>
<para>       0,3,0     3) *</para>
<para>       0,4,0     4) *</para>
<para>       0,5,0     5) *</para>
<para>       0,6,0     6) *</para>
<para>       0,7,0     7) *</para>
<para/>
<para>Здесь показано, что на шине 0,0,0 есть CD-RW привод. Предупреждение: В новых версиях cdrtools (2.01.01) и ядра 2.6.x надо писать cdrecord --dev=ATA --scanbus </para>
<para/></section><section><info><title>Запись ISO образа </title></info>
<para/>
<para>cdrecord --dev=ATA:0,0,0 /tmp/image.iso </para>
<para/>
<para>(Замените шину 0,0,0 на необходимую) Примечание: Вместо dev=ATA:0,0,0 можно указывать просто имя устройства, напирмер, dev=/dev/cdrw </para>
<para/></section><section><info><title>Дополнительные возможности </title></info>
<para/>
<para>Используйте опцию --speed=# для указания скорости записи </para>
<para/>
<para>cdrecord --dev=ATAPI:0,0,0 --speed=4 /tmp/image.iso </para>
<para/>
<para>Используйте --blank=fast для быстрой очистки CD-RW диска. </para>
<para/>
<para>cdrecord --dev=ATAPI:0,0,0 --blank=fast </para>
<para/>
<para>Большинство современных записывающих устройств поддерживает технологию BURN-free. К сожалению она не включена по умолчанию при запуске cdrecord. Для включения, добавьте опцию --driveropts=burnfree. Вы можете посмотреть, какие ещё опции поддерживает ваш CD-ROM посредством команды</para>
<para> cdrecord dev=/dev/cdrw driveropts=help -checkdrive </para>
<para/>
<para>Если в файле /etc/default/cdrecord установить переменную CDR_DEVICE=ATAPI:0,0,0 (можно и CDR_DEVICE=/dev/hdc), то не придется каждый раз указывать устройство (ключ --dev=ATAPI:0,0,0) и тогда для очистки CD-RW диска понадобится набрать только следуюшее: </para>
<para/>
<para>cdrecord --blank=fast </para>
<para>Если нужно разрешить пользователю запись на CD, то включите его в группу cdrom. </para>
<para/></section><section><info><title>Копирование дисков </title></info>
<para/>
<para>Если у вас всего один CD-ROM, то необходимо вначале создать файл-образ диска. Это можно сделать многими способами (с помощью dd, cat, cdrdao, readcd и т.д.). Лучше воспользоваться readcd, т.к. он уже входит в пакет cdrtools, и имеет множество интересных опций (смотри man readcd): readcd dev=/dev/cdrw -clone f=/tmp/image.iso </para>
<para>После этого запишем образ на болванку с помощью cdrecord:</para>
<para> cdrecord -v -eject dev=/dev/cdrw -raw96r -clone /tmp/image.iso </para>
<para/>
<para>ВАЖНО: Ключи -raw96r и -clone необходимы ТОЛЬКО если вы создавали файл-образ с помощью команды readcd -clone. </para>
<para/></section><section><info><title>Как дописывать диски </title></info>
<para/>
<para>Прежде всего, при создании и последующем дописывании мульти-сессионных дисков, необходимо всегда для cdrecord указывать опцию -multi, а для mkisofs использовать ключ -r или -R (т.е. включать расширение Rock Ridge). Таким образом создание первой сессий будет выглядить примерно так: Code: Запись первой сессии </para>
<para/>
<para>mkisofs -r -f -jcharset=koi8-r -o /tmp/image.iso /tmp/iso/ </para>
<para/>
<para>cdrecord -v -multi driveropts=burnfree -eject dev=/dev/cdrw /tmp/image.iso </para>
<para/>
<para>Для создания последующих сессий, нам нужна информация о номере начального сектора последней сессии и о номере сектора с которого будет начинаться новая сессия. Эта пара чисел выводится командой cdrecord -msinfo dev=/dev/cdrw. После этого данные числа указываются в команде mkisofs в качетстве аргументов к опции -C. Также, чтобы были видны файлы из предыдущей сессии, необходим ключ -M, аргументом к ключу -М служит имя устройства вашего CD-ROM (т.е. в нашем примере - это /dev/cdrw). Команда cdrecord остаётся такой же. Резюмируя вышесказанное получаем для записи последующей сессии: Code: Запись последующих сессий </para>
<para/>
<para>mkisofs -r -f -jcharset=koi8-r -C $(cdrecord dev=/dev/cdrw -msinfo) -M /dev/cdrw -o /tmp/image.iso /tmp/iso/ </para>
<para/>
<para>cdrecord -v -multi driveropts=burnfree -eject dev=/dev/cdrw /tmp/image.iso </para>
<para/>
<para/></section><section><info><title>Полезные ссылки </title></info>
<para>Классическое how-to по записи дисков на английском языке: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.tldp.org/HOWTO/CD-Writing-HOWTO.html%20">http://www.tldp.org/HOWTO/CD-Writing-HOWTO.html </link>
</para>
<para>То же самое на русском:</para>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.opennet.ru/docs/HOWTO-RU/CD-Writing-HOWTO.html%20">http://www.opennet.ru/docs/HOWTO-RU/CD-Writing-HOWTO.html </link>
</para>
<para>Создание аудио дисков (на английском языке): en:</para>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://gentoo-wiki.com/HOWTO_Create_an_Audio_CD">HOWTO Create an Audio CD</link>
</para>
<para/></section></section></section><section><info><title>Создание DVD</title></info><section><info><title>Введение</title></info><section><info><title>О чем эта статья</title></info>
<para/>
<para>В данной статье будет подробно рассмотрен вопрос формирования и записи видео дисков формата DVD в Gentoo Linux. </para>
<para/></section><section><info><title>Необходимые программы</title></info>
<para/>
<para>Для начала, убедитесь что у вас установлены следующие программы: transcode </para>
<para/>
<para>emerge -n transcode </para>
<para>cdrecord и mkisofs </para>
<para/>
<para>emerge -n cdrtools </para>
<para>growisofs </para>
<para/>
<para>emerge -n dvd+rw-tools </para>
<para>dvdauthor </para>
<para/>
<para>emerge -n dvdauthor </para>
<para/>
<para>также могут пригодиться: kino </para>
<para/>
<para>emerge -n kino </para>
<para/>
<para>cinelerra </para>
<para/>
<para>emerge -n cinelerra-cvs </para>
<para/>
<para>dvdrip </para>
<para/>
<para>USE='cdr mplayer ogg subtitles xvid rar' emerge -n dvdrip </para>
<para/>
<para>replex </para>
<para/>
<para>emerge -n replex </para>
<para>cdrecord-prodvd </para>
<para/>
<para>emerge -n cdrecord-prodvd </para>
<para/></section><section><info><title>Кодирование видео в формате DVD</title></info>
<para/>
<para>Использование transcode для декодирования видео произвольного формата и кодирования его в формат MPEG2, совместимый с DVD</para>
<para/>
<para>Хотелось бы заметить, что если вы не любители программ с кучей непонятных опций, то вам следует попробовать программу dvdrip, которая является неплохим фронтендом для transcode с понятным интерфейсом. </para>
<para/>
<para>Transcode, пожалуй, лучший инструмент для нашей задачи. Вам, возможно, придётся заглянуть в man страницу по transcode, чтобы понять те команды, которые используются здесь. Также вам могут пригодиться и другие инструменты для декодирования и кодирования вашего формата, так что не поленитесь заглянуть и в их man странички. Здесь будет приведен пример того, как конвертировать стандартный divx файл в широэкранный формат (без черных полос сверху и снизу). Затем мы конвертируем все это в формат letterbox 1.5:1. Зачем, спросите вы. Затем, что изначально широкоэкранный формат имеет соотношение 1.73 (16:9) с разрешением 720x416. DVD в свою очередь поддерживает размеры изображения только 720x480, 704x480, 352x480 и 352x240 (возможно это не все). Поэтому самое простое и качественное решение здесь - это привести наше видео к формату 720x480 (соотношение 1.5), добавив по 32 черных полоски сверху и снизу к изображению. </para>
<para/>
<para>transcode -i test-divx.avi -V -y mpeg -F d -Y -32,0,-32,0 -E 44100 -b 128 -o showgirls-dvd</para>
<para/>
<para>Отрицательные значения для параметра -Y сообщают transcode о том, чтобы добавить нужное количество черных полосок сверху и снизу. Если использовать положительные значения, то полоски будут соответственно убираться сверху и снизу. Часто вам может попасться видео уже в формате 720x480 или еще каком-то "хорошем" формате, тогда не нужно изменять его размеры, то есть просто не используйте опцию -Y. </para>
<para/>
<para>Here's what some of those command line arguments mean: Вот, что означают остальные опции: </para>
<para>-V     использовать YV12/I420 в качестве встроенного видео кодека [выключено изначально]</para>
<para>       Это, как правило, намного быстрее чем RGB процессинг, но </para>
<para>       некоторые импортированные модули могут не поддерживать этот формат.</para>
<para>       Используйте эту опцию всегда, когда это возможно.</para>
<para>-y vmod[,amod]</para>
<para>       видео[,аудио] модули для эксопртирования [отсутствуют изначально].  </para>
<para>       Если опустить, то transcode не будет кодировать никаким модулем.</para>
<para>       Полностью установленный transcode имеет следующие модули:</para>
<para> &lt;вырезано&gt;</para>
<para> mpeg - (видео) MPEG 1/2 | (аудио) MPEG 1 Layer II</para>
<para>     nasm должен быть доступен во время компиляции. Этот модуль не имеет</para>
<para>     зависимостей.  Этот модуль хорошо поддерживается.</para>
<para>         Инетрфейс к библиотеке bbmpeg (включена в transcode). Может</para>
<para>         кодировать в mpeg1, VCD, SVCD, MPEG2 и DVD видео форматы.</para>
<para>         Кодированое видео является отдельным файлом, который следует объединить</para>
<para>         с соответствующим аудио файлом после кодирования.</para>
<para>-F codec_string</para>
<para>       параметры енкодера [зависят от модуля].</para>
<para>       Параметр -F имеет разные значения для разных модулей.</para>
<para>&lt;вырезано&gt;</para>
<para>        -y mpeg:</para>
<para>          Синтаксис: -F "&lt;base-profile&gt;[,&lt;resizer-mode&gt;[,user-profile]]"</para>
<para>            &lt;base-profile&gt; может быть одним из:</para>
<para>              '1' = MPEG 1 (по умолчанию)</para>
<para>              'b' = big MPEG 1 (экспериментальный)</para>
<para>              'v' = VCD</para>
<para>              's' = SVCD</para>
<para>              '2' = MPEG2</para>
<para>              'd' = DVD совместимый</para>
<para>            &lt;resizer-mode&gt; может быть одним из:</para>
<para>               0 = выключить resizer (по умолчанию)</para>
<para>               1 = 352x288</para>
<para>               2 = 480x480</para>
<para>               3 = 480x576</para>
<para>               4 = 352x240</para>
<para>            &lt;user-profile&gt; Имя файла профиля. Вы можете</para>
<para>        можно указать как абсолютный путь так и относительный</para>
<para>        (относительно директории из которой запускаете transcode).</para>
<para>-Y top[,left[,bottom[,right]]]</para>
<para>       определить (для енкодера) рамку по котрой будет обрезано изображение. </para>
<para>       Отрицаельные значения будут добавлять рамку [отключено изначально].</para>
<para>-E r[,b[,c]]</para>
<para>       частота сэмплирования выходного аудио [Гц], битов на сэмпл и каналы</para>
<para>       [входящие данные]. Опция "-J resample" должна быть передана</para>
<para>       не совместимым с ресэмплингом.</para>
<para>-B n[,m[,M]]</para>
<para>       изменить размеры до высота-n*M горизонтальных полосок </para>
<para>       [,ширина-m*M] вертикальных полосок [отключено изначально,32].</para>
<para>       M должно иметь одно из значений 8, 16 или 32. Неважно какое M </para>
<para>       вы используете. Также взгляниет на флаг fast опции -Z если</para>
<para>       не хотите считать n и m вручную.</para>
<para>-b b[,v,[q,[m]]]</para>
<para>       битрейт аудио енкодера кБит/с [,vbr[,quality[,mode]]] [128,0,5,0]</para>
<para>       Параметр mode оперделяет какие модули будет использовать lame</para>
<para>       при кодировании.  Возможные значения для mode:</para>
<para>          0    Joint Stereo (по умолчанию)</para>
<para>          1    Full stereo</para>
<para>          2    Mono</para>
<para>-o file</para>
<para>       имя выходного файла, по умолчанию [/dev/null].</para>
<para/>
<para>Если бы, к примеру, наше видео имело формат 728x424, то следовало бы воспользоватья командой типа следующей: </para>
<para>transcode -i showgirls-divx.avi -V -y mpeg -F d -B 1,1,8 -E 44100 -b 128 -o showgirls-dvd</para>
<para/>
<para>Также обратитесь к опции -X для того, чтобы увеличить размеры видео. </para>
<para/>
<para>Использование tcmplex для объединения аудио и видео данных</para>
<para/>
<para>Transcode должен был создать *.m2v (mpeg-2 видео) и *.mpa (аудио) файлы в текущей директории. Теперь мы их объединим так: </para>
<para>tcmplex -o showgirls-dvd.vob -i showgirls-dvd.m2v -p showgirls-dvd.mpa -m d</para>
<para/></section><section><info><title>Использование kino (альтернатива transcode+tcmplex)</title></info>
<para/>
<para>Kino используется для получения видео с dv камер. Эта программа имеет возможности простейшего видеомонтажа (вырезать сцену, вставить, поменять местами). Она имеет удобный интерфейс для захвата видео (хотя вы можете использовать dvgrab для этой цели). Она использует фомат qt4linux mov по умолчанию для захвата. </para>
<para>Для более продвинутого монтажа cinelerra, пожалуй, пока единственный выбор под Linux. Это достаточно мощная, но достаточно долгая в освоении и пока что нестабильная (сохраняйтесь как можно чаще) программа. Вы можете просто импортировать тот же .mov полученный с помощью kino (dvgrab) в cinelerra (на самом деле, она падает при работе с большинством других форматов). Затем вы можете использовать cinelerra, чтобы привести оконченный фильм обратно к формату mov. </para>
<para>Как только вы наконец получите тот .mov файл, какой вы хотели, загрузите его опять в kino и перейдите в закладку export. Здесь вы уже можете экспортировать video в формат vcd, svcd или dvd. Формат DVD потребует достаточно много времени для конвертирования (желателен мощный процессор). </para>
<para/>
<para>Использование replex (подготовка DVB записей с цифрового телевидения (Digital Television))</para>
<para/>
<para>"Эти инструкции были испробованы на записях формата DVB-C, сделанных в Финляндии" </para>
<para/>
<para>Примечание: пожалуй, для России эта глава абсолютно бесполезна, но если есть большое желание, то я переведу и её. Мало ли, кто где живет ;) </para>
<para/>
<para>Digital television streams are transmitted as MPEG2-TS in which the TS stands for Transport Stream. This means that extra information, such as multiple audio streams, could be transferred along with the actual video. Quite fortunately, the video stream is already suitable for DVD without re-encoding which is both time consuming and stupid as it lowers the quality. Enter replex. First use czap for tuning into some channel: </para>
<para>czap -r -n 3</para>
<para/>
<para>This tunes the DVB card to channel number 3. Now, record some data by typing: </para>
<para>cat /dev/dvb/adapter0/dvr0 &gt; stream.ts</para>
<para/>
<para>This simply writes raw data from the first tuner card into a file. After awhile press CTRL-C to stop recording. </para>
<para/>
<para>Now, you should have a blob of data which could be played with e.g. mplayer. Next, you should use replex to transform TS format suitable for DVD. Enter following command: </para>
<para>replex -k -i TS -t DVD -o stream.dvd stream.ts</para>
<para/>
<para>This command ignores possible errors in original stream (-k), assumes that input file is in TS format (-i TS), outputs format suitable for DVD (-t DVD), writes to a file called stream.dvd (-o stream.dvd) and reads its input from the file entered as a last parameter (stream.ts). </para>
<para/>
<para>After a moment a file called stream.dvd should appear in the same directory where above command was entered. Now just follow the instructions from the next chapter onwards to burn this baby on a DVD. </para>
<para/></section><section><info><title>Создание структуры директорий (authoring) с использованием dvdauthor</title></info>
<para/>
<para>Это самый сложный этап! Имея готовый MPEG2 файл, воспользуйтесь программой dvdauthor (или вашим любимым графическим фронтендом к ней (например, dvdstyler)), чтобы создать структуру директорий для записи DVD (VIDEO_TS и AUDIO_TS). </para>
<para/>
<para>dvdauthor -o . showgirls-dvd.vob &amp;&amp; dvdauthor -o . -T </para>
<para/>
<para>Создание DVD образа для записи</para>
<para/>
<para>Если директории AUDIO_TS и VIDEO_TS созданы у вас в директории bar, которая в свою очередь находится в текущей директории, то введите команду: </para>
<para>mkisofs -dvd-video -o ./bar.img ./bar/</para>
<para/>
<para>и вы получите образ bar.img в текущей директории, который теперь следует записать на диск вашей любимой программой для записи дисков. </para>
<para/>
<para>Или можете записать диретории AUDIO_TS и VIDEO_TS прямо из каталога bar/ набрав: </para>
<para/>
<para>growisofs -Z /dev/dvd -dvd-video -V название_диска . </para>
<para/>
<para>Где /dev/dvd - ваш DVD-writer. </para>
<para/></section><section><info><title>Запись</title></info>
<para/>
<para>В Linux существует множество способов записи DVD. Из уже показанных можно использовать cdrecord или growisofs. </para>
<para/>
<para>С помощью графического интерфейса</para>
<para/>
<para>Формат ISO можно записать с помощью программы X-CDroast (она использует cdrecord-ProDVD, которая требует ключ, что доставляет определенное неудобство). </para>
<para/>
<para>Также можно воспользоваться прораммой k3b, котрая использует growisofs. Это, пожалуй, самый простой способ. </para>
<para/>
<para>Из командной строки</para>
<para/>
<para>Можно записать образ ещё и так: </para>
<para>cdrecord-ProDVD -dao -speed=4 -dev=/dev/dvd ./bar.img</para>
<para/>
<para>Воспользуйтесь командой cdrecord -scanbus предварительно, чтобы определить какое устройство использовать для записи. Для устройств ATAPI используйте формат -dev=/dev/dvd или -dev=/dev/hdd (зависит от машины), для эмуляции SCSI устройств используйте -dev=0,0,0 или -dev=0,0,1 (зависит от машины). </para>
<para/>
<para>Если у вас нет cdrecord-ProDVD можете использовать growisofs. </para>
<para>growisofs -dvd-compat -Z /dev/dvd=./bar.img</para>
<para/>
<para>Подсказка: С помощью growisofs вы можете писать диски налету (без создания четырёхгигабайтного файла .iso): </para>
<para>growisofs -dvd-compat -Z /dev/dvd -dvd-video ./bar</para>
<para/>
<para>Можно также воспользоваться скриптом, который расположен по адресу http://james.nontrivial.org/projdvd.htm </para>
<para/></section></section></section><section><info><title>Система Portage</title></info><section><info><title>Portage через NFS</title></info><section><info><title>Проблемы </title></info>
<para>Слишком долгое время выполнения 'emerge --sync' на всех серверах в LAN. Согласно этикету gentoo, вы не можете синхронизироваться чаще одного раза в день </para>
<para/></section><section><info><title>Решение </title></info>
<para/>
<para>Общий NFS portage. Одна машина синхронизируется под управлением cron, остальные машины монтируют свою директорию /usr/portage с помощью NFS. </para>
<para/>
<para>Общее представление </para>
<para/>
<para>1. Обязательная поддержка nfs в ядре. В случае компиляции ее как модуля, добавить соответствующие строчки в modules.autoload </para>
<para>2. Если потребуется, перезагрузить или загрузить модуль nfs </para>
<para>3. Выполнить emerge nfs-utils </para>
<para>4. Настроить NFS/fstab для автоматического монтирования общего репозитария portage. </para>
<para>5. Установить локальный PORTAGE_TMPDIR на локальную файловую систему. </para>
<para/></section><section><info><title>Выгоды </title></info>
<para>Только один сервер заботится о синхронизации portage (ночью по заданию cron'а). </para>
<para>Не нужен локальный rsync сервер. </para>
<para>Общий для всех каталог /usr/portage/distfiles означает, что вам не нужно скачивать одно и то же каждый раз, чтобы синхронизировать репозитарий portage на ваших ваши компьютерах. </para>
<para>И вообще, NFS - это классная штука ;) </para>
<para/>
<para>Предупреждение: NFS является очень скудным протоколом по части безопасности. Убедитесь, что используете его только в пределах вашей локальной сети, где вы полностью доверяете вашим пользователям. Мы вас предупредили! </para>
<para/>
<para/></section><section><info><title>Подробный процесс </title></info>
<para/>
<para>Поддержка ядра </para>
<para/>
<para>У вас ДОЛЖНА быть включена поддержка NFS в вашем ядре, либо вкомпиленная в ядро (в таком случае необходимо будет перезагрузиться): </para>
<para/>
<para>Linux Kernel Configuration: Встроенная поддержка </para>
<para>File systems ---&gt; </para>
<para>  Network File Systems ---&gt;</para>
<para>    &lt;*&gt; NFS file system support                                                                                                </para>
<para>    [*]   Provide NFSv3 client support                                                                                         </para>
<para>    [ ]   Provide NFSv4 client support (EXPERIMENTAL)                                                                          </para>
<para>    [ ]   Allow direct I/O on NFS files (EXPERIMENTAL)                                                                         </para>
<para>    &lt;*&gt; NFS server support                                                                                                     </para>
<para>    [*]   Provide NFSv3 server support                                                                                         </para>
<para>    [ ]     Provide NFSv4 server support (EXPERIMENTAL)                                                                        </para>
<para>    [ ]   Provide NFS server over TCP support (EXPERIMENTAL)                                                                   </para>
<para/>
<para/>
<para>либо в качестве модулей: </para>
<para>Linux Kernel Configuration: Включение модулей </para>
<para>File systems ---&gt; </para>
<para>  Network File Systems ---&gt;</para>
<para>    &lt;M&gt; NFS file system support                                                                                                </para>
<para>    [*]   Provide NFSv3 client support                                                                                         </para>
<para>    [ ]   Provide NFSv4 client support (EXPERIMENTAL)                                                                          </para>
<para>    [ ]   Allow direct I/O on NFS files (EXPERIMENTAL)                                                                         </para>
<para>    &lt;M&gt; NFS server support                                                                                                     </para>
<para>    [*]   Provide NFSv3 server support                                                                                         </para>
<para>    [ ]     Provide NFSv4 server support (EXPERIMENTAL)                                                                        </para>
<para>    [ ]   Provide NFS server over TCP support (EXPERIMENTAL)                                                                   </para>
<para/>
<para/>
<para>Добавляем NFS server support, так как на данной машине будет размещаться общий каталог portage. Поддержку клиента NFS можно добавить по желанию. </para>
<para/>
<para>Сохраните конфиг вашего ядра и пересоберите его. Code: Пересборка ядра </para>
<para/>
<para>gentoo # mount /boot //если это еще не сделано</para>
<para>gentoo # cd /usr/src/linux</para>
<para/>
<para>Для ядер 2.4:</para>
<para/>
<para>gentoo # make dep &amp;&amp; make bzImage modules modules_install install</para>
<para>Для ядер 2.6:</para>
<para>gentoo # make &amp;&amp; make modules_install </para>
<para/>
<para/></section><section><info><title>Включение поддержки</title></info>
<para/>
<para>Перезагрузитесь, если включили поддержку NFS в ядро, или, если вы собрали ее как модули, просто запустите: modprobe nfs </para>
<para/></section><section><info><title>Установка и настройка</title></info>
<para/>
<para>Установите пакет </para>
<para>nfs-utils: emerge nfs-utils</para>
<para>Настраиваем автоматическое монтирование общего portage </para>
<para>rc-update add portmap default </para>
<para>rc-update add nfs default </para>
<para>Отредактируйте crontab на сервере (метод зависит от того, какой cron вы используете). Для vixie-cron и dcron команда выглядит так: crontab -e Добавьте код: </para>
<para/>
<para>0 0 * * * emerge --sync &gt; /dev/null 2&gt;&amp;1 || true --nospinner &amp;&amp; emerge world -vup</para>
<para/>
<para>Отредактируйте файл /etc/exports на сервере, чтобы в нем были следующие строчки: </para>
<para>/usr/portage    ip_range/subnet(sync,no_root_squash,rw)</para>
<para/>
<para>Отредактируйте /etc/fstab на клиентах, добавив в него следующий код: </para>
<para>SERVER_IP:/usr/portage  /usr/portage  nfs  bg,hard 0 0</para>
<para/>
<para>Отредактируйте /etc/modules.autoload.d/kernel-version, добавив следующую строку: nfs</para>
<para>Примечание: Кеш портежей не расшарен через nfs. Если каждый раз вас докучает обновление кеша при команде emerge сразу после синхронизации, попробуйте добавить следующее в crontab клиентов. Это обновит кеш на компьютерах ваших клиентов спустя 10 минут после старта синхронизации на сервере. Установите время согласно скорости вашего подключения. </para>
<para/>
<para>10 0 * * * emerge --metadata </para>
<para/>
<para/>
<para>PORTAGE_TMPDIR</para>
<para/>
<para>PORTAGE_TMPDIR должен быть локальным каталогом (для скорости). </para>
<para/>
<para>Переменная PORTAGE_TMPDIR устанавливается в файле /etc/make.conf и по умолчанию указывает на /var/tmp, то есть на локальную файловую систему, но просто для того, чтобы увериться в том, что это так, а не иначе, сделайте: emerge info Если всё прошло успешно (а всё так и должно быть), вы спокойно можете очистить содержимое каталога /usr/portage на КЛИЕНТСКОЙ машине (например, чтобы освободить дополнительное свободное место на диске) </para>
<para/>
<para>Пояснение кода </para>
<para/>
<para>Запись crontab'а </para>
<para>0 0 * * * emerge --sync &gt; /dev/null 2&gt;&amp;1 || true --nospinner &amp;&amp; emerge world -vup</para>
<para/>
<para>говорит о том, что раз в сутки, в полночь будут выполнятся синхронизация с перенаправлением вывода в мусор и без бегунка и emerge world -vup и отправка письма root'у о том, что должно быть обновлено - настройте корректно почту). </para>
<para/>
<para>/etc/exports:</para>
<para>"/usr/portage" - каталог для экспорта</para>
<para>"ip_range/subnet" - только компьютеры из этого диапазона могут подключать его по сети</para>
<para>"(sync,no_root_squash,rw)" - полезные параметры, всегда мною используемые </para>
<para/>
<para>/etc/fstab:</para>
<para>"SERVER_IP:/usr/portage" - что вы хотите подключить</para>
<para>"/usr/portage" - куда вы хотите подключить</para>
<para>"nfs" - ФС ресурса</para>
<para>"bg,hard 0 0" - полезные параметры, всегда мною используемые </para>
<para/>
<para>/etc/modules.autoload.d/kernel-version:</para>
<para>"nfs" сообщает какой модуль загружать при загрузке ядра версии kernel-version </para>
<para/></section><section><info><title>Комментарии </title></info>
<para/>
<para>Советы? Пожелания? Похвала? Дайте нам знать. </para>
<para/>
<para>Если вы получаете ошибку "Error starting NFS daemon" попробуйте </para>
<para/>
<para># mount -t nfsd nfsd /proc/fs/nfsd </para>
<para/>
<para>это работает для меня.</para>
<para/></section></section></section><section><info><title>Настройка Portage</title></info><section><info><title>Portage Setup Howto </title></info>
<para/><section><info><title>Целевая аудитория </title></info>
<para/>
<para>Это руководство создается для людей, которые хотят использовать все возможности системы Portage. </para>
<para/></section><section><info><title>Зачем нужно это howto? </title></info>
<para/>
<para>Portage — это система управления пакетами Gentoo Linux. Ее возможности довольно велики — сборка пакетов из исходников, включая конфигурирование пакета на основе пользовательских USE-флагов; начальная настройка приложений; установка предкомпилированных пакетов; удаление програм; автоматическое обновление, и т. д. Однако, как показывает опыт, несмотря на отличную документацию, большинство пользователей не знают всех возможностей этой замечательной системы, поэтому очень часто Gentoo Linux подвергается незаслуженной критике. Данный документ — это попытка восполнить этот пробел. </para>
<para/></section><section><info><title>Профили Portage (Portage profiles) </title></info>
<para/>
<para>Gentoo — многоплатформенная система, при этом количество поддерживаемых архитектур постоянно увеличивается. Поэтому возникает необходимость в так называемых профилях сборки. Профиль — это набор настроек по умолчанию для определенной архитектуры, или определенного класса задач (например, для систем с повышенной безопасностью существуют профили hardened и selinux). Наличие профилей, которые легко создавать, позволяет называть Gentoo не дистрибутивом, а метадистрибутивом, то есть дистрибутивом для создания других дистрибутивов ;). Но не об этом сейчас разговор. </para>
<para/>
<para>Итак, для того, чтобы иметь работающую Gentoo-систему, необходимо выбрать себе нужный профиль. Профили по умолчанию находятся в каталоге /usr/portage/profiles. По названию профиля легко определить тот, который нужен вам. Например, 'default-x86-2004.2' — это стандартный профиль для архитектуры x86 версии 2004.2. Если в каталоге с профилем есть файл deprecated, то это означает, что данный профиль больше не поддерживается и выбирать его не следует. </para>
<para/>
<para>После того как вы определились с выбранным профилем необходимо создать симлинк /etc/make.profile на каталог с выбранным профилем. Например, ln -s /usr/portage/profiles/default-x86-2004.2 /etc/make.profile Когда выйдет новая версия Gentoo, вам не надо бежать в магазин, покупать новые диски. Достаточно просто поменять симлинк /etc/make.profile на симлинк, указывающий на каталог с новым профилем. </para>
<para/>
<para>Примечание: Сейчас идет переход на новый вид профилей — Cascading </para>
<para/>
<para>Profiles. Такие профили имеют вид: </para>
<para/>
<para>default-linux/x86/2004.2/ </para>
<para/>
<para>То есть настройки, общие для нескольких профилей не надо записывать по несколько раз. Пока что это экспериментальная фича, но если вы хотите помочь ее протестировать, то используйте на здоровье ;). </para>
<para/>
<para>Примечание: Вообще-то переход на cascading profiles уже произошел, посему надо обновить то, что написано выше в этой секции "Portage profiles" </para>
<para/>
<para/></section><section><info><title>Настройки профилей </title></info>
<para/>
<para>В профилях содержится следующая информация: </para>
<orderedlist>
<listitem>
<para>use-флаги использующиеся по умолчанию; </para>
</listitem>
<listitem>
<para>системные пакеты, то есть такие пакеты, которые устанавливаются при   emerge system; </para>
</listitem>
<listitem>
<para>маскированные пакеты; </para>
</listitem>
<listitem>
<para>Настройки сборки пакетов по умолчанию. (CFLAGS, CHOST и другие);</para>
</listitem>
<listitem>
<para>Какие пакеты надо устанавливать при наличии альтернативных. (например, xorg или xfree) </para>
</listitem>
</orderedlist>
<para/>
<para>Конфигурацию профилей напрямую менять не следует, так как ваши настройки будут удалены после следующей синхронизации с rsync-сервером. О том как правильно настраивать portage будет рассказано в следующем разделе. </para>
<para/>
<para>/etc/portage и /etc/make.conf </para>
<para>Для того, чтобы изменить конфигурацию выбранного профиля, нужно использовать конфигурационные файлы в /etc/portage. Если у вас нет этого каталога, то его необходимо создать. Вот список конфигурационных файлов, которые читает Portage во время своей работы: </para>
<para/>
<para>/etc/portage/package.mask </para>
<para>Синтаксис: в каждой строке содержится DEPEND ATOM, то есть один из знаков &gt;, &lt;, &gt;=, &lt;=, =, категорию, название и версию пакета. Логические знаки обязательны если указана версия пакета. </para>
<para>Например: &gt;=net-www/mozilla-1.7 </para>
<para/>
<para>Неправильные примеры: </para>
<para>net-www/mozilla-1.7 (нет логической операции) </para>
<para>&gt;=mozilla-1.7 (нет категории) </para>
<para/>
<para>Предназначение: Маскирует пакеты. Может использоваться для того, чтоб Portage не обновлял нужный вам пакет. Например, если вы хотите использовать apache-1.3 вместо apache-2.0 </para>
<para/>
<para>/etc/portage/package.unmask </para>
<para>Синтаксис: такой же, как и у package.mask </para>
<para>Предназначение: Демаскирует пакеты, которые маскированы в профиле. Используется для установки нестабильных пакетов. Рекомендуется использовать только тем, кто хочет протестировать какой-то нестабильный пакет. </para>
<para/>
<para>/etc/portage/profile/package.provided </para>
<para>Синтаксис: В каждой строчке содержится полное имя пакета, то есть category/name-version</para>
<para>Например: dev-lang/ghc-6.2.1-r1 </para>
<para>Предназначение: Замена 'emerge --inject'. При наличии пакета в package.provided Portage будет считать, что этот пакет уже установлен в системе.</para>
<para>Примечание: Иногда этого бывает недостаточно и пакет приходится вносить в /etc/make.profile/package.provided (который удаляется после каждого emerge sync) </para>
<para/>
<para/>
<para>/etc/portage/mirrors </para>
<para>Синтаксис: Такой же как и у файла /usr/portage/profiles/thirdpartymirrors. Предназначение: Список зеркал, которые будут использоватся в первую очередь. Можно также указать зеркала sourceforge или gnu, которые будут использоватся в первую очередь. </para>
<para>Например:  sourceforge http://keihanna.dl.sourceforge.net/sourceforge </para>
<para/>
<para>Так же можно использовать тип миррора 'local'. Такое зеркало будет проверятся, даже если в ebuild'е пакета есть RESTRICT="NOMIRROR". Например: </para>
<para/>
<para>local ftp://gentoo.linux.kiev.ua/pub/Linux/Gentoo/distfiles/ </para>
<para/>
<para/>
<para>/etc/portage/package.use </para>
<para>Синтаксис: DEPEND ATOM USE-флаги </para>
<para>Например: x11-libs/gtk+ doc </para>
<para>Предназначение: Установка индивидуальных USE-флагов для отдельных пакетов </para>
<para/>
<para>/etc/portage/package.keywords </para>
<para>Синтаксис: DEPEND ATOM KEYWORD KEYWORD — это идентификатор, который показывает, насколько стабилен пакет на данной архитектуре. Всего есть 4 вида KEYWORDS: </para>
<para>  arch — пакет стабилен на архитектуре arch </para>
<para>~arch — пакет стабилен на архитекруре arch, но еще не прошло время тестирования </para>
<para> -arch — у пакета наблюдаются проблемы на архитектуре arch. </para>
<para>      -* — пакет нестабилен на всех архитектурах </para>
<para/>
<para>Например: &gt;=app-editors/emacs-cvs-21.3 ~x86 </para>
<para>Предназначение: Установка индивидуальных KEYWORDS для отдельных пакетов. Используйте если хотите, чтоб в вашей стабильной системе были отдельные нестабильные пакеты или наоборот :) </para>
<para/>
<para>/etc/portage/categories </para>
<para>Синтаксис: В каждой строке содержится название категории. Предназначение: Используется для создание новых категорий для Portage. </para>
<para>Например: app-vasia </para>
<para>Теперь вы можете создать ebuild для пакетов категории app-vasia. emacs ${PORTDIR_OVERLAY}/app-vasia/pupkin/pupkin-0.0.1.ebuild </para>
<para/>
<para>/etc/make.conf </para>
<para>Файл /etc/make.conf служит для настройки самого процесса сборки пакетов. Никаких сложных опций там нет, читайте внимательно комментарии в /etc/make.conf.example. </para>
<para/>
<para>$PORTDIR_OVERLAY </para>
<para>Представьте себе такую ситуацию: вы хотите установить пакет, ebuild'а которого нет в официальном дереве, но кто-то уже его написал. Или вы собираетесь самостоятельно научится писать ebuild'ы, и вы хотите, чтоб Portage мог устанавливать нужные вам программы. Если вы запишете свой ebuild в /usr/portage, то он сотрется при следующей синхронизации с rsync-сервером. Для того, чтобы third-party ebuild'ы сохранялись, необходимо создать каталог для их хранения (например, /usr/local/portage) и записать его имя в переменную $PORTDIR_OVERLAY в файле /etc/make.conf. Теперь вы можете размещать свои ebuild'ы в этом каталоге, пример был показан в предыдущем разделе.</para></section></section></section><section><info><title>Portage Overlay</title></info><section><info><title>Введение</title></info>
<para>Это руководство расскажет о том как установить ebuild который не включен в официальное дерево портежей. </para></section><section><info><title>Установка Portage Overlay</title></info>
<para>Первым делом мы должны указать PORTAGE_OVERLAY директорию, для этого необходимо отредактировать файл /etc/make.conf </para>
<para/>
<para>Файл: /etc/make.conf </para>
<para>PORTDIR_OVERLAY="/usr/local/portage" </para>
<para/>
<para>Таким образом мы позволяем устанавливать дополнительные ebuild'ы при этом не нарушая процесс синхронизации основного дерева портежей. </para>
<para/></section><section><info><title>Месторасположение ebuild</title></info>
<para>Проверьте наличие директории /usr/local/portage, и если ее нет создайте ее install -d /usr/local/portage </para>
<para>Когда помещаете новый ebuild в /usr/local/portage, вы должны использовать такую же схему как в /usr/portage (category/program/program.ebuild) </para></section><section><info><title>Создание digest-файлов</title></info>
<para/>
<para>digest-файлы -- это файлы, которые содержат md5 суммы файлов, необходимых для установки пакетов. После того, как Portage скачает необходимые файлы, будет сделана проверка на соответствие файлов их md5-суммам (это дает возможность убедиться в целостности файлов). Для того, чтобы Portage мог устанавливать пакеты, необходим digest-файл. Digest-файл можно создать с помощью команды ebuild /usr/local/portage/category/program/program.ebuild digest Вручную редактировать созданные этой командой файлы не следует. При этом надо учитывать требования к имени ebuild-а. При переименовании ebuild-а в произвольное имя, команда </para>
<para/>
<para>ebuild /usr/local/portage/category/program/program.ebuild digest выдаст ошибку: </para>
<para/>
<para>!!! /usr/local/portage does not seem to have a valid PORTDIR structure. </para>
<para/>
<para>Чтобы этого не произошло необходимо переименовывать ebuild в то же самое имя, но с приставкой номера релиза. </para>
<para>Пример: </para>
<para>В портежах имеется ebuild: </para>
<para>/usr/portage/media-sound/ncmpc/ncmpc-0.11.1-r1.ebuild </para>
<para>И архив исходных кодов: </para>
<para>/usr/portage/distfiles/ncmpc-0.11.1.tar.gz для этого ebuild-а. </para>
<para>Вы хотите наложить свой патч и добавить ebuild вашего пропатченного пакета в систему. Для этого вы должны скопировать исходный ebuld в ваш новый, но добавить к нему приставку '-rN', где N - номер релиза. Если такая преставка уже есть - изменить её номер: </para>
<para>cp /usr/portage/media-sound/ncmpc/ncmpc-0.11.1-r1.ebuild /usr/local/portage/media-sound/ncmpc/ncmpc-0.11.1-r2.ebuild </para>
<para/>
<para/>
<para>После этого пропатчите исходные коды пакета, на который ссылается исходный </para>
<para>ebuild /usr/portage/distfiles/ncmpc-0.11.1.tar.gz</para>
<para>и сохраните его в /usr/portage/distfiles/ncmpc-0.11.1-r2.tar.gz </para>
<para/>
<para>Далее, нам нужно будет поправить наш новый ebuild: </para>
<para/>
<para>vi /usr/local/portage/media-sound/ncmpc/ncmpc-0.11.1-r2.ebuild </para>
<para>И изменить строку:</para>
<para>SRC_URI="http://mercury.chem.pitt.edu/~shank/${P}.tar.gz mirror://sourceforge/musicpd/${P}.tar.gz" </para>
<para/>
<para>На строку: </para>
<para>SRC_URI="http://mercury.chem.pitt.edu/~shank/${P}-r2.tar.gz mirror://sourceforge/musicpd/${P}-r2.tar.gz" </para>
<para/>
<para>Т.е. добавив наш префикс '-r2', чтобы система знала, какой именно файл с исходными кодами ей необходимо прописать. В данном случае скачать с сайта этот пакет конечно же не удастся, но нам этого и не требуется - нам необходимо установить нами поправленный пакет. </para>
<para/>
<para>После этого даём команду </para>
<para>ebuild /usr/local/portage/media-sound/ncmpc/ncmpc-0.11.1-r2.ebuild digest, </para>
<para>после чего emerge будет знать о вашем пакете. </para>
<para/><section><info><title>Установка нового ebuild</title></info>
<para/>
<para>Когда вы будете устанавливать пакет используя новый ebuild, скорее всего он будет masked, поэтому надо добавить имя пакета в /etc/portage/package.keywords </para>
<para>Создайте директорию /etc/portage/, если она еще не создана, и затем выполните команду: </para>
<para>echo "&lt;category&gt;/&lt;package&gt; ~x86" &gt;&gt;/etc/portage/package.keywords </para>
<para/>
<para>Теперь этот пакет можно установить как и любой другой: </para>
<para>emerge -p package </para>
<para>emerge package </para>
<para/></section><section><info><title>Дополнительно</title></info>
<para/>
<para>Unofficial ebuilds содержит список с коротким описанием сайтов где можно найти неофициальные пакеты Многие, написанные юзерами ebuild'ы, которые еще не попали в официальное дерево, находятся в Bugzill'е Gentoo. Найти нужные ebuild'ы можно с помощью поиска</para>
<para/></section></section></section><section><info><title>Экономия трафика с помощью deltup</title></info><section><info><title>Что это такое?</title></info>
<para>Как известно, программы в Gentoo Linux устанавливаются из исходников. Это чистый текст. Однако, такие программы как, например, gcc или openoffice весят непростительно много. А у большинства из нас интернет не позволяет качать файлы больших объемов, а пользователи модемов вообще толком ничего обновить не могут. Для людей, которые экономят свои деньги, и была написана программа deltup. Вместо wget мы заставляем emerge использовать getdelta. Эта программа скачивает со специального сайта не весь архив программы, а только разницу между требуемой версией и тем, что у вас есть. Если у вас нет предыдущей версии программы, то придется качать весь архив. </para></section><section><info><title>Установка и настройка</title></info>
<para>Установка deltup</para>
<para>Теперь установим deltup:</para>
<para>emerge deltup и getdelta: emerge getdelta </para>
<para/>
<para>Примечание: Если при выполнении emerge deltup выйдет ошибка "!!!All ebuilds that could satisfy "deltup" have been masked." перед командой добавьте ACCEPT_KEYWORDS="~x86" </para><section><info><title>Настройка emerge</title></info>
<para>Теперь нужно предупредить emerge о том что мы хотим использовать getdelta вместо wget. Для этого добавим в /etc/make.conf параметр FETCHCOMMAND: Файл: File /etc/make.conf </para>
<para>FETCHCOMMAND="/usr/bin/getdelta.sh \${URI}"</para>
<para/></section><section><info><title>Конфигурация getdelta</title></info>
<para/>
<para>У getdelta есть свой файл конфигурации:/etc/deltup/getdelta.rc. Рассмотрим некоторые полезные параметры: </para>
<para>DELTUP_SERVER - указывает на используемый deltup сервер. Рекомендуется оставить без изменений, так как deltup-сервера сейчас собраны в сеть обращение к которой идёт через один сервер linux01.gwdg.de. </para>
<para>QUEUERETRY - количество секунд, которые будет ждать getdelta,пока сервер не сделает dtu-файл. </para>
<para>MAXIMUM_ACCEPTABLE_QUEUEPOS - максимальный номер в очереди ожидания. В связи с ростом загруженности deltup-сервера имеет смысл установить число побольше. </para>
<para>REMOVE_OLD - удалять старые версии файлов. Полезно, если вы не хотите складировать дистфайлы. </para>
<para>DO_NOT_REMOVE - путь к файлу, содержащему имена файлов, которые не следует удалять при включенной опции REMOVE_OLD </para></section><section><info><title>Дополнительно</title></info>
<para>Могут возникнуть проблемы если вы скачали часть файла нужного для установки. Дело в том, что для продолжения докачки emerge использует не FETCHCOMMAND, а RESUMECOMMAND. Однако не следует менять RESUMECOMMAND на getdelta, так как getdelta не поддерживает докачку.</para>
<para/></section></section></section><section><info><title>Обновление портежей без доступа в интернет непосредственно из системы</title></info>
<para/>
<para>Данное руководство может помочь вам если с доступом в интернет из системы Gentoo проблемы. Однако у вас есть свежий portage-xxxxxxxx.tar.bz2. Если portage-xxxxxxxx.tar.bz2.md5sum не старше 40 дней(возможно это ограничение можно убрать, но автор этих строк не знает как) тогда проще сделать так : </para>
<para>Создаем папку /var/tmp/emerge-webrsync/ командой: </para>
<para># mkdir /var/tmp/emerge-webrsync/ </para>
<para>Копируем фаилы portage-xxxxxxxx.tar.bz2 и portage-xxxxxxxx.tar.bz2.md5, которые находятся к примеру, в корневом каталоге на CD-ROM диске (/mnt/cdrom/portage-xxxxxxxx.tar.bz2 и /mnt/cdrom/portage-xxxxxxxx.tar.bz2.md5sum), командами: </para>
<para># cp /mnt/cdrom/portage-xxxxxxxx.tar.bz2 /var/tmp/emerge-webrsync/ </para>
<para>#cp /mnt/cdrom/portage-xxxxxxxx.tar.bz2.md5sum /var/tmp/emerge-webrsync/</para>
<para>и обновляем портежи при помощи </para>
<para>emerge -webrsync: # emerge-webrsync </para>
<para/>
<para>Теперь мы получили систему портежей по состоянию на xxxxxxxx. </para>
<para>Если же portage-xxxxxxxx.tar.bz2 старше 40 дней тогда: </para>
<para>Первым делом переименовываем каталог /usr/portage например в /usr/portage2: </para>
<para># mv /usr/portage /usr/portage2 </para>
<para>затем создаем переименнованный /usr/portage: </para>
<para># mkdir /usr/portage </para>
<para>Перемещаем из /usr/portage2/distfiles исходники (если вам они нужны :) ) обратно в /usr/portage/distfiles: </para>
<para># cp /usr/portage2/distfiles /usr/portage/distfiles </para>
<para>Теперь можно распаковывать наш новый portage-xxxxxxxx.tar.bz2, который находится, к примеру, в корневом каталоге на CD-ROM диске (/mnt/cdrom/portage-xxxxxxxx.tar.bz2), командой: </para>
<para/>
<para># tar -xvjpf /mnt/cdrom/portage-xxxxxxxx.tar.bz2 -C /usr/portage </para>
<para>После достаточно продолжительной распаковки нужно обновить кэш системы портежей: </para>
<para># emerge metadata</para>
<para>Теперь мы получили систему портежей по состоянию на xxxxxxxx, а в каталоге /usr/portage2 - её бэкап. </para>
<para>Дополнительно можно прочитать:</para>
<para>
<link xlink:href="#">HOWTO Обновление пакетов без доступа в интернет непосредственно из системы.</link>
</para>
<para/></section><section><info><title>Обновление пакетов без доступа в интернет непосредственно из системы</title></info>
<para/>
<para>В моем случае это понадобилось в следующей (я полагаю довольно распространенной) ситуации: дома - нет интернета (дорогой, медленный - нужное подчеркнуть :) ), а на работе - хороший и бесплатный. Итак для начала необходимо получить список нужных пакетов. В этом примере мы хотим установить/обновить glibc baselayout texinfo gettext zlib binutils gcc ncurses. Список мы сохраняем на устаревший магнитный носитель, но счастливые обладатели более надежных носителей естественно могут пользоваться ими. </para>
<para>Получение списка для скачивания: </para>
<para>(Не забывайте '2' перед '&gt;') Code: </para>
<para># emerge -fp glibc baselayout gettext zlib binutils gcc ncurses 2&gt; stage1.list</para>
<para># mount -t vfat /dev/fd0 /mnt/floppy</para>
<para># cp /mnt/gentoo/stage1.list /mnt/floppy</para>
<para># umount /mnt/floppy </para>
<para/>
<para>Теперь вставляем дискету в компьютер с хорошим каналом. (В моем случае это рабочий компьютер.) Если заглянуть в файл stage1.list, можно увидеть, что в нем перечисляются несколько ссылок на каждую загрузку. К сожалению, это не совсем то, что нам надо. Сначала список надо почистить от лишнего: </para>
<para/>
<para>Очистка от лишних ссылок: </para>
<para/>
<para>Этот скрипт привязан к формату вывода emerge, который может измениться без предварительного предупреждения - используйте с осторожностью! # cut -f 1 -d ' ' stage1.list &gt; stage1.download </para>
<para>Теперь используем wget для загрузки списка пакетов: </para>
<para># wget -N -i stage1.download </para>
<para>Получив все файлы, переносим их в наш компьютер в /mnt/gentoo/usr/portage/distfiles. И для проверки запустим </para>
<para># emerge -pv glibc baselayout gettext zlib binutils gcc ncurses </para>
<para>Если в строке Total Download: указана цифра 0 - значит все было сделано верно. Можно теперь запускать установку: </para>
<para># emerge glibc baselayout gettext zlib binutils gcc ncurses </para>
<para>У всего вышеописанного есть один недостаток. В фаиле stage1.download есть все необходимые для установки фаилы. Даже те, которые у вас могут быть в distfiles. А как вырезать ссылки из stage1.download на имеющиеся в distfiles фаилы я не знаю. Если кто знает - напишите. </para>
<para>Взято с Gentoo.org: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gentoo.org/doc/ru/altinstall.xml">http://www.gentoo.org/doc/ru/altinstall.xml</link>
</para>
<para/></section><section><info><title>Полное обновление системы</title></info>
<para/><section><info><title/></info><section><info><title>Приведение в порядок /var/lib/portage/world </title></info>
<para/>
<para>В world должен быть список программ, которые нужно доустановить к тем, которые уже входят в "system" (т.е. в текущий профайл). </para>
<para>в world не должно быть никаких библиотек, и т.д., которые не нужны сами по себе, а нужны только для удовлетворения чьих-то зависимостей (чтобы не продолжать устанавливать/обновлять их, если они уже станут не нужны по какой-то причине) программ, которые уже входят в "system", не должно быть в world. В world нельзя указывать определенную версию софта, это лучше делать в /etc/portage/package.mask. </para>
<para>Скрипт regenworld может помочь восстановить world путем анализа /var/log/emerge.log и генерации на его базе файла world (он перезапишет текущий world!).</para>
<para>Скрипт dep -p -w поможет найти избыточные записи в world(которые всё-равно нужны другим записям в world или входят в system). </para>
<para/>
<para>Перед серьёзными обновлениями желательно просмотреть /etc/portage/*, т.к. там могут быть уже не актуальные записи мешающие текущему обновлению. </para>
<para/>
<para>Обновление profile </para>
<para>Не каждый Gentoo release включает в себя новый profile (например, 2004.1 был без profile). Даже если новый profile есть, то переходить на него не обязательно (если это будет обязательно, то старый профайл будет deprecated и emerge об этом должен будет громко кричать). </para>
<para>Инструкции по обновлению profile будут выкладываться здесь:</para>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gentoo.org/doc/en/gentoo-upgrading.xml">http://www.gentoo.org/doc/en/gentoo-upgrading.xml</link>
</para>
<para> и как правило сводиться к изменению симлинка /etc/make.profile </para></section></section><section><info><title/></info><section><info><title>USE-флаги </title></info>
<para>Запустить emerge -uDpv --newuse world и проверить что USE-флаги для всех пакетов выставлены корректно, и при необходимости скорректировать </para>
<para>USE-флаги выставляются в /etc/make.conf и /etc/portage/package.use </para>
<para>Запуск обновления системы (если не нужно обновлять toolchain) </para>
<para/>
<para/>
<para>Если </para>
<para>emerge -uDav --newuse world </para>
<para>показывает что будет обновляться пакет входящий в toolchain (linux-headers, glibc, binutils или gcc), то крайне рекомендуется полностью перекомпилировать всю систему - см. следующий пункт - а иначе можно вместо следующего пункта просто запустить: </para>
<para>emerge -uDav --newuse world </para>
<para>Некоторые причины не использовать emerge -U вместо -u </para>
<para>Причина 1: Проблемы со SLOT </para>
<para>Это, к примеру, происходит потому, что некоторые люди хотели gimp-2 вместо gimp-1.2. Представьте ситуацию, где gimp-1.2 помечен stable и находится в SLOT 1, gimp-2 помечен unstable и находится в SLOT 2. Теперь при выполнении ACCEPT_KEYWORDS=~x86 emerge gimp получите gimp-2. </para>
<para>Позже, когда вы посчитаете, что наступило время обновить свою систему чем-либо похожим на "emerge -U world", эта команда установит gimp-1.2, потому, что gimp находится в world-файле, и флаг "-U" не обрабатывает SLOT должным образом. </para>
<para/>
<para>Причина 2: Проблемы, в случае удаления ebuild-ов с Portage-дерева. </para>
<para>Допустим, в Portage находятся 2 версии пакетов foo, foo-1.4 (помеченный как stable) и foo-1.6 (помеченный как unstable). Вы хотите вариант unstable и делаете emerge, как с вышеуказанным gimp. Позже обновляете world как было сказано выше, но в промежутке этого времени вышло критическое обновление для foo-1.6 - foo-1.6.1. Теперь появляется несколько возможностей обработки. </para>
<para>foo-1.6 был удален из Portage. Будет установлен foo-1.4, несмотря на "снижение" версии вместо флага "-U" </para>
<para>Ситуация будет еще хуже, если foo-1.6 не был удалён из Portage по какой-либо причине: foo-1.6 (тот, что с критической уязвимостью) будет оставаться на вашей системе до тех пор, пока не будет помечено stable что-либо выше чем foo-1.6. </para>
<para/>
<para>Обновление одного из пакетов входящих в toolchain </para>
<para/>
<para>Если обновляется хотя-бы один из linux-headers, glibc, binutils или gcc, то рекомендуется пересобрать их дважды, после чего весь system, после чего весь world.</para>
<para>Примечание: Цель двойной компиляции toolchain - получить гарантированно стабильный и корректный toolchain не зависящий от предыдущего. Перекомпилировать system/world после этого жёсткой необходимости нет, по крайней мере если остальной софт продолжает работать (возможно даже используя библиотеки из старого toolchain - см. предыдущие пункты об апгрейде). </para>
<para>Цель перекомпиляции system/world - чтобы весь софт получил потенциальное преимущество от установки нового toolchain. system перекомпилируется перед world из тех-же соображений, т.к. при компиляции программ из world используются утилиты из system. </para>
<para>Если увеличивается первая или вторая цифра версии gcc, то перед второй сборкой нужно переключиться на новую версию через gcc-config - иначе новый gcc просто установится параллельно со старым в "новый слот", но по умолчанию использоваться будет старый. </para>
<para>При сборке system после двойной перекомпиляции toolchain нет необходимости опять компилировать toolchain как часть system. Аналогично при сборке world после system нет небходимости опять компилировать пакеты из system как часть world. Это можно попробовать обойти либо вручную, либо используя скрипты [1], либо через бинарные пакеты и `emerge -k` (я предпочитаю последний вариант). </para>
<para>Итак, рекомендованный набор команд: </para>
<para># для того, чтобы безопасно использовать `emerge -k` нужно очистить</para>
<para># каталог с текущими бинарными пакетами</para>
<para># (напр., переместить его в /tmp/portage-packages)</para>
<para>pkgdir=$(portageq pkgdir)</para>
<para>mv $pkgdir /tmp/portage-packages1</para>
<para>install -d -o portage -g portage $pkgdir</para>
<para># первая сборка toolchain</para>
<para>emerge linux-headers glibc binutils gcc-config gcc</para>
<para># выбрать новый gcc если он установился в новый слот</para>
<para>gcc-config имя_или_номер_нового_gcc</para>
<para># см. `gcc-config -l`</para>
<para>source /etc/profile</para>
<para># компиляция toolchain с созданием бинарных пакетов</para>
<para>emerge -b glibc binutils gcc portage</para>
<para># не компилить glibc, binutils и gcc</para>
<para>emerge -bke system </para>
<para># не компилить предыдущие пакеты (включая system)</para>
<para>emerge -bke world</para>
<para>Примечание: Чисто теоретически существует пакет binutils-config, который когда-нибудь может потребоваться использовать аналогично gcc-config. </para>
<para/></section></section><section><info><title/></info><section><info><title>Обновление безопасности. </title></info>
<para/>
<para>Примечание: Даже после `emerge -uDav --newuse world` в системе могут оставаться </para>
<para>устаревшие пакеты с дырами в безопасности - в слотах! </para>
<para/>
<para>glsa-check -l | grep '\[N\]'</para>
<para>emerge ... # если нужно</para>
<para/></section></section><section><info><title/></info><section><info><title>Удаление неиспользуемых пакетов. </title></info>
<para/>
<para>После обновления системы в ней могут оказаться пакеты, которые никто не использует. Эти пакеты желательно удалить, т.к. они не будут в дальнейшем обновляться при `emerge -uDav --newuse world`. </para>
<para>emerge -a depclean # очень осторожно!!!</para>
<para>После обновления библиотек может потребоваться перекомпилировать программы, которые эти библиотеки используют: </para>
<para/>
<para>Примечание: Для glsa-check, revdep-rebuild необходимо установить пакет gentoolkit </para>
<para/>
<para>rm /root/.revdep-rebuild*.?_*</para>
<para>revdep-rebuild -p</para>
<para>revdep-rebuild</para>
<para/></section></section><section><info><title/></info><section><info><title>Обновление конфигов. </title></info>
<para>dispatch-conf</para>
<para>Если используется runit-init и обновлялся пакет baselayout, то нужно восстановить /sbin/init: </para>
<para>ls -l /sbin/*init*</para>
<para>if (/sbin/init это бинарник, а не симлинк) {</para>
<para>mv /sbin/init /sbin/init-sysv</para>
<para>ln -s runit-init /sbin/init</para>
<para>}</para>
<para/></section></section><section><info><title/></info><section><info><title>Отслеживание важных сообщений при установке пакетов. </title></info>
<para/>
<para>В процессе emerge world выдаётся очень много сообщений, причём важные комментарии перемешаны с командами компиляции, и отследить их при сборке нескольких пакетов одновременно не возможно. </para>
<para>Но все эти сообщения можно получить из log-файлов после окончания установки emerge world. Для этого нужно использовать либо enotice, либо portlog-info.</para>
<para/></section></section></section><section><info><title>Сборка на другом компьютере</title></info>
<para/>
<para>Существует много методов добиться этого, но мы используем самый удобный - тот, что работает с портежами. </para>
<para>Другие методы могут быть более подходящими для других ситуаций, когда главная проблема не только медленный процессор и долгое время сборки, например, если надо перенести Gentoo на систему, которая не может загружаться с CD или сети. </para>
<para>Скомпилировать Gentoo для старых систем x86 (например, Pentium Pro 200MHz с небольшим количеством RAM) можно на x86_64-системе с работающей Gentoo. Обратный трюк, собрать 64-битную систему на 32-битном компьютере, невозможен. </para>
<para/>
<para>Я собирал систему в chroot-окружении согласно Gentoo-handbook, используя мою 64bit-Gentoo вместо "живого" CD: </para>
<para># mkdir /your/new/gentoo</para>
<para># tar xjvpf stage3-x86-*.tar.bz2 -C /your/new/gentoo</para>
<para/>
<para>Отредактируйте переменные CHOST и CFLAGS, соответствующие вашей целевой системе (не изменяйте CHOST, если используете стадию 2 или 3 - возмите стадию для соответствующей платформы). У меня было: </para>
<para># CHOST="i686-pc-linux-gnu"</para>
<para># CFLAGS="-march=pentiumpro -Os -momit-frame-pointer -pipe" </para>
<para># CXXFLAGS="$CFLAGS"</para>
<para/>
    <para>Далее переходим в chroot-окружение и выполняем все шаги, описанные в <link xlink:href="#">Руководстве Gentoo по установке</link>. </para>
<para/>
<para>Чтобы собрать ядро для i386 на x86_64-машине добавьте ARCH=i386 при конфигурации и компиляции ядра. </para>
<para># make menuconfig ARCH=i386</para>
<para># make clean dep modules modules_install bzImage ARCH=i386</para>
<para># cp arch/i386/boot/bzImage /boot/vmlinuz</para>
<para/>
<para>Размечать диск и создавать файловые системы на старом компьютере вам придется с помощью "живого" CD или другой системы Linux. </para>
<para/>
<para>Переносим готовую систему на старый компьютер: </para>
<para># cd /your/new/gentoo</para>
<para># echo "/sys/*" &gt;&gt; tar_exclusions</para>
<para># echo "/var/run/*" &gt;&gt; tar_exclusions</para>
<para># echo "/tmp/*" &gt;&gt; tar_exclusions</para>
<para># echo "/proc/*" &gt;&gt; tar_exclusions</para>
<para>#</para>
<para># tar -C /your/new/gentoo -X tar_exclusions --preserve -cf ../gentoo.tar .</para>
<para>## можете добавить -v для подробного вывода или -j / -z для компрессии</para>
<para># scp [-P ssh_port]  ../gentoo.tar user@dest_pc:</para>
<para/>
<para>На старой машине подготавливаем диски и распаковываем систему: </para>
<para># tar -C /your/new/system --preserve -xf ~user/gentoo.tar </para>
<para/>
<para>Теперь вы можете войти в chroot-окружение. Сконфигурируйте системный загрузчик и перегрузитесь. Теперь вы находитесь в новой, с иголочки, Gentoo. </para>
<para>Система теперь должна работать, но я заметил проблему - я не могу ничего скомпилировать. Похоже, что не работает ни C-препроцессор, ни gcc (обычно configure говорит, что /lib/cpp fails sanity check). Не знаю почему, но копирование /usr/include из chroot-каталога с исходной машины на старый компьютер эту проблему решило. </para>
<para/>
<para>Удачи! </para>
<para/>
<para>Оригинал на http://gentoo-wiki.com/HOWTO_Compile_on_another_computer </para>
<para>Перевод Poor Fred</para>
<para/></section><section><info><title>Прочее</title></info>
<para/><section><info><title>Разделы MS Windows по-русски</title></info><section><info><title>Введение</title></info>
<para/>
<para>Достаточно часто возникает необходимость подмонтировать раздел с установленным M$ Windows. </para></section><section><info><title>Ядро </title></info>
<para/>
<para>Для того, чтобы система могла работать с разделами FAT или NTFS, необходимо включить их поддержку в ядре.</para>
<para> Linux Kernel Configuration: Filesystems </para>
<para>File systems -&gt; </para>
<para>  DOS/FAT/NT Filesystems -&gt;</para>
<para>    (M) DOS FAT fs support</para>
<para>    (M)   MSDOS fs support</para>
<para>    (M)   VFAT (Windows-95) fs support</para>
<para>    (M) NTFS file system support</para>
<para/>
<para>Также надо включить поддержку следующих кодировок: </para>
<para>Linux Kernel Configuration: Native Language Support </para>
<para>File systems -&gt; </para>
<para>  Native Language Support -&gt;</para>
<para>    &lt;M&gt; Windows CP1251 (Bulgarian, Belarusian)</para>
<para>    &lt;M&gt; Codepage 866 (Cyrillic/Russian)</para>
<para/></section><section><info><title>Монтирование </title></info>
<para/>
<para>Теперь можно примонтировать любой windows-раздел программой mount. mount -t file_system /dev/device /mnt/dir В нашем случае в качестве file_system необходимо указывать vfat или ntfs, в зависимости от файловой системы раздела с windows. </para>
<para/>
<para>Монтирование FAT</para>
<para/>
<para>Для монтирования разделов FAT нужно использовать следующую команду: </para>
<para>mount -t vfat -o codepage=866,iocharset=koi8-r,quiet,umask=000 /dev/hdd2 /mnt/win1</para>
<para/>
<para>Для украинских символов: </para>
<para>mount -t vfat -o codepage=866,iocharset=koi8-u,quiet,umask=000 /dev/hdd2 /mnt/win1 </para>
<para/>
<para>Мы использовали дополнительные опции iocharset, codepage, quiet и umask. </para>
<para>Рассмотрим их внимательнее: </para>
<orderedlist>
<listitem>
<para>codepage - это кодовая страница используемая на монтируемой ФС. Так как мы из России,то нужно писать codepage=866. Эта опция нужна для перекодировки имен файлов. </para>
</listitem>
<listitem>
<para>iocharset - указывает какую кодировку использовать для ввода/вывода.Нужно указать свою системную локаль. Локаль можно узнать командой locale. (Здесь под вводом/выводом понимается ввод с и вывод на терминал. Иммено поэтому нужно указывать кодировку локали, т.е. кодировку которую используют программы запущенные в терминале.) </para>
</listitem>
<listitem>
<para>quiet - при копировании на файловую систему FAT программа попытается записать права доступа, владельца и т.д., но на FAT их сохранить нельзя и будет выведено сообщение об ошибке ( хотя файл скопируется ). Чтобы ошибки не появлялись мы просим смонтировать в "молчаливом" режиме </para>
</listitem>
<listitem>
<para>umask - в некоторых случаях у простого пользователя может не хватить прав на чтение или запись файлов из-за неправильно установленных прав на файлы и директории. Поскольку у файловой системы FAT нет прав доступа, они выставляются операционной системой ( в данном случае Linux ) на лету в соответствии с указанным значением umask. Про umask смотрите в umask(2) </para>
</listitem>
</orderedlist>
<para/>
<para>Параметры codepage и iocharset можно задать прямо в ядре. Тогда не нужно будет писать их каждый раз:</para>
<para>Linux Kernel Configuration: FAT </para>
<para>File systems -&gt; </para>
<para>  DOS/FAT/NT Filesystems -&gt;</para>
<para>    (utf8) Default iocharset for FAT</para>
<para>    (866) Default codepage for FAT</para>
<para/>
<para>То есть вместо </para>
<para>mount -t vfat -o codepage=866,iocharset=utf8,quiet,umask=000 /dev/hdd2 /mnt/win1 можно писать </para>
<para>mount -t vfat -o quiet,umask=000 /dev/hdd2 /mnt/win1 </para>
<para/>
<para>Монтирование NTFS</para>
<para/>
<para>Для монтирования NTFS разделов опции mount немного изменяться. Делаем это так: </para>
<para>mount -t ntfs -o nls=koi8-r,umask=0,ro /dev/hdd2 /mnt/win1 </para>
<para>Для украинских символов:</para>
<para>mount -t ntfs -o nls=koi8-u,umask=0,ro /dev/hdd2 /mnt/win1 </para>
<para>Вот что они значат: </para>
<para>nls - указывает на вашу системную локаль. Отсутствие опций codepage и iocharset связано с тем,что NTFS разделы используют юникод для хранения имен файла. </para>
<para>umask - указывает на то что читать файлы с этого раздела могут все. А вот писать не разрешает опция ro. Мы рекомендуем ее поставить,так как функция записи на разделы NTFS еще не отлажена. </para>
<para>В случае если вы в качестве системной кодировки используете utf-8, то опции mount должны быть следующими: mount -t ntfs -o utf8,umask=0,ro /dev/hdd2 /mnt/win1 </para>
<para>utf8 - использовать UTF-8 для перекодировки имён файлов. </para>
<para/></section><section><info><title>Автомонтирование</title></info>
<para>Если у вас все еще есть разделы ОС Windows на харде,то можно добавить монтирование этих разделов при загрузке.Для этого необходимо отредактировать файл /etc/fstab. Файл: /etc/fstab </para>
<para>...</para>
<para>/dev/hda9 /mnt/win1 vfat auto,codepage=866,iocharset=koi8-r,quiet,umask=000 0 0 </para>
<para>#/dev/hda9 /mnt/win1 vfat auto,codepage=866,iocharset=koi8-u,quiet,umask=000 0 0 </para>
<para>/dev/hda3 /mnt/win2 ntfs auto,nls=koi8-r,umask=0,user 0 0 </para>
<para/>
<para>еще к опциям можно добавить showexec, чтобы все файлы не выглядели исполняемыми, в случае с FAT32</para>
<para/></section></section><section><info><title>Udev</title></info><section><info><title>Настройка системы </title></info>
<para/>
<para>Установка необходимых программ </para>
<para>emerge udev hotplug coldplug </para></section><section><info><title>Конфигурация ядра </title></info>
<para/>
<para>Для активизации udev нам необходимо ядро 2.6. Лично у меня 2.6.12-mm1. </para>
<para>General setup ---&gt;</para>
<para> [*] Support for hot-pluggable devices</para>
<para>File systems ---&gt;</para>
<para> Pseudo filesystems ---&gt;</para>
<para>  [ ] /dev file system support (OBSOLETE)</para>
<para>  [ ]   Automatically mount at boot (NEW)</para>
<para>  [*] Virtual memory file system support (former shm fs)</para>
<para/>
<para>Примечание: devfs Может быть включен, но автоматическое монтирование обязано быть выключено. А с учетом того, что из 2.6.13 его вообще собираются убрать... ну смотрите сами. </para>
<para>Примечание: Во всяком случае, из 2.6.14 убрали </para>
<para/></section><section><info><title>Ядро собираем и устанавливаем. </title></info>
<para/>
<para>Конфигурация системы </para>
<para/>
<para>Не буду рассматривать как udev работает из таррбола, рассматриваю вариант чистого udev. </para>
<para/>
<para>/etc/conf.d/rc: </para>
<para>...</para>
<para>RC_DEVICE_TARBALL="no"</para>
<para>...</para>
<para>RC_DEVFSD_STARTUP="yes"</para>
<para>...</para>
<para/>
<para>Примечание: Последнюю опцию можно поставить в "no", когда мы убедимся в нормальной работоспособности udev </para>
<para/>
<para>rc-update add coldplug boot rc-update add hotplug default </para>
<para/>
<para>Конфигурация процесса загрузки </para>
<para/>
<para>GrUB </para>
<para/>
<para>К строке kernel от старого ядра необходимо дописать: </para>
<para>kernel /boot/kernel-2.6.9-r4 root=/dev/hda3 gentoo=noudev</para>
<para/>
<para>А в строке kernel для нового ядра прописать: </para>
<para>kernel /boot/kernel-2.6.10-r6 root=/dev/hda3 gentoo=nodevfs</para>
<para/></section><section><info><title>Troubleshuting </title></info>
<para/>
<para>Попытка номер раз </para>
<para/>
<para>В принципе можно перегружаться, но нас ждет одно неприятное сообщение. Вот примерно такое: </para>
<para>WARNING: Unable to open an initial console </para>
<para/>
<para>Для того чтобы все было хорошо, нам необходимо загрузиться с другого носителя (например любой LiveCD) подмонтировать наш корневой раздел, и в каталоге /dev (каталог по идее должен оказаться абсолютно пустым) проделать следующее: Code: </para>
<para># mknod -m 660 console c 5 1</para>
<para># mknod -m 660 null c 1 3</para>
<para/>
<para>POMAH007: Зачем же так жестоко - заставлять грузиться с компакта? Согласно udev guide с www.gentoo.org (http://www.gentoo.org/doc/en/udev-guide.xml), доступ к девственному /dev можно получить альтернативно: Code: Code Listing 3.1: Listing device nodes available at boot </para>
<para># mkdir test</para>
<para># mount --bind / test</para>
<para># cd test/dev</para>
<para># ls</para>
<para/>
<para/>
<para>Попытка номер два </para>
<para/>
<para>С консолью вроде все в порядке, а вот иксы не хотят... грузимся в шелл и в файле конфигурации Xorg прописываем в разделе мыши: </para>
<para/>
<para>Option "Device" "/dev/input/mice" </para>
<para/>
<para>PS </para>
<para>Ну теперь вроде все так как было раньше. и старая конфигурация тоже работает. Если старая конфигурация не нужна, то убираем все из загрузчика, ставим в /etc/conf.d/rc - "no" и живем спокойно под udev. </para>
<para/>
<para>PPS </para>
<para>Кстати тарболл может потребоваться пользователям нестандартных устройств, а так же некоторых сторонних модулей ядра</para>
<para/>
<para/></section></section><section><info><title>Использование CFLAGS для оптимизации собранных программ</title></info>
<para/><section><info><title>Для чего все это надо?</title></info>
<para/>
<para>Стремление выжать из своего компьютера максимум производительности есть в каждом, ну почти в каждом ;-). Особенно его много в русских линуксоидах Gentoo'шниках ;) Мы попытаемся путем изменения флагов оптимизации ускорить работу приложений нашей системы. </para>
<para>ВНИМАНИЕ: Некоторые флаги могут сделать приложения нестабильными, так что нужно быть аккуратным. </para>
<para/></section><section><info><title>Оптимизация</title></info>
<para/>
<para>Переменная окружения CFLAGS</para>
<para>Для указания параметров оптимизации компилятору GCC, используется переменная окружения CFLAGS. Эта переменная определена в /etc/make.conf, её можно изменить двумя способами: </para>
<para>Отредактировать эту переменную в /etc/make.conf; </para>
<para>Экспортировать ее в окружение (emerge будет использовать эти параметры, но каждый раз выполнять export неудобно): </para>
<para/>
<para>export CFLAGS='параметры оптимизации' </para>
<para/>
<para>Уровни оптимизации</para>
<para/>
<para>Для gcc версий 3.x и выше существует только 5 уровней оптимизации: -O0 (без оптимизации), -O1, -O2 и -O3 (O3 - самый высокий уровень), а так же -Os. </para>
<para>Примечание: Если вы используете несколько -O опций, то только последняя объявленная будет оказывать влияние на процесс компиляции. </para>
<para/>
<para>-O0 </para>
<para>Отключает оптимизацию. Только переменные, объявленные register, сохраняются в регистрах. </para>
<para/>
<para>-O(-O1) </para>
<para>Включает оптимизацию. Пытается уменьшить размер кода и ускорить работу программы. Соответственно увеличивается время компиляции. При указании -O активируются следующие флаги: -fthread-jumps, -fdefer-pop. </para>
<para>На машинах, у которых есть слоты задержки, включается опция -fdelayed-branch. </para>
<para>На тех машинах, которые способны поддерживать отладку даже без указателя на стек функции, также включается опция -fomit-frame-pointer. </para>
<para>На других машинах могут быть включены и другие флаги. </para>
<para/>
<para>-O2 </para>
<para>Оптимизирует еще больше. GCC выполняет почти все поддерживаемые оптимизации, которые не включают уменьшение времени исполнения за счет увеличения длины кода. Компилятор не выполняет раскрутку циклов или подстановку функций, когда вы указываете -O2. По сравнения с -O, эта опция увеличивает как время компиляции, так и эффективность сгенерированного кода. </para>
<para>-O2 включает все флаги оптимизации наследованные от -O. Также включает следущие флаги оптимизации: </para>
<para>          -fforce-mem -foptimize-sibling-calls</para>
<para>          -fstrength-reduce -fcse-follow-jumps  -fcse-skip-blocks</para>
<para>          -frerun-cse-after-loop  -frerun-loop-opt -fgcse  -fgcse-lm</para>
<para>          -fgcse-sm -fgcse-las -fdelete-null-pointer-checks -fexpensive-optimizations</para>
<para>          -fregmove -fschedule-insns  -fschedule-insns2 -fsched-interblock</para>
<para>          -fsched-spec -fcaller-saves -fpeephole2 -freorder-blocks</para>
<para>          -fre-order-functions -fstrict-aliasing -funit-at-a-time -falign-functions</para>
<para>          -falign-jumps -falign-loops  -falign-labels -fcrossjumping</para>
<para/>
<para>-O3 </para>
<para>Оптимизирует еще немного. Включает все оптимизации -O2 и также включает флаг -finline-functions и -fweb. </para>
<para/>
<para>-Os </para>
<para>Включает оптимизацию по размеру. -Os флаг активирует все флаги оптимизации из -O2, в основном те, которые не увиличивают размер выходного файла. В дальнейшем выполняются оптимизации по уменьшению размера кода. </para>
<para>-Os выключает следущие флаги оптимизации: -falign-functions, -falign-jumps, -falign-loop, -falign-labels, -freorder-blocks, -fprefetch-loop-arrays. </para>
<para/>
<para>Примечание: Более полное описание флагов -Ox, -fflag смотрите в man gcc </para>
<para/>
<para>Оптимизация под тип процессора</para>
<para/>
<para>Не все процессоры одинаковы,поэтому давайте укажем компилятору на наш тип процессора. Для этого есть опции -mtune и -march.Отличие в том,что с опцией -mtune компилятор сделает код,который будет совместим с более младшими моделями процессора,в то время как с -march этого не происходит.Вот список возможных значений для данных опций: </para>
<para>i386 </para>
<para>i486 </para>
<para>i586 </para>
<para>i686 </para>
<para>pentium </para>
<para>pentium-mmx </para>
<para>pentiumpro </para>
<para>pentium2 </para>
<para>pentium3 </para>
<para>pentium4 </para>
<para>pentium-m </para>
<para>prescott </para>
<para>nocona </para>
<para>k6 </para>
<para>k8 </para>
<para>k6-2 (не рекомендуется ставить, из-за багов в компиляторе, заменять на i686) </para>
<para>k6-3 </para>
<para>athlon </para>
<para>athlon-tbird </para>
<para>athlon-4 </para>
<para>athlon-xp </para>
<para>athlon-mp </para>
<para>athlon64 </para>
<para>opteron </para>
<para>winchip-c6 </para>
<para>winchip2 </para>
<para>c3. </para>
<para/>
<para>Внимание! pentium-m - это аналог для pentium3. Если процессор в вашем ноутбуке Mobile Intel Pentium 4 - M, то нужно ставить опцию pentium4 или pentium4m (они равнозначны) </para>
<para/>
<para>Примечание(JohnBat26) (обновлено в 1.5): Если Вы используете компилятор версии 4.2.0 и выше, то вместо указания специфичного типа процессора, можно указывать одно из двух (в параметрах: -march и -mtune):</para>
<orderedlist>
<listitem>
<para>generic: если Вы хотите, чтобы Ваш скомпилированный код запускался на всех процессорах, архитектуры x86;</para>
</listitem>
<listitem>
<para>native: если Вы хотите оптимизировать код только для Вашего процессора. В этом случае компилятор будет брать сведения о процессоре путем вызова cpuid ! .</para>
</listitem>
</orderedlist>
<para/>
<para/>
<para>Выбор оптимальных параметров </para>
<para/>
<para>Для этого есть очень интересная утилита. emerge acovea </para>
<para/>
<para>Правда существующие профили рассчитаны только на pentium 3/4, и на gcc 3.3/3.4, Но в принципе добавить свою конфигурацию тоже не составляет труда. Также рекомендуется добавить в конфигурацию опции -ftracer и -mfpmath=sse. В некоторых случаях они дают значительный прирост производительности сгенерированного кода. </para>
<para/>
<para>После чего вызываем утилиту runacovea -config gcc33_pentium3.acovea -bench evobench.c Ждем несколько часов и получаем оптимальные флаги компиляции. </para>
<para/>
<para>Возможны различные тесты, которые хранятся в каталоге /usr/share/acovea/benchmarks, И различные конфигурации платформы /usr/share/acovea/config, к которым при желании можно добавить свою.</para>
<para/></section></section><section><info><title>Редактор nano</title></info>
<para/>
<para>nano - Nano's ANOther editor</para>
<para/>
<para>Nano - достаточно простой и удобный текстовый редактор, клон редактора pico </para>
<para/><section><info><title>Установка</title></info>
<para/>
<para>emerge nano </para>
<para/>
<para>Конфигурация</para>
<para>Файл: /etc/nanorc </para>
<para/></section><section><info><title>Запуск</title></info>
<para/>
<para>Запуск редактора </para>
<para>nano -w somefile </para>
<para/>
<para>Параметр -w здесь означает запрет переноса строк.</para>
<para/>
<para/></section></section><section><info><title>Udev и автомонтирование носителей</title></info><section><info><title>Введение </title></info>
<para/>
<para>В данной статье речь пойдет о том, как настроить udev для автоматического монтирования и отмонтирования usb-носителей. Ведь согласитесь, неудобно каждый раз монтировать флэшки из консоли. А когда вам нужно быстро что-то скинуть с одной флэшки на другую? Здесь я привожу одно из возможных решений. </para>
<para/></section><section><info><title>Требования </title></info>
<para/>
<para>У меня установлена следующая версия udev: </para>
<para>sys-fs/udev-069 </para>
<para/>
<para>Я умышленно не ставлю более новые версии, т.к. с ними возникают проблемы при загрузке firmware на моем компьютере. Возможно в более новых версиях что-то работает по-другому, но суть одна и та же. </para>
<para/></section><section><info><title>Настраиваем udev </title></info>
<para/>
<para>Создаем правила для flash-носителей </para>
<para>Правила udev, в соответствии с которыми устройствам назначаются имена, а также выполняются специфические действия, расположены в /etc/udev/rules.d/*. В этой директории уже есть файлы, содержащие правила, у меня их было 2: </para>
<para># ls /etc/udev/rules.d</para>
<para>05-udev-early.rules</para>
<para>50-udev.rules</para>
<para/>
<para>Такие названия им были даны неспроста. Дело в том, что udev обрабатывает файлы в этой директории в алфавитном порядке по возрастанию. Вообще, при написании правил udev следует помнить 2 главные вещи: </para>
<para>Udev считывает файлы из /etc/udev/rules.d в алфавитном порядке. </para>
<para>Найдя первое подходящее правило для устройства, udev прекращает дальнейший поиск. </para>
<para>Давайте добавим свой файл с правилами так, чтобы он обрабатывался раньше, чем файл с правилами по умолчанию (50-udev.rules). Назовем его 10-udev-my.rules. Содержимое нового файла будет следующим: </para>
<para>Файл: /etc/udev/rules.d/10-udev-my.rules </para>
<para/>
<para># First rule</para>
<para>SUBSYSTEM=="block", KERNEL=="sd*", ACTION=="add", NAME="%k", GROUP="disk", RUN+="/etc/udev/scripts/udev-flash-mount add %k"</para>
<para>#Second rule</para>
<para>SUBSYSTEM=="block", KERNEL=="sd*", ACTION=="remove", RUN+="/etc/udev/scripts/udev-flash-mount remove %k"</para>
<para/>
<para>Теперь разберемся в том, что написали. </para>
<para>Первое правило (добавление устройства) </para>
<para>SUBSYSTEM=="block" При добавлении нового устройства в систему возникает множество событий разных классов. block - это класс для блочных устройств, который нам больше всего подходит для составления правила. Для просмотра значений всех переменных, возникающих событий используйте udevmonitor --env Т.о. здесь мы реагируем только на событие, в окружении которого есть переменная SUBSYSTEM со значением block . </para>
<para>KERNEL=="sd*" Эта часть правила сравнивает имя устройства, которое было дано по умолчанию ядром, с шаблоном. В данном случае нам нужны такие имена как: sda, sda1, sdb, sdb1 и т.д. </para>
<para>ACTION=="add" Реагируем на событие добавления устройства. Например, usb флэшка была вставлена в разьем. </para>
<para>NAME="%k" Обратите внимание на то, что здесь стоит один знак равенства, а не два, как в предыдущих частях правила. Это говорит о присваивании, а не сравнении. Здесь мы присваиваем вставленному устройству имя, которое соответствует тому, что было дано по умолчанию ядром. %k это одна из переменных окружения. Подробнее о них можно прочитать в man udev. </para>
<para>GROUP="disk" Причисляем устройство к группе дисковых. </para>
<para>RUN+="/etc/udev/scripts/udev-flash-mount add %k" Это самая интересная часть скрипта. Здесь мы добавляем ("+=") одно из действий, которое произойдет после обработки правила. В данном случае мы запускаем скрипт (он будет рассмотрен далее) /etc/udev/scripts/udev-flash-mount и передаем ему 2 параметра. Первый указывает на то что нужно выполнить действия по добавлению и инициализации нового устройства, а второй содержит имя устройства, с которым нужно выполнять действия. </para>
<para>Второе правило (удаление устройства) </para>
<para>ACTION=="remove" Реагируем на удаление устройства. </para>
<para>RUN+="/etc/udev/scripts/udev-flash-mount remove %k" Здесь мы запускаем скрипт, использовавшийся в первом правиле, но уже для выполнения действий после удаления устройства из системы. Этот скрипт будет выполнен как только ядро заметит, что устройство было удалено из системы. Это не самое лучшее решение, т.к. данные могут быть утеряны, но об этом в следующем разделе. </para>
<para/></section><section><info><title>Пишем скрипт </title></info>
<para/>
<para>Теперь напишем скрипт, который будет выполняться после добавления устройства и после его удаления. Допустим он будет размещен в /usr/bin/. Итак, от пользователя root: </para>
<para># su</para>
<para/>
<para>Создадим файл: </para>
<para># touch /etc/udev/scripts/udev-flash-mount</para>
<para/>
<para>Сделаем его исполняемым: </para>
<para># chmod u+x /etc/udev/scripts/udev-flash-mount</para>
<para/>
<para>Напишем в нем следующее: Файл: /etc/udev/scripts/udev-flash-mount </para>
<para>#!/bin/bash</para>
<para/>
<para>LOG="/var/log/udev"</para>
<para> </para>
<para>sleep 3</para>
<para>  </para>
<para>DEV=`echo $2 | sed -n '/^sd[a-z][1-9]\?/p'`</para>
<para>if [ "$1" = "add" ]; then</para>
<para>  if [ "$DEV" != "" ]; then</para>
<para>    echo "--- `date` ---" &gt;&gt; $LOG</para>
<para>    echo "Mounting /dev/$DEV" &gt;&gt; $LOG</para>
<para>    mkdir /mnt/$DEV &gt;&gt; $LOG 2&gt;&amp;1</para>
<para>    chmod a+rwx /mnt/$DEV &gt;&gt; $LOG 2&gt;&amp;1</para>
<para>    mount /dev/$DEV /mnt/$DEV -o sync,umask=0000,iocharset=cp1251 &gt;&gt; $LOG 2&gt;&amp;1</para>
<para>  fi</para>
<para>elif [ "$1" = "remove" ]; then</para>
<para>  if [ "$DEV" != "" ]; then</para>
<para>    echo "--- `date` ---" &gt;&gt; $LOG</para>
<para>    echo "Unmounting /dev/$DEV" &gt;&gt; $LOG</para>
<para>    umount /dev/$DEV &gt;&gt; $LOG 2&gt;&amp;1</para>
<para>    rm -rf /mnt/$DEV &gt;&gt; $LOG 2&gt;&amp;1</para>
<para>  fi</para>
<para>fi</para>
<para/>
<para/>
<para>Задержка в 3 или более секунд необходима для того, чтобы ядро успело выполнить свои действия по инициализации устройства. Если не лень, то поэкспериментируйте с задержкой. Если скрипту был передан параметр add, то он создает папку с именем устройства, затем пытается примонтировать устройство в эту папку. Весь вывод, в том числе и ошибки, выводятся в файл лога. Соответственно, при вызове скрипта с параметром remove, он пытается отмонтировать устройство и удалить ранее созданную папку. Предупреждение: Опция sync в параметрах mount является необходимой, т.к. форсирует мгновенную запись на устройство. Если ее не будет, то когда вы удалите устройство из системы, данные не будут записаны на него. Поэтому, чтобы избежать проблем такого рода, дождитесь пока индикатор на носителе перестанет мигать и после этого извлеките устройство. НО для файловой системы fat c версии ядра linux 2.6.13 sync ставить нельзя т.к. функционирование данной опции сильно изменилось и максимальная скорость записи на usb2.0 это 200 клибойт в секунду а для usb1.0 это где то 10 - 20 килобайт в секунду. Кроме того, опция sync в параметрах mount убьет Вашу флешку с гарантией за 6 месяцев использования. См. http://bugs.debian.org/309625 </para>
<para>Предупреждение: Внимание! Если какая-либо запущенная программа просматривает содержимое папки, в которую смонтировано устройство, то скрипт не сможет отмонтировать его и удалить папку. Поэтому сначала убедитесь в том, что ни одна из программ не использует эту папку. </para>
<para/></section><section><info><title>Заключение </title></info>
<para/>
<para>Последний скрипт можно немного модернизировать. Предположим, если вы монтируете свою камеру, чтобы просмотреть фотографии, то можно передать скрипту еще один параметр из udev правила, например, с производителем устройства. Либо можно проанализировать содержимое каталога и на основе этого выполнить какие-либо действия. Все в ваших руках, дерзайте</para>
<para/></section></section><section><info><title> Оптимизация glibc</title></info>
<para/><section><info><title>Введение </title></info>
<para/>
<para>Glibc - свободная библиотека, предоставляющая системные вызовы и другие основные операторы для основных систем GNU/Linux. Если C является наиболее распространённым языком, используемым для программирования в Linux, такая же судьба постигла и glibc - она является продуманной частью ядра системы. Glibc может быть оптимизирована на вашей системе для ускорения операций различными способами. Оптимизация, естественно, зависит от вашей системы и её использования. Это также зависит от установки флагов USE, доступных при выполнении emerge. До применения рекомендаций рекомендуется узнать о назначении и использовании флагов USE. Есть неплохая инструкция здесь. </para>
<para/></section><section><info><title>Оптимизация компиляции Glibc </title></info>
<para/>
<para>Эффект CFLAGS </para>
<para/>
<para>Компиляция Glibc с возможностями GCC используется в основном коде glibc. Glibc идентифицирует GCC как компилятор и использует установленный флаги CFLAGS.Подробней здесь. Используя правильные флаги CFLAGS для вашей системы, вы можете хорошо оптимизировать glibc. </para>
<para/>
<para>Улучшение оптимизации </para>
<para/>
<para>Если вы использовали -fomit-frame-pointer, вы можете также поместить glibc-omitfp во флаги USE. Повторно пересоберите glibc. Code: Remerging glibc </para>
<para>emerge --newuse -v world</para>
<para/>
<para>При этом соберутся Glibc и её зависимости. При компиляции glibc этот флаг активизирует флаг -enable-omitfp, который, в свою очередь, указывает glibc на использование --fomit-frame-pointer. В результате более безопасно устанавливается указатель кадра. Этот флаг устанавливает максимальную оптимизацию glibc и предоставляет два типа библиотек - 'оптимизированная' и 'стандартная'. То есть, по умолчанию будут использоваться оптимизированные библиотеки, но при необходимости можно будет использовать 'стандартную' версию. Это увеличит размер glibc и приведет к обычному поведению при установленном --fomit-frame-pointer, т.е. сделает невозможным отладку (debug) программ, так что не используйте этот флаг если вы планируете заниматься разработкой программ. Теоретически этот флаг может вызвать некоторые ошибки компилятора, хотя на практике он достаточно безопасен, тем не менее вы были предупреждены. </para>
<para/>
<para>Модели потоков </para>
<para/>
<para>glibc поддерживает 2 различных модели потоков - старую linuxthreads и новую nptl. По умолчанию, если не был указан флаг nptlonly, кроме nptl собирается и версия с linuxthreads. В случае, если у вас нет устаревшего программного обеспечения, вы можете указать флаг nptl. Если у вас современная система без сторонних бинарных пакетов, будет лучше указать nptlonly, чтобы избежать сборки glibc дважды (с поддежкой linuxthreads и без неё). </para>
<para/></section><section><info><title>Локализация </title></info>
<para/>
<para>В основном это основано на еженедельном новостном бюллетене Gentoo от 8 ноября 2004 года, который можно найти здесь (en:TIP Specifying only needed locales). Вы можете выбрать, какие локали (включая раскладки и установки клавиатуры, времени и т.д.) будут собраны при установке. Если вы не ограничите локали, используемые в вашей системе, будут собраны все имеющиеся локали, начиная с aa_DJ (локаль Афар для Джибути) через en_GB (английская локаль для Великобритании) и заканчивая zu_ZA.utf8 (локаль Зулу для Южной Африки). При ограничении сборки локалей вы можете сохранить до 90% места, необходимого для Glibc в вашей системе, сохранить время, необходимое на сборку ненужных вам локале и, как следствие, уменьшить общее время компиляции. Если вы действительно не нуждаетесь в них всех (а трудно представить, кому это могло бы понадобиться), вы можете ограничить их необходимым минимумом. </para>
<para/>
<para>Используйте флаг USE userlocales для сборки только тех локалей, которые указаны в /etc/locales.build. </para>
<para/>
<para>Отредактируйте /etc/make.conf в вашем любимом редакторе и поместите userlocales где-нибудь между "" в строке USE="". </para>
<para/>
<para>Другой способ - изменить /etc/portage/package.use используя данную команду: Code: Activating the userlocales USE flag for glibc </para>
<para>echo "sys-libs/glibc userlocales" &gt;&gt; /etc/portage/package.use</para>
<para/>
<para/>
<para>После этого вы можете указать локали, которые хотите использовать: </para>
<para>Файл: nano -w /etc/locales.build </para>
<para>#Читайте комментарии в начале файла для большей информации!</para>
<para>en_US/ISO-8859-1</para>
<para>en_US.UTF-8/UTF-8</para>
<para>#en_GB/ISO-8859-1</para>
<para>#en_GB.UTF-8/UTF-8</para>
<para>de_DE/ISO-8859-1</para>
<para>de_DE@euro/ISO-8859-15</para>
<para>ru_RU.UTF-8/UTF-8</para>
<para/>
<para>В glibc-2.3.6-r4 или glibc-2.4-r2, был удалён флаг userlocales. Вы должны править файл /etc/locale.gen и удалить /etc/locales.build. </para>
<para/>
<para>Вы можете воспользоваться для этого следующими командами: Code: Convert locales.build to locale.gen </para>
<para>cd /etc</para>
<para>grep '^[^#].*' locales.build | sed 's:/: :' &gt; locale.gen</para>
<para>rm locales.build</para>
<para>nano -w locale.gen</para>
<para>Файл: nano -w /etc/locale.gen </para>
<para>#Читайте комментарии в начале файла для большей информации!</para>
<para>en_US.UTF-8 UTF-8</para>
<para>en_US ISO-8859-1</para>
<para>ru_RU.UTF-8 UTF-8</para>
<para>de_DE ISO-8859-1</para>
<para>de_DE@euro ISO-8859-15</para>
<para/>
<para/>
<para>Вы можете найти правильные значения локалей в файле /usr/share/i18n/SUPPORTED. </para>
<para/>
<para>Помогите! Я не знаю, какими должны быть настройки моей локали! </para>
<para/>
<para>Не волнуйтесь, это просто. Записи в этом файле должны быть в формате &lt;locale&gt;/&lt;charmap&gt;. &lt;locale&gt; это локаль из каталога /usr/share/i18n/locales, а &lt;charmap&gt; -- это имя одного из файлов каталога /usr/share/i18n/charmaps/. Нужно только понимать два момента: первое, локаль с новой валютой, такой как евро, требует изменения @euro, описанного в примере выше. Второе, локали UTF-8 требуют от вас добавления .UTF-8 в конец определения локали (нет, я не знаю, зачем, но иначе оно не работает). </para>
<para/>
<para>Если вы В САМОМ ДЕЛЕ хотите минимизировать ваши локали, вам всего лишь нужно перевести вашу систему на Юникод. Вообще-то пока есть причины этого не делать, но это уже становится стандартом de facto, так как несёт множество преимуществ перед старыми форматами ISO, ASCII и другими. Больше об этом можно прочесть здесь и здесь, а также непосредственно в соответствующем руководстве с сайта Gentoo. </para>
<para/>
<para>Вам просто нужно определить следующее: Файл: nano -w /etc/locales.build </para>
<para>#Как раньше!</para>
<para>en_US.UTF-8/UTF-8</para>
<para>ru_RU.UTF-8/UTF-8</para>
<para/>
<para/>
<para>Обратите внимание, я оставил строку US UTF-8. Её лучше не убирать, так как некоторые программы не соберутся без неё. </para>
<para/>
<para>Сделайте это до установки Gentoo </para>
<para/>
<para>Вы можете выполнить эти настройки до началасборки системы с нуля. Просто следуйте инструкциям из Gentoo Handbook. Это позволит меньше волноваться о возможных недоделках программ после сборки и наслаждаться быстрой сборкой. </para>
<para/>
<para>Сделайте это после установки Gentoo </para>
<para/>
<para>Если glibc уже установлена, вам потребуется пересобрать glibc:</para>
<para>Code: Пересборка glibc </para>
<para>emerge glibc</para>
<para/>
<para>Вы также можете пересобрать world, если пакеты были скомпилированы с поддержкой множества локалей, но полученное ускорение работы пакетов и сэкономленное дисковое пространство не стоят затрат времени. Придётся затратить очень много времени на пересборку всей системы. </para>
<para>Возможно, вам стоит обратить внимание на пакет localepurge, который может очистить систему от любых установленных man страниц или info-файлов на языках не используемых в вашей системе. Вначале прочитайте man к localepurge, что бы определить локали, которые необходимо пропустить в /etc/locale.nopurge. </para>
<para>Для большей инфомации об управлении локалями читайте: </para>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gentoo.org/doc/ru/guide-localization.xml">Gentoo Linux Localization Guide</link>. </para>
    <para>Или на русском языке <link xlink:href="#">Руководство по русской локализации Gentoo Linux</link>. </para>
<para>Эта оптимизация полностью безопасна (Кроме случаев, если вы не можете читать на языке, который установили!). </para></section><section><info><title>Безопасность </title></info>
<para/>
<para>Как безопасность относится к оптимизации? Итак, это оптимизация безопасности, поскольку ранее было сказано, как оптимизация зависит от вашей системы и как всё это работает. Если это сервер, вы, к примеру, можете пожертвовать оптимизацией в угоду безопасности, или выполнить обе оптимизации. </para>
<para/>
<para>Стабилизация Glibc </para>
<para/>
<para>Это предполагает (как вы, возможно, догадывались...) использование флага USE hardened. Это сделает вашу систему более устойчивой к нападениям разного вида. </para>
<para/>
<para>Усиление стека </para>
<para/>
<para>Используйте флаг erandom если вам необходимо использование модуля случайных чисел, установленного в вашем ядре.</para>
<para/></section></section><section><info><title>Подключение USB-flash</title></info>
<para/><section><info><title>Подключение USB-flash к компьютеру</title></info>
<para/>
<para>Введение</para>
<para>В Linux я пользователь новый и с этим вопросом никогда не сталкивался, и более того - ядро по жизни собирал без поддержки USB устройств, т.к. ничего такого у меня просто нет :), но вот, как говорится - пришлось и срочно. И как оказалось - это довольно несложно. </para>
<para>Итак, по прочтении парочки-тройки вопросов связанных с USB, и небольшого количества теории - я без проблем подмонтировал USB флешку. Примечание: Что такое флешка и USB описывать не буду, т.к. если читатель этого не знает - то имхо ему следует сначала прочесть несколько других статей. </para>
<para/>
<para>Итак, начнем </para>
<para/>
<para>Конфигурация ядра</para>
<para>USB флешки видны в Linux как scsi устройства,ибо поддержка usb устройств в ядре Linux реализуется именно посредством эмуляции скази, т.е. типа /dev/sda1(2,3) и т.д, смотря сколько партиций. </para>
<para>Следовательно, чтобы была возможность подключения флешки, сначала необходимо добавить поддержку scsi в ядро </para>
<para>Linux Kernel Configuration: Включаем поддержку SCSI </para>
<para>Device Drivers ---&gt; </para>
<para> SCSI device support</para>
<para>  &lt;*&gt;legacy /proc/scsi/ support</para>
<para>  --- SCSI support type (disk, tape, CD-ROM)</para>
<para>  &lt;*&gt; SCSI disk support</para>
<para>  &lt;*&gt; SCSI generic support</para>
<para>  --- Some SCSI devices (e.g. CD jukebox) support multiple LUNs</para>
<para>  &lt;*&gt; Probe all LUNs on each SCSI device</para>
<para/>
<para>Далее добавляем непосредственно поддержку USB (я не говорю о клавиатурах или других устройствах USB, а говорю только о флешке) </para>
<para>Linux Kernel Configuration: Поддержка USB </para>
<para>Device Drivers ---&gt;</para>
<para> USB support</para>
<para>  &lt;*&gt; Support for Host-side USB</para>
<para>  &lt;*&gt; USB device filesystem</para>
<para>  &lt;*&gt; EHCI HCD (USB 2.0) support</para>
<para>  &lt; &gt; OHCI HCD support</para>
<para>  &lt;*&gt; UHCI HCD (most Intel and VIA) support</para>
<para>  &lt;*&gt; USB Mass Storage support</para>
<para>Примечание: В разделе USB Mass Storage support есть куча других устройств - я там не отмечал ничего, у меня заработало и так. Подозреваю, что для специфических устройств (всмысле каких то навороченных флешок) нужно будет что нибудь еще там отметить. </para>
<para/>
<para>Кроме того, для этих всяких сложных флешок скорее всего придется добавить MTD в ядро</para>
<para>Linux Kernel Configuration: MTD </para>
<para>Device Drivers ---&gt;</para>
<para> Memory Technology Devices (MTD) ---&gt;</para>
<para/>
<para>ну и там смотрим, что нужно. Примечание: Для большинства современных флэшек, USB носителей и цифровых фотоаппаратов поддержка MTD не требуется. </para>
<para/>
<para>Монтирование</para>
<para>После загрузки с новым ядром, нажимаем Alt+F12 и вставляем флешку - если с ядром все ок- то сразу появятся сообщения, что мол есть устройство USB , потом пишется, что есть /dev/uba ну и т.п. </para>
<para>Если этого не происходит, делаем </para>
<para>dmesg | grep usb </para>
<para>Если и здесь ничего нет, то советую перегрузиться и посмотреть включены ли USB контроллеры в BIOS :) как это не смешно звучит, но я сам себе это отрубил, когда ядро собирал, а потом включить забыл, и минут 15 гадал - чего же оно не работает :) </para>
<para>Если dmesg | grep usb выдает результат, а когда вставляем флешку - никакой реакции, то нужно проверить еще раз - все ли отмечено в ядре. </para>
<para>Вобщем - надеемся , что все заработало и теперь нужно смонтировать флешку. </para>
<para>Добавляем в /etc/fstab строку </para>
<para>Файл: /etc/fstab </para>
<para>/dev/uba1 /mnt/usbdir auto user,noauto,rw 0 0 </para>
<para/>
<para>и можно монтировать! но есть одно но, в опциях я не указал кодировки, т.к. кодировка по умолчанию указанна в разделе Native Languages конфигурации ядра. </para>
<para>Не будет лишним напомнить отмонтировать флешку перед тем как вытаскивать ее! </para>
<para>Если такой вариант вас не устраивает, то вы можете установить пакет submount и монтировать флэшку вот так: </para>
<para>Файл: /etc/fstab </para>
<para> /dev/uba1 /mnt/usb  subfs  fs=vfat,auto,umask=0,quiet,sync 0 0 </para>
<para/>
<para>Параметр sync необходим чтобы отключить отложенную запись и избежать потерю данных при копировании файлов на флэшку. </para>
<para>Вроде бы все. Удачи всем! </para>
<para>И естественно- за любые комментарии, дополнения, уточнения и исправления ошибок – буду только благодарен :) </para>
<para/>
<para>надеюсь, кому-то помог tradakad </para>
<para>исправил касательно монтирования при помощи submount (dernik) </para>
<para/>
</section>
    <section>
        <info><title>Монтирование под kde</title></info>
<para>Установите пакеты: hal, dbus, and hotplug </para>
<para/>
<para>Добавьте флаг hal в /etc/make.conf </para>
<para>emerge -avt kdebase-kioslaves </para>
<para/>
<para>Убедитесь, что hal используется всеми пакетами: </para>
<para>emerge -DNu world</para>
<para>rc-update add dbus default</para>
<para>/etc/init.d/dbus start</para>
<para>rc-update add hald default</para>
<para>/etc/init.d/hald start</para>
<para/>
<para>так же можно монтировать устройства без изменения /etc/fstab с помощью </para>
<para>emerge -av pmount</para>
<para/>
<para>Добавьте себя в групп plugdev </para>
<para>gpasswd -a USER plugdev</para>
<para/>
<para>Включите "Storage media" ("Устройства хранения данных" в русском варианте) в systray (на панель). Наслаждайтесь :) </para>
<para/></section><section><info><title>Автоматическое монтирование </title></info>
<para/>
<para>Если лень замарачиваться каждый раз при втыкании флэшки или сидюка, а хочется, чтоб как в одной другой ОС, добавьте параметр managed в /etc/fstab к требуемому устройству, например </para>
<para>Файл: /etc/fstab </para>
<para> /dev/cdrw    /mnt/cdrom    iso9660    user,noauto,ro,managed          0 0</para>
<para> /dev/sda     /mnt/flash    vfat       exec,user,noauto,sync,managed    0 0</para>
<para/>
<para>Типа, все, теперь при появлении флэшки в системе будет появляться иконка на рабочем столе. </para>
<para>ps. распишите эту статью подробнее. Добавьте gpasswd в статью:</para>
<para> <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://gentoo-wiki.com/HOWTO_D-BUS,_HAL,_KDE_media:/">http://gentoo-wiki.com/HOWTO_D-BUS,_HAL,_KDE_media:/</link>
</para>
<para/></section></section><section><info><title>Чтение-запись NTFS с использованием драйвера ntfs-3g</title></info>
<para/><section><info><title>Введение</title></info>
<para/>
<para>"Драйвер ntfs-3g является открытым, лицензированным по GPL, драйвером NTFS для Linux, созданным в рамках проекта Linux-NTFS. Он предоставляет полный доступ к разделам NTFS (чтение-запись), кроме работы с зашифрованными файлами и записи сжатых файлов. Так же не поддерживается смена владельца файла и его прав доступа. Технически он является сильно усовершенствованным драйвером ntfsmount. Улучшена функциональность, качество и добавлены дополнительные возможности." (Szakacsits Szabolcs, автор ntfs-3g) </para>
<para/>
<para>Автор создал драйвер, который гораздо лучше пригоден для использования, чем другие драйвера NTFS для Linux, и при этом не менее быстрый, чем драйвера родных файловых систем Linux - временами в два раза быстрее чем родной модуль файловой системы EXT3 в ядре. </para>
<para/>
<para>Для получения более подробной информации посетите: [1]</para>
<para>Предупреждение: Драйвер имеет статус BETA, имеются некоторые не решённые вопросы, возможна потеря данных и/или зависания при попытке примонтировать раздел. Он НЕ работает на архитектурах, отличных от x86 и amd64. </para>
<para/>
<para>СДЕЛАЙТЕ РЕЗЕРВНУЮ КОПИЮ ДАННЫХ ПЕРЕД ЛЮБЫМИ ПОПЫТКАМИ ИСПОЛЬЗОВАНИЯ !!! В ЛЮБОМ СЛУЧАЕ - ВЫ ПРЕДУПРЕЖДЕНЫ !!! </para>
<para/></section><section><info><title>Установка</title></info>
<para/>
<para>ebuild драйвера зависит от sys-fs/fuse (portage установит его автоматически). </para>
<para/>
<para>Поскольку это программное обеспечение находится на стадии бета-тестирования, вы должны размаскировать его: </para>
<para># echo "sys-fs/ntfs3g ~x86" &gt;&gt; /etc/portage/package.keywords</para>
<para/>
<para>И установить его: </para>
<para># emerge sys-fs/ntfs3g</para>
<para/>
<para>Модуль ядра fuse должен быть загружен перед использованием драйвера </para>
<para># modules-update</para>
<para># modprobe fuse</para>
<para/>
<para>Примеры использования</para>
<para/>
<para>Монтирование раздела: </para>
<para># ntfs-3g /dev/hda1 /mnt/windows</para>
<para/>
<para>Полный доступ для всех пользователей, без ограничений прав доступа, и поддержкой заданной локали (В примере используется ru_RU.utf8, однако у вас она может отличаться): </para>
<para># ntfs-3g /dev/hda1 /mnt/windows -o silent,umask=0,locale=ru_RU.utf8 </para>
<para/>
<para>Размонтирование </para>
<para># fusermount -u /mnt/windows</para>
<para/>
<para>Прочтите страницу руководства по ntfs-3g для получения более подробной информации. </para>
<para>$ man ntfs-3g</para>
<para/>
<para>Монтирование при загрузке:</para>
<para/>
<para>Для автоматической загрузки модуля fuse при старте системы выполните: </para>
<para># echo "fuse" &gt;&gt; /etc/modules.autoload.d/kernel-2.6</para>
<para/>
<para>Отредактируйте /etc/fstab: </para>
<para># echo "/dev/hda1 /mnt/windows ntfs-3g silent,umask=0,locale=ru_RU.utf8 0 0" &gt;&gt; /etc/fstab</para>
<para/></section><section><info><title>Вопрос обновления ядра</title></info>
<para/>
<para>Если после обновления ядра драйвер перестал работать, сделайте следующее: </para>
<para># emerge sys-fs/fuse</para>
<para># modules-update</para>
<para># modprobe fuse</para>
<para/></section><section><info><title>Отказ от гарантий</title></info>
<para/>
<para>Автор этого документа не отвечает за какие либо последтсвия, связанные с использованием этого драйвера. Всё что вы делаете - вы делаете на свой страх и риск.</para>
<para/></section></section></section><section><info><title>Сетевые сервисы</title></info><section><info><title>Установка Apache2</title></info><section><info><title>Установка </title></info>
<para/>
<para>Apache2 сейчас работает на большинстве системах без проблем, если у вас возникли проблемы прочтите раздел Common Problems это может помочь. </para>
<para>Начнем установку apache2: добавьте "apache2" к вашим USE флагу в файле /etc/make.conf и выполните: </para>
<para>emerge apache</para></section><section><info><title>Запуск Apache </title></info>
<para/>
<para>Запустите Apache2: </para>
<para>/etc/init.d/apache2 start</para>
<para/>
<para>Если вы хотите запускать apache2 при запуске системы выполните комманду: </para>
<para>rc-update add apache2 default</para>
<para/>
<para>Посмотрите init scripts section для дополнительной информации. </para>
<para>Теперь у вас есть работующий веб сервер Apache2. Перейдите в вашем браузере на страницу http://localhost/ и вы должны увидеть страницу приветствия. </para>
<para>Вы найдете в /var/www/localhost/htdocs/index.html HTML код страницы приветствия которую вы видите на http://localhost/. Замечаем что Apache отображает htdocs/index.html когда вы пытаетесь открыть htdocs/ . Это особенность протокола HTTP. Apache не может передать директорию но может показать содержимое. Список (index) файлов в директории может быть передан. Apache ищет страницу со специальным именем index либо генерирует список файлов в директории. Если у вас есть страница с именем 'index' то будет отображена она; в этом случае вы не сможете посмотреть список файлов в директории. </para>
<para/></section><section><info><title>Модули </title></info>
<para/>
<para>Apache очень гибок. Он может сёрфить файлы используя HTTP либо серфить файлы и помощью FTP. Он может передать файл с жесткого диска, либо вывод PHP скрипта. Для реализации этого Apache использует модули. Другие приложения используют для этого плагины. При добавлении модули добавляют функциональность. Их также можно инсталлировать, удалять, пересобирать (перекомпилировать). </para>
<para>Модули Apache обычно называются mod_something. Некоторые уже включены в Апачь а некоторые нужно добавлять отдельно. В портежах содержатся множество модулей. Процесс установки выглядит примерно так: </para>
<orderedlist>
<listitem>
<para>emerge module ;</para>
</listitem>
<listitem>
<para>отредактируйте /etc/conf.d/apache2 для активации добавьте -D MOD ;</para>
</listitem>
<listitem>
<para>опционально /etc/apache2/modules.d/xy_module  ;</para>
</listitem>
<listitem>
<para>добавьте директивы конфигурации в httpd.conf либо .htaccess  ;</para>
</listitem>
</orderedlist>
<para>        emerge mod_perl </para>
<para>        nano /etc/conf.d/apache2</para>
<para>        # change APACHE_OPTS="" to APACHE_OPTS="-D PERL"</para>
<para/>
<para>Документацию по конкретным модулям вы найдете Apache Index in this wiki. Вы также можете почитать the documentation для дополнительной информации о модулях Apache. </para>
<para/></section><section><info><title>Конфигурация </title></info>
<para/>
<para>В файле httpd.conf, (/etc/apache2/httpd.conf,) который поставляется с Gentoo хранятся большинство настроек Apache. However, it probably does both more and less than you need it to. Apache configuration files have a consistent syntax. </para>
<para/>
<para>Любые строки начинающиеся с # игнорируются </para>
<para># Apache не анализирует написанное здесь</para>
<para># это комментарии</para>
<para/>
<para>Некоторые строки начинаются с директивы и могут иметь один или несколько аргументов. </para>
<para/>
<para>Директивы могут быть объединены в секции. Разделы обычно заключены в угловые скобки. </para>
<para>&lt;Section&gt;</para>
<para>  # Will only apply when the section matches</para>
<para>  AnotherDirective</para>
<para>&lt;/Section&gt;</para>
<para/>
<para>В разделе могут быть подразделы. Вот часть файла httpd.conf: </para>
<para># If mod_alias is loaded</para>
<para>&lt;IfModule mod_alias.c&gt;</para>
<para>    # Alias is a directive and it only applies if mod_alias is loaded</para>
<para>    Alias /icons/ "/usr/share/httpd/icons/"</para>
<para>    # If the file is in the directory</para>
<para>    &lt;Directory "/usr/share/httpd/icons"&gt;</para>
<para>        # Options will only apply if:</para>
<para>        #   mod_alias is loaded AND</para>
<para>        #   the file is in the directory</para>
<para>        Options Indexes MultiViews</para>
<para>    &lt;/Directory&gt;</para>
<para>&lt;/IfModule&gt;</para>
<para/>
<para>Вы можете прочитать подробнее configuration files и sections в оффициальная документация Apache. </para>
<para/></section><section><info><title>Common Problems </title></info>
<para/>
<para>SSI Not Working </para>
<para/>
<para>When configuring for SSI (Server Side Includes), an error may occur: </para>
<para>mod_include: Options +Includes (or IncludesNoExec) wasn't set, INCLUDES filter removed</para>
<para>The problem is that setting Options +Includes in either .htaccess or httpd.conf is overwritten by the additional configuration file as defined at the end of httpd.conf. </para>
<para>Include /etc/apache2/vhosts.d/*.conf</para>
<para/>
<para>You need to edit this additional configuration file such that </para>
<para>AllowOverride None</para>
<para/>
<para>Is replaced by </para>
<para>AllowOverride Options</para>
<para/>
<para>Could Not Open Error Log </para>
<para/>
<para>While starting Apache, it prints: </para>
<para>Error while starting apache: (2)No such file or directory: apache2: could not open error log file /usr/lib/apache2/logs/error_log.</para>
<para/>
<para>/usr/lib/apache2/logs should be a symlink pointing to /var/log/apache2 . Check it using: </para>
<para>ls -la /usr/lib/apache2/logs</para>
<para/>
<para>(note the lack of a slash on the end). If /var/log/apache2 is missing, create it and make sure you give apache ownership: </para>
<para>mkdir /var/log/apache2</para>
<para>chown apache:apache /var/log/apache2</para>
<para/>
<para>If the symlink /usr/lib/apache2/logs is missing, you can create it: </para>
<para>ln -s /var/log/apache2 /usr/lib/apache2/logs</para>
<para/>
<para>You don't need to set permissions on the symlink. </para>
<para/>
<para>Check the Logs </para>
<para/>
<para>See /var/log/apache2/error_log for errors, especially towards the end of the file. You may find tail useful because it displays only the last few lines of a file: </para>
<para>tail /var/log/apache2/error_log</para>
<para/>
<para>If you wish to keep an eye one the log the -f option for tail may be useful: </para>
<para> tail -f /var/log/apache2/error_log</para>
<para/>
<para>Here's one error you might see: </para>
<para>Error: [alert] (EAI 2)Name or service not known: mod_unique_id: unable to find IPv4 address of ""</para>
<para/>
<para>With the base installation "mod_unique_id" is turned on, this can cause problems, notably the server not starting. Simply comment out this module in /etc/apache2/httpd.conf and the problem will be solved. </para>
<para/>
<para>(Your config file might be /etc/apache2/conf/apache2.conf) </para>
<para/>
<para>Forbidden User Directories </para>
<para/>
<para>If the server is returning "403 Forbidden" while accessing http://server/~username/ Make sure Apache (usually user apache and group apache) has read access to username's home directory and public_html (or equivalent). You can grant everyone read access using: </para>
<para>chmod 755 ~username/ ~username/public_html/</para>
<para/>
<para>Not Enough Entropy </para>
<para/>
<para>If Apache2 </para>
<para>accepts connections </para>
<para>does not respond to clients </para>
<para>creates exactly one process </para>
<para>is not stopped by </para>
<para>/etc/init.d/apache2 stop</para>
<para/>
<para>Check to see how much entropy is available using: </para>
<para>cat /proc/sys/kernel/random/entropy_avail</para>
<para/>
<para>If little entropy (less than 100) is available, Apache2 is probably waiting for more so it can generate the secret for digest authentication (mod_auth_digest). To generate more entropy, just do something else for a little while. Grepping the kernel or emerging a package usually works well. </para>
<para/>
<para>The video-entropyd and audio-entropyd supply /dev/random with entropy gathered from your video and audio devices, respectively. If you have a hardware random number generator (RNG), you can emerge rng-tools and run rngd. </para>
<para/>
<para>If there's still a shortage of entropy, you can enable the urandom USE flag and re-emerge APR and Apache2. This makes APR use /dev/urandom, which falls back to a pseudorandom number generator when there isn't enough entropy. The program gets a number immediately, but it is cryptographically weaker. This is okay for some things (e.g. solitaire), but completely unacceptable for others (like PGP key generation). </para>
<para/>
<para>Confusing config files </para>
<para/>
<para>If you start the Apache2 server with the startup script /etc/init.d/apache2 check to see if the line </para>
<para/>
<para>local myconf="/etc/apache2/httpd.conf" </para>
<para/>
<para>from /etc/init.d/apache2 points to your configuration script. If it points to apache.conf and you use httpd.conf, make the necessary adjustments. </para>
<para/>
<para/>
<para/>
<para/></section><section><info><title>See Also </title></info>
<para/>
<para>Configure LAMP (Linux, Apache, MySQL, and Python/PHP/Perl) - A popular web server combination </para>
<para>Apache Installation &amp; Configuration </para>
<para>How to install mod_security for Apache</para>
<para/></section></section><section><info><title>Настройка iptables для начинающих</title></info><section><info><title>Введение </title></info>
<para>В сети мало документации по <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</link> рассчитанной на новичков. Мы же попытаемся восполнить этот пробел. Рассмотрим основы составления правил, а также некоторые дополнительные модули которые помогут сделать жизнь легче. </para>
<para>Прежде чем двигаться дальше - убедитесь, что ... </para>
<orderedlist>
<listitem>
<para>Всё ваше аппаратное обеспечение работоспособно. То есть Вы подключили все оборудование, модули грузятся, устройства видны в системе. Полезно в начале проверить, что соединение с интернетом возможно и без всяких там <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</link>. Нет ничего хуже, чем в течении многих часов возиться с упрямой программой, ругая её почём зря, а потом понять, что сетевая карта не работает или модем сконфигурирован неправильно. </para>
</listitem>
<listitem>
<para>Вы имеете представление о сетевых технологиях и Вы знакомы с администрированием Linux и Gentoo Linux в частности. То есть необходимы навыки работы с такими базовыми вещами как <link xlink:href="http://ru.gentoo-wiki.com/index.php?title=Man_ifconfig&amp;action=edit">ifconfig</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=Man_rc-update&amp;action=edit">rc-update</link>, /etc/conf.d/net, и так далее. Если для Вас это пока пустые звуки, то, пожалуйста предварительно изучите <link xlink:href="#">Настольную книгу Gentoo</link> и <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.linuxhelp.ca/guides/networkbasics/">Linux Help's Networking Basics 101</link> </para>
</listitem>
</orderedlist></section><section><info><title>Конфигурация ядра ОС Linux </title></info>
<para>Все что вам нужно - это включить поддержку <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</link>. </para>
<para>Networking ---&gt;</para>
<para>  Networking Options----&gt;</para>
<para>   Network Packet Filtering (replace Ipchains)---&gt;</para>
<para>    Netfilter Configuration</para>
<para>Включим все опции как модули (хотя с точки зрения безопасности модули следует вообще отключить, монолитное ядро надежнее, хотя и медленнее). </para></section><section><info><title>Установка iptables </title></info>
<para>Далее вы должны установить пакет <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</link>: emerge iptables </para></section><section><info><title>Проверка сети </title></info>
<para>Предположим, что у нас есть 2 сетевых интерфейса: eth0 - локальная сеть и ppp0 - интернет соединение. </para>
<para>Проверим работоспособность сети командой <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=Man_ping&amp;action=edit">ping</link>: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ping </para>
</entry>
</row>
<row>
<entry>
<para>ping www.google.com</para>
<para>ping 192.168.1.78 </para>
<para>ping 192.168.2.77</para>
</entry>
</row></tbody></tgroup>
</informaltable></section><section><info><title>Запуск iptables </title></info>
<para>Запустим <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</link>: /etc/init.d/iptables start </para>
<para>Эта команда загрузит основные модули и создаст цепочки в ядре Linux. Теперь добавим <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</link> в автозагрузку: rc-update add iptables default </para></section><section><info><title>Использование /etc/init.d/iptables </title></info>
<para>Скрипт /etc/init.d/iptables понимает несколько команд (/etc/init.d/iptables &lt;команда&gt;), некоторые из них: </para>
<orderedlist>
<listitem>
<para>start - запуск <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</link>. Восстанавливает все правила (правила хранятся в /var/lib/iptables/rules-save); </para>
</listitem>
<listitem>
<para>stop - сброс всех цепочек; </para>
</listitem>
<listitem>
<para>save - сохранение всех правил. </para>
</listitem>
</orderedlist></section><section><info><title>Создание правил </title></info>
<para>Практически все правила можно привести к виду: iptables -A ЦЕПОЧКА ПАРАМЕТРЫ_ПАКЕТА -j ДЕЙСТВИЕ </para>
<para>Цепочки </para>
<para>Все изменения будем проводить над таблицей filter, именно она отвечает за фильтрацию пакетов. В таблице filter существует 3 цепочки: INPUT, OUTPUT и FORWARD. В каждой цепочки свой "тип" пакетов: </para>
<orderedlist>
<listitem>
<para>INPUT - пакеты пришедшие к Вам. То есть входящий трафик. </para>
</listitem>
<listitem>
<para>FORWARD - пакеты которые предназначены для другого узла, то есть транзитный трафик. </para>
</listitem>
<listitem>
<para>OUTPUT - пакеты, которые уходят от нас, или исходящий трафик. </para>
</listitem>
</orderedlist>
<para>Работают с цепочками так: iptables &lt;опция&gt; &lt;цепочка&gt; </para>
<para>Для работы с цепочками предусмотрены следующие опции: </para>
<orderedlist>
<listitem>
<para>-A - добавление нового правила в цепочку. Правило будет добавлено в конец цепочки. </para>
</listitem>
<listitem>
<para>-I - добавление правила не в конец,а туда куда вы укажите. Например команда: </para>
</listitem>
</orderedlist>
<para>iptables -I INPUT 2 bla-bla-bla - сделает наше правило вторым. </para>
<orderedlist>
<listitem>
<para>-D - удаление правила. Например для удаления пятого правила введите: </para>
</listitem>
</orderedlist>
<para>iptables -D INPUT 5 </para>
<orderedlist>
<listitem>
<para>-F - сброс всех правил цепочки. Нужно, например,при удалении ненужной цепочки. </para>
</listitem>
<listitem>
<para>-N - создание пользовательской цепочки. Если не хотите создавать кашу в каждой цепочке, то создайте несколько дополнительных цепочек. Синтаксис такой: iptables -N ЦЕПОЧКА. Только русские буквы, конечно, использовать нельзя. </para>
</listitem>
<listitem>
<para>-X - удаление пользовательской цепочки. </para>
</listitem>
</orderedlist>
<para>ПРИМЕЧАНИЕ: Удалить цепочки INPUT, OUTPUT и FORWARD нельзя. </para>
<orderedlist>
<listitem>
<para>-P - установка политики для цепочки. Например: </para>
</listitem>
</orderedlist>
<para>iptables -P ЦЕПОЧКА ПОЛИТИКА </para></section><section><info><title>Параметры пакетов </title></info>
<para>Итак по каким параметрам можно фильтровать пакеты? Рассмотрим самые основные. </para>
<para>Источник пакета </para>
<para>Для фильтрации по источнику используется опция -s. Например запретим все входящие пакеты с узла 192.168.133.133: iptables -A INPUT -s 192.168.133.133 -j DROP </para>
<para>Можно использовать доменное имя для указания адреса хоста. То есть: iptables -A INPUT -s test.host.jp -j DROP </para>
<para>Также можно указать целую подсеть: iptables -A INPUT -s 192.168.133.0/24 -j DROP </para>
<para>Также вы можете использовать отрицание (знак !). Например так - все пакеты с хостов отличных от 192.168.133.156 будут уничтожаться: iptables -A INPUT -s ! 192.168.133.156 -j DROP </para>
<para/>
<para>Адрес назначения </para>
<para>Для этого нужно использовать опцию -d. Например запретим все исходящие пакеты на хост 192.168.156.156: iptables -A OUTPUT -d 192.168.156.156 -j DROP </para>
<para>Как и в случае с источником пакета можно использовать адреса подсети и доменные имена. Отрицание также работает. </para>
<para/>
<para>Протокол </para>
<para>Опция -p указывает на протокол. Можно использовать all, icmp, tcp, udp. </para>
<para/>
<para>Порт источника </para>
<para>Указывает на порт с которого был прислан пакет. Вот синтаксис: iptables -A INPUT -p tcp --sport 80 -j ACCEPT </para>
<para>Для указания порта необходимо указать протокол (tcp или udp). Можно использовать отрицание. </para>
<para/>
<para>Порт назначения </para>
<para>Порт назначения. Синтаксис: iptables -A INPUT -p tcp --dport 80 -j ACCEPT </para>
<para>Как и в случае с портом источника нужно указать протокол. Можно использовать отрицание. </para></section><section><info><title>Действия над пакетами </title></info>
<para>Проку от того,что мы укажем параметры пакета нет.Нужно указать,что надо с ним делать. Для этого служит опция -j. Рассмотрим основные действия: </para>
<orderedlist>
<listitem>
<para>ACCEPT - разрешить пакет. </para>
</listitem>
<listitem>
<para>DROP - уничтожить пакет. </para>
</listitem>
<listitem>
<para>REJECT - будет отправлено ICMP сообщение, что порт недоступен. </para>
</listitem>
<listitem>
<para>LOG - информация об этом пакете будет добавлена в системный журнал (<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=Man_syslog&amp;action=edit">syslog</link>). </para>
</listitem>
</orderedlist>
<para>В качестве действия можно указать и имя пользовательской цепочки. Например перекинем все пакеты с локальной сети в цепочку, где будет производиться дополнительная проверка: iptables -A INPUT -s 192.168.200.0/24 -j LOCAL_NET </para></section><section><info><title>Пример правил </title></info>
<para>В больши�стве случаев пользователю достаточно выполнить такую последовательность комманд: iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT iptables -A INPUT -i lo -j ACCEPT iptables -P INPUT DROP </para>
<para>Вот собственно и вся настройка. На первый взгляд непонятно, что мы тут вообще сделали. Поэтому ознакомимся с основами составления правил. </para></section><section><info><title>Модули </title></info>
<para>Может сложиться впечатление, что возможностей у <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</link> маловато. Однако с использованием модулей <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=Man_iptables&amp;action=edit">iptables</link> получит просто безграничные возможности. Для указания модуля используется опция -m. Например: iptables -A INPUT -m модуль bla-bla </para>
<para>-m owner </para>
<para>Добавляет следующие опции (опции только для цепочки OUTPUT): </para>
<orderedlist>
<listitem>
<para>--uid-owner UID - UID программы пославшей пакет. </para>
</listitem>
<listitem>
<para>--gid-owner GID - GID прораммы пославшей пакет. </para>
</listitem>
</orderedlist>
<para>Следующие опции доступны только в версиях ядра ниже 2.6.14: </para>
<orderedlist>
<listitem>
<para>--pid-owner PID - PID программы пославшей пакет. </para>
</listitem>
<listitem>
<para>--sid-owner SID - SID (идентификатор сессии) производится проверка SID пакета, значение SID наследуются дочерними процессами от "родителя". </para>
</listitem>
<listitem>
<para>--cmd-owner NAME - имя программы пославшей пакет. </para>
</listitem>
</orderedlist>
<para/>
<para>-m multiport </para>
<para>Позволяет указывать не по одному порту, а сразу несколько: </para>
<orderedlist>
<listitem>
<para>--source-ports порт1,порт2 - список портов, с которых пришел пакет; </para>
</listitem>
<listitem>
<para>--sports порт1,порт2 - укороченый аналог --source-ports; </para>
</listitem>
<listitem>
<para>--destination-ports порт1,порт2 - список портов назначения; </para>
</listitem>
<listitem>
<para>--dports порт1,порт2 - укороченый аналог --destination-ports; </para>
</listitem>
<listitem>
<para>--ports порт1,порт2 - проверяет как исходящий так и входящий порт пакета. </para>
</listitem>
</orderedlist>
<para/>
<para>-m state </para>
<para>Предназначен для указания состояния пакета с помощью опции --state. Доступны следующие типы пакетов: </para>
<orderedlist>
<listitem>
<para>NEW - пакет устанавливающий новое соединение. </para>
</listitem>
<listitem>
<para>ESTABLISHED - пакет от уже установленного соединения. </para>
</listitem>
<listitem>
<para>RELATED - новый пакет уже установленном соединении. </para>
</listitem>
</orderedlist>
<para/>
<para>-m mac </para>
<para>Проверяет соответствие MAC-адреса в пакете с помощью опции --mac-source, например: </para>
<para>iptables -A INPUT -s 192.168.0.1 -m mac --mac-source 00:65:3F:ED:12:98 -j DROP</para>
<para>Получено с <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/Настройка_iptables_для_начинающих">http://ru.gentoo-wiki.com/Настройка_iptables_для_начинающих</link>
</para>
<para/></section></section><section><info><title>Подробная настройка iptables</title></info>
<para/><section><info><title>Введение</title></info>
<para>Документация по iptables в сети не рассчитана на новичков. В этой статье будет сжато и быстро описаны команды, затем, возможно, будут правки и добавления для расширенного объяснения. Так что это будет минимальная установка которую мы в дальнейшем расширим и упрочим с помощью правил. </para>
<para>Так же примите во внимание, что будет использовано pppoe соединение и 2.6.x ядро. Для настройки сетевой карты надо будет заменить ppp0 на eth0 (или подходящий по смыслу ваш сетевой интерфейс глядящий в интернет) </para>
<para> Прежде чем двигаться дальше - убедитесь, что ...</para>
<orderedlist>
<listitem>
<para>1.Всё ваше аппаратное обеспечение работоспособно. То есть вы все подключили, модули грузятся, устройства видны в системе. Полезно вначале проверить, что соединение с интернетом возможно и без всяких там iptables. Нет ничего хуже, чем в течение многих часов возиться с упрямой программой, ругая её почём зря, а потом понять, что сетевая плата не работает или модем сконфигурирован неправильно. </para>
</listitem>
<listitem>
<para>2.Вы читали маны по теме. Предполагается, что, пока вы изучаете это руководство, man iptables постоянно открыт в соседнем терминале для точного понимания и уточнения, что же та или иная команда означает на самом деле. </para>
</listitem>
<listitem>
<para>3.Вы имеете представление о сетевых технологиях и Вы знакомы с администрированием Linux и Gentoo Linux в частности. То есть необходимы навыки работы с такими базовыми вещами как <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=Ifconfig&amp;action=edit">ifconfig</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=Rc-update&amp;action=edit">rc-update</link>, /etc/conf.d/net, и так далее. Если для вас это пока пустые звуки, то, пожалуйста предварительно изучите <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gentoo.org/doc/en/handbook/index.xml">The Gentoo Handbook</link> и <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.linuxhelp.ca/guides/networkbasics/">Linux Help's Networking Basics 101</link> </para>
</listitem>
</orderedlist></section><section><info><title>Конфигурация ядра</title></info>
<para>Все что вам нужно - это включить поддержку iptables. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Linux Kernel Configuration: Включение IPTables </para>
</entry>
</row>
<row>
<entry>
<para>Device Drivers---&gt;</para>
<para> Networking Support---&gt;</para>
<para>  Networking Options----&gt;</para>
<para>   Network Packet Filtering (replace Ipchains)---&gt;</para>
<para>    Netfilter Configuration</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Я включил все опции как модули (с тем рассчетом, что я захочу попробовать другие опции позже) и добавил ip_tables в modules.autoload. Это загрузит еще несколько модулей в качестве зависимостей. Модуль ip_conntrack необходим для "statefull" фильтрования, то есть для отслеживания соединений. Для запуска скриптов выполните команду : </para>
<para># modprobe ip_tables </para>
</section>
     <section>
         <info><title>Необходимые утилиты</title></info>
<para>Далее вы должны установить пакет iptables: </para>
<para># emerge iptables </para></section><section><info><title>Конфигурация интерфейсов</title></info>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/Сетевые_протоколы_индекс">Сетевые протоколы</link> </para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/Сетевые_протоколы_индекс#.D0.9F.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.8B_.D1.83.D1.80.D0.BE.D0.B2.D0.BD.D1.8F_.D0.BF.D1.80.D0.B8.D0.BB.D0.BE.D0.B6.D0.B5.D0.BD.D0.B8.D1.8F">Прикладной уровень</link>
</para>
</entry>
<entry>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=HTTP&amp;action=edit">HTTP</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=SMTP&amp;action=edit">SMTP</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=SSH&amp;action=edit">SSH</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=SNMP&amp;action=edit">SNMP</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/FTP">FTP</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=NNTP&amp;action=edit">NNTP</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=NTP&amp;action=edit">NTP</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=LDAP&amp;action=edit">LDAP</link>, ...</para>
</entry>
</row>
<row>
<entry>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/Сетевые_протоколы_индекс#.D0.9F.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.8B_.D1.81.D0.B5.D0.B0.D0.BD.D1.81.D0.BE.D0.B2.D0.BE.D0.B3.D0.BE_.D1.83.D1.80.D0.BE.D0.B2.D0.BD.D1.8F">Сеансовый уровень</link>
</para>
</entry>
<entry>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=TLS&amp;action=edit">TLS</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=SSL&amp;action=edit">SSL</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=RPC&amp;action=edit">RPC</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=WSP&amp;action=edit">WSP</link>...</para>
</entry>
</row>
<row>
<entry>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/Сетевые_протоколы_индекс#.D0.9F.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.8B_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D0.BD.D0.BE.D0.B3.D0.BE_.D1.83.D1.80.D0.BE.D0.B2.D0.BD.D1.8F">Транспортный уровень</link>
</para>
</entry>
<entry>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=TCP&amp;action=edit">TCP</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=UDP&amp;action=edit">UDP</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=SCTP&amp;action=edit">SCTP</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/ICMP">ICMP</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/OSPF">OSPF</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=RSVP&amp;action=edit">RSVP</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=VRRP&amp;action=edit">VRRP</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/RTP">RTP</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=DCCP&amp;action=edit">DCCP</link> ...</para>
</entry>
</row>
<row>
<entry>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/Сетевые_протоколы_индекс#.D0.9F.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.8B_.D1.81.D0.B5.D1.82.D0.B5.D0.B2.D0.BE.D0.B3.D0.BE_.D1.83.D1.80.D0.BE.D0.B2.D0.BD.D1.8F">Сетевой уровень</link>
</para>
</entry>
<entry>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/IP">IPv4</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=IPv6&amp;action=edit">IPv6</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/ARP">ARP</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=RARP&amp;action=edit">RARP</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=MPLS&amp;action=edit">MPLS</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=IPX&amp;action=edit">IPX</link> ...</para>
</entry>
</row>
<row>
<entry>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/Сетевые_протоколы_индекс#.D0.9F.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.8B_.D0.BA.D0.B0.D0.BD.D0.B0.D0.BB.D1.8C.D0.BD.D0.BE.D0.B3.D0.BE_.D1.83.D1.80.D0.BE.D0.B2.D0.BD.D1.8F">Канальный уровень</link>
</para>
</entry>
<entry>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=Ethernet&amp;action=edit">Ethernet</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=IEEE_802&amp;action=edit">802.11</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=DSL&amp;action=edit">xDSL</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=Fibre_Channel&amp;action=edit">Fibre Channel</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=FDDI&amp;action=edit">FDDI</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=ATM&amp;action=edit">ATM</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/index.php?title=ISDN&amp;action=edit">ISDN</link> ...</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>В моем случае имеется 3 сетевых адаптера. Один подключен к <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/WAN">WAN</link> через pppoe. Другие два - к моей внутренней сети. Для того, чтобы не было проблем с iptables и маскардингом (<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/NAT">NAT</link>'ом), они должны быть сконфигурированы для различных подсетей. Для примера, 2 сетевых адаптера подключены к моим внутренним компьютерам (внутренние сетевые интерфейсы). Им присвоены IP-адреса: 192.168.1.1 и 192.168.2.1. </para>
<para>Следует заметить, что будет лучше если подключать эти внутренние адаптеры в любое сетевое устройство, такие как свитч и хаб. Для pppoe подключений мы должны убедиться, что сетевой адаптер подключен к внешнему миру, то есть внешним интерфейсам не присвоены никакие IP-адреса. Его запись в /etc/conf.d/net должна оставаться пустой. Это делается потому, что pppoe выступает в качестве виртуального устройства, которое включается вслед за сетевым интерфейсом. Мы также должны присвоить правильные сетевые маски и широковещательные адреса для этих интерфейсов. Ваш conf.d/ должна выглядеть примерно так: </para>
<para>Сервер</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/conf.d/net </para>
</entry>
</row>
<row>
<entry>
<para> # Для pppoe подключений вы не должны указывать значения для [[eth0]], </para>
<para> # просто добавьте net.ppp0 или rc-pppoe в default уровень загрузки.</para>
<para> iface_eth0="192.168.1.1 broadcast 192.168.1.255 netmask 255.255.255.0"</para>
<para> iface_eth1="192.168.2.1 broadcast 192.168.2.255 netmask 255.255.255.0"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Заметьте, что не было указано никаких шлюзов. </para>
<para>Клиент1</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/conf.d/net </para>
</entry>
</row>
<row>
<entry>
<para> iface_eth0="192.168.1.77 broadcast 192.168.1.255 netmask 255.255.255.0"</para>
<para> gateway="eth0/192.168.1.1"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para/>
<para>Клиент2</para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /etc/conf.d/net </para>
</entry>
</row>
<row>
<entry>
<para> iface_eth0="192.168.2.77 broadcast 192.168.2.255 netmask 255.255.255.0"</para>
<para> gateway="eth0/192.168.2.1"</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Шлюз для клиентов установлен на внутренний IP сетевого интерфейса сервера, что и логично. Теперь добавьте все интерфейсы в default уровень загрузки и перезапустите подключения: </para>
<para># rc-update add net.eth1 default &amp;&amp; rc-update add net.eth2 default &amp;&amp; rc-update add net.ppp0 default </para>
<para>и </para>
<para># /etc/init.d/net.eth1 start &amp;&amp; /etc/init.d/net.eth2 start &amp;&amp; /etc/init.d/net.ppp0 start </para>
<orderedlist>
<listitem>
<para>Для клиентов: </para>
</listitem>
</orderedlist>
<para># /etc/init.d/net.eth0 restart </para></section><section><info><title>Проверка настроек</title></info>
<para>Теперь убедитесь в том, что ваш сервер подключен к интернету, а также все интерфейсы могут пинговать друг друга. Для сервера: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ping </para>
</entry>
</row>
<row>
<entry>
<para>ping www.google.com; </para>
<para>ping 192.168.1.78 </para>
<para>ping 192.168.2.78</para>
<para>ping 192.168.1.77</para>
<para>ping 192.168.2.77</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Убедитесь что у клиентов правильно указаны <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ru.gentoo-wiki.com/DNS">DNS</link>-сервера в /etc/resolv.conf </para></section><section><info><title>Scripting</title></info>
<para>Теперь интересная часть... iptables и NAT(трансляция адресов). Для начала сделаем простое перенаправление адресов с минимальными правилами, чтобы убедиться что можем выходить в сеть. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Предупреждение: Если вы параноик, то это не самое секретное, что можно сделать... мы открываемся в сеть с мизерной защитой. Однако будем считать, что сеть настраиваем для дома или для игрового класса. </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Файл: /var/lib/iptables/rules-save </para>
</entry>
</row>
<row>
<entry>
<para>#!/bin/bash</para>
<para/>
<para>IPTABLES='/sbin/iptables'</para>
<para/>
<para># Определяем интерфейсы</para>
<para>EXTIF='ppp0'</para>
<para>INTIF1='eth1'</para>
<para>INTIF2='eth2'</para>
<para/>
<para># Включаем форвардинг ip в ядре.</para>
<para>/bin/echo 1 &gt; /proc/sys/net/ipv4/ip_forward</para>
<para/>
<para># Сбросить правила и удалить цепочки </para>
<para>$IPTABLES -F</para>
<para>$IPTABLES -t nat -F</para>
<para>$IPTABLES -t mangle -F</para>
<para>$IPTABLES -X</para>
<para>$IPTABLES -t nat -X</para>
<para>$IPTABLES -t mangle -X</para>
<para/>
<para># Включаем маскарадинг для разрешения доступа в интернет</para>
<para>$IPTABLES -t nat -A POSTROUTING -o $EXTIF -j MASQUERADE</para>
<para/>
<para># Форвардить сетевой трафик с $INTIF1 на интернетовский интерфейс $EXTIF</para>
<para>$IPTABLES -A FORWARD -i $INTIF1 -o $EXTIF -m state --state NEW,ESTABLISHED -j ACCEPT</para>
<para/>
<para># Форвардить сетевой трафик с $INTIF2 на интернетовский интерфейс $EXTIF</para>
<para>$IPTABLES -A FORWARD -i $INTIF2 -o $EXTIF -m state --state NEW,ESTABLISHED -j ACCEPT</para>
<para/>
<para>#echo -e "       - Разрешаем доступ к SSH серверу"</para>
<para>$IPTABLES -A INPUT --protocol tcp --dport 22 -j ACCEPT</para>
<para>#echo -e "       - Разрешаем доступ к HTTP серверу"</para>
<para>$IPTABLES -A INPUT --protocol tcp --dport 80 -j ACCEPT</para>
<para># Блокируем все прочие попытки доступа на $EXTIF</para>
<para>$IPTABLES -A INPUT -i $EXTIF -m state --state NEW,INVALID -j DROP</para>
<para>$IPTABLES -A FORWARD -i $EXTIF -m state --state NEW,INVALID -j DROP</para>
</entry>
</row></tbody></tgroup>
</informaltable></section><section><info><title>Проверка на работоспособность</title></info>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Примечание: Этот скрипт написан кем-то в сетевом форуме... Адрес автора утерян, имя... В общем, спасибо ему, пусть и без имени. (Надеюсь, он не обидется). </para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь проверяем могут ли наши пользователи выйти в интернет или подключиться к серверу по ssh. Если все нормально, то можно переходить ниже по тексту. Если нет - проверьте синтаксические ошибки и прочее... Удостоверьтесь, что IP-адреса и маски клиентов и сервера введены правильно... Ну или... </para>
<para>Если все работает, как задумали, сохраняем конфигурацию: </para>
<para># /etc/init.d/iptables save </para>
<para>И бэкапим вашу рабочую конфигурацию для возможного восстановления "как было": </para>
<para># cp /var/lib/iptables/rules-save /var/lib/iptables/rules.working </para>
<para>Проверим iptables start-up скрипт перед тем как добавить iptables в default runlevel: </para>
<para/>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Проверка скрипта </para>
</entry>
</row>
<row>
<entry>
<orderedlist>
<listitem>
<para>/etc/init.d/iptables start </para>
</listitem>
<listitem>
<para>/etc/init.d/iptables stop </para>
</listitem>
<listitem>
<para>/etc/init.d/iptables start </para>
</listitem>
</orderedlist>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Смысл в запуске-остановке-запуске в том, что у нас нет скрипта запуска iptables... поэтому нужно “инициализировать” статус перед остановкой. Остановка, по существу, обнуляет настройки и возвращает все к исходному. Перезапуск покажет нам работает ли наша сеть после перезагрузки. Если все в порядке, то добавляем iptables в default runlevel: </para>
<para>rc-update add iptables default </para>
<para>Не забудем также установить в /etc/sysctl.conf: </para>
<para>net.ipv4.ip_forward = 1 </para></section><section><info><title>Оборона Firewall</title></info>
<para>Далее мы сделаем наш, уже работающий файрвол безопасным, т.е. защищающим нашу систему от проникновений извне. На самом деле нам придется настроить файрвол таким образом, чтобы он не только защищал нас, но и защищал внешнюю сеть от нас. :) Защита такого рода является обязательной, она нужна для того, чтобы, в том случае, если наша система все-таки была взломана, взломщик не смог воспользоваться нашими ресурсами для дальнейшей атаки любого рода. Этот аспект является важнейшим в сетях класса SOHO, т.е. небольших офисах. Обыкновенно вирусы не оказывают никакого влияния на малые сети и заражение ими редко приводит к потере данных. Для нас, пользователей *nix, этой проблемы практически не существует. В любом случае, т.к. небольшие сети, как правило, защищены гораздо хуже больших, кракеры стараются использовать их в качестве “опорной базы” для DoS атак, или другой своей вредоносной активности. </para>
<para>В последующем я опишу всю конфигурацию по кусочкам, дабы мы смогли бы проверить пошагово каждый фрагмент. Каждый шаг может потребовать от вас вставки чего-либо до, после или в середину указываемого скрипта. Все действия производятся так, чтобы (я надеюсь) ваша сеть не работала только лишь короткий промежуток времени во время настройки. Это сделано мною потому как я предположил что у многих из вас (таких как я) выделен сервер под Firewall. И так как я предпочитаю настраивать свой сервер через SSH, отключение сети может иметь пренеприятные последствия, такие как ползания под столами или хуже того. Если же вы смелы, то вы можете скопировать скрипт в конце этого документа и запустить его на своей машине. Этот скрипт должен быть работоспособен на все сто, но тестировал я его только на своей машине, так что <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://lingvo.yandex.ru/en?text=YMMV">ymmv</link>. </para>
<para/></section><section><info><title>Установка переменных окружения</title></info>
<para>Вы можете установить необходимые переменные окружения следующим скриптом: </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ' </para>
</entry>
</row>
<row>
<entry>
<para>#!/bin/sh</para>
<para>#</para>
<para># Внешний интерфейс</para>
<para>EXTIF="ppp0"</para>
<para/>
<para># Внутренний интерфейс</para>
<para>INTIF="eth1"</para>
<para/>
<para># Loop device/localhost</para>
<para>LPDIF="lo"</para>
<para>LPDIP="127.0.0.1"</para>
<para>LPDMSK="255.0.0.0"</para>
<para>LPDNET="$LPDIP/$LPDMSK"</para>
<para/>
<para># Необходимые утилиты</para>
<para>IPT="/sbin/iptables"</para>
<para>IFC="/sbin/ifconfig"</para>
<para>G="/bin/grep"</para>
<para>SED="/bin/sed"</para>
<para>AWK="/usr/bin/awk"</para>
<para>ECHO="/bin/echo"</para>
<para/>
<para># Последующие команды могут работать некорректно при локализации.</para>
<para/>
<para># Установка переменных окружения внешнего интерфейса</para>
<para>EXTIP="`$IFC $EXTIF | $AWK /$EXTIF/'{next}//{split($0,a,":");split(a[2],a," ");print a[1];exit}'`"</para>
<para>EXTBC="255.255.255.255" </para>
<para>#EXTMSK="`$IFC $EXTIF | $G Mask:|$SED 's/.*Mask:\([^ ]*\)/\1/'`"</para>
<para>EXTMSK="`$IFC $EXTIF | $AWK /$EXTIF/'{next}//{split($0,a,":");split(a[4],a," ");print a[1];exit}'`"</para>
<para>EXTNET="$EXTIP/$EXTMSK"</para>
<para>$ECHO "EXTIP=$EXTIP EXTBC=$EXTBC EXTMSK=$EXTMSK EXTNET=$EXTNET"</para>
<para/>
<para># Due to absence of EXTBC I manually set it to 255.255.255.255</para>
<para># this (hopefully) will serve the same purpose</para>
<para/>
<para># Установка переменных окружения внутреннего интерфейса</para>
<para>INTIP="`$IFC $INTIF | $AWK /$INTIF/'{next}//{split($0,a,":");split(a[2],a," ");print a[1];exit}'`"</para>
<para>INTBC="`$IFC $INTIF | $AWK /$INTIF/'{next}//{split($0,a,":");split(a[3],a," ");print a[1];exit}'`"</para>
<para>INTMSK="`$IFC $INTIF | $AWK /$INTIF/'{next}//{split($0,a,":");split(a[4],a," ");print a[1];exit}'`"</para>
<para>INTNET="$INTIP/$INTMSK"</para>
<para>$ECHO "INTIP=$INTIP INTBC=$INTBC INTMSK=$INTMSK INTNET=$INTNET"</para>
</entry>
</row></tbody></tgroup>
</informaltable></section><section><info><title>iptables ACCEPTS</title></info>
<para>Теперь мы должны установить ACCEPTы, так, чтобы мы могли соединяться с нашим сервером. На самом деле это очень больной вопрос. Правила для надежного маршрутизатора должны по умолчанию запрещать нежели разрешать. Однако, если вы сделаете это, то потеряете все соединения. Продолжайте тестирование пока не будете уверены что ваши ACCEPTы работают как надо. Однако думаю, что сперва мы введем следующее и это будет предпоследним правилом в окончательном скрипте. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ' </para>
</entry>
</row>
<row>
<entry>
<para>$IPT -t nat -A PREROUTING -j ACCEPT</para>
<para># $IPT -t nat -A POSTROUTING -o $EXTIF -s $INTNET -j SNAT --to $EXTIP</para>
<para/>
<para># Закомментируйте последующие строки (которые содержат "MASQUERADE") </para>
<para># для сетей без трансляции адресов (NAT)</para>
<para>$IPT -t nat -A POSTROUTING -o $EXTIF -s $INTNET1 -j MASQUERADE</para>
<para>$IPT -t nat -A POSTROUTING -o $EXTIF -s $INTNET2 -j MASQUERADE</para>
<para>$IPT -t nat -A POSTROUTING                       -j ACCEPT</para>
<para>$IPT -t nat -A OUTPUT                            -j ACCEPT</para>
<para>$IPT -A INPUT   -p tcp --dport auth --syn -m state --state NEW -j ACCEPT</para>
<para>$IPT -A INPUT   -m state --state ESTABLISHED,RELATED -j ACCEPT</para>
<para>$IPT -A OUTPUT  -m state --state ESTABLISHED,RELATED -j ACCEPT</para>
<para>$IPT -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT</para>
</entry>
</row></tbody></tgroup>
</informaltable></section><section><info><title>iptables DROP &amp; REJECT</title></info>
<para>Теперь мы определим пару цепочек (chains) которые будут фиксировать события DROP и REJECT. Таким образом нам не придется вводить отдельные строки для каждой введенной команды. Сообщения о событиях будут отправлены сервису syslog, (обычно они фиксируются в /var/log/messages). Позже я (переводчик не имеет к этому никакого отношения) собираюсь написать скрипт на sed/grep по разбору событий для облегченного просмотра и установлю его как ежедневную работу для сервиса cron. </para>
<para>Эти строки следует вставить сразу после текста выше, в тот же скрипт. Когда вы это сделаете, запустите скрипт снова. Это не окажет влияния на вашу сеть, вы пока просто устанавливаете правила. Но это поможет убедиться что мы не сделали ошибок на данном этапе. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ' </para>
</entry>
</row>
<row>
<entry>
<para># ********** Цепочки журналирования событий **********</para>
<para>#</para>
<para># Теперь мы определяем несколько цепочек которые служат для записи </para>
<para># событий о сбрасываемых пакетах. Это позволит нам избежать ввода </para>
<para># команд для каждого правила. Сперва мы фиксируем DROP, а потом REJECT.</para>
<para># Не жалуйтесь, если цепочки уже существуют (однако это не приведет к ошибкам???)</para>
<para>$IPT -N DROPl   2&gt; /dev/null</para>
<para>$IPT -A DROPl -m limit --limit 3/minute --limit-burst 10 -j LOG --log-prefix 'FIREWALL DROP BLOCKED:'</para>
<para>$IPT -A DROPl   -j DROP</para>
<para>$IPT -N REJECTl 2&gt; /dev/null</para>
<para>$IPT -A REJECTl -m limit --limit 3/minute --limit-burst 10 -j LOG --log-prefix 'FIREWALL REJECT BLOCKED:'</para>
<para>$IPT -A REJECTl -j REJECT</para>
<para>$IPT -N DROP2   2&gt; /dev/null</para>
<para>$IPT -A DROP2 -m limit --limit 3/second --limit-burst 10 -j LOG --log-prefix 'FIREWALL DROP UNKNOWN:'</para>
<para>$IPT -A DROP2   -j DROP</para>
<para>$IPT -N REJECT2 2&gt; /dev/null</para>
<para>$IPT -A REJECT2 -m limit --limit 3/second --limit-burst 10 -j LOG --log-prefix 'FIREWALL REJECT UNKNOWN:'</para>
<para>$IPT -A REJECT2 -j REJECT</para>
<para/>
<para># Для тестирования фиксируем события ACCEPT</para>
<para>$IPT -N ACCEPTl   2&gt; /dev/null</para>
<para>$IPT -A ACCEPTl -m limit --limit 10/second --limit-burst 50 -j LOG --log-prefix 'FIREWALL ACCEPT:'</para>
<para>$IPT -A ACCEPTl   -j ACCEPT</para>
</entry>
</row></tbody></tgroup>
</informaltable></section><section><info><title>Сброс правил</title></info>
<para>Теперь, когда мы видим наши устройства, правильно определенные, вставляем команду сброса правил. Однако все уже назначенные правила будут сброшены. Эти строки должны быть вставлены после определения утилит, которые заканчиваются строкой: ECHO='/bin/echo' </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ' </para>
</entry>
</row>
<row>
<entry>
<para># Сброс всех существующих и очистка персональных цепочек.</para>
<para>CHAINS=`cat /proc/net/ip_tables_names 2&gt;/dev/null`</para>
<para/>
<para>for i in $CHAINS</para>
<para>do</para>
<para>    $IPT -t $i -F</para>
<para>done</para>
<para/>
<para>for i in $CHAINS</para>
<para>do</para>
<para>    $IPT -t $i -X</para>
<para>done</para>
</entry>
</row></tbody></tgroup>
</informaltable>
</section>
    <section><info><title>Локальные интерфейсы</title></info>
<para>Теперь мы готовы для того, чтобы описать некоторые правила. Для начала мы разрешим все пакеты с loopback интерфейса, имеющие в качестве адреса назначения один из адресов наших интерфейсов. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ' </para>
</entry>
</row>
<row>
<entry>
<para>$IPT -A INPUT   -i $LPDIF -s   $LPDIP  -j ACCEPT</para>
<para>$IPT -A INPUT   -i $LPDIF -s   $EXTIP  -j ACCEPT</para>
<para>$IPT -A INPUT   -i $LPDIF -s   $INTIP1  -j ACCEPT</para>
<para>$IPT -A INPUT   -i $LPDIF -s   $INTIP2  -j ACCEPT</para>
</entry>
</row></tbody></tgroup>
</informaltable></section><section><info><title>Блокировка широковещательных пакетов</title></info>
<para>Теперь мы должны заблокировать все входящие и исходящие широковещательные пакеты. Это предотвратит DoS атаки против нас, и не позволит нашим клиентам проводить DoS атаки против кого либо другого. Если бы все системные администраторы следовали этим правилам, тогда много суровых и дорогих DoS атак не состоялись или были максимально ограниченными. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: Блокировка широковещательных пакетов </para>
</entry>
</row>
<row>
<entry>
<para>$IPT -A INPUT   -i $EXTIF -d   $EXTBC  -j DROPl</para>
<para>$IPT -A INPUT   -i $INTIF1 -d  $INTBC1  -j DROPl</para>
<para>$IPT -A INPUT   -i $INTIF2 -d  $INTBC2  -j DROPl</para>
<para>$IPT -A OUTPUT  -o $EXTIF -d   $EXTBC  -j DROPl</para>
<para>$IPT -A OUTPUT  -o $INTIF1 -d  $INTBC1  -j DROPl</para>
<para>$IPT -A OUTPUT  -o $INTIF2 -d  $INTBC2  -j DROPl</para>
<para>$IPT -A FORWARD -o $EXTIF -d   $EXTBC  -j DROPl</para>
<para>$IPT -A FORWARD -o $INTIF1 -d  $INTBC1  -j DROPl</para>
<para>$IPT -A FORWARD -o $INTIF2 -d  $INTBC2  -j DROPl</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Теперь проверим скрипт еще раз, чтобы убедиться в том, что мы не наделали синтаксических ошибок. Также отмечу, что мы используем определенные нами DROP1 цепочки (chains). Это означает, что отбрасываемые пакеты будут отмечены в журнале событий (log file). </para></section><section><info><title>Блокировка доступа в локальную сеть из глобальной</title></info>
<para>Теперь мы блокируем доступ из глобальной сети в нашу локальную сеть, если мы не хотим что бы интернет провайдер назначал IP адреса для нашей внутренней сети. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ' </para>
</entry>
</row>
<row>
<entry>
<para># Блокировать внешний доступ к локальной сети</para>
<para># Это позволит остановить боевых кракеров от использования </para>
<para># нашей сети как стартовой точки для других атак.</para>
<para>#</para>
<para># Нижеприведенная строчка на человеческом языке будет выглядеть как</para>
<para># "если входящий пакет, пришедший на наш внешний интерфейс,</para>
<para># имеет адрес назначения, отличный от адреса нашего внешнего интерфейса,</para>
<para># то этот пакет не будет пропущен."</para>
<para>$IPT -A INPUT   -i $EXTIF -d ! $EXTIP  -j DROPl</para>
</entry>
</row></tbody></tgroup>
</informaltable></section><section><info><title>Изолирование локальных сетей</title></info>
<para>Теперь мы предпримем некоторые действия для наших локальных сетей. Другими словами - все пакеты не относящиеся к локальным сетям должны быть блокированы. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ' </para>
</entry>
</row>
<row>
<entry>
<para># Теперь мы должны заблокировать все пакеты не относящиеся к </para>
<para># адресному пространству наших локальных сетей.</para>
<para># Запомните, если вы подключите свой ноутбук к другому разъему, </para>
<para># вам надо убедиться, что ваш сетевой адрес соответствует адресам этой сети.</para>
<para>#</para>
<para># Первая локальная сеть</para>
<para>$IPT -A INPUT   -i $INTIF1 -s ! $INTNET1 -j DROPl</para>
<para>$IPT -A OUTPUT  -o $INTIF1 -d ! $INTNET1 -j DROPl</para>
<para>$IPT -A FORWARD -i $INTIF1 -s ! $INTNET1 -j DROPl</para>
<para>$IPT -A FORWARD -o $INTIF1 -d ! $INTNET1 -j DROPl</para>
<para># Вторая локальная сеть</para>
<para>$IPT -A INPUT   -i $INTIF2 -s ! $INTNET2 -j DROPl</para>
<para>$IPT -A OUTPUT  -o $INTIF2 -d ! $INTNET2 -j DROPl</para>
<para>$IPT -A FORWARD -i $INTIF2 -s ! $INTNET2 -j DROPl</para>
<para>$IPT -A FORWARD -o $INTIF2 -d ! $INTNET2 -j DROPl</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Дальше мы сделаем некоторые дополнительные проверки исходящих пакетов и остановим все icmp пакеты кроме ping. </para>
<informaltable frame="all">
<tgroup cols="1"><tbody>
<row>
<entry>
<para>Code: ' </para>
</entry>
</row>
<row>
<entry>
<para># Дополнительная проверка</para>
<para>$IPT -A OUTPUT  -o $EXTIF -s ! $EXTNET -j DROPl</para>
<para># Блокируем исходящие ICMP (кроме PING)</para>
<para>$IPT -A OUTPUT  -o $EXTIF -p icmp --icmp-type ! 8 -j DROPl</para>
<para>$IPT -A FORWARD -o $EXTIF -p icmp --icmp-type ! 8 -j DROPl</para>
</entry>
</row></tbody></tgroup>
</informaltable>
<para>Замечательно. Двигаемся дальше и проверяем скрипт на ошибки. </para></section><section><info><title>Ports</title></info>
<para>Предполагая что у нас все сработало мы заткнем еще несколько портов, доступ по которым может представлять для нас серьезную опасность: </para>
<para># COMmon ports:</para>
<para># 0 is tcpmux; SGI had vulnerability, 1 is common attack</para>
<para># 13 is daytime</para>
<para># 98 is Linuxconf</para>
<para># 111 is sunrpc (portmap)</para>
<para># 137:139, 445 is Microsoft</para>
<para># SNMP: 161,2</para>
<para># Squid flotilla: 3128, 8000, 8008, 8080</para>
<para># 1214 is Morpheus or KaZaA</para>
<para># 2049 is NFS</para>
<para># 3049 is very virulent Linux Trojan, mistakable for NFS</para>
<para># Common attacks: 1999, 4329, 6346</para>
<para># Common Trojans 12345 65535</para>
<para> COMBLOCK="0:1 13 98 111 137:139 161:162 445 1214 1999 2049 3049 4329 6346 3128 8000 8008 8080 12345 65535"</para>
<para># TCP ports:</para>
<para># 98 is Linuxconf</para>
<para># 512-5!5 is rexec, rlogin, rsh, printer(lpd)</para>
<para>#   [very serious vulnerabilities; attacks continue daily]</para>
<para># 1080 is Socks proxy server</para>
<para># 6000 is X (NOTE X over SSH is secure and runs on TCP 22)</para>
<para># Block 6112 (Sun's/HP's CDE)</para>
<para> TCPBLOCK="$COMBLOCK 98 512:515 1080 6000:6009 6112"</para>
<para/>
<para># UDP ports:</para>
<para># 161:162 is SNMP</para>
<para># 520=RIP, 9000 is Sangoma</para>
<para># 517:518 are talk and ntalk (more annoying than anything)</para>
<para> UDPBLOCK="$COMBLOCK 161:162 520 123 517:518 1427 9000 9 6346 3128 8000 8008 8080 12345 65535"</para>
<para>После определения переменных окружения нам останется только пробежаться по ним циклом: </para>
<para>echo -n "FW: Blocking attacks to TCP port"</para>
<para>for i in $TCPBLOCK;</para>
<para>do</para>
<para> echo -n "$i "</para>
<para>  $IPT -A INPUT   -p tcp --dport $i  -j DROPl</para>
<para>  $IPT -A OUTPUT  -p tcp --dport $i  -j DROPl</para>
<para>  $IPT -A FORWARD -p tcp --dport $i  -j DROPl</para>
<para>done</para>
<para>echo ""</para>
<para>echo -n "FW: Blocking attacks to UDP port "</para>
<para>for i in $UDPBLOCK;</para>
<para>do</para>
<para> echo -n "$i "</para>
<para>   $IPT -A INPUT   -p udp --dport $i  -j DROPl</para>
<para>   $IPT -A OUTPUT  -p udp --dport $i  -j DROPl</para>
<para>   $IPT -A FORWARD -p udp --dport $i  -j DROPl</para>
<para>done</para>
<para>echo ""</para>
<para>Ну что ж, теперь каждый раз, когда мы запускаем скрипт, эти строчки просто добавляются к уже существующим... что создаёт небольшой бардак. По этой причине мы собираемся перепрыгнуть в начало скрипта... сразу после переменных окружения для sed и grep, но перед переменными для EXTIP и EXTBC - там мы добавляем цикл, который производит очистку. Так мы будем уверены, что работаем в чистой среде. Нам не приходилось задумываться об этом ранее, потому что мы не имели возможности оттестить скрипт без обрыва соединения либо закрытия файрвола. Этот скрипт сначала выставляет всю политику в DROP, после чего очищает и удаляет наши цепочки. Чтобы убедиться, что мы по-прежнему можем залогиниться по ssh на наш сервер после того, как скрипт перезапуститься, мы добавим цепочку INPUT для ssh. Пока что поставим её в конец скрипта. Это делается для того чтобы избежать открытия дыры в момент установки новых правил, что является довольно распространённой ошибкой: </para>
<para># Отказываем, потом принимаем: это уберёт дыру в момент,</para>
<para># когда мы закрываем порты</para>
<para> $IPT        -P INPUT       DROP</para>
<para> $IPT        -P OUTPUT      DROP</para>
<para> $IPT        -P FORWARD     DROP</para>
<para># Очищаем все существуещие цепочки и стираем дополнительные</para>
<para> CHAINS=`cat /proc/net/ip_tables_names 2&gt;/dev/null`</para>
<para> for i in $CHAINS;</para>
<para> do</para>
<para>   $IPT -t $i -F</para>
<para> done</para>
<para> for i in $CHAINS;</para>
<para> do</para>
<para>   $IPT -t $i -X</para>
<para> done</para>
<para> $IPT -A INPUT   -i $INTIF1 -p tcp --dport 22 --syn -m state --state NEW -j ACCEPT</para></section><section><info><title>Sysctl'ы</title></info>
<para>Сразу после этого мы запустим sysctl'ы для tcp_syncookies, icmp_echo_ignore_broadcasts, rp_filter и accept_source_routе. До этого момента многие правила, которые мы "проверяли", фактически не выполнялись. По сути, мы просто делали проверку синтаксических ошибок. Теперь наши правила будут выполняться в полной мере: </para>
<para>echo 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</para>
<para>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</para>
<para># Проверка адреса источника</para>
<para>for f in /proc/sys/net/ipv4/conf/*/rp_filter;</para>
<para>do</para>
<para> echo 1 &gt; $f</para>
<para>done</para>
<para># Отключаем роутинг источника IP и ICMP-редиректы</para>
<para>for f in /proc/sys/net/ipv4/conf/*/accept_source_route;</para>
<para>do</para>
<para> echo 0 &gt; $f</para>
<para>done</para>
<para>for f in /proc/sys/net/ipv4/conf/*/accept_redirects;</para>
<para>do</para>
<para> echo 0 &gt; $f</para>
<para>done</para>
<para>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</para>
<para>Теперь мы собираемся добавить трекинг ftp-соединения, так что нам не доведётся наблюдать ошибки PASV при установке паков: </para>
<para># Запускаем трекинг ftp-соединения</para>
<para>MODULES="ip_nat_ftp ip_conntrack_ftp"</para>
<para>for i in $MODULES;</para>
<para>do</para>
<para> echo "Добавляем модуль $i"</para>
<para> modprobe $i</para>
<para>done</para></section><section><info><title>Базовая конфигурация NAT</title></info>
<para>А сейчас возвратимся к концу нашего скрипта, поскольку мы собираемся открыть сервисы для хостов, находящихся за файерволом. Я включил следующие сервисы: IRC, MSN, ICQ, and NFS, FTP, domain,time и некоторые другие. Самое главное здесь то, что эти сервисы могут использоваться ТОЛЬКО ЗА файерволом.Таким образом никто не сможет их использовать по ftp внутри Вашей локальной сетки: </para>
<para>IRC='ircd'</para>
<para>MSN=1863</para>
<para>ICQ=5190</para>
<para>NFS='sunrpc'</para>
<para># Мы пользуемся sync!!</para>
<para>PORTAGE='rsync'</para>
<para>OpenPGP_HTTP_Keyserver=11371</para>
<para># Все порты сервисов считываются из /etc/services</para>
<para>TCPSERV="domain ssh http https ftp ftp-data mail pop3 pop3s imap3 imaps imap2 time $PORTAGE $IRC $MSN $ICQ $OpenPGP_HTTP_Keyserver"</para>
<para>UDPSERV="domain time"</para>
<para>echo -n "FW: Allowing inside systems to use service:"</para>
<para>for i in $TCPSERV;</para>
<para>do</para>
<para> echo -n "$i "</para>
<para> $IPT -A OUTPUT  -o $EXTIF -p tcp -s $EXTIP --dport $i --syn -m state --state NEW -j ACCEPT</para>
<para> $IPT -A FORWARD -i $INTIF1 -p tcp -s $INTNET1 --dport $i --syn -m state --state NEW -j ACCEPT</para>
<para> $IPT -A FORWARD -i $INTIF2 -p tcp -s $INTNET2 --dport $i --syn -m state --state NEW -j ACCEPT</para>
<para>done</para>
<para>echo ""</para>
<para>echo -n "FW: Allowing inside systems to use service:"</para>
<para>for i in $UDPSERV;</para>
<para>do</para>
<para> echo -n "$i "</para>
<para> $IPT -A OUTPUT  -o $EXTIF -p udp -s $EXTIP --dport $i -m state --state NEW -j ACCEPT</para>
<para>   $IPT -A FORWARD -i $INTIF1 -p udp -s $INTNET1 --dport $i -m state --state NEW -j ACCEPT</para>
<para>   $IPT -A FORWARD -i $INTIF2 -p udp -s $INTNET2 --dport $i -m state --state NEW -j ACCEPT</para>
<para>done</para>
<para>echo ""</para>
<para>Теперь сделаем так, чтобы файервол позволил нам пинговать внешний мир. Для этого разрешим прохождение icmp-пакетов через внешний интерфейс: </para>
<para># Разрешаем внешнее пингование</para>
<para>$IPT -A OUTPUT  -o $EXTIF -p icmp -s $EXTIP --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para>$IPT -A FORWARD -i $INTIF1 -p icmp -s $INTNET1 --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para>$IPT -A FORWARD -i $INTIF2 -p icmp -s $INTNET2 --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para>                                                                              </para>
<para># Разрешим файерволу пинговать наши внутренние сетки:</para>
<para>$IPT -A OUTPUT  -o $INTIF1 -p icmp -s $INTNET1 --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para>$IPT -A OUTPUT  -o $INTIF2 -p icmp -s $INTNET2 --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para>Теперь мы по умолчанию будем записывать в журнал все прочие запросы, но никак не будем на них реагировать. Все что нам надо было принять мы описали в начале наших правил. Так что заканчиваем правила блокировкой всего, что специально не разрешено: </para>
<para># Заблокируем все, что осталось:</para>
<para> $IPT -A INPUT             -j DROPl</para>
<para> $IPT -A OUTPUT            -j REJECTl</para>
<para> $IPT -A FORWARD           -j DROPl</para>
<para>Итак, все сделано. я имею дружественные nmap и nessus для моих соединений с вышеописанным набором правил и ничего не препятствует использованию IRC, MSN, ICQ, и emerge sync. </para></section><section><info><title>The full script</title></info>
<para>А сейчас, полноценный скрипт во всей своей красе (Заодно я поместил форвардинг ssh в более подходящее для него место): </para>
<para># Внешний интерфейс</para>
<para> EXTIF=ppp0</para>
<para># Внутренний интерфейс</para>
<para> INTIF1=eth1</para>
<para> INTIF2=eth2</para>
<para># Loop-устройство/localhost</para>
<para> LPDIF=lo</para>
<para> LPDIP=127.0.0.1</para>
<para> LPDMSK=255.0.0.0</para>
<para> LPDNET="$LPDIP/$LPDMSK"</para>
<para># Переменные текстовых инструментов</para>
<para> IPT='/sbin/iptables'</para>
<para> IFC='/sbin/ifconfig'</para>
<para> G='/bin/grep'</para>
<para> SED='/bin/sed'</para>
<para># Последнее (но немаловажное) - пользователи</para>
<para> JAMES=192.168.1.77</para>
<para> TERESA=192.168.2.77</para>
<para># Deny вместо accept: предотвращает открытие "дыр"</para>
<para># в то время, как мы закрываем порты и все такое</para>
<para> $IPT        -P INPUT       DROP</para>
<para> $IPT        -P OUTPUT      DROP</para>
<para> $IPT        -P FORWARD     DROP</para>
<para># Сброс всех существующих цепочек и стирание персональных цепочек</para>
<para> CHAINS=`cat /proc/net/ip_tables_names 2&gt;/dev/null`</para>
<para> for i in $CHAINS</para>
<para> do</para>
<para>  $IPT -t $i -F</para>
<para>  $IPT -t $i -X</para>
<para> done</para>
<para> echo 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</para>
<para> echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</para>
<para># Проверка адреса источника</para>
<para> for f in /proc/sys/net/ipv4/conf/*/rp_filter;</para>
<para> do</para>
<para>  echo 1 &gt; $f</para>
<para> done</para>
<para># Запрет маршрутизации IP от источника и редиректов ICMP</para>
<para> for f in /proc/sys/net/ipv4/conf/*/accept_source_route;</para>
<para> do</para>
<para>  echo 0 &gt; $f</para>
<para> done</para>
<para> for f in /proc/sys/net/ipv4/conf/*/accept_redirects;</para>
<para> do</para>
<para>  echo 0 &gt; $f</para>
<para> done</para>
<para> echo 1 &gt; /proc/sys/net/ipv4/ip_forward</para>
<para># Установка переменных среды для внешнего интерфейса</para>
<para> EXTIP="`$IFC $EXTIF|$G addr:|$SED 's/.*addr:\([^ ]*\) .*/\1/'`"</para>
<para> #EXTBC="`$IFC $EXTIF|$G Bcast:|$SED 's/.*Bcast:\([^ ]*\) .*/\1/'`"</para>
<para> EXTBC="255.255.255.255"</para>
<para> EXTMSK="`$IFC $EXTIF|$G Mask:|$SED 's/.*Mask:\([^ ]*\)/\1/'`"</para>
<para> EXTNET="$EXTIP/$EXTMSK"</para>
<para> #echo "EXTIP=$EXTIP EXTBC=$EXTBC EXTMSK=$EXTMSK EXTNET=$EXTNET"</para>
<para> echo "EXTIP=$EXTIP EXTBC=$EXTBC EXTMSK=$EXTMSK EXTNET=$EXTNET"</para>
<para># Так как EXTBC отсутствует, я устанавливаю ее вручную как it to 255.255.255.255</para>
<para># Это (надеюсь) послужит тем же целям</para>
<para># Устанвка переменных среды для первого внутреннего интерфейса</para>
<para> INTIP1="`$IFC $INTIF1|$G addr:|$SED 's/.*addr:\([^ ]*\) .*/\1/'`"</para>
<para> INTBC1="`$IFC $INTIF1|$G Bcast:|$SED 's/.*Bcast:\([^ ]*\) .*/\1/'`"</para>
<para> INTMSK1="`$IFC $INTIF1|$G Mask:|$SED 's/.*Mask:\([^ ]*\)/\1/'`"</para>
<para> INTNET1="$INTIP1/$INTMSK1"</para>
<para> echo "INTIP1=$INTIP1 INTBC1=$INTBC1 INTMSK1=$INTMSK1 INTNET1=$INTNET1"</para>
<para># Установка переменных среды для второго внутреннего интерфейса</para>
<para> INTIP2="`$IFC $INTIF2|$G addr:|$SED 's/.*addr:\([^ ]*\) .*/\1/'`"</para>
<para> INTBC2="`$IFC $INTIF2|$G Bcast:|$SED 's/.*Bcast:\([^ ]*\) .*/\1/'`"</para>
<para> INTMSK2="`$IFC $INTIF2|$G Mask:|$SED 's/.*Mask:\([^ ]*\)/\1/'`"</para>
<para> INTNET2="$INTIP2/$INTMSK2"</para>
<para> echo "INTIP2=$INTIP2 INTBC2=$INTBC2 INTMSK2=$INTMSK2 INTNET2=$INTNET2"</para>
<para># Сейчас мы собираемся создать несколько собственных цепочек, результатом работы </para>
<para># которых будет логгинг отброшенных пакетов. Это поможет нам избежать необходимости</para>
<para># вводить команду log перед каждым отбрасыванием пакета, что мы хотим запротоколировать.</para>
<para># Первыми идут лог отброшенных пакетов и собственно отброс, затем лог пакетов с отказами</para>
<para># и собственно отказы.</para>
<para># Отключаем сообщения о том, что цепочки уже существуют (чтобы перезапуск был без мусора)</para>
<para> $IPT -N DROPl   2&gt; /dev/null</para>
<para> $IPT -A DROPl   -j LOG --log-prefix 'DROPl:'</para>
<para> $IPT -A DROPl   -j DROP</para>
<para> $IPT -N REJECTl 2&gt; /dev/null</para>
<para> $IPT -A REJECTl -j LOG --log-prefix 'REJECTl:'</para>
<para> $IPT -A REJECTl -j REJECT</para>
<para># Весь траффик от устройства loopback принимается</para>
<para># если IP совпадает с любым из наших интерфейсов.</para>
<para> $IPT -A INPUT   -i $LPDIF -s   $LPDIP  -j ACCEPT</para>
<para> $IPT -A INPUT   -i $LPDIF -s   $EXTIP  -j ACCEPT</para>
<para> $IPT -A INPUT   -i $LPDIF -s   $INTIP1  -j ACCEPT</para>
<para> $IPT -A INPUT   -i $LPDIF -s   $INTIP2  -j ACCEPT</para>
<para># Широковещательные пакеты блокируем</para>
<para> $IPT -A INPUT   -i $EXTIF -d   $EXTBC  -j DROPl</para>
<para> $IPT -A INPUT   -i $INTIF1 -d   $INTBC1  -j DROPl</para>
<para> $IPT -A INPUT   -i $INTIF2 -d   $INTBC2  -j DROPl</para>
<para> $IPT -A OUTPUT  -o $EXTIF -d   $EXTBC  -j DROPl</para>
<para> $IPT -A OUTPUT  -o $INTIF1 -d   $INTBC1  -j DROPl</para>
<para> $IPT -A OUTPUT  -o $INTIF2 -d   $INTBC2  -j DROPl</para>
<para> $IPT -A FORWARD -o $EXTIF -d   $EXTBC  -j DROPl</para>
<para> $IPT -A FORWARD -o $INTIF1 -d   $INTBC1  -j DROPl</para>
<para> $IPT -A FORWARD -o $INTIF2 -d   $INTBC2  -j DROPl</para>
<para># Блокируем доступ к внутренней сети из WAN</para>
<para># Это также призвано не дать нечестивым крякерам использовать нашу сетку </para>
<para># в качестве отправной точки для атак на других людей</para>
<para># Перевод с языка iptables:</para>
<para># "если пришедшие на наружный интерфейс пакеты были отправлены не с выданного</para>
<para># nefarious адреса, выкинуть их как горячую картошку"</para>
<para> $IPT -A INPUT   -i $EXTIF -d ! $EXTIP  -j DROPl</para>
<para># А сейчас мы блокируем внутренние адреса, кроме двух, присвоенных нашим двум</para>
<para># внутренним интерфейсам.....только помните, что если вы воткнете свой лэптоп или</para>
<para># какой другой pc в напрямую в одну из этих сетевых карт, то нужно удостовериться,</para>
<para># что они имеют именно эти IP-адреса или добавить соответствующий адрес отдельно.               </para>
<para># Первый интерфейс/первая внутренняя сеть</para>
<para> $IPT -A INPUT   -i $INTIF1 -s ! $INTNET1 -j DROPl</para>
<para> $IPT -A OUTPUT  -o $INTIF1 -d ! $INTNET1 -j DROPl</para>
<para> $IPT -A FORWARD -i $INTIF1 -s ! $INTNET1 -j DROPl</para>
<para> $IPT -A FORWARD -o $INTIF1 -d ! $INTNET1 -j DROPl</para>
<para># Второй интерфейс/вторая внутренняя сеть</para>
<para> $IPT -A INPUT   -i $INTIF2 -s ! $INTNET2 -j DROPl</para>
<para> $IPT -A OUTPUT  -o $INTIF2 -d ! $INTNET2 -j DROPl</para>
<para> $IPT -A FORWARD -i $INTIF2 -s ! $INTNET2 -j DROPl</para>
<para> $IPT -A FORWARD -o $INTIF2 -d ! $INTNET2 -j DROPl</para>
<para># Дополнительная Egress-проверка</para>
<para> $IPT -A OUTPUT  -o $EXTIF -s ! $EXTNET -j DROPl</para>
<para># Блокируем исходящиие пакеты ICMP (за исключением PING)</para>
<para> $IPT -A OUTPUT  -o $EXTIF -p icmp --icmp-type ! 8 -j DROPl</para>
<para> $IPT -A FORWARD -o $EXTIF -p icmp --icmp-type ! 8 -j DROPl</para>
<para># печально известные порты:</para>
<para># 0 - tcpmux; у SGI есть уязвимость, через которую можно атаковать</para>
<para># 13 - daytime</para>
<para># 98 - Linuxconf</para>
<para># 111 - sunrpc (portmap)</para>
<para># 137:139, 445 - Microsoft</para>
<para># SNMP: 161,2</para>
<para># Флотилия Squid: 3128, 8000, 8008, 8080</para>
<para># 1214 - Morpheus или KaZaA</para>
<para># 2049 - NFS</para>
<para># 3049 - очень заразный троян для Linux, часто путаемый с NFS</para>
<para># Часто атакуемые: 1999, 4329, 6346</para>
<para># Частые трояны 12345 65535</para>
<para> COMBLOCK="0:1 13 98 111 137:139 161:162 445 1214 1999 2049 3049 4329 6346 3128 8000 8008 8080 12345 65535"</para>
<para># Порты TCP:</para>
<para># 98 - Linuxconf</para>
<para># 512-5!5 - rexec, rlogin, rsh, printer(lpd)</para>
<para>#   [очень серьезеные уязвимости; продолжаются ежедневные атаки]</para>
<para># 1080 - прокси-серверы Socks</para>
<para># 6000 - X (ЗАМЕЧАНИЕ. X через SSH - безопасен, и работает на порту TCP 22)</para>
<para># Блокировка 6112 (CDE у Sun и HP)</para>
<para> TCPBLOCK="$COMBLOCK 98 512:515 1080 6000:6009 6112"</para>
<para># Порты UDP:</para>
<para># 161:162 - SNMP</para>
<para># 520=RIP, 9000 - Sangoma</para>
<para># 517:518 - talk и ntalk (самые надоедливые)</para>
<para> UDPBLOCK="$COMBLOCK 161:162 520 123 517:518 1427 9000"</para>
<para>echo -n "FW: Blocking attacks to TCP port"</para>
<para>for i in $TCPBLOCK;</para>
<para>do</para>
<para> echo -n "$i "</para>
<para>  $IPT -A INPUT   -p tcp --dport $i  -j DROPl</para>
<para>  $IPT -A OUTPUT  -p tcp --dport $i  -j DROPl</para>
<para>  $IPT -A FORWARD -p tcp --dport $i  -j DROPl</para>
<para>done</para>
<para>echo ""</para>
<para>echo -n "FW: Blocking attacks to UDP port "</para>
<para>for i in $UDPBLOCK;</para>
<para>do</para>
<para> echo -n "$i "</para>
<para>  $IPT -A INPUT   -p udp --dport $i  -j DROPl</para>
<para>  $IPT -A OUTPUT  -p udp --dport $i  -j DROPl</para>
<para>  $IPT -A FORWARD -p udp --dport $i  -j DROPl</para>
<para>done</para>
<para>echo ""</para>
<para># Открываем отлеживание соединений по ftp</para>
<para> MODULES="ip_nat_ftp ip_conntrack_ftp"</para>
<para> for i in $MODULES;</para>
<para> do</para>
<para>  echo "Inserting module $i"</para>
<para>  modprobe $i</para>
<para> done</para>
<para># Защищаем некоторые распространенные клиенты для чата.</para>
<para># Уберите из списка допустимых для пущей безопасности.</para>
<para> IRC='ircd'</para>
<para> MSN=1863</para>
<para> ICQ=5190</para>
<para> NFS='sunrpc'</para>
<para># Нам нужно синхронизировать данные!!</para>
<para> PORTAGE='rsync'</para>
<para> OpenPGP_HTTP_Keyserver=11371</para>
<para># Все порты сервисов читаются из /etc/services</para>
<para> TCPSERV="domain ssh http https ftp ftp-data mail pop3 pop3s imap3 imaps imap2 time $PORTAGE $IRC $MSN $ICQ  $OpenPGP_HTTP_Keyserver" UDPSERV="domain time"</para>
<para>echo -n "FW: Allowing inside systems to use service:"</para>
<para>for i in $TCPSERV;</para>
<para>do</para>
<para> echo -n "$i "</para>
<para>  $IPT -A OUTPUT  -o $EXTIF -p tcp -s $EXTIP --dport $i --syn -m state --state NEW -j ACCEPT</para>
<para>  $IPT -A FORWARD -i $INTIF1 -p tcp -s $INTNET1 --dport $i --syn -m state --state NEW -j ACCEPT</para>
<para>  $IPT -A FORWARD -i $INTIF2 -p tcp -s $INTNET2 --dport $i --syn -m state --state NEW -j ACCEPT</para>
<para>done</para>
<para>echo ""</para>
<para>echo -n "FW: Allowing inside systems to use service:"</para>
<para>for i in $UDPSERV;</para>
<para>do</para>
<para> echo -n "$i "</para>
<para>  $IPT -A OUTPUT  -o $EXTIF -p udp -s $EXTIP --dport $i -m state --state NEW -j ACCEPT</para>
<para>  $IPT -A FORWARD -i $INTIF1 -p udp -s $INTNET1 --dport $i -m state --state NEW -j ACCEPT</para>
<para>  $IPT -A FORWARD -i $INTIF2 -p udp -s $INTNET2 --dport $i -m state --state NEW -j ACCEPT</para>
<para>done</para>
<para>echo ""</para>
<para># Разрешается ping наружу</para>
<para>$IPT -A OUTPUT  -o $EXTIF -p icmp -s $EXTIP --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para>$IPT -A FORWARD -i $INTIF1 -p icmp -s $INTNET1 --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para>$IPT -A FORWARD -i $INTIF2 -p icmp -s $INTNET2 --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para># Файерволу разрешается ping внутренних систем</para>
<para>$IPT -A OUTPUT  -o $INTIF1 -p icmp -s $INTNET1 --icmp-type 8 -m state --state NEW -j ACCEPT</para>
<para>$IPT -A OUTPUT  -o $INTIF2 -p icmp -s $INTNET2 --icmp-type 8 -m state --state NEW -j ACCEPT                                                                                                                                                             </para>
<para>$IPT -A INPUT   -i $INTIF1 -p tcp --dport 22 --syn -m state --state NEW -j ACCEPT</para>
<para>$IPT -t nat -A PREROUTING -j ACCEPT</para>
<para>$IPT -t nat -A POSTROUTING -o $EXTIF -s $INTNET1 -j MASQUERADE</para>
<para>$IPT -t nat -A POSTROUTING -o $EXTIF -s $INTNET2 -j MASQUERADE</para>
<para>$IPT -t nat -A POSTROUTING -j ACCEPT</para>
<para>$IPT -t nat -A OUTPUT -j ACCEPT</para>
<para>$IPT -A INPUT -p tcp --dport auth --syn -m state --state NEW -j ACCEPT</para>
<para>$IPT -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</para>
<para>$IPT -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</para>
<para>$IPT -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT</para>
<para># Заблокировать и запротоколировать все, что мы могли забыть.</para>
<para>$IPT -A INPUT -j DROPl</para>
<para>$IPT -A OUTPUT -j REJECTl</para>
<para>$IPT -A FORWARD -j DROPl</para>
<para/>
<para/>
<para/></section></section><section><info><title>Установка почтовой системы</title></info>
<para/>
<para/>
<para>Установка почтовой системы на Gentoo linux для небольшой конторы </para>
<para/>
<para>Используется postfix + cyrus-imap, авторизация пользователей через cyrus-sasl без прикручивания какой-либо БД (подходит для контор с несколькими десятками почтовых ящиков - хранить что-либо в mysql или postgress в данном случае нет смысла). Пользователи хранятся в базе sasldb, поэтому нет нужды заводить в системе реальных пользователей. </para>
<para>Возможно при установке указанных пакетов понадобится установить все зависимости, которые они за собой тянут. Предоставим системе самой разобраться, что же ей не хватает - она с этим вполне успешно справляется. </para>
<para>Предпочитаю использовать для /var reiserfs, но это сугубо личные предпочтения. </para>
<para/>
<para/>
<para>emerge -pv cyrus-sasl</para>
<para>[ebuild   N   ] dev-libs/cyrus-sasl-2.1.20  -authdaemond +berkdb -debug +gdbm +java -kerberos -ldap +mysql  +pam -postgres +ssl -static 0 kB</para>
<para/>
<para>На всякий случай проверяем флаги - все ОК </para>
<para>emerge cyrus-sasl</para>
<para/>
<para>Этот пакет поставили, едем дальше </para>
<para>emerge -pv postfix</para>
<para>These are the packages that I would merge, in order:</para>
<para> Calculating dependencies ...done!</para>
<para>[ebuild   N   ] mail-mta/postfix-2.1.5-r1  +ipv6 -ldap -mailwrapper -mbox +mysql +pam -postgres -sasl*(-selinux) +ssl -vda 0 kB</para>
<para/>
<para>Здесь нам может пригодиться флаг sasl, хотя в моем случае пока нет нужды авторизоваться на smtp, возможно в дальнейшем здесь будет описана авторизация через cyrus-sasl на smtp - вообщем выставляйте флаги по вкусу кому что надо </para>
<para>USE="sasl" emerge postfix</para>
<para/>
<para>Постфикс собрался </para>
<para>emerge -pv cyrus-imapd</para>
<para>These are the packages that I would merge, in order:</para>
<para>Calculating dependencies ...done!</para>
<para>[ebuild   N   ] net-mail/cyrus-imapd-2.2.10  -afs -drac -idled -kerberos +pam -snmp +ssl +tcpd 0 kB</para>
<para/>
<para>После проверки и установки нужных нам флагов пересобираем openssl и imap-сервер </para>
<para>emerge cyrus-imapd</para>
<para/>
<para>Программа для администрирования имаповских ящиков </para>
<para>emerge cyrus-imap-admin</para>
<para/>
<para>После того как все нужные нам пакеты поставлены, можно приступать к настройке </para>
<para/>
<para>сначала cyrus-sasl </para>
<para>passwd cyrus</para>
<para>pwconv</para>
<para>chown -R cyrus:mail /etc/sasl2 - доступ cyrus к базе /etc/sasl2/sasldb2</para>
<para>saslpasswd2 cyrus - заводим в sasldb2 </para>
<para>sasldblistusers2 - для проверки</para><section><info><title>Разбираемся с postfix </title></info>
<para/>
<para>Cодержимое /etc/postfix/main.cf, ниже приведена примерная конфигурация почтового сервера подключенного напрямую к инету (не через relayhost), естественно для этого случая должна быть MX-запись в ДНС. Подчеркиваю, что умышленно опускаю многие параметры в main.cf, чтобы не раздувать описание. Добавьте все остальное руководствуясь документацией postfix. </para>
<para/>
<para>queue_directory = /var/spool/postfix</para>
<para>command_directory = /usr/sbin</para>
<para>daemon_directory = /usr/lib/postfix</para>
<para>mail_owner = postfix</para>
<para>myhostname = mail.domain.tld</para>
<para>mydomain = mail.domain.tld</para>
<para>myorigin = $mydomain</para>
<para>inet_interfaces = all</para>
<para>mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain</para>
<para>local_recipient_maps =</para>
<para>unknown_local_recipient_reject_code = 550</para>
<para>mynetworks_style = subnet</para>
<para>mynetworks = 192.168.1.0/24, 127.0.0.0/8</para>
<para>relay_domains = $mydestination</para>
<para>НА ЭТУ СТРОЧКУ ОБРАТИТЕ ВНИМАНИЕ!!! </para>
<para>mailbox_transport = lmtp:unix:/var/imap/socket/lmtp</para>
<para>Если надо подключить procmail то вместо нее пишем</para>
<para>mailbox_transport = procmail</para>
<para/>
<para>Когда добавили все, что нужно в main.cf, идем в /etc/postfix/master.cf </para>
<para/>
<para>Ищем такую строку </para>
<para> # Also specify in main.cf: cyrus_destination_recipient_limit=1</para>
<para>cyrus     unix  -       n       n       -       -       pipe</para>
<para> user=cyrus argv=/cyrus/bin/deliver -e -r ${sender} -m ${extension} ${user}</para>
<para> </para>
<para>И заменяем путь на </para>
<para> # Also specify in main.cf: cyrus_destination_recipient_limit=1</para>
<para>cyrus     unix  -       n       n       -       -       pipe</para>
<para> user=cyrus argv=/cyrus/deliver -e -r ${sender} -m ${extension} ${user}</para>
<para/>
<para>При использовании procmail, добавляем </para>
<para>procmail unix  -       n      n       -        -       pipe</para>
<para> flags=R user=cyrus argv=/usr/bin/procmail -p /etc/procmailrc  USER=${user}</para>
<para/>
<para>Где файл /etc/procmailrc : </para>
<para>DELIVERMAIL=/usr/lib/cyrus/deliver</para>
<para>LOGFILE=/var/log/procmaillog</para>
<para>IMAP="$DELIVERMAIL -e -a $USER -m user.$USER"</para>
<para>(если надо подключить spamassassin)</para>
<para>:0fw : spamassassin.lock</para>
<para>* &lt; 90000</para>
<para>| /usr/bin/spamassassin</para>
<para>и далее обязательно</para>
<para>:0</para>
<para>| $IMAP</para>
<para>:0w</para>
<para>{</para>
<para>EXITCODE=$?</para>
<para>HOST</para>
<para>}  </para>
<para/>
<para>Все, с постфиксом разобрались, теперь cyrus-imapd </para>
<para/>
<para>Редактируем /etc/cyrus.conf </para>
<para># $Header: /var/cvsroot/gentoo-x86/net-mail/cyrus-imapd/files/cyrus.conf,v 1.4 2004/07/18 04:02:23 dragonheart  Exp $</para>
<para># Standard standalone server configuration.</para>
<para>START {</para>
<para> # Do not delete this entry!</para>
<para> recover        cmd="ctl_cyrusdb -r"</para>
<para> # This is only necessary if using idled for IMAP IDLE.</para>
<para> #idled                cmd="idled"</para>
<para>}</para>
<para># UNIX sockets start with a slash and are put into /var/imap/socket.</para>
<para>SERVICES {</para>
<para>  # Add or remove based on preferences.</para>
<para>  imap                cmd="imapd" listen="imap2" prefork=0</para>
<para>  pop3                cmd="pop3d" listen="pop-3" prefork=0</para>
<para>   # Don't forget to generate the needed keys for SSL or TLS</para>
<para>  # (see doc/html/install-configure.html).</para>
<para>  imaps                cmd="imapd -s" listen="imaps" prefork=0</para>
<para>  pop3s                cmd="pop3d -s" listen="pop3s" prefork=0</para>
<para>  sieve                cmd="timsieved" listen="sieve" prefork=0</para>
<para>  # at least one LMTP is required for delivery</para>
<para>  #lmtp                cmd="lmtpd" listen="lmtp" prefork=0</para>
<para>   ##ОБРАТИТЕ ВНИМАНИЕ НА ЭТУ СТРОКУ</para>
<para>  lmtpunix        cmd="lmtpd" listen="/var/imap/socket/lmtp" prefork=0</para>
<para>     # this is only necessary if using notifications</para>
<para>  #notify        cmd="notifyd" listen="/var/imap/socket/notify" proto="udp" prefork=1</para>
<para>}</para>
<para>EVENTS {</para>
<para>  # This is required.</para>
<para>  checkpoint        cmd="ctl_cyrusdb -c" period=30</para>
<para>  # This is only necessary if using duplicate delivery suppression.</para>
<para>  delprune        cmd="ctl_deliver -E 3" period=1440</para>
<para>  # This is only necessary if caching TLS sessions.</para>
<para>  tlsprune        cmd="tls_prune" period=1440</para>
<para>}</para>
<para/>
<para>Вот так делаем сертификаты </para>
<para>openssl req -new -nodes -out req.pem -keyout key.pem  </para>
<para>openssl rsa -in key.pem -out new.key.pem</para>
<para>openssl x509 -in req.pem -out ca-cert -req \</para>
<para>-signkey new.key.pem -days 999 </para>
<para>cp new.key.pem /etc/ssl/cyrus/server.pem</para>
<para>rm new.key.pem</para>
<para>cat ca-cert &gt;&gt; /etc/ssl/cyrus/server.pem</para>
<para>chown cyrus:mail /etc/ssl/cyrus/server.pem</para>
<para>chmod 600 /etc/ssl/cyrus/server.pem # Your key should be protected</para>
<para/>
<para>Проверяем все-ли директории созданы </para>
<para>/var/imap</para>
<para>cd /var</para>
<para>mkdir imap</para>
<para>chown cyrus:mail imap</para>
<para>chmod 750 imap</para>
<para>/var/spool/imap </para>
<para>cd /var/spool</para>
<para>mkdir imap</para>
<para>chown cyrus:mail imap</para>
<para>chmod 750 imap</para>
<para>/usr/sieve</para>
<para>cd /usr</para>
<para>mkdir sieve</para>
<para>chown cyrus:mail sieve</para>
<para>chmod 750 sieve</para>
<para/>
<para>Далее редактируем /etc/imapd.conf </para>
<para>configdirectory:        /var/imap</para>
<para>partition-default:        /var/spool/imap</para>
<para>auto_transition:        yes</para>
<para>tls_ca_path:           /etc/ssl/cyrus</para>
<para>tls_cert_file:                /etc/ssl/cyrus/server.pem</para>
<para>tls_key_file:                /etc/ssl/cyrus/server.pem</para>
<para>admins:                        cyrus</para>
<para>hashimapspool:                yes</para>
<para>allowanonymouslogin:        no</para>
<para>allowplaintext:                yes</para>
<para>sasl_pwcheck_method:        auxprop</para>
<para>sasl_auxprop_plugin:        sasldb</para>
<para>sasldb_path:                /etc/sasl2/sasldb2</para>
<para>sasl_mech_list:                LOGIN PLAIN </para>
<para/>
<para>Авторизация через базу sasldb, механизмы авторизации LOGIN,PLAIN Если мы будем использовать обычные открытые пароли, без шифрования (например внутри организации) то изменим в /etc/imapd.conf </para>
<para>allowanonymouslogin: yes</para>
<para/>
<para>вроде бы с настройкой cyrus покончено </para>
<para/>
<para>Теперь займемся почтовыми ящиками юзеров, для этого используем программу cyradm </para>
<para>/etc/init.d/cyrus start</para>
<para>cyradm -user cyrus -server localhost</para>
<para>localhost&gt; cm user.testuser</para>
<para>localhost&gt; help - выводит все команды для руления юзерскими ящиками</para>
<para>localhost&gt; exit</para>
<para/>
<para>Не забудьте забить в sasldb2 нового юзера: </para>
<para>saslpasswd2 testuser </para>
<para/>
<para>Поднимаем сервисы </para>
<para>/etc/init.d/postfix start</para>
<para>/etc/init.d/cyrus start</para>
<para/>
<para>Настраиваем почтового клиента (проверено с thunderbird 1.0 и с KMail 1.7.1, с Outlook Express тоже не должно быть проблем). </para>
<para/>
<para>Пробуем отправить письмо, если что-то не работает - смотрим логи, прежде всего проверьте права на доступ в /var/imap/socket/lmtp для пользователей postfix и cyrus, чаще всего проблемы связаны именно с этим. Также проверьте права на доступ к /etc/sasl2/sasldb2 для пользователя cyrus, который должен быть в группе mail. </para>
<para/>
<para>Желательно поставить антивирус например clamav используем для этого связку clamav + clamsmtp хотя возможны и другие варианты например amavisd-new. Установка прекрасно описана здесь http://www.nixp.ru/articles/clamav_postfix, необходимо руководствоваться ей,естественно с адаптацией под реалии Gentoo </para>
<para>emerge clamav</para>
<para>ACCEPT_KEYWORDS="~x86" emerge clamsmtp (пока замаскирован в портаджах)</para>
<para/>
<para>Затем в файле /etc/conf.d/clamd START_CLAMD = yes (для версии старше 0.85 уже не актуально - все настройки только в clamd.conf и clamsmtpd.conf) </para>
<para/>
<para>Редактируем файлы /etc/clamd.conf и /etc/clamsmtpd.conf в соответствии с рекомендациями приведенными выше по ссылке Обратите внимание на параметры LocalSocket: /var/run/clamav/clamd.sock в /etc/clamav.conf и ClamAddress: /var/run/clamav/clamd.sock в /etc/clamsmtpd.conf - путь и имя файла должен одинаковым для обоих конфигов </para>
<para/>
<para>В файл main.cf необходимо добавить две строчки: </para>
<para>content_filter = scan:127.0.0.1:10025</para>
<para>receive_override_options = no_address_mappings</para>
<para/>
<para>Первая говорит postfix'у о том, что необходимо пересылать всю почту через сервис (фильтр) 'scan' на 10025-ый порт, который, как раз, открыт clamsmtpd. Вторая строчка говорит о том, чтобы postfix не делал никаких манипуляций с адресами до того, как они дойдут до content_filter. Так что получается, что фильтр работает с реальными почтовыми адресами, а не с результатами перевода в виртуальные псевдонимы, маскарадингом и т.п. </para>
<para/>
<para>В файл master.cf необходимо добавить следующие строки: </para>
<para># AV scan filter (used by content_filter)</para>
<para>scan      unix  -       -       n       -       16      smtp</para>
<para>       -o smtp_send_xforward_command=yes</para>
<para># For injecting mail back into postfix from the filter</para>
<para>127.0.0.1:10026 inet  n -       n       -       16      smtpd</para>
<para>       -o content_filter=</para>
<para>       -o receive_override_options=no_unknown_recipient_checks,no_header_body_checks</para>
<para>       -o smtpd_helo_restrictions=</para>
<para>        -o smtpd_client_restrictions=</para>
<para>       -o smtpd_sender_restrictions=</para>
<para>       -o smtpd_recipient_restrictions=permit_mynetworks,reject</para>
<para>       -o mynetworks_style=host</para>
<para>       -o smtpd_authorized_xforward_hosts=127.0.0.0/8</para>
<para/>
<para>Примечание: вокруг знака '=' пробелы не ставить. Значение 127.0.0.1:10026 открывает 10026-порт для возвращения почты обратно от clamsmtpd. </para>
<para>rc-update add clamd default</para>
<para>rc-update add clamsmtpd default</para>
<para>/etc/init.d/postfix reload</para>
<para/>
<para>все - антивирус должен проверять всю почту проходящую через Ваш почтовик </para>
<para/>
<para>P.S. Все вышеописанное проверялось на моей рабочей машине и на серваке небольшой конторы. Автор (или авторы) не несут ответственности за безграмотное и необдуманное применение данного руководства. Ваша безопасность в ваших руках и в голове! Данное описание не претендует на полное и развернутое и не является единственно возможным вариантом конфигурации. Также выражаю признательность разработчикам вышеописанных замечательных программ за прекрасное исполнение и хорошую документацию. Практически все вышенаписанное подчерпнуто из документации к самим пакетам, а также некоторые мысли родились из отрывочных данных, блуждающих в рунете - большое спасибо за это их авторам. </para>
<para/>
<para>PS. Некоторая путаница возникает с переадресацией почты - самый простой вариант использование файла aliases - но до его использования в отличие от sendmail, ящик который должен быть переадресован должен быть все-таки создан в системе через cyradm -user cyrus -auth login -server localhost команда cm и не забыть что etc/postfix/main.cf </para>
<para>alias_maps = hash:/usr/local/etc/postfix/aliases</para>
<para>alias_database = hash:/usr/local/etc/postfix/aliases</para>
<para/></section></section><section><info><title>Настройка vsftpd</title></info><section><info><title>Введение </title></info>
<para/>
<para>Это перевод статьи en:HOWTO vsftpd. Кое-что изменено и добавлено от себя для более понятного, как мне кажется, изложения </para>
<para>Взято из en:HOWTO Plan, setup and run a high school Gentoo Club и модифицировано. </para>
<para>Это руководство описывает процесс установки VSFTP и настройки его для анонимного доступа с правами только для чтения. FTP (File Transfer Protocol) - старый, но надежный протокол, используемый для быстрой передачи файлов в сети. </para>
<para/></section><section><info><title>Установка VSFTPD </title></info>
<para/>
<para>Зайдите в систему под пользователем root и введите комманду: Code: Установка </para>
<para> emerge vsftpd</para>
<para/>
<para>Настройка </para>
<para/>
<para>Это очень легко. Откройте файл /etc/vsftpd/vsftpd.conf вашим любимым текстовым редактором и внесите в него вот эти изменения: </para>
<para/>
<para>Общие настройки </para>
<para>Файл: /etc/vsftpd/vsftpd.conf </para>
<para> dirmessage_enable=YES</para>
<para> # banner_file=/etc/vsftpd/vsftpd.banner # edit banner first</para>
<para> chown_uploads=NO</para>
<para> xferlog_enable=YES</para>
<para> idle_session_timeout=600</para>
<para> data_connection_timeout=120</para>
<para> ascii_upload_enable=NO</para>
<para> ascii_download_enable=NO</para>
<para> chroot_list_enable=YES</para>
<para> background=YES</para>
<para> listen=YES</para>
<para> ls_recurse_enable=NO</para>
<para/>
<para/>
<para>Анонимный пользователь (Anonymous), только для чтения</para>
<para>Файл: /etc/vsftpd/vsftpd.conf </para>
<para> anonymous_enable=YES</para>
<para> anon_upload_enable=NO</para>
<para> anon_mkdir_write_enable=NO</para></section><section><info><title>Отключаем локальных пользователей </title></info>
<para/>
<para>Это плохая идея разрешать локальным пользователям доступ через ftp (проще sftp/ssh), потому мы отключаем им доступ. Файл: /etc/vsftpd/vsftpd.conf </para>
<para> local_enable=NO</para>
<para> write_enable=NO</para></section><section><info><title>Запуск службы </title></info>
<para/>
<para>Gentoo предоставляет централизированное место для служб, которые называються init scripts или скрипты инициализации. Эти скрипты находяться в каталоге /etc/init.d/ и имеют имя сервиса, который они стартуют. Инит скрипты используються для управления сервисами. Для запуска VSFTPD сервера наберите Code: Запуск vsftpd как службы </para>
<para> /etc/init.d/vsftpd start</para>
<para/>
<para>Вы можете узнать больше о том что вы можете сделать этим скриптом инициализации набрав "/etc/init.d/vsftpd" без аргументов ("start" это аргумент, еще есть "stop" и "restart") ) </para>
<para/></section><section><info><title>Настройка скриптов конфигурации </title></info>
<para/>
<para>Вы не хотите набирать /etc/init.d/vsftpd start каждый раз когда вы включаете свой компьютер? Gentoo предоставляет простой путь запуска скриптов инициализации при включении вашего компьютера. Чтобы настроить VSFTPD для запуска при каждой загрузке, наберите: Code: запуск vsftpd как службы загрузке </para>
<para> rc-update add vsftpd default</para>
<para/>
<para>Если вы хотите узнать больше о rc-update наберите "man rc-update". </para>
<para/>
<para>Также можно и через chkconfig: Code: запуск vsftpd как службы загрузке </para>
<para> chkconfig vsftpd on</para></section><section><info><title>Где размещать файлы </title></info>
<para/>
<para>Файлы анонимного пользователя находятся в домашнем каталоге специального пользоватьля ftp (пользователя в системе). По умолчанию это - /home/ftp. Если вы хотите сменить его например на /var/ftp, вам нужно сделать следущие действия: /var/ftp Code: Смена размещения </para>
<para> rmdir /home/ftp</para>
<para> mkdir /var/ftp</para>
<para> chown ftp:ftp /var/ftp</para>
<para> ln -s /var/ftp /home/</para>
<para/>
<para/>
<para>Теперь можно что-то разместить в этом каталоге. Например, если вы хотите сделать доступными для других каталоги disfiles и packages, можно сделать следущие действия: Code: ' </para>
<para> mv /usr/portage/disfiles /var/ftp/</para>
<para> ln -s /var/ftp/disfiles /usr/portage/</para>
<para> mv /usr/portage/packages /var/ftp/</para>
<para> ln -s  /var/ftp/packages /usr/portage/</para>
<para/>
<para/>
<para>Примечание: VSFTPD автоматически запусается в chroot окружении, поэтому символические ссылки не работают. Именно для этого пришлось перенести каталоги /usr/portage/disfiles и usr/portage/packages и создать символические ссылки в тех местах где они должны находится. </para>
<para/>
<para>Но можно например монтировать нужные каталоги в .../ftp при помощи fstab. Для этого нужно создать каталоги: /var/ftp/distfiles и /var/ftp/packages Code: ' </para>
<para> mkdir /var/ftp/distfiles</para>
<para> mkdir /var/ftp/packages</para>
<para/>
<para/>
<para>После чего пропишите в /etc/fstab следущее: Code: ' </para>
<para> /usr/portage/distfiles /var/ftp/distfiles none ro,bind 0 0</para>
<para> /usr/portage/packages /var/ftp/packages none ro,bind 0 0</para></section><section><info><title>Клиенты </title></info>
<para/>
<para>Есть множеcтво программ, которые позволяют получать доступ к ftp серверу. Вот некоторые из них: </para>
<para>ftp </para>
<para>lftp - лучшый консольный клиент </para>
<para>mozilla-firefox </para>
<para>nautilus </para>
<para>gftp</para></section></section><section><info><title>Jabber Server</title></info><section><info><title>Введение</title></info>
<para/>
<para>Jabber - это открытый протокол, использующий XML, для быстрого обмена сообщениями и информацией о присутствии между любыми двумя абонентами в интернете. Благодаря своей уникальной расширяемости и гибкости, jabber способен поддерживать множество протоколов - ICQ, IRQ, MSN, RSS, Yahoo и др. </para></section><section><info><title>Установка пакетов</title></info>
<para>В качестве платформы для развертывания протокола jabber возьмем пакет jabberd. Он поддерживает множество возможностей - основные IM-протоколы ICQ, MSN, Yahoo, поддержку SSL-соединений и даже IPv6.</para>
<para>Сначала посмотрим, какие USE-флаги требует jabber: Code: Зависимости </para>
<para/>
<para># emerge -pv jabberd</para>
<para>These are the packages that I would merge, in order:</para>
<para>Calculating dependencies ...done!</para>
<para>[ebuild N ] net-im/jabberd-1.4.3-r5 -icq -ipv6 -ldap -msn -oscar -ssl -yahoo 0 kB </para>
<para>Total size of downloads: 0 kB </para>
<para/>
<para>Включаем соответсвующие флаги в установку (неважно, через переменную USE или через файл make.conf) и собираем: USE="icq ssl" emerge jabberd В качестве зависимости вытянется пакет jit - Jabber ICQ Transport, необходимый для поддержки протокола ICQ. </para>
<para/></section><section><info><title>Конфигурация</title></info>
<para/>
<para>Сначала добавьте пользователей, ответсвенных за администрирование сервера jabber, в группу jabber: </para>
<para>gpasswd -a имя_пользователя jabber </para>
<para>Все конфигурационные файлы, связанные с jabber, имеют формат XML и находятся в каталоге /etc/jabber. </para>
<para>Обязательно надо прописать имя хоста и РАЗРЕШИТЬ регистрации. </para></section><section><info><title>Запуск демона</title></info>
<para/>
<para>Добавляем запуск сервера при старте системы: </para>
<para>rc-update add jabber default </para>
<para>Стартуем наш сервер: /etc/init.d/jabber start </para>
<para>Все должно работать :)</para>
<para/></section></section><section><info><title>Выделенный сервер Counter-Strike</title></info>
<para/>
<para>Рано или поздно у большинства админов локальных сетей возникает необходимость настраивать игровые сервера для пользователей. Одной из самых популярных сетевых игр на сегодняшний день является Counter-Strike.CS:Source. Которая, к сожалению пока не приобрела достаточной популярности у нас в России. Мы рассмотриму установку сервера для игры CS 1.6. Более популярной в среде российских геймеров. </para>
<para/><section><info><title>Необходимое программное обеспечение</title></info>
<para>Для установки CS-сервера нам понадобится только одна программа:halflife-steam Code: emerge -pv halflife-steam </para>
<para/>
<para>Calculating dependencies ...done! </para>
<para>[ebuild N ] games-server/halflife-steam-2.0 3,431 kB </para>
<para>Total size of downloads: 3,431 kB </para>
<para/>
<para/>
<para>Steam - это утилита от Valve,позволяющая обновлять любую их игру через steam-network. </para></section><section><info><title>Установка и настройка</title></info>
<para/>
<para>Ставим steam</para>
<para>Установка сводится к простому emerge halflife-steam. </para>
<para/>
<para>Настройка установка hl</para>
<para/>
<para>Steam установится в каталог /opt/halflife </para>
<para/>
<para>ВАЖНО: в ноябре 2006 года в пакете была бага. Что характерно для всех продуктов получаемых через стим, они иногда забывают unix специфику. Непостредственно у меня, на steam не стоял бит исполняемости. И в cs было имя типа xxx.WAD (нужно wad, различаеться регистр) Code: команды </para>
<para/>
<para>cd /opt/halflife </para>
<para>chmod +x stream </para>
<para/>
<para>Code: команды </para>
<para>./steam -command update -game cstrike -dir ./ </para>
<para/>
<para>Наблюдаем лог. Если никаких слов типа error нет - значит сервер установился. Code: output </para>
<para/>
<para>HLDS installation up to date </para>
<para/>
<para/>
<para>Предупреждение: Этот сервер работает только в LAN (класс С) и только со steam клиентами. Все остальное Варез</para>
<para/></section></section><section><info><title>Файл сервер Samba в домене Win2k</title></info>
<para>Задача: </para>
<para>Организация файлового сервера </para>
<para>Авторизация пользователей через домен контроллер </para>
<para/>
<para>Дано: </para>
<para>Red Hat 9.0 </para>
<para>Samba 3.0.13 </para>
<para>DC win 2003 server </para>

    <section>
        <info><title>Вступление </title></info>
        <para>Взяться за написание данной статьи меня побудило то, что когда возникла задача о которой написано выше , то статьи описывающей решение данной проблемы полностью я не нашел вот и решил написать такую статью в которой было бы готовое решение. </para>
<para/></section><section><info><title>Основная часть </title></info>
<para>Первым делом устанавливаем самбу. Решено было использовать последнюю версию 3.0.13. Установлено все это было из стандартного RPM пакета. Думаю с этим сложностей ни у кого не возникает, док по данному вопросу полно и потому начнем сразу править конфиг самбы. Ниже приведен окончательный работающий конфиг, может там и есть что лишнее, но после того как все заработало я убирать оттуда ничего не стал. </para>
<para> [global]</para>
<para>   realm = bryusov.iasnet.ru</para>
<para> # Workgroup = имя NT-домена (или рабочей группы): </para>
<para>   workgroup = DOMAIN  </para>
<para/>
<para> # NetBIOS-имя, под которым будет виден сервер остальным машинам сети.</para>
<para>   netbios name = NAU</para>
<para/>
<para> # Комментарий, появляющийся рядом с именем машины в "Сетевом окружении" Windows.</para>
<para>   server string = Samba Server</para>
<para/>
<para> # Следующий параметр влияет на безопасность. Hosts allow разрешает машинам с </para>
<para> # указанными IP-адресами присоединяться к Samba-серверу. </para>
<para>   hosts allow = 172.18. 172.17.  127.</para>
<para/>
<para> # если подставить %m то для каждой машины  подключенной к Samba-серверу будет </para>
<para> # использоваться свой log-файл. </para>
<para>   log file = /var/log/samba/log.smbd   </para>
<para/>
<para> # это кому скока не жалко             </para>
<para>   max log size = 500    </para>
<para/>
<para> # определяет, каким образом будет осуществляться проверка пароля (нам надо через DC)                                          </para>
<para>   security = domain</para>
<para/>
<para> # Параметр Password server используется только совместно с опцией security = domain</para>
<para>   password server =  &lt;IP домен контролера&gt;</para>
<para/>
<para> # для репликации всех доменов входящих в траст с вашим доменом</para>
<para>   allow trusted domains = yes                </para>
<para/>
<para> # включаем  поддержку шифрованных паролей. </para>
<para>   encrypt passwords = yes</para>
<para/>
<para> # Используя следующий параметр можно создать отдельную конфигурацию для каждой машины домена. </para>
<para> # Вместо пары символов %m при входе подставляется NetBIOS-имя машины. </para>
<para> # Я Такого не делал хотя поэксперементровать можно.</para>
<para> # include = /usr/local/samba/lib/smb.conf.%m</para>
<para/>
<para> # данные строчки можно не включать в работающий конфиг они определяют место</para>
<para> # хранения , порядок обновления Unix паролей и какой программой все это производится</para>
<para>   smb passwd file = /etc/samba/smbpasswd</para>
<para>   unix password sync = Yes</para>
<para>   passwd program = /usr/bin/passwd %u</para>
<para>   passwd chat = *New*UNIX*password* %n\n *ReType*new*UNIX*password* %n\n *passwd:*all*authentication*tokens*updated*successfully*</para>
<para/>
<para> # В документации  говорится, что с помощью этого параметра</para>
<para> # можно повысить производительность Samba-сервера.</para>
<para>   socket options = TCP_NODELAY SO_RCVBUF=8192 SO_SNDBUF=8192</para>
<para/>
<para> # по дефолту слушаются все интерфейсы, здесь можно указать конкретно</para>
<para>   interfaces = &lt;ip или название интерфейса&gt;</para>
<para/>
<para> # строчки которых не было в стандартном конфиге и были добавлены руками для pепликации NT-юзеpов:</para>
<para/>
<para>  winbind uid = 10000-20000</para>
<para>  winbind gid = 10000-20000</para>
<para>  winbind enum groups = yes</para>
<para>  winbind enum users = yes</para>
<para/>
<para> # Если вам нужны русские буквы в именах файлов, то раскоментируйте </para>
<para> # следующие 3 строки (заменив KOI8-R на свою локаль)</para>
<para> # dos charset = CP866       </para>
<para> # unix charset = KOI8-R     </para>
<para> # display charset = KOI8-R  </para>
<para/>
<para/>
<para/>
<para> # описываем шары</para>
<para> [FILES]</para>
<para>   comment = share</para>
<para>   path = /share/FILES</para>
<para>   public = no</para>
<para>   writable = yes</para>
<para>   valid users = DOMAIN\users</para>
<para>   create mask = 0744</para>
<para/>
<para> # настройка кириллицы по желанию</para>
<para/>
<para>Все с конфигом самбы закончили, далее привожу конфиг /etc/krb5.conf </para>
<para> [logging]</para>
<para>  default = FILE:/var/log/krb5libs.log</para>
<para>  kdc = FILE:/var/log/krb5kdc.log</para>
<para>  admin_server = FILE:/var/log/kadmind.log</para>
<para/>
<para> [libdefaults]</para>
<para>  ticket_lifetime = 24000</para>
<para>  default_realm = PDC.DOMAIN.NAME.RU</para>
<para>  dns_lookup_realm = false</para>
<para>  dns_lookup_kdc = false</para>
<para/>
<para> [realms]</para>
<para>  DOMAIN.NAME.RU = {</para>
<para>   kdc = pdc.domain.name.ru:88</para>
<para>   admin_server = kerberos.domain.name.ru:749</para>
<para>   default_domain = domain.name.ru</para>
<para>  }</para>
<para/>
<para> [domain_realm]</para>
<para>  .domain.name.ru = DOMAIN.NAME.RU</para>
<para>  domain.name.ru = DOMAIN.NAME.RU</para>
<para/>
<para> [kdc]</para>
<para>  profile = /var/kerberos/krb5kdc/kdc.conf</para>
<para/>
<para> [appdefaults]</para>
<para>  pam = {</para>
<para>    debug = false</para>
<para>    ticket_lifetime = 36000</para>
<para>    renew_lifetime = 36000</para>
<para>    forwardable = true</para>
<para>    krb4_convert = false</para>
<para>  }</para>
<para/>
<para>Все остальное оставлено без изменений. </para>
<para/>
<para>Теперь заводим самба сервер в домен, делаем со стороны домен контролера двусторонние доверительные отношения, запускаем getent group и видим что все работает. </para>
<para/>
<para>Вот и все надеюсь полезной инфы достаточно для быстрой и эффективной настройки файл сервера. </para>
<para/>
<para>Огромное спасибо всем кто писал статьи про самбу почти все их прочитал и почерпнул много полезного , в том числе не только для решения своих задач.</para>
<para/></section></section><section><info><title>Руководство по настройке Samba в режиме PDC с использованием LDAP</title></info>
<para/><section><info><title>Устанавливаемые пакеты </title></info>
<para/>
<para>Установим нужные пакеты: </para>
<para/>
<para># USE="ldap acl ldapsam pam gdbm samba ssl tcpd winbind" emerge samba openldap acl nss_ldap pam_ldap </para>
<para/>
<para/>
<para/>
<para>ВАЖНО: Версия nss_ldap должна быть не ниже 250-r1 (&gt;=sys-auth/nss_ldap-250-r1) </para>
<para/></section><section><info><title>OpenLDAP</title></info>
<para/>
<para>Конфигурирование OpenLDAP</para>
<para/>
<para>Для примера используется домен amber.global.com который является дочерним доменом домена global.com, который работает под управлением Win2003 Server. </para>
<para/>
<para>Примечание: Не решенной задачей осталось создание доверительных отношений между доменами и включение домена amber в лес global.com </para>
<para>Файл: /etc/openldap/slapd.conf </para>
<para>include /etc/openldap/schema/core.schema</para>
<para> include /etc/openldap/schema/cosine.schema</para>
<para> include /etc/openldap/schema/inetorgperson.schema</para>
<para> include /etc/openldap/schema/misc.schema</para>
<para> include /etc/openldap/schema/nis.schema</para>
<para> include /etc/openldap/schema/openldap.schema</para>
<para> include /etc/openldap/schema/samba.schema</para>
<para> pidfile                        /var/run/openldap/slapd.pid</para>
<para> argsfile                /var/run/openldap/slapd.args</para>
<para/>
<para> access to dn.base=""</para>
<para>                by self write</para>
<para>                by * auth</para>
<para> access to attr=userPassword</para>
<para>                by self write</para>
<para>                by * auth</para>
<para> access to attr=shadowLastChange</para>
<para>                by self write</para>
<para>                by * read</para>
<para> access to *</para>
<para>                by * read</para>
<para>                by anonymous auth</para>
<para> #loglevel 1</para>
<para> database        ldbm</para>
<para> suffix          "dc=amber,dc=global,dc=com"</para>
<para> rootdn          "cn=Manager,dc=amber,dc=global,dc=com"</para>
<para> # Пароль rootpw лучше всего указывать в зашифрованном виде.</para>
<para> # Для генерации шифрованного пароля используйте утилиту slappasswd</para>
<para> # Например: slappasswd -h {MD5}</para>
<para> # rootpw = secret</para>
<para> rootpw                {MD5}Xr4ilOzQ4PCOq3aQ0qbuaQ==</para>
<para> directory        /var/lib/openldap-ldbm</para>
<para/>
<para> index objectClass           eq</para>
<para> index cn                    eq,subinitial</para>
<para> index sn                    eq,subinitial</para>
<para> index uid                   eq,subinitial</para>
<para> index displayName           eq,subinitial</para>
<para> index uidNumber             eq</para>
<para> index gidNumber             eq</para>
<para> index memberUID             eq</para>
<para> index sambaSID              eq</para>
<para> index sambaPrimaryGroupSID  eq</para>
<para> index sambaDomainName       eq</para>
<para>Файл: /etc/openldap/ldap.conf </para>
<para>HOST 127.0.0.1</para>
<para>BASE dc=sanaa,dc=global,dc=com</para>
<para/>
<para/>
<para/>
<para>Проверяем разрешения на каталоги /var/lib/openldap-*</para>
<para>ls -la /var/lib/ </para>
<para/>
<para>ВАЖНО: </para>
<para>drwx------   2 ldap     ldap      104 Июн  8 18:31 openldap-data</para>
<para>drwx------   2 ldap     ldap       72 Июн  8 18:31 openldap-ldbm</para>
<para>drwx------   2 ldap     ldap       72 Июн  8 18:31 openldap-slurp</para>
<para/></section><section><info><title>Запуск сервера OpenLDAP</title></info>
<para/>
<para>пока работаем без шифрования трафика, так как сервер LDAP и SAMBA работают на одном сервере, подправляем конфиг чтобы LDAP слушал 389 порт только на localhost. </para>
<para>Файл: /etc/conf.d/sldap </para>
<para># conf.d file for the openldap-2.1 series</para>
<para>#</para>
<para># To enable both the standard unciphered server and the ssl encrypted</para>
<para># one uncomment this line or set any other server starting options</para>
<para># you may desire.</para>
<para>#</para>
<para># OPTS="-h 'ldaps:// ldap:// ldapi://%2fvar%2frun%2fopenldap%2fslapd.sock'"</para>
<para>OPTS="-h 'ldap://127.0.0.1'"</para>
<para/>
<para>и запускаем OpenLDAP </para>
<para/>
<para>/etc/init.d/slapd start </para>
<para/></section><section><info><title>SAMBA</title></info>
<para/>
<para>Миграция OpenLDAP</para>
<para/>
<para>Существует 2 пути создания учетных записей пользователей: домен уже существует и создание нового домена. В первом случае самбу нужно настроить в режиме BDC, перенести все учетные записи, и потом изолировав PDC, перезапустить самбу в режиме PDC. Во втором случае все еще проще, самбу сразу запускаем в режиме PDC и создаем стандарные учетные записи при помощи замечательного пакета smbldap-tools. </para>
<para/>
<para/>
<para/>
<para>emerge smbldap-tools</para>
<para/>
<para>/etc/init.d/samba start</para>
<para/>
<para>Code: configure.pl </para>
<para>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-</para>
<para>       smbldap-tools script configuration</para>
<para>       -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</para>
<para>Before starting, check</para>
<para> . if your samba controller is up and running.</para>
<para> . if the domain SID is defined (you can get it with the 'net getlocalsid')</para>
<para/>
<para> . you can leave the configuration using the Crtl-c key combination</para>
<para> . empty value can be set with the "." character</para>
<para>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-</para>
<para>Looking for configuration files...</para>
<para/>
<para>Samba Configuration File Path [/etc/samba/smb.conf] &gt; </para>
<para>The default directory in which the smbldap configuration files are stored is shown.</para>
<para>If you need to change this, enter the full directory path, then press enter to continue.</para>
<para>Smbldap-tools Configuration Directory Path [/etc/smbldap-tools/] &gt; </para>
<para>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</para>
<para>Let's start configuring the smbldap-tools scripts ...</para>
<para/>
<para>. workgroup name: name of the domain Samba act as a PDC</para>
<para>  workgroup name [amber] &gt; </para>
<para>. netbios name: netbios name of the samba controler</para>
<para>  netbios name [neptun] &gt; </para>
<para>. logon drive: local path to which the home directory will be connected </para>
<para> (for NT Workstations). Ex: 'H:'</para>
<para>  logon drive [U:] &gt; </para>
<para>. logon home: home directory location (for Win95/98 or NT Workstation).</para>
<para>  (use %U as username) Ex:'\\neptun\%U'</para>
<para>  logon home (press the "." character if you don't want homeDirectory) [\\%L\users\%U] &gt; </para>
<para>. logon path: directory where roaming profiles are stored. Ex:'\\neptun\profiles\%U'</para>
<para>  logon path (press the "." character if you don't </para>
<para>  want roaming profile) [\\%L\Profiles\%a\%U] &gt; </para>
<para>. home directory prefix (use %U as username) [/home/%U] &gt; </para>
<para>. default users' homeDirectory mode [700] &gt; </para>
<para>. default user netlogon script (use %U as username) [] &gt;</para>
<para>   default password validation time (time in days) [45] &gt; 900</para>
<para>. ldap suffix [dc=amber,dc=global,dc=com] &gt; </para>
<para>. ldap group suffix [ou=Groups] &gt; </para>
<para>. ldap user suffix [ou=Users] &gt; </para>
<para>. ldap machine suffix [ou=Users] &gt; </para>
<para>. Idmap suffix [ou=Idmap] &gt; </para>
<para>. sambaUnixIdPooldn: object where you want to store the next uidNumber</para>
<para>  and gidNumber available for new users and groups</para>
<para>  sambaUnixIdPooldn object (relative to ${suffix}) [sambaDomainName=amber] &gt; </para>
<para>. ldap master server: IP adress or DNS name of the master (writable) ldap server</para>
<para>  ldap master server [127.0.0.1] &gt; </para>
<para>. ldap master port [389] &gt; </para>
<para>. ldap master bind dn [cn=Manager,dc=amber,dc=global,dc=com] &gt; </para>
<para>. ldap master bind password [] &gt;  </para>
<para>. ldap slave server: IP adress or DNS name of the slave ldap server: can also </para>
<para>  be the master one</para>
<para>  ldap slave server [127.0.0.1] &gt; </para>
<para>. ldap slave port [389] &gt; </para>
<para>. ldap slave bind dn [cn=Manager,dc=amber,dc=global,dc=com] &gt; </para>
<para>. ldap slave bind password [] &gt;  </para>
<para>. ldap tls support (1/0) [0] &gt; </para>
<para>. SID for domain amber: SID of the domain (can be obtained with 'net getlocalsid neptun')</para>
<para>  SID for domain amber [S-1-5-21-1918777035-593721947-2697221154] &gt; </para>
<para>. unix password encryption: encryption used for unix passwords</para>
<para>  unix password encryption (CRYPT, MD5, SMD5, SSHA, SHA) [SSHA] &gt; MD5</para>
<para>. default user gidNumber [513] &gt; </para>
<para>. default computer gidNumber [515] &gt; </para>
<para>. default login shell [/bin/bash] &gt; </para>
<para>. default skeleton directory [/etc/skel] &gt; </para>
<para>. default domain name to append to mail adress [] &gt; </para>
<para>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</para>
<para>backup old configuration files:</para>
<para>  /etc/smbldap-tools/smbldap.conf-&gt;/etc/smbldap-tools/smbldap.conf.old</para>
<para>  /etc/smbldap-tools/smbldap_bind.conf-&gt;/etc/smbldap-tools/smbldap_bind.conf.old</para>
<para>writing new configuration file:</para>
<para>  /etc/smbldap-tools/smbldap.conf done.</para>
<para>  /etc/smbldap-tools/smbldap_bind.conf done.</para>
<para/>
<para/>
<para/>
<para>Если мы не хотим, что бы у всех пользователей профили были перемещаемыми, то в файле /etc/smbldap-tools/smbldap.conf установим следующее значение: Файл: /etc/smbldap-tools/smbldap.conf </para>
<para> ...</para>
<para> userProfile=""</para>
<para> ...</para>
<para> </para>
<para>Инициализируем каталоги самбы в LDAP: </para>
<para/>
<para>smbldap-populate -a Administrator -k 0 -m 0</para>
<para/>
<para>Конфигурация SAMBA</para>
<para>Файл: /etc/samba/smb.conf </para>
<para>[global]</para>
<para>        workgroup = amber</para>
<para>        netbios name = neptun</para>
<para>        realm = amber.global.com</para>
<para>        nt acl support = yes</para>
<para>        acl compatibility = win2k</para>
<para>        map acl inherit = yes</para>
<para>        server string = Samba Server %v</para>
<para>        interfaces = eth0</para>
<para>        bind interfaces only = yes</para>
<para>        hosts allow = 192.168.7. 127.</para>
<para>        log file = /var/log/samba/log.%m</para>
<para>        debug level = 9</para>
<para>        max log size = 500</para>
<para>        socket options = TCP_NODELAY SO_SNDBUF=8192 SO_RCVBUF=8192</para>
<para>        security = user</para>
<para>        os level = 250</para>
<para>        passdb backend = ldapsam:"ldap://127.0.0.1/"</para>
<para>        enable privileges = yes</para>
<para>        </para>
<para>        passwd program = /usr/sbin/smbldap-passwd "%u"</para>
<para>        passwd chat = *new*password* %n\n *new*password* %n\n *successfully*</para>
<para>        passdb expand explicit = no</para>
<para>        unix password sync = no</para>
<para>        ldap passwd sync = no</para>
<para>        </para>
<para>        ldap suffix = dc=amber,dc=global,dc=com</para>
<para>        ldap admin dn = cn=Manager,dc=amber,dc=global,dc=com</para>
<para>        ldap user suffix = ou=Users</para>
<para>        ldap group suffix = ou=Groups</para>
<para># Т.к. для самбы компьютеры и пользователи - одно и то же,</para>
<para># и искать она в дальнейшем записи компьютеров будет в пользователях,</para>
<para># то для избежания дальнейших проблем при добавлении рабочих станций</para>
<para># к домену мы вместо следующей строки</para>
<para>#</para>
<para>#        ldap machine suffix = ou=Computers</para>
<para>#</para>
<para># напишем другую:</para>
<para>        ldap machine suffix = ou=Users</para>
<para>        ldap idmap suffix = ou=Idmap</para>
<para>        idmap backend = ldapsam:ldap://127.0.0.1/</para>
<para>        idmap uid = 10000-20000</para>
<para>        idmap gid = 10000-20000</para>
<para>        </para>
<para>        ldap delete dn = Yes</para>
<para>        ldap ssl = no</para>
<para>        </para>
<para>        </para>
<para>        add user script = /usr/sbin/smbldap-useradd -n -a "%u"</para>
<para>        delete user script = /usr/sbin/smbldap-userdel "%u"</para>
<para>        </para>
<para>        add group script = /usr/sbin/smbldap-groupadd -p "%g"</para>
<para>        delete group script = /usr/sbin/smbldap-userdel "%g"</para>
<para>        </para>
<para>        add user to group script = /usr/sbin/smbldap-groupmod -m "%u" "%g"</para>
<para>        delete user from group script = /usr/sbin/smbldap-groupmod -x "%u" "%g"</para>
<para>        set primary group script = /usr/sbin/smbldap-usermod -g "%g" "%u"</para>
<para>        </para>
<para>        </para>
<para>        add machine script = /usr/sbin/smbldap-useradd -w "%u"</para>
<para>        </para>
<para>        #PDC</para>
<para>        domain master = yes</para>
<para>        preferred master = yes</para>
<para>        #BDC</para>
<para>#        domain master = no</para>
<para>#        preferred master = no</para>
<para>        domain logons = Yes</para>
<para>        </para>
<para/>
<para>        logon script = </para>
<para># Если хотите, что бы профили всех пользователей были перемещаемыми</para>
<para># и хранились на сервере (со всеми гигабайтами фильмов и личных фотографий)</para>
<para># то укажите такое значение следующего параметра:</para>
<para>#</para>
<para>#        logon path = \\%L\Profiles\%a\%U</para>
<para>#</para>
<para># Если вы не хотите гонять профили по сети, оставьте значение пустым, </para>
<para># (но ни в коем случае не комментируйте эту строку, она просто получит </para>
<para># значение по умолчанию), вот так:</para>
<para>        logon path =</para>
<para>        logon drive = U: </para>
<para>        logon home = \\%L\users\%U</para>
<para>        </para>
<para>        </para>
<para>#============================ Share Definitions ==============================</para>
<para>[netlogon]</para>
<para>    comment = Network Logon Service</para>
<para>    path = /var/lib/samba/netlogon</para>
<para>    browseable = yes</para>
<para>    guest ok = yes</para>
<para>    writable = no</para>
<para>    share modes = no</para>
<para/>
<para>[Profiles]</para>
<para>    admin users = admin</para>
<para>    create mode = 600</para>
<para>    directory mode = 700</para>
<para>    path = /var/lib/samba/profiles</para>
<para>    browseable = yes</para>
<para>    guest ok = yes</para>
<para>    writable = yes</para>
<para/>
<para>[homes]</para>
<para>  comment = Home Directories</para>
<para>  browseable = no</para>
<para>  read only = no</para>
<para/>
<para>[public]</para>
<para>  path = /pub</para>
<para>  guest ok = yes</para>
<para>  read only = no</para>
<para/>
<para>[users]</para>
<para>  path = /home/users</para>
<para>  writable = yes</para>
<para>  printable = no</para>
<para> </para>
<para/>
<para/>
<para>Добавим запуск winbind с самбой (если нужно): Файл: /etc/conf.d/samba </para>
<para> ...</para>
<para> daemon_list="smbd nmbd winbind"</para>
<para> ...</para>
<para> </para>
<para>Введём пароль рабочей станции: </para>
<para/>
<para>smbpasswd -w secret </para>
<para/>
<para>Введём контроллёр домена, собственно в домен </para>
<para/>
<para>net rpc join -S neptun -U Administrator </para>
<para/></section><section><info><title>Настройка системы на авторизацию в LDAP</title></info>
<para/>
<para>--ladserg 14:05, 28 июля 2006 (UTC) У меня честно говоря не получилось сделать авторизацию пользователей samba через LDAP без настройки поддержки авторизации системных пользователей в LDAP, пришлось настраивать и это. </para>
<para/>
<para>Сначала поправим файл /etc/ldap.conf, приведя его примерно к следующему виду: </para>
<para/>
<para>Файл: /etc/ldap.conf </para>
<para> host 127.0.0.1</para>
<para> base dc=amber,dc=global,dc=com</para>
<para> ldap_version 3</para>
<para> rootbinddn cn=Manager,dc=amber,dc=global,dc=com</para>
<para> bind_timelimit 10</para>
<para> bind_policy soft</para>
<para> pam_filter objectClass=posixAccount</para>
<para> pam_password exop</para>
<para> nss_base_passwd         ou=Users,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_shadow         ou=Users,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_group          ou=Groups,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_hosts          ou=Hosts,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_services       ou=Services,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_networks       ou=Networks,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_protocols      ou=Protocols,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_rpc            ou=Rpc,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_ethers         ou=Ethers,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_netmasks       ou=Networks,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_bootparams     ou=Ethers,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_aliases        ou=Aliases,dc=tty,dc=perm,dc=ru?one</para>
<para> nss_base_netgroup       ou=Netgroup,dc=tty,dc=perm,dc=ru?one</para>
<para> ssl off</para>
<para> nss_reconnect_tries 4</para>
<para> nss_reconnect_sleeptime 1</para>
<para> nss_reconnect_maxsleeptime 16</para>
<para> nss_reconnect_maxconntries 2</para>
<para> </para>
<para>Сим мы скажем nss_ldap где и как искать зписи пользователей и групп. </para>
<para/>
<para>Теперь сзодадим файл /etc/ldap.secret и при помощи лбого текстого редактора в plain/text виде занесём туда пароль пользователя, который выше у нас указан в опции rootbinddn, нпример пароль secret: </para>
<para>Файл: /etc/ldap.secret </para>
<para>secret </para>
<para/>
<para>Затем непременно установим на него нужные права:</para>
<para>Code: Установка прав на файл /etc/ldap.secret </para>
<para> #chmod 600 /etc/ldap.secret</para>
<para> #chown root:root /etc/ldap.secret</para>
<para/>
<para>Далее приведём файл /etc/pam.d/system-auth к следующему виду: </para>
<para>Файл: /etc/pam.d/system-auth </para>
<para> auth       required     pam_env.so</para>
<para> auth       sufficient   pam_unix.so likeauth nullok</para>
<para> auth       sufficient   pam_ldap.so use_first_pass</para>
<para> auth       required     pam_deny.so</para>
<para/>
<para> account    sufficient   pam_ldap.so</para>
<para> account    required     pam_unix.so</para>
<para/>
<para> password   required     pam_cracklib.so difok=2 minlen=8 dcredit=2 ocredit=2 retry=3</para>
<para> password   sufficient   pam_unix.so nullok md5 shadow use_authtok</para>
<para> password   sufficient   pam_ldap.so use_authtok</para>
<para> password   required     pam_deny.so</para>
<para/>
<para> session    required     pam_limits.so</para>
<para> session    required     pam_unix.so</para>
<para> session    required     pam_mkhomedir.so skel=/etc/skel/ umask=077</para>
<para> session    optional     pam_ldap.so</para>
<para> </para>
<para>Обратите внимание на строку: </para>
<para/>
<para>session required pam_mkhomedir.so skel=/etc/skel/ umask=077 </para>
<para/>
<para>Она заставляет систему создавать домашние каталоги для тех пользоватей у которых они ещё не созданы, при этом в новый каталог помещается содержимое директории /etc/skel/ и задаётся маска каталога 0x700 </para>
<para/>
<para>После чего правим файл /etc/nsswitch.conf, приводя его к следующему виду: </para>
<para>Файл: /etc/nsswitch.conf </para>
<para> passwd:      files ldap</para>
<para> shadow:      files ldap</para>
<para> group:       files ldap</para>
<para/>
<para> hosts:       files dns</para>
<para> networks:    files dns</para>
<para/>
<para> services:    db files</para>
<para> protocols:   db files</para>
<para> rpc:         ldap [NOTFOUND=return] db files</para>
<para> ethers:      ldap [NOTFOUND=return] db files</para>
<para> netmasks:    files</para>
<para> netgroup:    ldap [NOTFOUND=return] files</para>
<para> bootparams:  files</para>
<para/>
<para> automount:   files</para>
<para> aliases:     files </para>
<para/>
<para>Предупреждение: Ни в коем случае не добавляйте значение ldap к следующим базам: hosts, networks, protocols, services. Иначе вы рискуете не дождаться следующей загрузки системы. </para>
<para/>
<para>Всё, теперь мы указали системе брать пользователей как из системных файлов, так и из LDAP. </para>
<para/>
<para>Перезагрузим наш компьютер, дабы убедиться что система грузится нормально. Если система останавливается на загрузке udev, то смотрите ошибки в файле /etc/nsswitch.conf, может вы указали использовать ldap не в той базе. </para>
<para/></section><section><info><title>Управление пользователями</title></info>
<para/>
<para>Ранее мы установили пакет smbldap-tools, теперь рассмотрим возможность управления пользователями с его помощью. </para>
<para/>
<para>Создание пользователя</para>
<para/>
<para>smbldap-useradd [-o] [-a] [-b] [-w] [-i] [-u uid] [-g gid ] [-G groups,,,] </para>
<para> [-n] [-d home] [-s shell] [-c gecos] [-m [-k]] [-t] [-P] [-A 0|1] [-B 0|1] </para>
<para> [-C sambaHomePath] [-D sambaHomeDrive] [-E sambaLogonScript] [-F sambaProfilePath] </para>
<para> [-H sambaAcctFlags] [-N surname] [-S family name] [-M local mailAddress,,,] </para>
<para> [-T mailToAddress] [-?] user</para>
<para/>
<para>Где: </para>
<para> user - системное имя создаваемого пользователя</para>
<para> -o   - add the user in the organizational unit (relative to the user suffix)</para>
<para> -a   - is a Windows User (otherwise, Posix stuff only)</para>
<para> -b   - is a AIX User</para>
<para> -w   - is a Windows Workstation (otherwise, Posix stuff only)</para>
<para> -i   - is a trust account (Windows Workstation)</para>
<para> -u   - uid</para>
<para> -g   - gid</para>
<para> -G   - список групп пользователя, разделённых запятой.</para>
<para> -n   - do not create a group</para>
<para> -d   - домашний каталог пользователя (по умолчанию /home/имя_пользователя)</para>
<para> -s   - оболочка пользователя (по умолчанию /bin/false)</para>
<para> -c   - отображаемое в Windows имя пользователя</para>
<para> -m   - создать домашний каталог и скопировать в него файлы из /etc/skel</para>
<para> -k   - указать иной каталог, из которого будут копироваться файлы при </para>
<para>        создании домашнего каталога пользователя (используется с ключём -m)</para>
<para> -t   - time. Wait 'time' seconds before exiting (when adding Windows Workstation)</para>
<para> -P   - ends by invoking smbldap-passwd</para>
<para> -A   - возможность менять пароль пользователем, значение 0 если нет, 1 если да</para>
<para> -B   - пользователь должен поменять пароль, значение 0 если нет, 1 если да</para>
<para> -C   - домашний каталог samba (например '\\PDC-SRV\homes')</para>
<para> -D   - буква диска для монтирования домашнего каталога samba (например 'H:')</para>
<para> -E   - скрипт, выполняемый при входе в систему</para>
<para> -F   - каталог профиля пользователя (например '\\PDC-SRV\profiles\foo')</para>
<para> -H   - sambaAcctFlags (samba account control bits like '[NDHTUMWSLKI]')</para>
<para> -N   - настоящее имя пользователя (для русских ещё и отчество)</para>
<para> -S   - фамилия пользователя</para>
<para> -M   - local mailAddress (comma seperated)</para>
<para> -T   - mailToAddress (forward address) (comma seperated)</para>
<para> -?   - отобразить помощь</para>
<para/>
<para>Например создание пользователя ladserg: </para>
<para/>
<para>smbldap-useradd -a -c 'Serg Alex Lad' -N 'Serg Alex' -S 'Lad' -s /bin/bash ladserg </para>
<para/>
<para>К сожалению подружить smbldap-tools с русским мне не удалось, даже при использовании кодировки UTF-8. </para>
<para>Итак, в приведённом выше примере будет создан пользователь с системным именем ladserg, фамилией Lad, именем Serg Alex, оболочкой /bin/bash, домашним каталогом /home/ladserg. Флаг -a укажет, что пользователь также будет являться пользователем домена. </para>
<para/>
<para>Изменение пароля</para>
<para>smbldap-passwd [-s] [-u] [-h] username</para>
<para/>
<para>Где: </para>
<para> username       - имя пользователя</para>
<para> -h, -?, --help - показать помощь</para>
<para> -s             - обновить только samba пароль</para>
<para> -u             - обновить только UNIX пароль</para>
<para/>
<para/>
<para>Например: </para>
<para/>
<para>smbldap-passwd ladserg </para>
<para/>
<para>После чего дважды будет запрошен пароль. </para>
<para/>
<para>Теперь можно попробовать зайти в систему под учётной записью только что созданного пользователя. </para>
<para/>
<para>Модификация пользователя</para>
<para>smbldap-usermod [-a] [-c comment] [-d home_dir] [-e expiration_date] </para>
<para> [-g initial_group] [-r new_login_name] [-p passwd] [-s shell] [-u uid [ -o]] [-x] </para>
<para> [-A canchange] [-B mustchange] [-C smbhome] [-D homedrive] [-E scriptpath] </para>
<para> [-F profilepath] [-G group[,...]] [-H acct‐flags] [-N canonical_name] </para>
<para> [-S surname] [-P] login</para>
<para/>
<para>Где: </para>
<para> -c    - Полное имя</para>
<para> -d    - Домашний каталог</para>
<para> -r    - новое имя пользователя (cn, sn и dn будут обновлены)</para>
<para> -u    - uid</para>
<para> -o    - uid может быть не уникальным</para>
<para> -g    - gid</para>
<para> -G    - список групп пользователя, разделённых запятой.</para>
<para> -s    - оболочка</para>
<para> -N    - настоящее имя пользователя (для русских ещё и отчество)</para>
<para> -S    - фамилия пользователя</para>
<para> -P    - ends by invoking smbldap-passwd</para>
<para>For samba users:</para>
<para> -a    - add sambaSAMAccount objectclass</para>
<para> -e    - expire date ("YYYY-MM-DD HH:MM:SS")</para>
<para> -A    - возможность менять пароль пользователем, значение 0 если нет, 1 если да</para>
<para> -B    - пользователь должен поменять пароль, значение 0 если нет, 1 если да</para>
<para> -C    - домашний каталог samba (например '\\PDC-SRV\homes')</para>
<para> -D    - буква диска для монтирования домашнего каталога samba (например 'H:')</para>
<para> -E    - скрипт, выполняемый при входе в систему</para>
<para> -F    - каталог профиля пользователя (например '\\PDC-SRV\profiles\foo')</para>
<para> -H    - sambaAcctFlags (samba account control bits like '[NDHTUMWSLKI]')</para>
<para> -I    - disable an user. Can't be used with -H or -J</para>
<para> -J    - enable an user. Can't be used with -H or -I</para>
<para> -M    - mailAddresses (comma seperated)</para>
<para> -T    - mailToAddress (forward address) (comma seperated)</para>
<para> -?|-h - отобразить помощь</para>
<para/>
<para/>
<para>Например команда: </para>
<para>smbldap-usermod -A 1 ladserg</para>
<para/>
<para>Позволит пользователю ladserg менять пароль. А команда: </para>
<para>smbldap-usermod -a slad-adm</para>
<para/>
<para>Добавит к учётной записи пользователя slad-adm класс sambaSAMAccount, что сделает его пользователем samba. </para>
<para/>
<para>Удаление пользователя</para>
<para>smbldap-userdel [-r|-R|-?] username</para>
<para/>
<para>Где: </para>
<para> -r    удалить домашний каталог</para>
<para> -R    удалить домашний каталог с запросом на удаление каждого файла</para>
<para> -?    отобразить помощь</para>
<para/>
<para>Например команда: </para>
<para>smbldap-userdel -r slad-adm </para>
<para/>
<para>удалит пользователя slad-adm, и его домашний каталог. </para>
<para/>
<para>Управление пользователями в оффтопике</para>
<para/>
<para>Если вы вводите в домен компьютеры под управлением Windows, то вам пригодятся пара утилит, архив которых можно скачать отсюда: </para>
<para/>
<para>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="ftp://ftp.microsoft.com/Softlib/MSLFILES/SRVTOOLS.EXE">ftp://ftp.microsoft.com/Softlib/MSLFILES/SRVTOOLS.EXE</link>
</para>
<para/></section></section><section><info><title>Мониторинг работы системы</title></info>
<para/><section><info><title>Введение</title></info>
<para/>
<para>В данной статье описывается, как осуществить мониторинг разных системных и физических параметров компьютеров, работающих под GNU/Linux или другими UNIX. </para>
<para/>
<para/>
<para/>
<para>Постановка задачи</para>
<para/>
<para>Нужно осуществлять постоянный мониторинг основных параметров работы компьютеров (физических и системных) через сеть, собирать и выдавать эту информацию в удобной форме.</para>
<para/>
<para>Для примера см: http://monitoring.sourceforge.net/example.html</para>
<para/>
<para>К основным системным параметрам относят: загрузка процессоров (пользователями, системой, привилегированными программами, свободное процессорное время), использования оперативной памяти (и многие другие, всего больше 100), дисков, сетевого трафика. Для получения необходимых нам значений параметров работы системы используем программы df, sar и iptables или ipfw.</para>
<para/>
<para>К физическим параметрам относят: температуру процессора и материнской платы, скорость вращения вентиляторов, напряжения питания. Для получения показателей датчиков материнских плат используется модуль ядра I2C и программа lm_sensors.</para>
<para/>
<para>Для передачи информации через сеть используем клент-серверную модель и программу Net-Telnet. Базу данных строим пакетом rrdtool, информацию предоставляем через сервер apache и/или по почте. С помощью скриптов постараемся максимально упростить и автоматизировать поставленную задачу, это избавит вас от рутинной работы.</para>
<para/>
<para>Программа работает по клиент-серверной технологии. На компьютерах, которые нужно мониторить, размещается часть программы, которая снимает различные показатели работы компьютера и выдает их по запросу через сеть. На одном административном компьютере осуществляется периодический опрос всех компьютеров, за которыми ведется наблюдение, данные записываются в специально созданную базу, и на её основе формируется html страница, которая экспортируется через apache для просмотра обычным браузером.</para>
<para/>
<para>Теперь подробно о том, что нам нужно сделать:</para>
<para>Загружаем последнюю версию программы для мониторинга с сайта http://monitoring.sourceforge.net/ Файл monitoring-*.tar.bz2 размещаем в доступном месте, например в папке локального ftp: /var/ftp/pub/linux. </para></section><section><info><title>"Серверная" сторона</title></info>
<para/>
<para>Разархивируйте monitoring-*.tar.bz2.</para>
<para/>
<para>У Gentoo есть ебилд, для установки программы monitoring со всеми зависимостями. С сайта необходимо скачать monitoring-*.ebuild.tar.bz2 и распаковать его в /usr/local. Далее выполните: </para>
<para># emerge -pv monitoring</para>
<para>[ebuild N ] net-analyzer/monitoring-0.11 USE="-admin -apache2 -lm_sensors -server"</para>
<para/>
<para>Для серверной стороны необходимо добавить USE="server", а для поддержки мониторинга датчиков USE="lm_sensors" </para>
<para># export "USE=lm_sensors server"</para>
<para># emerge monitoring</para>
<para/>
<para>Компиляция и установка lm_sensors, sysstat, iptables, coreutils, xinetd в случае использования Gentoo можно пропустить, потому что эти пакеты уже установлены как зависимости, и перейти сразу к их настройке. </para></section><section><info><title>Мониторинг физических параметров</title></info>
<para/>
<para>Определяем на базе какого чипсета сделаны платы: материнская, видеокарта (некоторые имеют датчики) и прочие, заходим на страницы: http://secure.netroedge.com/~lm78/supported.html и http://www.lm-sensors.nu/~lm78/newdrivers.html и ищем, есть ли драйверы для мониторинга этих плат под Линуксом. Если определили, что ваши чипсеты поддерживаются и драйвер стабильный, можете продолжить выполнение этого пункта.</para>
<para/>
<para>Внимание, если версия ядра меньше за 2.4.9, нужно обновить ядро или воспользоваться старой версией программы! смотрите: i2c. Если ядро версии 2.4.*, вам дополнительно нужен СООТВЕТСТВУЮЩИЙ! модуль i2c-*.*.*.tar.gz, родной Линуксовый не подходит. В версии ядра 2.6.* все хорошо - отлично работает родной модуль ядра i2c. </para>
<para/></section><section><info><title>Компиляция ядра</title></info>
<para/>
<para>Подробную инструкцию по сборке нового ядра можно прочесть по ссылке "Ставим ядро 2.6, или Ядерная физика для домохозяйки. Версия 2.0"</para>
<para>Обратите особое внимание на пункты, которые добавляют к ядру GNU/Linux поддержку сенсоров:</para>
<para>Для поддержания ACPI: </para>
<para>Power management options (ACPI, APM) ---&gt; ACPI (Advanced Configuration and Power Interface) Support ---&gt;</para>
<para/>
<para>Для поддержки IPMI стандарта управления сенсорами. </para>
<para>Device Drivers ---&gt; Character devices ---&gt; IPMI ---&gt;</para>
<para/>
<para>Включаем поддержку сенсоров в ядре </para>
<para>Device Drivers ---&gt; I2C support ---&gt;</para>
<para/>
<para>Выбираем алгоритмы, использующие ваши чипы </para>
<para>Device Drivers ---&gt; I2C support ---&gt; I2C Algorithms ---&gt;</para>
<para/>
<para>Выбираем ваш чипсет (внимание, здесь нужно указать чипсет именно вашей системной платы, или видеокарты, см. ниже): </para>
<para>Device Drivers ---&gt; I2C support ---&gt; I2C Hardware Bus support ---&gt;</para>
<para>Device Drivers ---&gt; I2C support ---&gt; Miscellaneous I2C Chip support ---&gt;</para>
<para/>
<para>Выбираем драйверы ко всем вашим сенсорам (внимание, именно тех, соответствующих вашим чипам, предыдущим пунктам): </para>
<para>Device Drivers ---&gt; Hardware Monitoring support ---&gt;</para>
<para/>
<para>Можно собрать необходимые драйверы как модули, хотя это несколько добавит работы при настройке (нужно будет запустить программу sensors-detect). Для мониторинга сети можно использовать netfilter (iptables) и прочие опции... </para>
<para/>
<para>Если Ваше аппаратное обеспечения поддерживается, установите lm_sensors</para>
<para/>
<para>Загружаем с: lm_sensors, свеженькую версию lm_sensors-*.*.*.tar.gz. Разархивируем lm_sensors-*.*.*.tar.gz Заходим в директорию, какая создалась и выполняем: </para>
<para># make user</para>
<para># make user_install</para>
<para># depmod -a</para>
<para/>
<para>Проверяем, есть ли строка /usr/local/lib в файле /etc/ld.so.conf, если нет, добавляем и выполняем команду: </para>
<para># ldconfig</para>
<para/>
<para/>
<para>Настройка lm_sensors</para>
<para/>
<para>Выполняем команду </para>
<para># prog/mkdev/mkdev.sh</para>
<para/>
<para>Чтобы правильно определить ваше оборудование и знать, какие модули нужно загрузить, выполним: </para>
<para># prog/detect/sensors-detect</para>
<para/>
<para>именно этот скрипт и указывает, какие у вас чипсеты, и какие в них сенсоры!</para>
<para>Добавляем строки, созданные программой для modules.conf в /etc/modules.conf</para>
<para>Копируем prog/init/lm_sensors.init в каталог /etc/rc.d/init.d/lm_sensors (назначить права для исполнения).</para>
<para>Добавляем строки, которые создала программа prog/detect/sensors-detect с modprobe и sensors -s например, в конец файла /etc/conf.d/local.start - чтобы они загружались при старте системы</para>
<para>или можно запускать как сервис:</para>
<para>для Gentoo выполняем: </para>
<para># rc-update -a lm_sensors default</para>
<para/>
<para>Только для клонов RedHat выполняем: </para>
<para># chkconfig --add lm_sensors</para>
<para/>
<para>копируем prog/init/lm_sensors.sysconfig в /etc/sysconfig/lm_sensors</para>
<para>копируем etc/sensors.conf.eg в /etc/sensors.conf</para>
<para>копируем prog/sensors/sensors в каталог /usr/bin/sensors (предоставить права на выполнение) </para>
<para/>
<para>Все теперь выполняют modprobe с параметрами, которые указала программа sensors-detect для загрузки модулей, потом выполняем: </para>
<para># sensors -s</para>
<para/>
<para>Корректируем /etc/sensors.conf таким образом, чтобы названия напряжений, скорости вентиляторов и температур, именно Ваших чипов содержали соответственно: "Volt", "Fan", "Temp". При этом, названия меток допускают только малые и большие латинские буквы, цифры, знак "_", и не должны содержать знаков „.”, ”/” или ”+”! Выполнение этих условий обязательно!!!</para>
<para>Пример /etc/sensors.conf можно найти в server/etc/sensors.conf</para>
<para>Например, для lm85*: </para>
<para># cat /etc/sensors.conf</para>
<para>...</para>
<para># Voltage inputs</para>
<para>  label in0   "VoltA1_5"      # AGP on Intel S845WD1-E</para>
<para>  label in1   "Volt1_5"</para>
<para>  label in2   "Volt3_3"</para>
<para>  label in3   "Volt5"</para>
<para>  label in4   "Volt12"</para>
<para># Temperature inputs</para>
<para>  label temp1  "TempCPU"</para>
<para>  label temp2  "TempMB1"</para>
<para>  label temp3  "TempMB2"</para>
<para># Fan inputs</para>
<para>  label fan1   "FanCPU"</para>
<para>  label fan2   "FanSys1"</para>
<para>  label fan3   "FanSys2"</para>
<para>  label fan4   "FanSys3"</para>
<para># PWM Outputs</para>
<para>  label pwm1   "CPUF_PWM"</para>
<para>  label pwm2   "SysF1_PWM"</para>
<para>  label pwm3   "SysF2_PWM"</para>
<para>...</para>
<para/>
<para>Теперь выполним команду sensors, и если у нас все получилось, то увидим примерно следующее: </para>
<para># sensors</para>
<para>lm85b-i2c-0-2e </para>
<para>Adapter: SMBus I801 adapter at c800 </para>
<para>VoltA1_5:   +1.48 V  (min =  +1.42 V, max =  +1.58 V)</para>
<para>Volt1_5:    +1.50 V  (min =  +1.45 V, max =  +1.60 V)</para>
<para>Volt3_3:    +3.33 V  (min =  +3.13 V, max =  +3.47 V)</para>
<para>Volt5:     +5.10 V  (min =  +4.74 V, max =  +5.26 V)</para>
<para>Volt12:   +12.31 V  (min = +11.38 V, max = +12.62 V)</para>
<para>FanCPU:    3360 RPM  (min = 3000 RPM)</para>
<para>TempCPU:     +36C  (low  =   +10C, high =   +60C)</para>
<para>TempMB1:     +33C  (low  =   +10C, high =   +45C)</para>
<para>TempMB2:     +33C  (low  =   +10C, high =   +45C)</para>
<para>CPUF_PWM:  255</para>
<para>SysF1_PWM: 255</para>
<para>SysF2_PWM:  77</para>
<para>vid:      +1.525 V    (VRM Version  9.1)</para>
<para/>
<para>Если у вас названия напряжений, скорости вентиляторов и температуры не содержат соответственно: "Volt", "Fan", "Temp" - обязательно отредактируйте файл /etc/sensors.conf как показано выше. </para>
<para/></section><section><info><title>Мониторинг системных параметров</title></info>
<para/>
<para>Установка sysstat</para>
<para/>
<para>Загружаем последнюю версию пакета sysstat с сайта http://perso.wanadoo.fr/sebastien.godard/ или ftp://ibiblio.org/pub/Linux/system/status/ </para>
<para>Розархивируем файл sysstat-*.*.*.tar.bz2 в /usr/src </para>
<para>Заходим в созданный каталог и выполняем: </para>
<para># make config                 #Отвечаем на вопросы только 'y' или 'n'</para>
<para># make</para>
<para># make install</para>
<para/>
<para>Теперь из командной строки пробуем: </para>
<para># sar -A 1 1 |grep Average: </para>
<para>Average:       proc/s </para>
<para>Average:         0.00 </para>
<para>Average:      cswch/s </para>
<para>Average:       258.00 </para>
<para>Average:          CPU     %user     %nice   %system   %iowait     %idle </para>
<para>Average:          all      1.90      0.00      0.40      0.00     97.70 </para>
<para>........................................................................</para>
<para>Average:      runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15 </para>
<para>Average:            0        83      0.06      0.15      0.16 </para>
<para/>
<para>Проверка df</para>
<para># df</para>
<para>Filesystem           1K-blocks      Used Available Use% Mounted on</para>
<para>/dev/sda3              2007996    411772   1596224  71% /</para>
<para>/dev/sda1               132206     10981    114399  43% /boot</para>
<para>/dev/sda5               248895      4256    231789   2% /tmp</para>
<para>/dev/sda6              5863496   2556028   3307468  64% /var</para>
<para>/dev/sda7              6843432   5128048   1715384  75% /usr</para>
<para>/dev/sda8              1976492   1048740    827348  56% /home</para>
<para>/dev/sda9              5863496   4479752   1383744  77% /usr/portage/distfiles</para>
<para>none                    254752         0    254752   0% /dev/shm</para>
<para>/usr/portage/distfiles 5863496   4479752   1383744  77% /var/ftp/pub/linux/distfiles</para>
<para>/usr/portage/packages  6843432   5128048   1715384  75% /var/ftp/pub/linux/packages</para>
<para/>
<para>Если Вам выдало: </para>
<para>bash: df: command not found</para>
<para>установите df из пакета coreutils. </para>
<para/></section><section><info><title>Мониторинг сети</title></info>
<para/>
<para>Мониторинг сети основывается на подсчете байт, попадающих в правила сетевых экранов - iptables или ipfw, и поэтому они достаточно гибкие, но является зависимым от конфигурации сетевого экрана.</para>
<para>Если Вы хотите осуществлять мониторинг сети: просмотрите server/etc/show_network.conf (/etc/monitoring/show_network.conf) – это список графиков, которые Вы получите. Он должен отвечать названиям графиков в admin/etc/network (/etc/monitoring/network). </para>
<para/></section><section><info><title>Linux iptables</title></info>
<para/>
<para>Нужно откорректировать server/etc/show_iptables_acc.conf (/etc/monitoring/show_network.conf)</para>
<para>1 колонка – название графика (должна отвечать show_network.conf, но с “in_*.N” или “out_*.N”, где N – некоторый идентификатор, например число)</para>
<para>2 колонка – название таблицы</para>
<para>3 колонка – название цепочки с таблицы</para>
<para>4 колонка – порядковый номер правила с цепочки</para>
<para>Это всё должно отвечать Вашим правилам!</para>
<para>Простые примеры экранов находятся в server/firewall/* и если подходит Вам, можете использовать их.</para>
<para>Проверьте работу /usr/bin/show_iptables.sh. Результат найдёте в /home/monitoring </para>
<para/></section><section><info><title>FreeBSD ipfw</title></info>
<para/>
<para>Для BSD, надо откорректировать server/bin/show_ipf_acc.conf:</para>
<para>1 колонка – название графика</para>
<para>2 колонка – номер правила</para>
<para>3 колонка – порядковый номер правила в ipfw show</para>
<para>Это должно отвечать Вашим правилам!</para>
<para>Проверьте работу /usr/bin/show_ipfw.sh Результат в /home/monitoring </para>
<para/>
<para>Некоторые важные системные настройки</para>
<para/>
<para>Если нет xinetd – установите его. Загляньте в </para>
<para>server/etc/host.allow (/etc/host.allow): </para>
<para># BEGIN allow services for monitoring</para>
<para>show_hdisk.sh:127.0.0.1 # IP ком п'ютера что мониторит</para>
<para>show_sensors.sh:127.0.0.1 # IP ком п'ютера что мониторит</para>
<para>show_info.sh:127.0.0.1 # IP ком п'ютера что мониторит</para>
<para>show_system.sh:127.0.0.1 # IP ком п'ютера что мониторит</para>
<para>show_network.sh:127.0.0.1 # IP ком п'ютера что мониторит</para>
<para># END allow services for monitoring</para>
<para/>
<para>Также некоторые из них вы можете изменить в server/bin/show_* и строки "only_from", "bind" и "disable" в server/xinetd.d/show_* </para>
<para>$ cat server/xinetd.d/show_hdisk</para>
<para># default: on</para>
<para># description: The showdisk server show disk useg on the server.</para>
<para>#       It dont uses authentication !!!!!!!!!!!!!!!.</para>
<para>service df</para>
<para>{</para>
<para>       socket_type             = stream</para>
<para>       wait                    = no</para>
<para>       user                    = monitoring</para>
<para>       bind                    = 127.0.0.1               # IP сетевого интерфейса, на котором мониторят</para>
<para>       server                  = /usr/bin/show_hdisk.sh</para>
<para>       only_from               = 127.0.0.1               # IP комп'ютера, который мониторит</para>
<para>       disable                 = no                      # Вкл./Выкл.</para>
<para>}</para>
<para/>
<para>Откройте доступ к следующим портам: 9045/tcp 9046/tcp 9047/tcp 9048/tcp 9049/tcp с административного компьютера в случае наличия сетевых экранов. Если Вы хотите осуществить установку вручную, пропустите следующий пункт. </para>
<para/>
<para>Автоматическая инсталляция</para>
<para/>
<para>Для автоматической установки отредактируйте следующие строки в monitoringinstall.sh (/usr/sbin/monitoringinstall.sh): </para>
<para># Edit this first:</para>
<para># all command will execute user:</para>
<para>runuser=monitoring</para>
<para>rungroup=monitoring</para>
<para># cron cfg directory</para>
<para>cronpath=/etc/cron.d</para>
<para># init script locations:</para>
<para>crond=/etc/init.d/crond</para>
<para># Edit only for server side:</para>
<para># init script location:</para>
<para>xinetd=/etc/init.d/xinetd</para>
<para># program location:</para>
<para>dfpath=/bin/df</para>
<para>sarpath=/usr/bin/sar</para>
<para>sensorspath=/usr/bin/sensors</para>
<para/>
<para>Теперь с правами суперпользователя выполните: </para>
<para># ./monitoringinstall.sh --server</para>
<para/>
<para>В Gentoo просто: </para>
<para># monitoringinstall.sh --server</para>
<para/>
<para>Вы можете пропустить пункт следующий пункт и перейти к „административной” части системы. </para>
<para/></section><section><info><title>Ручная установка</title></info>
<para/>
<para>Копируем следующие файлы: </para>
<para>cp server/etc/show_iptables_acc.conf /etc/monitoring        #for GNU/Linux</para>
<para>cp server/etc/show_ipfw_acc.conf /etc/monitoring        #for BSD</para>
<para>cp server/etc/show_network.conf /etc/monitoring</para>
<para>cp server/xinetd.d/show_hdisk /etc/xinetd.d/</para>
<para>cp server/xinetd.d/show_network /etc/xinetd.d/</para>
<para>cp server/xinetd.d/show_sensors /etc/xinetd.d/</para>
<para>cp server/xinetd.d/show_system /etc/xinetd.d/</para>
<para>cp server/bin/show_hdisk.sh /usr/bin</para>
<para>cp server/bin/show_iptables.sh /usr/bin                #for GNU/Linux</para>
<para>cp server/bin/show_ipfw.sh /usr/bin                        #for BSD</para>
<para>cp server/bin/show_network.sh /usr/bin</para>
<para>cp server/bin/show_sar.sh /usr/bin</para>
<para>cp server/bin/show_sensors.sh /usr/bin</para>
<para>cp server/bin/show_system.sh /usr/bin</para>
<para/>
<para>Добавим следующие строки к /etc/service: </para>
<para>network                9045/tcp                        # show network info</para>
<para>info                9046/tcp                        # show server info</para>
<para>df                9047/tcp                        # show disk info</para>
<para>sys                9048/tcp                        # show system info</para>
<para>sensors                9049/tcp                        # show sensors info</para>
<para/>
<para>Создадим специального пользователя: </para>
<para>groupadd monitoring</para>
<para>useradd -g monitoring -d /home/monitoring -s /bin/bash -c monitoring monitoring</para>
<para>mkdir /home/monitoring</para>
<para>chmod 700 /home/monitoring</para>
<para>chown -R monitoring:monitoring /home/monitoring</para>
<para/>
<para>В случае использования политик SELinux необходимо также добавить: </para>
<para># cat /etc/security/selinux/src/policy/users</para>
<para>...</para>
<para># BEGIN monitoring selinux:</para>
<para>user monitoring roles user_r;</para>
<para># END monitoring selinux.</para>
<para/>
<para>и дополнительно выполнить: </para>
<para># cd /etc/security/selinux/src/policy</para>
<para># make load</para>
<para/>
<para>Перегрузим xinetd: </para>
<para># /etc/init.d/xinetd restart</para>
<para/>
<para>и добавьте строки в crontab: </para>
<para>*/10 * * * * monitoring /usr/bin/show_iptables.sh        # для GNU/Linux</para>
<para>*/10 * * * * monitoring /usr/bin/show_ipfw.sh                # для BSD</para>
<para>*/1 * * * * monitoring /usr/bin/show_sar.sh</para>
<para/>
<para>Перегрузим crond: </para>
<para># /etc/init.d/crond restart</para>
<para/>
<para>Все вышесказанное нужно сделать на КАЖДОМ сервере, который вы хотите мониторить... </para>
<para/></section><section><info><title>"Административная" сторона</title></info>
<para/>
<para>Для начала убедитесь что все хорошо со стороны серверов</para>
<para/>
<para>Для каждого сервера проверяем доступность необходимых сервисов: </para>
<para># telnet server_name 9045</para>
<para>Trying serverIP...</para>
<para>Connected to serverIP.</para>
<para>Escape character is '^]'.</para>
<para>in_ftp                    0</para>
<para>out_ftp                   0</para>
<para>in_http                    0</para>
<para>out_http                   0</para>
<para>in_other                    249</para>
<para>out_other                   27</para>
<para>Connection closed by foreign host.</para>
<para/>
<para># telnet server_name 9046</para>
<para>Trying serverIP...</para>
<para>Connected to server_name.</para>
<para>Escape character is '^]'.</para>
<para>  Intel(R) Celeron(R) CPU 2.40GHz | 504 Mb</para>
<para>Connection closed by foreign host.</para>
<para/>
<para># telnet server_name 9047</para>
<para>Trying serverIP...</para>
<para>Connected to server_name.</para>
<para>Escape character is '^]'.</para>
<para>/dev/sda3              2007996    411772   1596224  71% /</para>
<para>/dev/sda1               132206     10981    114399  43% /boot</para>
<para>/dev/sda5               248895      4256    231789   2% /tmp</para>
<para>/dev/sda6              5863496   2556028   3307468  64% /var</para>
<para>/dev/sda7              6843432   5128048   1715384  75% /usr</para>
<para>/dev/sda8              1976492   1048740    827348  56% /home</para>
<para>/dev/sda9              5863496   4479752   1383744  77% /usr/portage/distfiles</para>
<para>Connection closed by foreign host.</para>
<para/>
<para># telnet server_name 9048</para>
<para>Trying serverIP...</para>
<para>Connected to server_name.</para>
<para>Escape character is '^]'.</para>
<para>Average:       proc/s</para>
<para>Average:         3.98</para>
<para>Average:      cswch/s</para>
<para>Average:       308.00</para>
<para>Average:          CPU     %user     %nice   %system   %iowait     %idle</para>
<para>Average:          all      1.76      0.00      0.47      0.00     97.76</para>
<para>.............................................................</para>
<para>Average:      runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15</para>
<para>Average:            1        88      0.05      0.21      0.21</para>
<para>Connection closed by foreign host.</para>
<para/>
<para># telnet server_name 9049</para>
<para>Trying serverIP...</para>
<para>Connected to server_name.</para>
<para>Escape character is '^]'.</para>
<para>lm85b-i2c-0-2e</para>
<para>Adapter: SMBus I801 adapter at c800</para>
<para/>
<para>Volt1_5:    +1.48 V  (min =  +1.42 V, max =  +1.58 V)</para>
<para>VoltCore:   +1.50 V  (min =  +1.45 V, max =  +1.60 V)</para>
<para>Volt3_3:    +3.33 V  (min =  +3.13 V, max =  +3.47 V)</para>
<para>Volt5:     +5.10 V  (min =  +4.74 V, max =  +5.26 V)</para>
<para>Volt12:   +12.25 V  (min = +11.38 V, max = +12.62 V)</para>
<para>CPU_Fan:   3377 RPM  (min = 3000 RPM)</para>
<para>fan2:         0 RPM  (min =    0 RPM)</para>
<para>fan3:         0 RPM  (min =    0 RPM)</para>
<para>fan4:         0 RPM  (min =    0 RPM)</para>
<para>TempCPU:     +32 C  (low  =   +10 C, high =   +50 C)</para>
<para>TempBoard:   +30 C  (low  =   +10 C, high =   +45 C)</para>
<para>TempRemot:   +30 C  (low  =   +10 C, high =   +40 C)</para>
<para>CPU_PWM:   255</para>
<para>Fan2_PWM:  255</para>
<para>Fan3_PWM:   77</para>
<para>vid:      +1.525 V  (VRM Version 9.0)</para>
<para/>
<para>Connection closed by foreign host.</para>
<para/>
<para/>
<para/></section><section><info><title>Установление необходимых программ</title></info>
<para/>
<para>Разархивируйте monitoring-*.tar.bz2.</para>
<para/>
<para>Для Gentoo есть ебилд, для установления программы monitoring со всеми зависимостями с сайта стоит брать monitoring-*.ebuild.tar.bz2 и распаковать его в /usr/local дальше выполните: </para>
<para># emerge -pv monitoring</para>
<para>[ebuild N ] net-analyzer/monitoring-0.11 USE="-admin -apache2 -lm_sensors -server"</para>
<para/>
<para>Для административной стороны необходимо добавить USE=admin, а для поддержки apache-2* USE=apache2 </para>
<para># export "USE=admin apache2"</para>
<para># emerge monitoring</para>
<para/>
<para>Компиляцию и установление rrdtool, apache, Net-Telnet в случае использования Gentoo можно пропускать, потому что эти пакеты уже будут установлены как зависимости, а переходить сразу к их настройке. </para>
<para/></section><section><info><title>Инсталляция rrdtool</title></info>
<para/>
<para>Базой данных, для хранения информации и инструмент генерации графиков, используется пакет rrdtool (round robin database tool). Зкачать пакет можно отсюда: http://rrdtool.eu.org или http://people.ee.ethz.ch/~oetiker/webtools/rrdtool/ Подробно ознакомиться с этим пакетом можно здесь: http://www.bog.pp.ru/work/rrdtool.html (Российская). В принципе, программа самостоятельно создаст необходимые базы так, что дополнительных знаний не нужно и следующий пункт Пример расчёта настройки базы RRD можно пропустить. </para>
<para/>
<para>Пример расчёта настройки базы RRD</para>
<para/>
<para>Расчёт настроек создания базы RRD файлы /etc/monitoring/*.rrd.cf Количество "слов" в файле будет соотведствовать количеству графиков в разных маштабах времени. например для расчёта подобия MRTG: 5-ти минутный - даные за последние 2 дня: х-доля=0.5 количество отсчётов на ячейку=1 количество ячеек=2*24*12=576 +min+max+avg+cur ~ 650 </para>
<para>0.5:1:650</para>
<para/>
<para>30-ти минутный - дание за последние две недели: х-доля=0.5 количество отсчётов на ячейку=30/5=6 количество ячеек=2*7*24*2=672 +min+max+avg+cur ~ 750 </para>
<para>0.5:6:750</para>
<para/>
<para>2-ух часовой - даные за последние два месяца: х-доля=0.5 количество отсчётов на ячейку=60*2/5=24 количество ячеек=2*31*24/2=744 +min+max+avg+cur ~ 850 </para>
<para>0.5:24:850</para>
<para/>
<para>1-но дневный - даные за последние два года: х-доля=0.5 количество отсчётов на ячейку=60*24/5=288 количество ячеек=2*366=732 +min+max+avg+cur ~ 900 </para>
<para>0.5:288:900</para>
<para/>
<para>Таким образом имеем: </para>
<para># cat /etc/monitoring/5min.rrd.cf</para>
<para>0.5:1:650        0.5:6:750        0.5:24:850        0.5:288:900</para>
<para/></section><section><info><title>Инсталляция Net-Telnet</title></info>
<para/>
<para>Данная версия программы для работы через сеть требует Net-Telnet perl модуль (можно при желании использовать и netcat): из-за этого нужно установить perl (что пожалуй уже сделано). Дальше Net-Telnet perl модуль берем и устанавливаем отсюда: http://cpan.perl.org/modules/by-module/Net/ название файлу Net-Telnet-*.tar.gz </para>
<para/></section><section><info><title>Инсталляция Apache</title></info>
<para/>
<para>Нужно установить и настроить apache сервер, дополнительно можете добавить (admin/etc/apache/monitoring.conf): </para>
<para># cat /etc/apache2/vhosts.d/monitoring.conf</para>
<para>### /etc/apache2/vhosts.d/monitoring.conf</para>
<para>### $Id: monitoring.conf,v 0.11 2006/09/28 16:27:12 hse Exp $</para>
<para>###</para>
<para>### For Monitoring *.shtml</para>
<para>AddType text/html .shtml</para>
<para>AddOutputFilter INCLUDES .shtml</para>
<para>### For authentication:</para>
<para>&lt;Directory "/var/www/localhost/htdocs/administration/monitoring"&gt;</para>
<para>   AllowOverride All</para>
<para>   Options Includes</para>
<para>   &lt;IfModule mod_access.c&gt;</para>
<para>### For password authentication:</para>
<para>#       AuthUserFile /var/www/localhost/htdocs/administration/passwd_file</para>
<para>#       AuthGroupFile /dev/null</para>
<para>#       AuthName Administrative-information</para>
<para>#       AuthType Basic</para>
<para>#       Require valid-user</para>
<para>### For host/network authentication:</para>
<para>        Order deny,allow</para>
<para>        Deny from all</para>
<para>        Allow from 127.0.0.1</para>
<para>#        Allow from .cluster.linux</para>
<para>    &lt;/IfModule&gt;</para>
<para>&lt;/Directory&gt;</para>
<para/>
<para>Добавляем пользователя для просмотра веб страницы: </para>
<para># htpasswd -bcm /var/www/localhost/htdocs/administration/passwd_file username password</para>
<para/>
<para>Если все хорошо идем дальше. </para>
<para/></section><section><info><title>Установка программ для мониторинга</title></info>
<para/>
<para>В файл admin/etc/host (/etc/monitoring/host) вносим перечень серверов, которые нужно мониторить (имена должны разрешаться в IP адреса). Коректируем под свои потребности файл admin/etc/monitoring.conf (/etc/monitoring/monitoring.conf) </para>
<para>путь по которому установлено скрипт:</para>
<para>installpath=/usr/</para>
<para>путь к веб страницы:</para>
<para>apachehtmldir=/var/www/html</para>
<para>webdirpath=/administration/monitoring</para>
<para>путь к файлу с перечнем серверов для мониторинга:</para>
<para>confpath=$installpath/etc/host</para>
<para>путь к временных файлов:</para>
<para>diskinfopath=/tmp/monitoring/disk.tmp</para>
<para>sarinfopath=/tmp/monitoring/sar.tmp</para>
<para>sensorsinfopath=/tmp/monitoring/sensors.tmp</para>
<para>путь где установлен пакет rrdtool:</para>
<para>rrdtoolpath=/usr/bin/rrdtool</para>
<para>почтовый адресов:</para>
<para>emailvalue=root@localhost</para>
<para>По желанию (или за потребностью) правим другие файлы с каталога etc/ (/etc/monitoring/):</para>
<para/>
<para>diskusage memusage quantity cpu memory systemload - содержимое файлов должно отвечать тем параметрам которые Вы хотите мониторить. Все параметры должны выводиться командой sar -A 1 1 |grep Average: Названия файлов отвечают названиям графиков и баз которые создадутся и должны быть записаны в файле system. Значение параметров принадлежащих одном файлу должны быть одного типа!</para>
<para/>
<para>system - первая колонка определяет какие графики получите и каждый ее элемент отвечать файлу из этого же каталога (см. выше). Вторая указывает через какие периоды времени база rrdtool будет принимать данные. Третья и четвертая колонка определяет минимальное и максимальное значение параметра которое еще может быть записано в базу. Пятая колонка определяет легенду (размерность).</para>
<para/>
<para>сolors - файл с номерами цветов в 16-ричной системе.</para>
<para> </para>
<para>config - содержит имена конфигурационных файлов из этого же каталога отвечающие веб страницам что создаються (можно добавлять свои, но тогда их должны создать!).</para>
<para/>
<para>disk - содержит названия графиков, периоды времени через которые база rrdtool будет принимать данные, минимальные и максимальные значение параметров которые мониторите, легенду (размерность).</para>
<para/>
<para>network - содержит названия графиков, периоды времени через которые база rrdtool будет принимать данные, минимальные и максимальные значение параметров которые мониторите, легенду (размерность).</para>
<para/>
<para>sensors - содержит названия графиков, периоды времени через которые база rrdtool будет принимать данные, минимальные и максимальные значение параметров которые мониторите, легенду (размерность).</para>
<para/>
<para>disk.rrd.cf network.rrd.cf sensors.rrd.cf system.rrd.cf - описывают структуру базы данных.</para>
<para/>
<para>disk.msg network.msg sensors.msg system.msg - содержит информацию которую получите почтой в критических ситуациях.</para>
<para/>
<para>Если хотите осуществить установку вручную, пропустите следующий пункт. </para>
<para/></section><section><info><title>Автоматическая установка программ</title></info>
<para/>
<para>Теперь можете воспользоваться скриптом для инсталляции. Для этого нужно откорректировать следующие строки в файле monitoringinstall.sh (/usr/sbin/monitoringinstall.sh) или пропустить этот пункт и следовать дальнейшей инструкции для установки в ручную. </para>
<para>имя пользователя и группы:</para>
<para>runuser=monitoring</para>
<para>rungroup=monitoring</para>
<para>директория где расположены cron настройки:</para>
<para>cronpath=/etc/cron.d</para>
<para>путь к инициализационному скрипту</para>
<para>crond crond=/etc/init.d/crond</para>
<para>директория где находятся настройки apache</para>
<para>apachconfdir=/etc/apache/conf</para>
<para>файл конфигурации apache:</para>
<para>apachconffile=apache.conf</para>
<para>путь к инициализационному скрипту apache</para>
<para>apached=/etc/init.d/apache</para>
<para/>
<para>Теперь с правами рута выполните (нужно подождать 1 минуту, если не установили мониторинг сети, и 10 минут после установки мониторынга сети на последнем сервере, прежде чем выполнять следующую команду): </para>
<para># ./monitoringinstall.sh --admin</para>
<para/>
<para>В Gentoo просто </para>
<para># monitoringinstall.sh --admin</para>
<para/>
<para>Если видите ошибки, наверное надо:</para>
<para>1 поправить файлы конфигурации в admin/etc/ (/etc/monitoring)</para>
<para>2 посмотреть в /home/monitoring/hostname/err/...</para>
<para>3 удалить файлы с /home/monitoring/hostname/ и перезапустити скрипт</para>
<para>4 удалить базы данных с /var/db/monitoring/... и перезапустити скрипт</para>
<para>5 bin/net_telnet.pl читает только 500 строк входа. Если в Вас больше, отредактируйте його:</para>
<para>line 32: while [$и ne 500]</para>
<para/>
<para>Тогда попробуйте еще, но добавьте имена сервисов, под рутом выполните: </para>
<para># ./monitoringinstall.sh --admin=disk</para>
<para># ./monitoringinstall.sh --admin=sensors</para>
<para># ./monitoringinstall.sh --admin=system</para>
<para># ./monitoringinstall.sh --admin=network</para>
<para/>
<para>Если где-то допустили ошибку, можно просто выполнить monitoringuninstall.sh и попытаться еще раз. Можете пропустить следующий пункт. </para>
<para/></section><section><info><title>Ручная установка программ</title></info>
<para/>
<para>Устанавливаем скрипти для мониторинга, генерации базы данных и веб страницы скопировав с каталога monitoring/admin в каталог: /usr/ ($INSTALL_PATH), используя опцию –p для сохранения прав. Выполняем: </para>
<para># cp -p admin/bin/* $INSTALL_PATH/bin/</para>
<para># mkdir /etc/monitoring</para>
<para># cp -p admin/etc/* /etc/monitoring/</para>
<para># mkdir $INSTALL_PATH/share/monitoring</para>
<para># cp -p admin/share/* $INSTALL_PATH/share/monitoring/</para>
<para/>
<para># mkdir -p /var/www/localhost/htdocs/administration/monitoring</para>
<para># chmod 755 /var/www/localhost/htdocs/administration/monitoring/</para>
<para># groupadd -g 1111 monitoring</para>
<para># useradd -u 1111 -g monitoring -d /home/monitoring -s /bin/bash -c monitoring monitoring</para>
<para># chmod -R 700 /home/monitoring</para>
<para># chown -R monitoring:monitoring /home/monitoring</para>
<para># chown -R monitoring:monitoring /var/www/localhost/htdocs/administration/monitoring/</para>
<para/>
<para>И тогда выполняйте (подождите 1 минуту, если не устанавливали мониторинг сети, и 10 минут после установки мониторынга сети на последнем сервере, прежде чем выполнять следующую команду): </para>
<para># su monitoring</para>
<para>$ $INSTALL_PATH/bin/net.vert.1.sh</para>
<para>$ $INSTALL_PATH/bin/net.vert.10.sh</para>
<para/>
<para>создаются базы данных в каталоге /var/db/monitoring/имя_сервера/ для всех серверов с файлу /etc/monitoring/host и дополнительная конфигурация в /home/monitoring</para>
<para>Выполняем: </para>
<para>$ $INSTALL_PATH/bin/png_graph.sh disk -1week 30min</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh disk -1month 2hour</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh disk -1year 1day</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh network -1week 30min</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh network -1month 2hour</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh network -1year 1day</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh sensors -2day 5min</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh sensors -1week 30min</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh sensors -1month 2hour</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh sensors -1year 1day</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh system -2day 5min</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh system -1week 30min</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh system -1month 2hour</para>
<para>$ $INSTALL_PATH/bin/png_graph.sh system -1year 1day</para>
<para/>
<para>Если видите ошибки, наверное нужно:</para>
<para>1 поправить файлы конфигурации в /etc/monitoring</para>
<para>2 посмотреть в /home/monitoring/hostname/err/...</para>
<para>3 удалить файлы с /home/monitoring/hostname/ и перезапустить скрипт</para>
<para>4 удалить базы данных с /var/db/monitoring/... и перезапустить скрипт</para>
<para>5 bin/net_telnet.pl читает только 500 строк входа. Если в Вас больше, отредактируйте его:</para>
<para>line 32: while [$и ne 500]</para>
<para/>
<para>Тогда попробуйте еще раз.</para>
<para/>
<para>В каталоге /var/www/localhost/htdocs/administration/monitoring создаются начальная страница и каталоги с веб страницами для каждого сервера.</para>
<para/>
<para>Если не возникло больше ошибок, используйте следующий файл для автоматизации всей работы с crond: </para>
<para>$ exit</para>
<para># cat /etc/cron.d/monitoring</para>
<para/>
<para>SHELL=/bin/bash</para>
<para>PATH=/bin:/usr/bin</para>
<para>MAILTO=root</para>
<para>HOME=/home/monitoring</para>
<para>LANG=POSIX</para>
<para/>
<para># Begin server part (may be you wont monitoring "admin" computer too)</para>
<para>*/1 * * * * monitoring /usr/bin/show_sar.sh</para>
<para>*/10 * * * * monitoring /usr/bin/show_iptables.sh        #GNU/Linux</para>
<para>#*/10 * * * * monitoring /usr/bin/show_ipfw.sh                #BSD</para>
<para># End server part</para>
<para/>
<para># Begin disk admin part</para>
<para>*/30 * * * * monitoring /usr/bin/png_graph.sh hdisk -1week 30min</para>
<para>0 */2 * * * monitoring /usr/bin/png_graph.sh hdisk -1month 2hour</para>
<para>0 0 * * * monitoring /usr/bin/png_graph.sh hdisk -1year 1day</para>
<para># End  disk admin part</para>
<para/>
<para># Begin network admin part</para>
<para>*/30 * * * * monitoring /usr/bin/png_graph.sh network -1week 30min</para>
<para>0 */2 * * * monitoring /usr/bin/png_graph.sh network -1month 2hour</para>
<para>0 0 * * * monitoring /usr/bin/png_graph.sh network -1year 1day</para>
<para># End  network admin part</para>
<para/>
<para># Begin system admin part</para>
<para>*/5 * * * * monitoring /usr/bin/png_graph.sh system -2day 5min</para>
<para>*/30 * * * * monitoring /usr/bin/png_graph.sh system -1week 30min</para>
<para>0 */2 * * * monitoring /usr/bin/png_graph.sh system -1month 2hour</para>
<para>0 0 * * * monitoring /usr/bin/png_graph.sh system -1year 1day</para>
<para># End system admin part</para>
<para/>
<para># Begin sensors admin part</para>
<para>*/5 * * * * monitoring /usr/bin/png_graph.sh sensors -2day 5min</para>
<para>*/30 * * * * monitoring /usr/bin/png_graph.sh sensors -1week 30min</para>
<para>0 */2 * * * monitoring /usr/bin/png_graph.sh sensors -1month 2hour</para>
<para>0 0 * * * monitoring /usr/bin/png_graph.sh sensors -1year 1day</para>
<para># End sensors admin part</para>
<para/>
<para># Begin vert admin part</para>
<para>*/1 * * * * monitoring /usr/bin/net.vert.1.sh</para>
<para>*/10 * * * * monitoring /usr/bin/net.vert.10.sh</para>
<para># End  vert admin part</para>
<para/>
<para>Выполняем: </para>
<para># /etc/init.d/crond restart</para>
<para/>
<para/>
<para/>
<para>Если все хорошо</para>
<para/>
<para>Теперь заходим Вашим любимым браузером на страницу http://servername/administration/monitoring/index.html. Здесь уже можем выбрать ссылки на сервер, который вас интересует :) </para>
<para/></section><section><info><title>Добавление новых серверов</title></info>
<para/>
<para>Если Вам когда-то придется добавить новый сервер, достаточно будет сделать следующее:</para>
<para>1. Выполнить для него пункт 2 („Серверная” сторона)</para>
<para>2. Добавить его имя в файл /etc/monitoring/host</para>
<para>Всё остальное создастся само !!! Наслаждайтесь :))) </para>
<para/></section><section><info><title>Альтернативы</title></info>
<para/>
<para>Если Вы недовольны реализацией мониторинга таким образом (по моему мнению достаточно неплохое решение ;)) подберите себе лучшую. Вот некоторый перечень альтернатив или дополнений :=) </para>
<para>Angel Network Monitor http://www.paganini.net/angel/ </para>
<para>Autostatus http://www.angio.net/consult/autostatus/ </para>
<para>Cacti http://cacti.net </para>
<para>HiWAyS http://www.hiways.org/ </para>
<para>MARS http://www.altara.org/mars.html </para>
<para>Mon http://www.kernel.org/software/mon/ </para>
<para>Monit http://www.tildeslash.com/monit/ </para>
<para>Nagios http://www.nagios.org </para>
<para>Netup (French) http://www.pasteur.fr/units/sis/netup/ </para>
<para>NocMonitor http://www2.discpro.org/nocmon/ </para>
<para>NodeWatch http://www.skendric.com/nodewatch/ </para>
<para>Penemo http://www.communityprojects.org/apps/penemo/ </para>
<para>PIKT http://pikt.org/ </para>
<para>RITW http://www.terravista.pt/Ancora/1883/ritw_e.html </para>
<para>RRDWorld http://oss.oetiker.ch/rrdtool/rrdworld/index.en.html </para>
<para>Scotty http://wwwhome.cs.utwente.nl/~schoenw/scotty/ </para>
<para>Spong http://spong.sourceforge.net/ </para>
<para>Sysmon http://www.sysmon.org/ </para>
<para>ZABBIX http://www.zabbix.com </para>
<para>ZEUS http://www.zeus.com/ </para>
<para/></section></section></section><section><info><title>Настройка X</title></info>
<para/><section><info><title>Настройка русских шрифтов в X</title></info>
<para/><section><info><title>Введение </title></info>
<para/>
<para>Введение временное </para>
<para/>
<para>Ну вот и начался этот проект, призванный восполнить достаточно широкий пробел в документации по настройке шрифтов в Иксах. Надеюсь многочисленные русские пользователи проявят некую сознательность и отпишут сюда пару строчек. </para>
<para/>
<para>Кто принимает участие </para>
<para>Macil - линуксоид из Ярославля. Обитает на yar.lancktelecom.ru/talk, forum.median.ru, а также Macil [at] jabber.ru </para>
<para>Wanderer - пользователь Linux из Москвы. Всерьез занимаюсь изучением и использоваением Linux последние 4 года, до этого просто приглядывался ;-). На Gentoo пересел почти год назад и ничуть не жалею и даже наоборот, очень этим доволен. Связаться со мной можно посредством e-mail (wanderer_mg [at] mail.ru) или jabber (wanderer [at] jabber.ru). </para>
<para/>
</section>
    <section>
        <info><title>Две системы рисования шрифтов </title></info>
   
<para>Исторически в X Window System существует 2 системы рисования шрифтов. Родная (core) и Xft. </para>
<para>Родная система – прямой потомок системы рисования шрифтов, введенной в X11R1, выпущенной в 1987 году. Изначально она могла рисовать только монохромные растровые шрифты, но на протяжении всех этих лет предпринимались более-менее успешные попытки заставить ее работать с векторными шрифтами. </para>
<para>Xft не является неотъемлемой частью X, хотя возможно будет ей в будущем. Это значит, что она распространяется не со всеми реализациями X. Она проектировалась для работы с векторными шрифтами, и делает это достаточно эффективно. В отличие от родной системы рисования, Xft поддерживает anti-aliasing и sub-pixel rasterisation. Кроме того, она позволяет приложениям полностью контролировать то, как будут рисоваться шрифты, обеспечивая возможность создания WYSIWYG приложений. </para>
<para/>
<para>Нужно ли уточнять что эти две подсистемы совершенно не совместимы на уровне API? Из-за достаточно анархичного развития X в последнее время, возникла большая путаница в определениях и версиях используемых библиотек. </para>
<para/>
<para>//Источник: вольный перевод файла README.fonts </para>
<para/></section><section><info><title>Хft </title></info>
<para/>
<para>Введение в Xft </para>
<para/>
<para>Xft это библиотека, которая предоставляет клиентский API для рисования шрифтов. В настоящее время версия Xft 2.0 использует библиотеки fontconfig и freetype для выбора шрифтов и их рисования, соответственно. Xft 1.0 использовала внутренний механизм конфигурации, что было не очень хорошей идеей так как KDE и Pango "заимствовали" механизм конфигурации шрифтов и создали еще большую путаницу. Подробности можно посмотреть [здесь]. </para>
<para/>
<para>Нужно запомнить 3 вещи: </para>
<para>fontconfig - для конфигурации </para>
<para>freetype - для рисования </para>
<para>XFT - связывает все во едино </para>
<para/>
<para>Freetype - библиотека рисования шрифтов </para>
<para/>
<para>[Freetype] - совершенно независимый от кого-либо проект по созданию библиотеки рисования шрифтов. Библиотека предоставляет достаточно простой API, но поскольку обычные приложения заинтересованы в более высокоуровневых сервисах, в чистом виде не используется. Вместе с X идет модифицированная freetype, предназначенная для поддержки векторных шрифтов родной системой рисования. Я не вижу смысла даже пытаться ее компилировать (она компилируется в модуль freetype), так как большинство приложений перешли на использование Xft и путанице со шрифтами приходит конец. Рендеринг векторных шрифтов очень сложный процесс, и к сожалению, freetype не может его выполнять до конца и в некоторых шрифтах появляются не очень приятные артефакты. Но ничего лучшего (открытого и бесплатного) пока нет... Как обычно, существует 2 версии freetype: freetype1 и freetype2. Отличия их в том, что freetype1 может рисовать тоько шрифты формата TrueType. Сложно найти современный дистрибутив, где отсутствует freetype2. </para>
<para/></section><section><info><title>Теория рендеринга векторных шрифтов </title></info>
<para/>
<para>Что такое hinting </para>
<para/>
<para>На английском много информации о hinting можно найти тут http://www.myfonts.com/activity/hinting/ </para>
<para/>
<para>Не уверен, однако, что можно тут публиковать такие ссылки. </para>
<para>Это — незавершённая статья. Вы можете помочь проекту, исправив и дополнив материал.</para>
<para/>
<para>Что такое anti-aliasing </para>
<para/>
<para>Это методы избавления от артефактов, возникающих при отрисовке векторного изображения в растовое. Когда вектороное изображение (не дискретное, к примеру, формула y=2*x) отрисовывается в растовое, то в результате погрешностей и того, что цвет каждого пискселя строго зависит от формулы, возникают артефакты. То есть наклонную линию мы будем видеть ступенчато, а не плавно. Методы anti-aliasing, в основном, базируются на отрисовке изображения в большее разрешение и приведение к обычному путём билинейной фильтрации, т.е. цвет пикселя будет строиться из цветов нескольких пикселей большого изображения. Шрифты после применения anti-aliasing выглядят более гладко, т.к. более точно соответствуют "векторной формуле". </para>
<para>Это — незавершённая статья. Вы можете помочь проекту, исправив и дополнив материал.</para>
<para/>
<para>Шрифты из Microsoft Windows </para>
<para/>
<para/>
<para>Установка шрифтов Microsoft Windows имея доступ в интернет </para>
<para/>
<para>Если есть доступ к интернету, то можно просто установить пакет corefonts: emerge corefonts </para>
<para/></section><section><info><title>Настройка родной подсистемы </title></info>
<para/>
<para>Настройка Xft </para>
<para/>
<para>Все настройки Xft хранятся в файлах /etc/fonts/fonts.conf и /etc/fonts/local.conf. Все изменения нужно производить в файле /etc/fonts/local.conf. Изменение файла /etc/fonts/fonts.conf не рекомендуется, т.к. при обновлении пакета fontconfig он будет перезаписан и все настройки потеряны. </para>
<para/>
<para>Отключение сглаживания для шрифтов меньше определенного размера </para>
<para/>
<para>По умолчанию сглаживание действует для всех шрифтов, но для шрифтов маленького размера его лучше отключить, т.к. смотрится это почти всегда плохо. </para>
<para/>
<para>Ниже приведен пример конфига /etc/fonts/local.conf, в котором указана отмена сглаживания для шрифтов, размер которых меньше 14. Code: /etc/fonts/local.conf </para>
<para>&lt;?xml version="1.0"?&gt;</para>
<para>&lt;!DOCTYPE fontconfig SYSTEM "fonts.dtd"&gt;</para>
<para>&lt;!-- /etc/fonts/local.conf file for local customizations --&gt;</para>
<para>&lt;fontconfig&gt;</para>
<para/>
<para>&lt;!--  Enable sub-pixel rendering  --&gt;</para>
<para/>
<para>        &lt;match target="font"&gt;</para>
<para>                &lt;edit name="rgba" mode="assign"&gt;&lt;const&gt;rgb&lt;/const&gt;&lt;/edit&gt;</para>
<para>        &lt;/match&gt;</para>
<para>        &lt;match target="font"&gt;</para>
<para>            &lt;test name="size" compare="less_eq"&gt;</para>
<para>                &lt;double&gt;14&lt;/double&gt;</para>
<para>            &lt;/test&gt;</para>
<para>            &lt;edit name="antialias" mode="assign"&gt;</para>
<para>                &lt;bool&gt;false&lt;/bool&gt;</para>
<para>            &lt;/edit&gt;</para>
<para>        &lt;/match&gt;</para>
<para>        &lt;match target="font"&gt;</para>
<para>            &lt;test name="pixelsize" compare="less_eq"&gt;</para>
<para>                &lt;double&gt;14&lt;/double&gt;</para>
<para>            &lt;/test&gt;</para>
<para>            &lt;edit name="antialias" mode="assign"&gt;</para>
<para>                &lt;bool&gt;false&lt;/bool&gt;</para>
<para>            &lt;/edit&gt;</para>
<para>        &lt;/match&gt;</para>
<para/>
<para>&lt;/fontconfig&gt;</para>
<para/></section><section><info><title>Настройка Qt и Gtk </title></info>
<para/>
<para>Для Qt</para>
<para>emerge qt qtconfig </para>
<para/>
<para>Для Gtk</para>
<para>emerge gtk-theme-switch switch2 </para>
<para/>
<para/></section></section><section><info><title>Настройка размера шрифтов в X</title></info>
<para/><section><info><title>Введение </title></info>
<para>Столкнулся с проблемой (и не я один) размера шрифтов. </para>
<para/>
<para>Процесс сталкивания выглядел так: </para>
<para>~ $ emerge xorg-x11</para>
<para>...</para>
<para>~ $ emerge kde</para>
<para>...</para>
<para>startx</para>
<para/>
<para>Попал я, естессна сразу в KDE. И увидел очень мелкие шрифты, очень мелкие, похожие на точечки. Примерно такие:</para>
<para>Естессна, первое, что я сделал - полез в центр управления и установил размер, соответствующий моему зрению. Им оказался 40. Немало. Тогда я понял, что что-то неправильно. Порылся в инете, не нашел ничего. Смирился. Однако вскоре узнал, что та же проблема у меня и в KDM, только там изменить размер немного сложнее. Изменил. Но проблему это не решило, потому что нашлись еще всякие шибко умные проги, которые пользовались собственными настройками шрифтов. Их (настройки) искать оказалось очень сложно и пришлось брать быка за рога. Итак, </para></section><section><info><title>Суть проблемы </title></info>
<para/>
<para>Она состоит в том, что шрифты ориентированы на определенное физическое разрешение экрана - dpi (точек на дюйм). В винде по дефолту оно идет равным 96. X11 решил, что это слишком сложно не знаю для кого и, как выяснилось позже, выставил себе аж целых 25 dots per inch. В переводе в метрическую систему это около 1 точки на миллиметр. Соответсвенно, экран разрешением 1024х768 должен быть шириной в метр, высотой 77 см, чтоб читалось все как надо. Ну а поскольку реально экран у нас меньше, мы видели то, что мы видели. </para>
<para/></section><section><info><title>Неправильный ход мысли </title></info>
<para/>
<para>но полезный совет. Увеличть размер шрифта для KDM можно в этом файле: </para>
<para>/usr/kde/3.5/share/config/kdm/kdmrc</para>
<para>Но это не выход, как я уже говорил. Кстати, GDM настраивается в другом файле, его я не знаю, потому что пришел к следующему пункту: </para>
<para/></section><section><info><title>Правильный ход мысли </title></info>
<para>Надо изменить разрешение, те самые dpi. Где? Как? </para>
<para/>
<para>Меняем dpi </para>
<para/>
<para>Тут, кстати, возможны варианты. Если Вы запускаете иксы из консоли по мере необходимости командой startx, то Вам сюда. Если иксы стартуют сами при загрузке системы - то сюда. В идеале стоит проделать оба варианта. </para>
<para/>
<para>Для команды startx </para>
<para/>
<para>Лезем туда, где этот стартикс лежит и правим его </para>
<para>~ $ find /usr -name startx</para>
<para/>
<para>У меня он оказался в /usr/bin, и с вероятностью 99,(9)% там же он будет и у Вас. </para>
<para>Вписать в него надо всего ничего параметр -dpi 96 в ключ defaultserverargs </para>
<para>defaultserverargs="-dpi 96"</para>
<para/>
<para>Те параметры, которые там есть не удаляйте, у них свое назначение, этот просто допишите к ним.</para>
<para>В принципе, на этом все. Можно </para>
<para>~ $ startx</para>
<para/>
<para>Жизнь удалась. </para>
<para/>
<para>Для пользователей KDM, XDM и тому подобного </para>
<para/>
<para>Вооружитесь калькулятором. В файле xorg.conf Вам надо изменить параметр DisplaySize. По умолчанию, он устанавливается равным разрешению (помните, я говорил в начале статьи), но ваш-то монитор меньше. Можно померять линейкой, можно посчитать, какие значения ему присвоить: </para>
<para>X = x * 25,4 / dpi</para>
<para>Y = y * 25,4 / dpi</para>
<para>где X, Y - значения, которые надо присвоить DisplaySize </para>
<para>x, y - разрешение монитора (x - ширина, y - высота) </para>
<para>dpi - то физическое разрешение, которое должно получиться </para>
<para/>
<para>У меня при разрешении 1024x768 получилось так: </para>
<para>~ $ vi /etc/X11/xorg.conf</para>
<para/>
<para>Section "Monitor"</para>
<para>       Identifier   "Monitor0"</para>
<para>       VendorName   "HSD"</para>
<para>       ModelName    "HSD150PX17-A"</para>
<para>       DisplaySize  270.9 203.2 # mm</para>
<para>EndSection</para>
<para/>
<para>Вывод </para>
<para>Ерунда какая, ничего сложного, если сразу заглянуть в xorg.conf и почитать комментарии, то этого можно избежать. Но я не избежал и, кстати, долго с этим мучился. </para>
<para/>
<para>Вывод-то в чем: будьте внимательнее! </para>
<para/>
<para>P.S. </para>
<para>В Gnome есть такая настроечка, как dpi, сам не видел, но знающие люди говорят, что есть и рекомендуют ее тоже выставить на 96 или то, которое принято везде.</para>
<para/>
<para/></section></section><section><info><title>Xorg X11 и прозрачность</title></info>
<para/><section><info><title>Введение</title></info>
<para/>
<para>Это руководство поможет в установке X.org на Linux/Gentoo машине, хотя общие настройки должны работать и на любом другом дистрибутиве. </para>
<para/>
<para>Шаг за шагом</para>
<para/></section><section><info><title>Установка X.org</title></info>
<para/>
<para>Установите последнюю версию X.org с помощью команды emerge xorg-x11 </para>
<para/>
<para>После компиляции необходимо настроить X.org путем редактирования /etc/X11/xorg.conf </para>
<para>Если у вас было установленно XFree86 то рабочий /etc/X11/XF86Config будет автоматически использоватся для работы X.org. Для обеспечения целостности рекомендуется переименовать /etc/X11/XF86Config в /etc/X11/xorg.conf. </para>
<para/>
<para>Для загрузки X.org выполните команду startx </para>
<para/></section><section><info><title>Установка X Composite Extension</title></info>
<para/>
<para>Откройте /etc/X11/xorg.conf для редактирования nano -w /etc/X11/xorg.conf пользуйте ваш любимый редактор ;) </para>
<para/>
<para>Добавьте следующие строки в любом месте конфиг файла Файл: /etc/X11/xorg.conf </para>
<para>Section "Extensions"</para>
<para>    Option "Composite" "Enable"</para>
<para>    Option "RENDER" "Enable"</para>
<para>EndSection</para>
<para/>
<para>При следующей перезагрузке X.org у вас будет включен Composite Extension. Это расширение включает предварительную отрисовку вне экрана, чтобы на экран выводилось уже законченное изображение. Это позволяет использовать различные эффекты (например прозарчность и тени). </para>
<para/>
<para>Для достоверности можно проверить лог файл grep COMPOSITE /var/log/Xorg.0.log </para>
<para>(II) Initializing built-in extension COMPOSITE</para>
<para/>
<para>Включение теней и настоящей прозрачности</para>
<para/></section><section><info><title>KDE 3.4 или более поздняя</title></info>
<para/>
<para>Начиная с версии 3.4 KDE поддерживает прозрачность через Xorg. На заголовке любого окна щелкните правой кнопкой мыши, выбирите "настройка поведения окна" и в списке слева надите пункт полупрозрачность. Поставьте флажок "использовать прозрачность/тени", после чего станут доступны множество настроек прозрачности (активного,неактивного окна, окна при перетаскивании, плавные переходы прозрачности и т.д.) и теней. </para>
<para/>
<para>xcompmgr и transset</para>
<para/>
<para>Многие WM еще не обладают поддержкой новых функций X.org, так что нам придется использовать дополнительные инструменты для наших эффектов. </para>
<para>Вначале нам надо установить xcompmgr </para>
<para/>
<para>echo "x11-misc/xcompmgr ~x86" &gt;&gt; /etc/portage/package.keywords </para>
<para/>
<para>emerge xcompmgr </para>
<para>Затем установим transset </para>
<para/>
<para>echo "x11-misc/transset ~x86" &gt;&gt; /etc/portage/package.keywords </para>
<para/>
<para>emerge transset </para>
<para/>
<para>Теперь у нас есть все необходимое, чтобы включить тени, затенение и настоящую прозрачность. Запустите из Xterm xcompmgr xcompmgr -c Эта команда позволит вам увидеть эффекты от запущенного xcompmgr, если они вам не понравятся, то CTRL+C в консоли позволит вам убить процесс, а если они вам нравятся, то надо убить процесс и запустить его в фоновом режиме (сзади консоли): xcompmgr -c &amp; Примечание: символ &amp; позволяет запустить xcompmgr в фоновом режиме, но при этом если убить сам терминал - процесс тоже сдохнет, чтобы этого не произошло можно использовать утилиту nohup: nohup xcompmgr -c &amp; При этом весь вывод будет направлен в nohup.out </para>
<para/>
<para>Таким образом xcompmgr включит "мягкие" тени. Если будет использован флаг -s то будут "грубые" тени. </para>
<para/>
<para>Рабочий пример для xcompmgr с тенью и затенением xcompmgr -cCfF -r7 -o.65 -l-10 -t-8 -D7 &amp; </para>
<para/>
<para>Теперь о прозрачности. Выполните в консоли transset Теперь ваш курсор изменился, вы можете кликнуть на окне которое хотите сделать прозрачным. Если запустить transset с цифровым значением от 0 до 1 то это укажет насколько прозрачным должно быть окно </para>
<para>0 - полностью прозрачно </para>
<para>1 - не прозрачно </para>
<para/>
<para>Попробуйте выполнить transset 0.2 </para>
<para/>
<para>Для возвращения окна назад просто выполните transset и кликните по прозрачному окну. </para>
<para/>
<para>Как это выглядит</para>
<para/>
<para>Изображение взято на http://www.grebowiec.net/archives/xorg4.html </para>
<para/>
<para> </para>
<para/>
<para>Выключение эффектов</para>
<para/>
<para>Для выключения всех эффектов выполните killall xcompmgr </para>
<para/>
<para>Примечание</para>
<para/>
<para>NVIDIA</para>
<para/>
<para>При использовании NVIDIA видео карточек рекомендуется добавить в /etc/X11/xorg.conf нижеприведенные строки для того, чтобы можно было использовать расширение "Composite" и увеличить производительность при его использовании. Файл: /etc/X11/xorg.conf </para>
<para/>
<para>Section "Device"</para>
<para>...</para>
<para>Option "RenderAccel" "true"</para>
<para>Option "AllowGLXWithComposite" "true"</para>
<para>...</para>
<para>EndSection </para>
<para/>
<para>ВАЖНО: При использовании RenderAccel у вас могут возникнуть проблемы со стабильностью, так как эта опция экспериментальная и использовать ее вам предлагается на свой страх и риск.</para>
<para>При использовании AllowGLXWithComposite у вас могут возникнуть проблемы с opengl приложениями. Могут появляться артефакты, так как glx и composite не рекомендуется использовать одновременно. </para>
<para/>
<para>ATI </para>
<para/>
<para>При использовании ATI видео карточек совместно с ATI драйверами, дополните /etc/X11/xorg.conf опцией backingstore, для включения поддержки backing store, механизма с помощью которого пиксельные данные закрытого окна запоминаются Х сервером и снимает необходимость посылки сообщений к Х клиенту когда надо обновить изображение Файл: /etc/X11/xorg.conf </para>
<para/>
<para>Section "Device"</para>
<para>...</para>
<para>Option "backingstore" "true"</para>
<para>...</para>
<para>EndSection </para>
<para/>
<para/></section><section><info><title>Заключение</title></info>
<para/>
<para>Эти разработки находятся в самой начальной стадии и мы можем использовать их уже в X.org версии 6.8. По мере развития WM и приложений будет возможность воспользоваться новым функционалом X.org в полную меру без установки дополнительных приложений. Некоторые программы, kwin к примеру, уже портируются.</para>
<para/></section></section><section><info><title>Xorg. Переключение раскладок</title></info>
<para>Переключение USA/RUS + Scroll Lock Led </para>
<para/>
<para>В секции InputDevice для клавиатуры надо дописать следующее: </para>
<para>Section "InputDevice"</para>
<para>   Identifier        "Keyboard1"</para>
<para>   Driver        "kbd"</para>
<para>   Option        "AutoRepeat"        "500 30"</para>
<para>   Option "XkbModel"        "pc105"</para>
<para>   Option "XkbLayout"        "us,ru(winkeys)"</para>
<para>   Option "XkbOptions"        "grp:alt_shift_toggle, grp_led:scroll"</para>
<para>EndSection</para>
<para/>
<para>Раскладки будут переключаться по Alt+Shift, с индикацией на Scroll Lock Led </para>
<para/>
<para>Если, конечно, не забыть, что в Section "ServerLayout" должно быть прописано InputDevice "Keyboard1". По умолчанию там как раз Keyboard0, так что будьте внимательны. </para>
<para/>
<para>а если вы захотите что-бы CTRL-C CTRL-V работали во всех раскладках так-же четко как в микрософт виндовс - то этого увы вам никто не расскажет :) - надо править запутанные конфиги xkb </para>
<para/>
<para>Возможно, вариант русской раскладки winkeys у вас не заработает. Тогда измените следующую строку: </para>
<para>   Option "XkbLayout" "us,ru"</para>
<para/>
<para>и добавьте </para>
<para>   Option "XkbVariant" ",winkeys"</para>
<para/>
<para>Обратите внимание на запятую, она указывает на то, что вариант "winkeys" применяется именно к русской раскладке!</para>
<para/></section><section><info><title>Установка Xgl</title></info><section><info><title>Введение</title></info>
<para/>
<para>Проект Xgl позволяет ускорять посредством подсистемы OpenGL вывод примитивов X сервера, а также обеспечивать ускорение composite и render. На данный момент мы можем получить быструю работу с прозрачностью, тенью и отрисовкой окон. </para>
<para/>
<para>Более подробное руководство на английском языке рамещено по адресу en:HOWTO XGL </para>
<para/></section><section><info><title>Инсталяция</title></info>
<para/>
<para>Xorg</para>
<para/>
<para>Нам понадобится последняя версия Xorg. Необходимо размаскировать нужные пакеты и установить Xorg-7.0emerge xorg-x11 Примечание: Дополнительно можно почитать статью Настройка Portage </para>
<para/>
<para/>
<para>glitz</para>
<para/>
<para>Так же необходимо скачать из CVS последнюю версию glitz. cvs -d:pserver:anoncvs@cvs.freedesktop.org:/cvs/cairo co glitz Установить ее.autogen.sh &amp;&amp; ./configure --prefix=/usr/ &amp;&amp; make &amp;&amp; make install </para>
<para/>
<para>glxcompmgr</para>
<para/>
<para>Для работы с расширением composite скачаем утилиту glxcompmgr cvs -d :pserver:anoncvs@cvs.freedesktop.org:/cvs/xorg co app/glxcompmgr Скомпилируем и установимautogen.sh &amp;&amp; ./configure --prefix=/usr/ &amp;&amp; make &amp;&amp; make install </para>
<para/>
<para>metacity</para>
<para/>
<para>Так уж сложилось, что пока glxcompmgr может себя показать во всей красе только с оконным менеджером metacity, да, он способен работать и с kwin, но при этом запуск kdesktop вызовет прекращение нормальной работы glxcompmgr. metacity </para>
<para/>
<para>MesaLib</para>
<para/>
<para>Если мы хотим использовать composite, необходимо собрать библиотеку libGL.so.1.2 из пакета MesaLib-6.4.1 с патчем mesa-glx-x11-render-texture-3.diff, который лежит в каталоге glxcompmgr.patch -p0 &lt;mesa-glx-x11-render-texture-3.diff &amp;&amp; ./configure --prefix=/usr/ &amp;&amp; make Нет необходимости переустанавливать весь пакет т.к. нас интересует только файл ./lib/libGL.so.1.2. Заменим старый файл.cp ./lib/libGL.so.1.2 /usr/lib/opengl/xorg-x11/lib/ </para>
<para/>
<para>Xgl</para>
<para/>
<para>Теперь скачаем. cvs -d:pserver:anoncvs@cvs.freedesktop.org:/cvs/xorg login </para>
<para>CVS password: нажмите Enter </para>
<para>cvs -d:pserver:anoncvs@cvs.freedesktop.org:/cvs/xorg co -r xgl-0-0-1 xserver </para>
<para>Код находится в ./hw/xql </para>
<para>И установим сам Xgl сервер. ./configure --prefix=/usr/ --enable-xglserver --enable-glx --enable-xkb &amp;&amp; make &amp;&amp; make install </para>
<para/></section><section><info><title>Запуск сервера для видеокарт nvidia</title></info>
<para/>
<para>"Голый" сервер</para>
<para/>
<para>Убедимся, что мы используем libGL.so.1.2 от nvidiaeselect opengl set nvidia Для запуска сервера в отдельном окне откройте свой любимый терминал и выполните командуXgl :1 -ac -accel xv -accel glx:pbuffer -screen 800x600 &amp; Если сервер не запускается, то, возможно, необходимо отключить расширение xkb, добавив опцию -kb Xgl :1 -kb -ac -accel xv -accel glx:pbuffer -screen 800x600 &amp; Также могут возникнуть проблемы с шрифтами, тогда путь к ним надо указать вручную Xgl :1 -kb -ac -accel xv -accel glx:pbuffer -fp /usr/share/fonts/misc/ -screen 800x600 &amp; Для запуска сервера в полноэкранном режиме можно использовать опцию -fullscreenXgl :1 -kb -ac -accel xv -accel glx:pbuffer -fp /usr/share/fonts/misc/ -fullscreen &amp; </para>
<para/>
<para>Для запуска на ATI картах с установленными драйверами fglrx необходимо вместо ... -accel xv... Использовать ... -accel xv:pbuffer... </para>
<para/>
<para>Запускаем glxcompmgr</para>
<para/>
<para>Сначала для примера запустим xterm и metacity из терминала. export DISPLAY=:1xterm &amp;metacity &amp; После этого необходимо переключиться на использование библиотеки libGL.so.1.2 из пакета MesaLibeselect opengl set xorg-x11 После этого можно запускать glxcompmgr.glxcompmgr shadow wobbly &amp; После этого уже должен быть виден интересный эффект на запущеном xterm'е. </para>
<para/>
<para>KDE, GNOME</para>
<para/>
<para>Для запуска kde или Gnome необходимо запустить сначало metacity затем kde(Gnome) и в последнюю очередь glxcompmgr. </para>
<para/>
<para>Возможные проблемы</para>
<para/>
<para>Возможно у вас не получится запустить сервер т.к. файл /usr/lib/libGL.so.1 будет указывать не на /usr/lib/opengl/nvidia/lib/libGL.so.1.2, а на /usr/lib/libnvidia-tls.so.1. Поменяйте симлинк и сервер запустится.</para>
<para>Для переключения раскладки подойдет программа xruskb.</para>
<para/></section></section><section><info><title>XGL</title></info><section><info><title>Введение </title></info>
<para/>
<para>Xgl это X сервер, который использует OpenGL для прорисовки обьектов. Вместе с композитным оконным менеджерами Compiz или новой версией Metacity позволяет получить превосходное качество 3D и 2D эффектов рабочего стола. Xgl базируется на расширении Mesa, GLX_EXT_texture_from_pixmap, который представлен только в версиях Mesa 6.5 и старше. </para>
<para/>
<para>На the XOrg mailing list предлагается написать спецификацию GLX_EXT_texture_from_pixmap расширения совместно с NVIDIA. Бета версия драйверов уже выпущеных NVIDIA, версия 9625, поддерживают это расширение, это означает что Xgl уже не нуждается в использовании Compiz на NVIDIA картах, кроме этого использование данной конфигурации приветствуется. Для информации об этом методе использования Xgl, пожалуйста ознакомтесь на en:HOWTO nVidia GL Desktop Effects </para>
<para/>
<para>Кроме того, Compiz тесно связан с GNOME-компонентами, Xgl и Compiz работают прекрасно во всех окружениях рабочих столов (KDE/GNOME/Xfce/*box). Если Вы всё же не используете GNOME, будте готовы к установке необходимых библиотек и утилит. </para>
<para>Предупреждение: Данное программное обеспечение ещё не является стабильным, и хотя оно почти всегда работает, всё же используйте его с осторожностью. </para>
<para/></section><section><info><title>Системные требования</title></info>
<para/>
<para>см. the article on video card support under Xgl. </para>
<para/>
<para>Установка Xgl Примечание: Установка должна быть произвадена на системе с работающей X сессией используя эмулятор терминала типа konsole или gterm, выполнение этого условия необходимо для запуска gconf-editor или gset-compiz для конфигурации Compiz в конце установки. </para></section><section><info><title>Требования к програмному обеспечению</title></info>
<para/>
<para>Обновите Ваше локальное дерево портажей. </para>
<para/>
<para>emerge --sync </para>
<para/>
<para>Вам необходима модульная версия XOrg (версия 7.x). Для установки модульной версии XOrg ознакомтесь с официальной Gentoo документацией или соответствующей статьёй wiki. </para>
<para>en:HOWTO Modular Xorg </para>
<para/></section><section><info><title>Официальное руководство </title></info>
<para/>
<para>Модульный XOrg (версия 7.x) был опубликован в стабильнй ветке дерева портажей, поэтому Вы можете пропустить эту главу если Ваш Gentoo полностью обновлен. </para>
<para/>
<para>Compiz использует рабочую оболочку GNOME GConf для конфигурации, и некоторые из опций конфигурации будут приведены здесь. Наиболее легким и популярным способом конфигурации является программа gconf-editor, одна из приложений GNOME. Конечно, и менее известная KDE программа KConfigEditor также может использоваться для конфигурации. Правда для этой программы пока не существует ebuild файла, но Вы можете загрузить исходный код этой программы с extragear.kde.org. Пожалуй самый нежелательный из способов это редактирование gconf конфигурационных файлов вручную, что является скучным и неблагодарным занятием. </para>
<para/>
<para>Если Вы хотите использовать gconf-editor, то его необходимо установить. </para>
<para/>
<para>emerge -nav gconf-editor </para>
<para/>
<para>Также Вам необходимо установить Subversion с включенной поддержкой webdav. Вы должны отключить флаг nowebdav. Добавте добавте при необходимости следующую строку в /etc/portage/package.use: Примечание: Тут используется двойное отрицание в использовании USE флага. </para>
<para/>
<para>echo "dev-util/subversion -nowebdav" &gt;&gt; /etc/portage/package.use </para>
<para>затем, </para>
<para>emerge -nav subversion </para>
<para/></section><section><info><title>Загрузка Portage оверлея</title></info>
<para/>
<para>Существуют два метода для создания требуемого оверлея; оверлей можно загрузить используя svn утилиту или использовать layman утилиту которая будет управлять оверлеями вместо Вас. Используя layman производить обновление системы проще, так что решать Вам. Вне зависимости, что Вы будете использовать результат будет одним и темже. </para>
<para/>
<para>Метод по умолчанию: использование Layman утилиты</para>
<para/>
<para>Если вы ещё не установили Layman, сделайте это сейчас. </para>
<para/>
<para>emerge -nav layman </para>
<para/>
<para>Также Вам необходимо добавить следующую строку в Ваш make.conf. </para>
<para/>
<para>echo "source /usr/portage/local/layman/make.conf" &gt;&gt;/etc/make.conf </para>
<para/>
<para>Если Вы используете Eix Caching System, удостовертесь что Вы используете самую новую версию; старые версии не поддерживают чтение внешних файлов make.conf. </para>
<para/>
<para>Измените "nocheck" переменную на значение "yes" в конфигурационном файле утилиты layman. (/etc/layman/layman.cfg) </para>
<para/>
<para>Затем добавте оверлей с помощью Layman утилиты: </para>
<para/>
<para>layman -f</para>
<para>layman -a xeffects </para>
<para/>
<para>если вы используете layman версии 1.0.7 или позже, то оверлеи с неправильными атрибутами будут проигнорированы. Используйте опцию -k для обхода этой ситуации. </para>
<para/>
<para>layman -k -a xeffects </para>
<para/></section><section><info><title>Альтернативный метод: Создание оверлея вручную</title></info>
<para/>
<para>Если Вы хотите обслуживать Вашь оверлей самостоятельно, то сделайте следующее. Иначе (если используется lanman), вы можете перейти к главе Размаскирование необходимых пакетов. Примечание: Лучше всего не смешивать оверлеи и использовать их отдельно друг от друга. </para>
<para/>
<para>Перейдите в Вашу директорию оверлеев </para>
<para/>
<para>cd /usr/local/overlays </para>
<para/>
<para>Загрузите последнюю версию из CoffeeBuzz's Subversion репозитория в директорию 'xgl-coffee' </para>
<para/>
<para>svn co http://svn.xgl-coffee.org/xgl-coffee/trunk xgl-coffee </para>
<para/>
<para>Теперь Вы создали оверлей дерева портежей в /usr/local/overlays/xgl-coffee. </para>
<para/>
<para>Добавьте следующий путь в переменную PORTDIR_OVERLAY в /etc/make.conf. </para>
<para>Файл: /etc/make.conf </para>
<para>PORTDIR_OVERLAY="${PORTDIR_OVERLAY} /usr/local/overlays/xgl-coffee"</para>
<para/>
<para/></section><section><info><title>Размаскирование необходимых пакетов</title></info>
<para/>
<para>Много пакетов маркированы как нестабильные и должны быть размаскированы чтобы их можно было установить из дерева портажей Добавте следующие строки к файлу /etc/portage/package.keywords или /etc/portage/package.unmask </para>
<para>Файл: /etc/portage/package.keywords </para>
<para># Зависимости</para>
<para>dev-util/git</para>
<para>media-libs/glitz</para>
<para>media-libs/mesa</para>
<para>x11-apps/mesa-progs</para>
<para>sys-apps/man</para>
<para>x11-libs/cairo</para>
<para>dev-python/pycairo</para>
<para>x11-libs/qt</para>
<para>x11-misc/util-macros</para>
<para>x11-proto/glproto</para>
<para>x11-apps/xvinfo</para>
<para>x11-apps/xlsclients</para>
<para>x11-libs/libwnck</para>
<para>x11-misc/xwinwrap</para>
<para>virtual/xft</para>
<para>gnome-base/gconf</para>
<para>gnome-base/libgnomeui</para>
<para>x11-libs/gtk+</para>
<para>dev-libs/glib</para>
<para>x11-libs/libdrm</para>
<para/>
<para>#XGL пакет</para>
<para>x11-base/xgl</para>
<para/>
<para># старые версии Compiz</para>
<para>x11-wm/compiz-quinnstorm</para>
<para>x11-misc/compiz-quinnstorm-plugins</para>
<para>x11-wm/compiz</para>
<para>x11-wm/cgwd</para>
<para>x11-misc/csm</para>
<para>x11-misc/cgwd-themes</para>
<para>x11-misc/cgwd-themes-extra</para>
<para>x11-misc/gset-compiz</para>
<para>x11-misc/compiz-manager</para>
<para/>
<para># новая ветка Beryl для Compiz</para>
<para>x11-wm/beryl-core</para>
<para>x11-plugins/beryl-plugins</para>
<para>x11-misc/beryl-manager</para>
<para>x11-misc/beryl-settings</para>
<para>x11-wm/emerald</para>
<para>x11-misc/emerald-themes</para>
<para/>
<para/>
<para>Удостоверьтесь что флаги glitz, pdf и png включены в переменную USE для Cairo. Возможно Вам понадобится добавить следующую строку к файлу package.use: </para>
<para>Файл: /etc/portage/package.use </para>
<para>x11-libs/cairo glitz pdf png</para>
<para/></section><section><info><title>Установка Xgl</title></info>
<para/>
<para>Новые бета драйверы с закрытым исходным кодом от nVidia (версия 1.0.9625) уже включают в себя поддержку XGL. Поэтому не нужно более никаких установок. Если вы не хотите использовать новейшие бета драйвера, то следуйте к главе "не-nVidia пользователи". Данный способ работает на nVidia картах при этом установка и использование новых nVidia драйверов намного проще. Если Вы хотите использовать новейшие бета драйвера тогда Вы должны перейти к главе "nVidia Пользователи". </para>
<para/>
<para>Не-nVidia пользователи</para>
<para/>
<para>Во-первых Вы должны установить Cairo. Используй опуцию --oneshot чтобы не записывать этот пакет в список world (не захламляй свой world список). </para>
<para/>
<para># emerge --oneshot --ask --verbose cairo </para>
<para/>
<para>Переинсталируй pango и gtk+ с использованием новоустановленного Cairo пакета. </para>
<para/>
<para># emerge --oneshot --ask --verbose pango gtk+ </para>
<para/>
<para/>
<para>Далее у Вас есть выбор между beryl и compiz ветками: </para>
<para>compiz это оригинальное приложение написанное Давидом Равеманом (David Reveman) из Новел (Novell). Это приложение уже включено в дерево портажей. </para>
<para>beryl это снимок Quinnstorm's Ubuntu кодовой базы с некоторыми экспериментальными плагинами. Формально эта ветка известна под названием compiz-quinnstorm. Использует emerald как window decorator. это отдельный пакет не включенный в дерево портежей. </para>
<para/>
<para>Проверьте что флаги dbus и svg включены в переменную USE для Compiz. Возможно Вам потребуется добавить следующую строку в package.use: Файл: /etc/portage/package.use </para>
<para>x11-wm/compiz dbus svg</para>
<para/>
<para>Проверьте что пакеты glproto и libdrm установлены. Установите их если это требуется: </para>
<para/>
<para># emerge --ask --verbose --oneshot --noreplace glproto libdrm </para>
<para/>
<para>В конечном итоге Вы должны будете установить Xgl и Mesa, которые автоматичеси скомпилируют и установят Compiz а также все его плагины и Xgl сервер. </para>
<para/>
<para># emerge --ask --verbose --oneshot --noreplace mesa </para>
<para/>
<para>Опция 1: Для использования vanilla compiz: </para>
<para/>
<para># emerge --ask --verbose xgl compiz </para>
<para/>
<para>Опция 2: Для использования beryl мета пакета: </para>
<para/>
<para># emerge --ask --verbose xgl beryl-core </para>
<para/>
<para>Примечание: Установка beryl также устанавливает декоратор окон emerald и его темы. Таким образом emerald не надо устанавливать отдельно. </para>
<para>Примечание: NVIDIA пользователи пожалуйста переустановите nvidia-drivers после установки Xgl </para>
<para>Примечание: Если неудается скомпилировать xgl, проверте заплатку на </para>
<para>http://forums.xgl-coffee.org/viewtopic.php?t=178 </para>
<para>Примечание: Если неудается скомпилировать beryl из за dbus, попробуйте обновить пакет dbus </para>
<para>Примечание: Если неудается скомпилировать xgl и компиляция обрывается на fbmmx.c или fbedge.c, попробуйте удалить флаг "-fforce-addr" из переменной CFLAGS. Также ознакомтесь с документацией на форуме </para>
<para/>
<para>Если всё прошло удачно, то Cairo должен присутствовать в системе как зависимость. Примечание: Для следующей проверки необходим установленый пакет gentoolkit. </para>
<para/>
<para>Проверите с помощью следующей команды </para>
<para/>
<para># equery d -o -p cairo </para>
<para/>
<para>Предупреждение: Если команда не возвращает никаких пакетов, то значит чтото прошло не правильно! </para>
<para/>
<para>После произведенных действий Вы должны получить функционирующую установку Xgl. Пожалуйста ознакомтесь с Глава работающий Xgl. </para>
<para/>
<para>nVidia пользователи</para>
<para/>
<para>nVidia драйвер версии 9625 BETA и старше содержат XGL и AIGLX-подобные расширения и могут быть использованы совмесно с другими композитными менеджерами окон. см. en:HOWTO nVidia GL Desktop Effects для более детальной информации. </para>
<para/></section><section><info><title>Обновление Xgl </title></info>
<para/>
<para>Из-за быстрой разработки Xgl и Compiz, оверлей обновляется как минимум один раз в неделю. Используйте один из приведённых методов для обновления оверлея. </para>
<para/>
<para>Обновление с помощью Layman утилиты</para>
<para/>
<para>Обновление оверлея с помощью Layman утилиты очень просто: </para>
<para/>
<para>layman -s xeffects </para>
<para/>
<para>Обновление вручную</para>
<para/>
<para>Для обновления оверлея вручную, перейдите в директорию оверлея и введите ./svnup.sh. этот скрипт также выведет список изменений. </para>
<para>cd /usr/local/overlays/xgl-coffee/</para>
<para>./svnup.sh</para>
<para/></section><section><info><title>Запуск Xgl </title></info>
<para/>
<para>Конфигурация Compiz </para>
<para/>
<para>Для начала надо сконфигурировать Compiz и его плагинов. Если никакие плагины не указаны, тогда окна останутся без декораций! (не будет кнопок minimize/maximize/close, невозможно будет изменять размеры окна, ничего вообще толком не будет.) </para>
<para/>
<para>Существуют два пути указания плагинов. Вы можете указать плагины в командной строке или использовать оконный редактор конфигурации например с помощью программ gconf-editor или gset-compiz. Но вы не можете использовать оба способа одновременно! Если gconf указан в командной строке, тогда Compiz проигнорирует все другие плагины указанные в командной сторке и возьмёт список плагинов из вашей конфигурации gconf. </para>
<para/>
<para>Таким образом если Вы впервые запускаете Xgl и Вы хотите конфигурировать в оконном редакторе, наступило время сделать это, до того как Вы выйдете из Вашей X сессии. </para>
<para/>
<para>Способ "По умолчанию": Использование gconf-editor </para>
<para># gconf-editor</para>
<para/>
<para>Перейдите в apps --&gt; compiz --&gt; general --&gt; allscreens --&gt; options и отредактируйте узел active_plugins находящийся справа. Примечание: Если в gconf-editor нет вкладок Сompiz, тогда это можно исправить таким образом: </para>
<para> # export GCONF_CONFIG_SOURCE="xml:merged:/etc/gconf/gconf.xml.defaults"</para>
<para> # gconftool-2 --makefile-install-rule /etc/gconf/schemas/compiz.schemas</para>
<para/>
<para>Способ "По умлочанию" для compiz-quinnstorm: Использование csm</para>
<para># csm</para>
<para/>
<para>Плагины могут быть активированы кликая в checkbox после имени. Индивидуальная конфигурация плагинов осуществляется после щелчка мышью на имени плагина. Примечание: Compiz-quinnstorm поставляется вместе с Compiz Manager (compiz-manager). Это оконное приложение находящееся в системной панели и включает в себя Compiz Settings Manager (csm) и Compiz Theme Manager (gcompizthemer). Запустив на выполнение эти две утилиты (управляйте compiz и темами), перестартуйте оконный менеджер или декоратор из системной панели и установите запасной оконный менеджер который будет использоваться в случае неудачного старта. </para>
<para/>
<para># compiz-manager</para>
<para> or (if any dbus problem) :</para>
<para># dbus-launch compiz-manager</para>
<para/>
<para>Альтернативный способ: Испльзование gconftool-2</para>
<para># gconftool-2 -s /apps/compiz/general/allscreens/options/active_plugins "[gconf,decoration,wobbly,fade,minimize,cube,switcher,move,resize,place,rotate,zoom,scale]" -t list --list-type=string</para>
<para/>
<para>Укажите активные плагины внутри квадратных скобок. </para>
<para/>
<para>Альтернативный способ: Использование gset-compiz Предупреждение: </para>
<para/>
<para>gset-compiz больше не пытается использовать все возможности Compiz. Используйте лучше gconf-editor или более новые программы для возможностей которыми не располагает gset-compiz. </para>
<para/>
<para># gset-compiz</para>
<para/>
<para>Плагин можно активировать поставив галочку сразу возле его имени. Конфигурация индивидуальных настроек плагина доступна после нажатия кнопки Plugins находящейся сразу под меню. </para>
<para/>
<para>Как минимум, потребуются пакеты gconf и decoration. Также, если Вы хотите включить все доступные эффекты, надо также добавить wobbly, fade, switcher, move, resize, place, minimize, cube, rotate, zoom, и scale. Из имени пакета Вы сами можете догадаться, что выполняет каждый из плагинов, так что не торопитесь включать их все. Это как предпочтения "сладостей для глаз", установите плагины move и resize - у Вас появится возможность работать с их функциями. </para>
<para/>
<para>Using Quinnstorm's compiz &amp; cgwd </para>
<para/>
<para>Quinnstorm's new compiz doesn't use gconf plugin anymore (so settings). To use it, replace any instance of compiz --replace gconf found in this document with dbus-launch compiz --replace dbus csm. And set it by csm or dbus-launch csm. </para>
<para/>
<para>Quinnstorm's new window decorator must be called instead of gnome-window-decorator in order to function. If you chose to emerge cgwd, just replace any instance of gnome-window-decorator found in this document with dbus-launch cgwd. </para>
<para/>
<para>Оконный режим </para>
<para/>
<para>Запустив Xgl таким способом мы создадим новое окно с включенным Xgl сервером. Это отличный способ протестировать правильность установки прежде чем запускать XGL в полноэкранном режиме. </para>
<para/>
<para>Чтобы попробовать его работу в оконном режиме при уже запущенном X сервере: Code: Для ati пользователей </para>
<para>Xgl :1 -ac -accel glx:pbuffer -accel xv:pbuffer -fp /usr/share/fonts/misc,/usr/share/fonts/other_fonts</para>
<para>Code: Для nVidia пользователей </para>
<para>Xgl :1 -ac -accel glx:pbuffer -accel xv -fp /usr/share/fonts/misc,/usr/share/fonts/other_fonts</para>
<para/>
<para>Примечание: Обсуждение использования pbuffer или fbo как аргументов accel, можно почитать здесь http://forums.gentoo.org/viewtopic-t-455153-highlight-.html </para>
<para>Примечание: Xgl не будет считывать значение FontPath из xorg.conf, по-этому, лучше в конце строки после опции -fp прописать пути к шрифтам разделяя их запятой. Используйте этот скрипт для получения путей к шрифтам прописанным в файле xorg.conf: </para>
<para/>
<para> grep -i fontpath /etc/X11/xorg.conf | egrep -v "[:space:]*#" | sed "s/.\+\"\(.\+\)\"/\1,/g" | xargs echo | sed "s/\ //g" | sed "s/,\$//"</para>
<para/>
<para>Протестируйте Вашу конфигурацию: </para>
<para/>
<para>Запустите композитный оконный менеджер (compiz or compiz-quinnstorm), запустите декоратор окон (gnome-window-decorator or cgwd) и запустите приложение (xterm). Code: Для большинства: Если Вы используете compiz совмесно с gnome-window-decorator </para>
<para/>
<para>Учтите что название gnome-window-decorator изменилось на gtk-window-decorator 22 Сентября 2006 года. </para>
<para>LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ \</para>
<para>DISPLAY=:1 compiz gconf</para>
<para>DISPLAY=:1 gnome-window-decorator</para>
<para>DISPLAY=:1 xterm</para>
<para>Code: Альтернатива 1: если Вы используете compiz-quinnstorm совмесно с gnome-window-decorator </para>
<para>LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ \</para>
<para>DISPLAY=:1 dbus-launch compiz dbus csm</para>
<para>DISPLAY=:1 gnome-window-decorator</para>
<para>DISPLAY=:1 xterm</para>
<para>Code: Альтернатива 2: Если вы используете compiz-quinnstorm с cgwd </para>
<para>LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ \</para>
<para>DISPLAY=:1 dbus-launch compiz dbus csm</para>
<para>DISPLAY=:1 dbus-launch cgwd</para>
<para>DISPLAY=:1 xterm</para>
<para/>
<para/>
<para>Если всё прошло успешно, мы можем начать конфигурировать Вашу систему для запуска Xgl с Вашим графическим менеджером аутентификации. Следуйте инструкциям которые помогут Вам настр�ить менеджер аутентификации. Это последний шаг необходим для удобного использования Xgl. </para>
<para/>
<para>startx (Для пользователей startx) </para>
<para/>
<para>Если вы обычно загружаетесь в консоль и Xorg сервер запускается через startx, а .xinitrc загружает ваш менеджер окон на DISPLAY:0, то вам нужно: написать скрипт startxgl для запуска сервера Xgl, а так же файл .xglinitrc для загрузки менеджера окон на DISPLAY:1. Эти действия не изменят вашей текущей конфигурации и вы сможете в любой момент вернутся в нормальный Xorg сервер. </para>
<para/>
<para>1) Скопируйте startx (cp /usr/bin/startx /usr/local/bin/startxgl) и отредактируйте 2 строки: Файл: /usr/local/bin/startxgl </para>
<para> ## userclientrc=$HOME/.xinitrc</para>
<para> userclientrc=$HOME/.xglinitrc</para>
<para/>
<para> ## xinit $clientargs -- $serverargs -deferglyphs 16 &amp;</para>
<para> # ATI</para>
<para> xinit $clientargs -- /usr/bin/Xgl :1 $serverargs -ac -accel xv -accel glx:pbuffer -deferglyphs 16 &amp;</para>
<para> # NVIDIA</para>
<para> xinit $clientargs -- /usr/bin/Xgl :1 $serverargs -ac -accel xv -accel glx:fbo -deferglyphs 16 &amp;</para>
<para/>
<para/>
<para>2) создайте файл ~/.xglinitrc (vi ~/.xglinitrc) Файл: ~/.xglinitrc </para>
<para> sleep 2 # give Xgl some extra time to start</para>
<para> DISPLAY=:1 KDEWM=compiz-decorator startkde</para>
<para>Примечание: Пользователи Gnome должны вписать gnome-session вместо startkde и WINDOW_MANAGER вместо KDEWM. Пользователи других DM вписывают соответствующие им команды запуска. Для уточнения проверте ваш ~/.xinitrc. </para>
<para/>
<para/>
<para>3) создайте файл compiz-decorator (vi /usr/local/bin/compiz-decorator) Файл: /usr/local/bin/compiz-decorator </para>
<para>## Start compiz or compiz-quinnstorm</para>
<para>## compiz --replace gconf &amp;</para>
<para>## dbus-launch compiz --replace dbus csm &amp;</para>
<para>compiz --replace gconf &amp;</para>
<para/>
<para>sleep 2</para>
<para/>
<para>## Start gnome-window-decorator or cgwd</para>
<para>## gnome-window-decorator &amp;</para>
<para>## dbus-launch cgwd &amp;</para>
<para>gnome-window-decorator &amp;</para>
<para>Примечание: Команды для запуска и использования compiz-quinnstorm и cgwd в скрипте закоментированны. Если вы хотите пользоваться ими то незабудте закоментировать текущие </para>
<para/>
<para>Смените права доступа на /usr/local/bin/compiz-decorator что бы сделать его исполняемым: </para>
<para># chmod +x /usr/local/bin/compiz-decorator</para>
<para/>
<para>4) Для запуска вашего оконного менеджера в XOrg используйте startx, для запуска в Xgl используйте startxgl. </para>
<para/>
<para>Скрипты тестировались на связке ATI и KDE. --Ash 17:48, 11 Сентября 2006 (UTC) </para>
<para/>
<para>XDM (Базовая графическая система аутентификации) </para>
<para/>
<para>Измените ссылку на X сервер: Файл: /etc/X11/xdm/Xservers </para>
<para>:0 local /usr/bin/Xgl vt7</para>
<para/>
<para/>
<para>KDM (для пользователей KDM) </para>
<para/>
<para>Замените строку с ServerCmd в kdmrc на одну из следующих:</para>
<para>Файл: /usr/kde/&lt;your version&gt;/share/config/kdm/kdmrc </para>
<para># NVidia Command</para>
<para>ServerCmd=/usr/bin/Xgl -br -ac -accel glx:pbuffer -accel xv</para>
<para># ATI Command</para>
<para>ServerCmd=/usr/bin/Xgl -br -ac -accel glx:pbuffer -accel xv:pbuffer</para>
<para/>
<para>Вы также должны поменять занчение ServerTimeout так как Xgl запускается немного дольше, чем нормальный Х сервер: </para>
<para>Файл: /usr/kde/&lt;your version&gt;/share/config/kdm/kdmrc </para>
<para>ServerTimeout=30</para>
<para>Если kdm не смог загрузится, измените значение ServerTimeout на 600. Учтите, что в этом случае время загрузки Xgl значительно увеличится. </para>
<para>Не используйте скрипт /usr/kde/3.5/share/config/kdm/Xstartup для запуска Compiz. Для его выполнения нужны права пользователя root. </para>
<para/>
<para>Скопируйте скрипт в другое место, например сюда: Файл: /usr/local/bin/compiz-decorator </para>
<para>## Start compiz or compiz-quinnstorm</para>
<para>## compiz --replace gconf &amp;</para>
<para>## dbus-launch compiz --replace dbus csm &amp;</para>
<para>compiz --replace gconf &amp;</para>
<para/>
<para>sleep 2</para>
<para/>
<para>## Start gnome-window-decorator or cgwd</para>
<para>## gnome-window-decorator &amp;</para>
<para>## dbus-launch cgwd --replace &amp;</para>
<para>gnome-window-decorator --replace &amp;</para>
<para/>
<para>Примечание: Команды для запуска и использования compiz-quinnstorm и cgwd в скрипте закоментированны. Если вы хотите пользоваться ими то незабудте закоментировать текущие. </para>
<para/>
<para>Сделайте вновь созданный скрипт /usr/local/bin/compiz-decorator исполняемым: </para>
<para># chmod +x /usr/local/bin/compiz-decorator</para>
<para/>
<para/>
<para>Далее измените: </para>
<para>Файл: /etc/env.d/99kde-env </para>
<para>KDEWM=compiz-decorator</para>
<para/>
<para>И наконец, выполните команду: </para>
<para># env-update</para>
<para/>
<para>Теперь после перезагрузки или выполнения комманды /etc/init.d/xdm start вы запустите полнофункциональный Xgl со всеми эффектами без пользовательского вмешательства и аутентификацией с помощью KDM. </para>
<para/>
<para>GDM (для пользователей GNOME) </para>
<para/>
<para>Вы должны сделать 3 вещи, чтобы заставить Xgl работать с GDM и использовать Compiz для автоматической загрузке при авторизации пользователя. </para>
<para>Сконфигурируйте GDM для Xgl с отложенным запуском, чтобы при запуске нельзя было сказать, что она не работает </para>
<para>Сконфигурируйте GDM для использования с Xgl-сервером </para>
<para>Установите сессию GNOME для автоматического запуска из Compiz Примечание: Конфигурирование gdm для отложенного запуска Xgl доступно с gdm-2.14.1 и поздних версий. Если Вы используете раннюю версию, начинте с шага 2, но, возможно, Вам не удастся заставить gdm работать с Xgl. Также использование gdmsetup для конфигурирования gdm на испольльзоваине Xgl-сервера (Раздел 2a) может быть недоступно для версий gdm ранее 2.14.0. Если недоступны необходимые Вам функции, самостоятельно отредактируйте конфигурационный файл GDM (Раздел 2b). </para>
<para/>
<para/>
<para>Конфигурирование Gdm на отложенный запуск для запуска Xgl </para>
<para/>
<para>Gdm сконфигурирована по умолчанию на завершение (kill) X-сервера, если загрузка заняла более 10 секунд. К сожадению, новые версии Xgl могут загружаться дольше. Пользователи Xgl в Gentoo, могут сконфигурировать Gdm (пример по версии 2.14.1) на ожидание более 10 секунд. </para>
<para># emerge --ask --verbose &gt;=gdm-2.14.1</para>
<para>Добавьте/измените следующие команды секции [daemon] файла /etc/X11/gdm/custom.conf. Строка: Файл: /etc/X11/gdm/custom.conf </para>
<para>GdmXserverTimeout=30</para>
<para/>
<para>Если /etc/X11/gdm/custom.conf не существует, попробуйте /etc/X11/gdm/gdm.conf-custom или /etc/X11/gdm/gdm.conf. </para>
<para/>
<para>Конфигурирование Gdm для использования сервера Xgl </para>
<para/>
<para>Использование gdmsetup </para>
<para>Для начала сделайте резервную копию файла gdm.conf </para>
<para>cp /etc/X11/gdm/gdm.conf /etc/X11/gdm/gdm.conf.bak </para>
<para>Запустите gdmsetup </para>
<para>Выберите раздел Security </para>
<para>Щёлкните кнопку Configure X Server, расположенную снизу-справа раздела </para>
<para/>
<para>Для начала мы удалим значения для стандартного X-сервера </para>
<para>Нажмите по стандартному серверу, ктороы находится в списке Servers to Start </para>
<para>Нажмите Remove Button </para>
<para/>
<para>Сейчас мы создадим значения для сервера Xgl </para>
<para>Нажмите кнопку Add/Modify </para>
<para>Задайте использование нового сервера VT 1. Используйте Standard для Server опцию — она отображает, какой профиль использовать для сервера, в идеале мы должны создать новый "Xgl"-профиль, а в настоящее время при помощи gdmsetup это сделать невозможно, так что отредактируем настройки для профиля Standard. Не воодите здесь каких-либо опций. Нажмите Ok по завершении. </para>
<para>В Server Settings измените Server Name на "Xgl" </para>
<para>Введите команду Xgl в поле Command, например, для пользователей ATI: </para>
<para>/usr/bin/Xgl :1 -ac -accel glx:pbuffer -accel xv:pbuffer</para>
<para>NVIDIA users should use: </para>
<para>/usr/bin/Xgl -br -ac -accel glx:pbuffer -accel xv</para>
<para>Измените в выпадающем списке Launch значение на Greeter </para>
<para>Установите Logins are handled by this computer </para>
<para>Установите Flexible (on demand) </para>
<para>Save и Close </para>
<para>Перезапустите gdm </para>
<para/>
<para>Ручная настройка </para>
<para>Для начала сделайте резервную копию файла gdm.conf </para>
<para>cp /etc/X11/gdm/gdm.conf /etc/X11/gdm/gdm.conf.bak</para>
<para>Now open /etc/X11/gdm/gdm.conf in a text editor and search for the [servers] section. This should be near the end of the file. </para>
<para>Comment out 0=Standard and add a new line that reads 0=inactive and one that reads 1=Xgl. </para>
<para>Add the server information for the Xgl server, remember to substitute the correct Xgl server command! The one below is for ATI cards. </para>
<para/>
<para>The modified /etc/X11/gdm/gdm.conf: </para>
<para>[servers]</para>
<para>#0=Standard</para>
<para>1=Xgl</para>
<para/>
<para># Definition of the xgl X server.</para>
<para>[server-Xgl]</para>
<para>name=Xgl</para>
<para>command=/usr/bin/Xgl :1 -ac -accel xv:pbuffer -accel glx:pbuffer</para>
<para>flexible=true</para>
<para>chooser=false</para>
<para>handled=true</para>
<para>priority=0 </para>
<para>Restart gdm Примечание: For i810 users (not necessarly i915; this would kill my xorg sessions, I had to use the ATI command), the command for the above should be:</para>
<para>[server-xgl]</para>
<para>name=Xgl server</para>
<para>command=/usr/bin/Xgl -accel xv -accel glx:pbuffer -accel xv:pbuffer -ac -audit 0 -br -dpms -dpi 72</para>
<para>flexible=true</para>
<para/>
<para/>
<para>Via xsession </para>
<para/>
<para>You can add another session for Xgl on display :1 (leaving the standard server on :0). It is a 2 step setup and imho the best option, first create a file to start Xgl and second create a new xsession file. </para>
<para/>
<para>Create a new file startxgl.sh in /usr/bin which starts Xgl. </para>
<para>vim /usr/bin/startxgl.sh</para>
<para/>
<para>And add one of the four options below. </para>
<para>NVIDIA (using GNOME) </para>
<para>#!/bin/bash</para>
<para>Xgl -fullscreen :1 -audit 0 -ac -br -accel glx:pbuffer -accel xv:fbo &amp;</para>
<para>sleep 2 &amp;&amp; DISPLAY=:1 gnome-session</para>
<para>NVIDIA (using KDE) </para>
<para>#!/bin/bash</para>
<para>Xgl -fullscreen :1 -audit 0 -ac -br -accel glx:pbuffer -accel xv:fbo &amp;</para>
<para>sleep 2 &amp;&amp; DISPLAY=:1 startkde</para>
<para>ATI and Intel (using GNOME) </para>
<para>#!/bin/bash</para>
<para>Xgl -fullscreen :1 -audit 0 -ac -br -accel glx:pbuffer -accel xv:pbuffer &amp;</para>
<para>sleep 2 &amp;&amp; DISPLAY=:1 gnome-session</para>
<para>ATI and Intel (using KDE) </para>
<para>#!/bin/bash</para>
<para>Xgl -fullscreen :1 -audit 0 -ac -br -accel glx:pbuffer -accel xv:pbuffer &amp;</para>
<para>sleep 2 &amp;&amp; DISPLAY=:1 startkde</para>
<para/>
<para>Create a new xsession file: Файл: /usr/share/xsessions/xgl.desktop </para>
<para>[Desktop Entry]</para>
<para> Encoding=UTF-8</para>
<para> Name=Xgl</para>
<para> Comment=Start an Xgl Session</para>
<para> Exec=/usr/bin/startxgl.sh</para>
<para> Icon=</para>
<para> Type=Application</para>
<para/>
<para/>
<para>Now you will be able to select a new session via gdm's option menu. Options -&gt; Select Session </para>
<para/>
<para>The benefit is that it will not replace your normal XOrg server. So when you "break" your Xgl you can return to the normal XOrg server. </para>
<para/>
<para>Adding Compiz to your GNOME session (replacing Metacity) </para>
<para/>
<para>Here is a little startscript, which I've placed in /usr/bin/. Useful if you do not always run Xgl. Change or remove the setxkbmap line according to your keyboard layout. Файл: /usr/bin/compizrc </para>
<para>#!/bin/bash</para>
<para>#</para>
<para># Start compiz within gnome-session</para>
<para>#</para>
<para>if [ `ps -A -o comm | grep -c '^Xgl$'` == "1" ]; then</para>
<para>        DISPLAY=:1 LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ compiz --replace gconf &amp;</para>
<para>        DISPLAY=:1 gnome-window-decorator &amp;</para>
<para>#       DISPLAY=:1 setxkbmap -model pc105 -layout it -variant basic # Change according to your needs, and uncomment if needed</para>
<para/>
<para>#       Or like that, if you need to switch between layouts.</para>
<para>#       setxkbmap -model pc105 -layout "us,ru(winkeys)" -variant winkeys -option "grp:alt_shift_toggle,grp_led:scroll"</para>
<para>else echo "${0}: Error: Compiz and g-w-d not launched. Xgl not running?"</para>
<para>fi</para>
<para>Файл: /usr/bin/compizrc.modified </para>
<para>#!/bin/bash</para>
<para>#</para>
<para># Start compiz within gnome-session</para>
<para>#</para>
<para>if [ `ps -A -o comm | grep -c '^Xgl$'` == "1" ]; then</para>
<para># For old versions</para>
<para>#       DISPLAY=:0 LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ compiz --replace gconf &amp;</para>
<para># For Compiz-Quinnstorm with csm</para>
<para>        DISPLAY=:0 LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ compiz --replace dbus csm &amp;</para>
<para>        DISPLAY=:0 dbus-launch cgwd --replace &amp;</para>
<para>#       DISPLAY=:0 setxkbmap -model br-abnt2 -layout br -variant br</para>
<para>else echo "${0}: Error: Compiz and cgwd not launched. Xgl not running?"</para>
<para>fi</para>
<para>Code: Make the script executable </para>
<para/>
<para>chmod 755 /usr/bin/compizrc </para>
<para/>
<para/>
<para/>
<para>After logging into GNOME, start System-&gt;Settings-&gt;Sessions. Here you go to the 3rd tab Startup Programs and press the Add button. Enter the path to your Compiz startscript (e.g., /usr/bin/compizrc). </para>
<para>After logging out and back in Compiz will start, but you'll see no decorations and effects. Thats because the Compiz gconf tree for the current user has just been created - without any plugins! </para>
<para>So start your configuration editor and go to apps/compiz/general/allscreens/options and edit the active_plugins key. This should contain the following items in this order: gconf decoration wobbly fade minimize cube rotate zoom scale move resize place menu switcher </para>
<para>If the key is not there, make it with a type of List </para>
<para>After restarting your Xgl Server should be accessible with GDM &amp; gnome-session. </para>
<para/>
<para>Xsession (Modifying startx)Примечание: This is for NVIDIA users. </para>
<para>Предупреждение: This currently will not work for ATI users because of the display issues, requiring to be run on DISPLAY=:1. </para>
<para>Примечание: I use simmilar configuration (see startx section) on ATI. Consider /usr/bin/Xgl :1 instead of /usr/bin/Xgl and starting Gnome at :1 as well, if DISPLAY:0 is problematic. --Ash 17:57, 11 September 2006 (UTC) </para>
<para/>
<para/>
<para>Copy /usr/bin/startx to /usr/bin/startxgl and change the following line towards the end of the file: Файл: /usr/bin/startxgl </para>
<para>xinit $clientargs -- $serverargs -deferglyphs 16 &amp;</para>
<para/>
<para>to </para>
<para>xinit $clientargs -- /usr/bin/Xgl $serverargs -ac -accel xv -accel glx:pbuffer -deferglyphs 16 &amp;</para>
<para/>
<para/>
<para>This does not start Compiz so create a small start script and add it to the gnome-session manager (Once GNOME is up. The first time, you will have to open a terminal and call the script manually.) Файл: /usr/bin/compizrc </para>
<para>#!/bin/bash</para>
<para>#</para>
<para># Start compiz within gnome-session</para>
<para>#</para>
<para>if [ `ps -A | grep Xgl | wc -l` == "1" ]; then</para>
<para>        LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ compiz --replace gconf &amp;</para>
<para>        gnome-window-decorator &amp;</para>
<para>#       setxkbmap -model pc105 -layout it -variant basic # Change according to your needs, and uncomment if needed</para>
<para/>
<para>#       Or like that, if you need to switch between layouts.</para>
<para>#       setxkbmap -model pc105 -layout "us,ru(winkeys)" -variant winkeys -option "grp:alt_shift_toggle,grp_led:scroll"</para>
<para/>
<para>fi</para>
<para>Примечание: This should start the desktop environment configured via XSESSION in /etc/rc.conf </para>
<para/>
<para/>
<para>Xfce4 </para>
<para/>
<para>With xfce4-session</para>
<para/>
<para>xfce4-session is installed by default as part of the xfce4 meta-package. If you installed xfce4 this way, the following will work. </para>
<para/>
<para>First, it is necessary to create a script that will start Compiz and gnome-window-decorator with the correct libraries and switches. Файл: /usr/bin/compizrc </para>
<para>LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib compiz --replace gconf &amp;</para>
<para>gnome-window-decorator</para>
<para>Code: Make the script executable </para>
<para>chmod 755 /usr/bin/compizrc</para>
<para/>
<para/>
<para>Now, edit the xfce4-session settings to point to this rather than xfwm4. Файл: /etc/xdg/xfce4-session/xfce4-session.rc </para>
<para>[Failsafe Session]</para>
<para>Count=4</para>
<para>Client0_Command=compizrc</para>
<para>Client0_PerScreen=False</para>
<para>Client1_Command=xfce4-panel</para>
<para>Client1_PerScreen=True</para>
<para>Client2_Command=xftaskbar4</para>
<para>Client2_PerScreen=True</para>
<para>Client3_Command=xfdesktop</para>
<para>Client3_PerScreen=False</para>
<para>Примечание: Instead of editing system-wide file you may also add above section to ~/.config/xfce4-session/xfce4-session.rc file. Note also that you may need to delete content of the ~/.cache/sessions directory, if you still have xfwm4 rather than Compiz running. </para>
<para/>
<para/>
<para/>
<para>Finally, create a script to start Xgl with Xfce4. Файл: /usr/bin/startxgl for NVIDIA </para>
<para>#!/bin/bash</para>
<para>Xgl -ac -accel xv:fbo -accel glx:pbuffer &amp;</para>
<para>xfce4-session</para>
<para>Файл: /usr/bin/startxgl for ATi </para>
<para>#!/bin/bash</para>
<para>Xgl -ac -accel xv:pbuffer -accel glx:pbuffer &amp;</para>
<para>xfce4-session</para>
<para>Code: Make the script executable </para>
<para>chmod 755 /usr/bin/startxgl</para>
<para/>
<para/>
<para>You will notice that xfce4-panel is now transparent, just like if you were using xfwm4's compositor. The pager will be distorted, but otherwise everything works beautifuly. Windows even minimize to the correct spot on the taskbar. </para>
<para/>
<para>Without xfce4-session</para>
<para/>
<para>If you compiled a minimal Xfce (without xfce4-session, xffm4, etc.), then you can use this altered startxgl script from the gnome script above: </para>
<para>#!/bin/bash</para>
<para>echo "&gt;Starting XGL at Display: $1"</para>
<para>echo "========= XGL ============"</para>
<para>Xgl :$1 -ac -accel xv -accel glx:pbuffer &amp;</para>
<para>sleep 3</para>
<para>echo "======= COMPIZ ==========="</para>
<para>DISPLAY=:$1 LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ compiz --replace switcher decoration wobbly fade minimize cube rotate zoom scale move resize place &amp;</para>
<para>sleep 3</para>
<para>echo "======= XFCE ============"</para>
<para>DISPLAY=:$1 xfce-mcs-manager</para>
<para>DISPLAY=:$1 gnome-window-decorator &amp;</para>
<para>DISPLAY=:$1 xftaskbar4 &amp;</para>
<para>DISPLAY=:$1 xfdesktop &amp;</para>
<para>DISPLAY=:$1 exec xfce4-panel</para>
<para/>
<para>Again, xfce4-panel will be transparent as if you had the X.org composite extension turned on (but you don't) or if you use xfce4-svn, and the pager will be distorted. Everything else should be fine. </para>
<para/>
<para>With startxfce4</para>
<para/>
<para>To do it the old fashioned, or 'normal' way via startx/startxfce4 I did the following. First, startxfce4 shouldn't be called I don't think. just use an .xinitrc in your homedir and startx. Файл: ~/.xinitrc </para>
<para>#!/bin/sh</para>
<para>/usr/bin/startxfce4</para>
<para/>
<para/>
<para>Now as root, we create compizrc, like above. Note however that for me, it worked best/only without the DISPLAY variable. Файл: /usr/bin/compizrc </para>
<para>#!/bin/bash</para>
<para>LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib/ compiz --replace gconf &gt; ~/compiz.log 2&gt;&amp;1 &amp;</para>
<para>sleep 1;</para>
<para>gnome-window-decorator &gt; ~/gnome-window.log 2&gt;&amp;1 &amp;</para>
<para/>
<para/>
<para>Obviously the output redirections are optional (but handy for debugging). The sleep 1; might also be removed to speed things up. If things go TO fast however, you might get in trouble though. Don't forget to chmod 755 /usr/bin/compizrc </para>
<para/>
<para>Lastly we need to use this new compizrc instead of the default xfce4 window manager. </para>
<para/>
<para>Again, as root edit /etc/xdg/xfce4-session/xfce4-session.rc and replace xfwm4 with compizrc Файл: /etc/xdg/xfce4-session/xfce4-session.rc (old) </para>
<para>Client0_Command=xfwm4</para>
<para>Файл: /etc/xdg/xfce4-session/xfce4-session.rc (new) </para>
<para>Client0_Command=compizrc</para>
<para/>
<para/>
<para>Now only one thing is left, start Xgl. As above you can copy startx in /usr/bin/startx to /usr/bin/startxgl and make the following change: Файл: /usr/bin/startxgl (old) </para>
<para/>
<para>xinit $clientargs -- $serverargs -deferglyphs 16 &amp; </para>
<para>Файл: /usr/bin/startxgl (new) </para>
<para/>
<para>xinit $clientargs -- /usr/bin/Xgl -ac -accel xv -accel glx:pbuffer $serverargs -deferglyphs 16 &amp; </para>
<para/>
<para/>
<para>Примечание: Todo: Make Client0_Command depend on wether startx or startxgl is beeing used as 3D apps don't appear to work as they should and switching back to the 'old way' is required. </para>
<para/>
<para/>
<para>Edit: it seams that when using the startxfce4 script, the /etc/xdg/xfce4-session/xfce4-session.rc file (and the .xinitrc) get ignored thus starting a non Xgl desktop. Making 'switchin' not needed. startxfce4 for oldschool, startxgl for new style </para>
<para/>
<para>Entrance </para>
<para>Emerge latest entrance: </para>
<para>echo "=x11-misc/entrance-0.9.0.007 ~x86" &gt;&gt; /etc/portage/package.keywords</para>
<para>emerge -av entrance</para>
<para>Use the ecore_config utility to change the xserver string (choose according to your video card): </para>
<para># ATI</para>
<para>ecore_config -k "/entranced/xserver" -s "/usr/bin/Xgl -ac -accel xv:pbuffer -accel glx:pbuffer -nolisten tcp"  -c /etc/entrance_config.cfg</para>
<para># NVIDIA</para>
<para>ecore_config -k "/entranced/xserver" -s "/usr/bin/Xgl -ac -accel xv:fbo -accel glx:pbuffer -nolisten tcp"  -c /etc/entrance_config.cfg</para>
<para>Restart entrance.</para>
<para/>
<para>Qingy </para>
<para/>
<para>It is quite easy to change Qingy to start Xgl instead of a regular X server. All you need to do to make it start Xgl is change 2 lines in /etc/qingy/settings Файл: /etc/qingy/settings </para>
<para>...</para>
<para># x_server = "/usr/X11R6/bin/XFree86"</para>
<para>x_server = "/usr/bin/Xgl"</para>
<para># x_args = "-nolisten tcp"</para>
<para>x_args = "-ac -accel xv -accel glx:pbuffer -nolisten tcp"</para>
<para>...</para>
<para/>
<para/>
<para>Now Qingy should start Xgl instead of regular X. To make KDE and GNOME load Compiz you need to export a variable. KDEWM for KDE and WINDOW_MANAGER for GNOME. It is easiest to do this in /etc/X11/Sessions. </para>
<para/>
<para>You need to have followed the instructions for adding plugins to gconf-editor. Then make a /usr/bin/compizrc as shown and chmod +x it. Файл: /usr/bin/compizrc </para>
<para>#!/bin/bash</para>
<para>LD_LIBRARY_PATH=/usr/lib/opengl/xorg-x11/lib compiz --replace gconf &amp;</para>
<para>sleep 2</para>
<para>gnome-window-decorator &amp;</para>
<para>setxkbmap -model itouch -layout gb &amp; ## Change/Remove as appropriate</para>
<para/>
<para/>
<para>Then edit the appropriate file (or both) in /etc/X11/Sessions</para>
<para>For KDE: Файл: /etc/X11/Sessions/kde-3.5 </para>
<para>#!/bin/sh</para>
<para>export KDEWM="/usr/bin/compizrc"</para>
<para>exec /usr/kde/3.5/bin/startkde</para>
<para/>
<para/>
<para>Or for GNOME add this to the top of the file : Файл: /etc/X11/Sessions/Gnome </para>
<para>#!/bin/sh</para>
<para/>
<para>export WINDOW_MANAGER="/usr/bin/compizrc"</para>
<para/>
<para>...</para>
<para/>
<para/>
<para>For Xfce4 edit /etc/xdg/xfce4-session/xfce4-session.rc as shown in a previous section.</para>
<para>Hopefully Qingy should now start Xgl and Compiz instead of X and some other WM. </para>
<para/>
<para>Generic startxgl script</para>
<para/>
<para>There is a generic startup script in the overlay. For usage instructions start it without arguments. </para>
<para>Currently it support Xfce, Xfce-svn, GNOME and KDE. </para>
<para>cd /usr/local/overlays/xgl-coffee</para>
<para>./startxgl</para></section></section><section><info><title>Автоматическое переключение раскладок</title></info>
<para>Для начала сделаем ebuild в portage overlay </para>
<para/>
<para>Создаём каталог:</para>
<para>mkdir -p /usr/local/portage/x11-misc/xneur cd /usr/local/portage/x11-misc/xneur </para>
<para/>
<para>Создаём ebuild:</para>
<para> nano -w xneur-0.1.0_1.ebuild Файл: /usr/local/portage/x11-isc/xneur/xneur-0.1.0_1.ebuild </para>
<para># Copyright 1999-2005 Gentoo Foundation</para>
<para># Distributed under the terms of the GNU General Public License v2</para>
<para/>
<para>DESCRIPTION="It's program like Punto Switcher, but has other final aim."</para>
<para>SRC_URI="http://www.xneur.ru/xneur/${P}.tar.gz"</para>
<para>HOMEPAGE="http://www.xneur.ru/"</para>
<para>DEPEND="virtual/x11"</para>
<para/>
<para>LICENSE="GPL-2"</para>
<para>SLOT="0"</para>
<para>KEYWORDS="~x86 ~amd64 ~sparc ~alpha ~ppc ~hppa ~ppc64"</para>
<para/>
<para>src_install () {</para>
<para>       make DESTDIR=${D} install || die</para>
<para>       #dodoc AUTHORS README COPYING INSTALL NEWS ChangeLog TODO .xneurrc</para>
<para>}</para>
<para/>
<para>pkg_postinst() {</para>
<para>      # einfo "Run:"</para>
<para>      # einfo "gzcat /usr/doc/${P}/.xneurrc.gz &gt; ~/.xneurrc"</para>
<para>}</para>
<para/>
<para/>
<para>Далее: ebuild xneur-0.1.0_1.ebuild digest Поскольку у нас бэта: echo "x11-misc/xneur ~x86" &gt;&gt; /etc/portage/package.keywords emerge xneur ;) </para>
<para/>
<para>А за подробностями на <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.xneur.ru/">http://www.xneur.ru/</link>
</para>
<para/></section><section><info><title>Cedega 5.1</title></info><section><info><title>Введение</title></info>
<para/>
<para>Cedega - коммерческая версия ПО для реализации WinAPI на *nix-платформах WINE, разработанная Transgaming, ранее известная как Winex. Поддерживается большинство популярных игр. В последней версии добавилась официальная поддержка Sid Meier's Civilization® IV, FIFA® 06 и Need for Speed™: Most Wanted. </para>
<para/>
<para>Cedega 5.1 состоит из двух компонентов: </para>
<para>Point-to-play - графический интерфейс для простой установки игр, распространяется в виде .rpm/.deb/.tgz </para>
<para>Engine / engine update - модифицированный WINE, распространяется в виде файлов .cpkg - tar архивы, содержащие tgz архив и файл manifest с номером версии . </para>
<para/></section><section><info><title>Установка</title></info>
<para/>
<para>Установка самого эмулятора, без неудобного в использовании Point-to-play выглядит так: </para>
<para>Code: Установка Cedega </para>
<para>su</para>
<para>tar -zxf cedega-engine-5.1-local-update.i386.cpkg</para>
<para>tar -C /usr -zxf cedega_5.1-1.i386.p2p.tgz bin winex</para>
<para>mv /usr/share/share/doc/* /usr/share/doc</para>
<para>mv /usr/share/share/man/man1/* /usr/share/man1</para>
<para>mv /usr/bin/winex3 /usr/bin/cedega</para>
<para>mkdir /usr/lib/transgaming/cedega; mv /usr/winex /usr/lib/transgaming_cedega</para>
<para>exit</para>
<para/>
<para/>
<para>Первоначальная настройка</para>
<para>Code: Первоначальная настройка </para>
<para>tar -C $HOME -zxf cedega_5.1-1.i386.p2p.tgz .transgaming</para>
<para>nano ~/.transgaming/config</para>
<para/>
<para>Проверка</para>
<para/>
<para>cedega -version</para>
<para/></section></section></section><section><info><title>Секреты командной строки</title></info>
<para/><section><info><title/></info><section><info><title>Общие команды</title></info>
<para/>
<para>поиск команды Linux, ее описания и номера секции man страниц </para>
<para/>
<para>apropos word </para>
<para>закодировать файл file с помощью GnuPG </para>
<para/>
<para>gpg -c file </para>
<para>раскодировать файл file </para>
<para/>
<para>gpg file.gpg </para>
<para>быстрый поиск по словарю слов, начинающихся с word </para>
<para/>
<para>look word </para>
<para>подсветить слово word в файле /somefile </para>
<para/>
<para>grep --color word /somefile </para>
<para>запустить command с низким приоритетом </para>
<para/>
<para>nice command </para>
<para>назначить низший приоритет текущему шеллу (и всем потомкам). Может быть полезно, если вашу систему сильно замедляет установка нового пакета (emerge). Кстати, для автоматического понижения приоритета emerge используется переменная PORTAGE_NICENESS в файле /etc/make.conf </para>
<para/>
<para>renice 19 -p $$ </para>
<para>посмотреть код завершения предыдущей команды </para>
<para/>
<para>echo $? </para>
<para>скачать список новых страничек с нашего сайта в 01:00 в текущую директорию </para>
<para/>
<para>echo "wget http://ru.gentoo-wiki.com/Special:Newpages" | at 01:00 </para>
<para>в 17:45 послать пустое письмо с заголовком 'got the r00t?'на bugs@microsoft.com </para>
<para/>
<para>echo "mail -s 'got the r00t?' bugs@microsoft.com &lt; /dev/null" | at 17:45 </para>
<para>напечатать 1234 в соответствии с настройками локали (в России обычно 1.234) </para>
<para/>
<para>printf "%'d\n" 1234 </para>
<para>запускать просмотр прерываний каждую секунду </para>
<para/>
<para>watch -n1 "cat /proc/interrupts" </para>
<para>посмотреть, сколько времени занимает выполнение команды </para>
<para/>
<para>time command </para>
<para>удобный алиас для вывода дампа </para>
<para/>
<para>alias hd='od -Ax -tx1z -v' </para>
<para>полный путь к команде command </para>
<para/>
<para>which command </para>
<para>вывести в 9 колонок по ширине терминала </para>
<para/>
<para>ls | pr -T9 -W$COLUMNS </para>
<para>установить время изменения для файла file (в формате YYMMDDhhmm) </para>
<para/>
<para>touch -c -t 0304050607 file </para>
<para>показать иерархию запущенных процессов </para>
<para/>
<para>pstree -p </para>
<para>показать процессы, использующие файл /dir/file (чаще всего использую нечто вроде 'lsof /mnt/cdrom'). Не забудьте сделать 'emerge -n lsof' </para>
<para/>
<para>lsof /dir/file </para>
<para/></section></section><section><info><title/></info><section><info><title>Ввод-вывод</title></info>
<para>объединить stderr и stdout (вернее сказать перенаправить stderr в stdout) </para>
<para/>
<para>gcc file.c 2&gt;&amp;1 | less </para>
<para>Перенаправить stderr в файл errors.log а stdout в файл compile.log для дальнейшего анализа </para>
<para/>
<para>gcc file.c 2&gt;errors.log 1&gt;compile.log </para>
<para>Если нужно запретить вывод потока (например убрать в скрипте сообщения об ошибках) то достаточно перенаправить поток на устройство /dev/null, тогда сообщения уйдут в никуда: </para>
<para/>
<para>rm -r /var/tmp/portage 2&gt;&amp;1 &gt;/dev/null или rm -r /var/tmp/portage &amp;&gt; /dev/null </para>
<para>Порой нужно обьединить выходной поток сразу нескольких комманд, а поток одной изних отключить, тогда группу нужно объединить в скобки: </para>
<para/>
<para>( cat /etc/gentoo-release ; cat /etc/passwd &gt;/dev/null; cat /etc/group ) |less </para>
<para/>
<para>Навигация по директориям.</para>
<para>вернуться в предыдущую директорию (не путать с 'cd ..') </para>
<para/>
<para>cd - </para>
<para>вернуться в домашнюю директорию </para>
<para/>
<para>cd </para>
<para>перейти в директорию dir, запустить command и автоматически вернуться назад </para>
<para/>
<para>(cd dir; command) </para>
<para>добавить текущую директорию в стек, чтобы потом можно было сделать popd и вернуться к ней </para>
<para/>
<para>pushd . </para>
<para/></section></section><section><info><title/></info><section><info><title>Дисковое пространство</title></info>
<para>показать список файлов с информацией о каждом файле (-l), отсортировав список по убыванию размера (-S) и перевернуть список (-r). Получим сортировку по возрастанию. </para>
<para/>
<para>ls -lSr </para>
<para>показать, сколько места на диске занимает файл file и директория dir </para>
<para/>
<para>du -sh file dir </para>
<para>показать свободное место на примонтированных ресурсах </para>
<para/>
<para>df -h </para>
<para>то же самое но в инодах </para>
<para/>
<para>df -i </para>
<para>показать геометрию размещения разделов жесткого диска (нужны права root) </para>
<para/>
<para>fdisk -l </para>
<para/></section></section><section><info><title/></info><section><info><title>Работа с CD</title></info>
<para>создать iso-образ диска и заархивировать его </para>
<para/>
<para>dd bs=1M if=/dev/cdrom | gzip &gt; cdrom.iso.gz </para>
<para>создать iso-образ из директории dir </para>
<para/>
<para>mkisofs -r dir | gzip &gt; cdrom.iso.gz </para>
<para>смонтировать cdrom.iso в /mnt/dir (для просмотра и правки) </para>
<para/>
<para>mount -o loop cdrom.iso /mnt/dir </para>
<para>записать архивированный образ на диск </para>
<para/>
<para>gzip -dc cdrom.iso.gz | cdrecord dev=0,0,0 - </para>
<para>рипнуть дорожки с Audio-CD в текущую директорию (в формате .wav) </para>
<para/>
<para>cdparanoia -B </para>
<para>создать Audio-CD из всех .wav файлов в текущей директории </para>
<para/>
<para>cdrecord dev=0,0,0 -audio *.wav </para>
<para>конвертировать файл track.cdda.wav формат .ogg </para>
<para/>
<para>oggenc --tracknum="track" track.cdda.wav -o "track.ogg" </para>
<para/></section></section><section><info><title/></info><section><info><title>Работа с архивами</title></info>
<para>создать архив директории dir </para>
<para/>
<para>tar c dir/ | bzip2 &gt; dir.tar.bz2 </para>
<para/>
<para>tar -cjf dir.tar.bz2 dir </para>
<para>извлечь архив в директорию /to/dir (без '-C /to/dir' в текущую директорию) </para>
<para/>
<para>bzip2 -dc dir.tar.bz2 | tar x -С /to/dir </para>
<para/>
<para>tar -xjf dir.tar.bz2 -C /to/dir </para>
<para>создать архив всех .png файлов в директории dir/ </para>
<para/>
<para>find dir/ -name "*.png" | xargs tar rf dir.tar; bzip2 dir.tar </para>
<para>скопировать (с сохранением прав доступа!) директорию /dir/to/copy/ в /where/to/ </para>
<para/>
<para>( tar cf - /dir/to/copy ) | ( cd /where/to/ &amp;&amp; tar xf - ) </para>
<para>скопировать (с сохранением прав доступа!) содержимое директории /dir/to/copy в /where/to/ </para>
<para/>
<para>( cd /dir/to/copy &amp;&amp; tar cf - . ) | ( cd /where/to/ &amp;&amp; tar xf - ) </para>
<para>скопировать (с сохранением прав доступа!) директорию /dir/to/copy/ в директорию /where/to/ на удаленной машине </para>
<para/>
<para>( tar cf - /dir/to/copy ) | gzip | ssh user@remote 'cd /where/to/ &amp;&amp; gzip -dc | tar xf -' </para>
<para>создать и сохранить бэкап жесткого диска на удаленной машине </para>
<para/>
<para>dd bs=1M if=/dev/hda | gzip | ssh user@remote 'dd of=hda.gz' </para>
<para/></section></section><section><info><title/></info><section><info><title>Работа с файлами</title></info>
<para>удобный листинг по команде l </para>
<para/>
<para>alias l='ls -l --color=auto' </para>
<para>вывести листинг с упорядочиванием по дате </para>
<para/>
<para>ls -lrt </para>
<para>показать в папке dir файлы модифицированные раньше, чем 2 дня назад </para>
<para/>
<para>find dir -mtime +2 </para>
<para>удаляем в папке dir файлы старше 1 часа </para>
<para/>
<para>find dir -type f -mmin +60 -exec rm -f {} \; </para>
<para>удаляем в папке dir файлы старше 10 дней </para>
<para/>
<para>find dir -type f -mtime +10 -exec rm -f {} \; </para>
<para>найти в текущей директории (и ниже) .c и .h файлы содержащие строку "search string" </para>
<para/>
<para>find -name "*.[ch]" | xargs grep -E "search string" </para>
<para>искать строку "search string" только в обычных файлах </para>
<para/>
<para>find -type f | xargs grep -E "search string" </para>
<para>искать строку "search string" только в текущей директории (не спускаться ниже) </para>
<para/>
<para>find -type f -maxdepth 1 | xargs grep -E "search string" </para>
<para>в текущей директории найти все файлы с расширением sql содержащие USER1 и заменить в них USER1 на USER2 </para>
<para/>
<para>tmp="/tmp/$RANDOM$$.tmp"; f="USER1"; r="USER2"; </para>
<para/>
<para>find . -name '*.sql' -exec grep -l "$f" {} \; | </para>
<para/>
<para>xargs --replace="{}" bash -c "( sed 's/$f/$r/g' &lt; {} &gt; $tmp &amp;&amp; cat $tmp &gt; {} &amp;&amp; rm -f $tmp )" </para>
<para>найти файл в базе данных программы slocate. Замечание: данное регулярное выражение эквивалентно маске *file*.txt </para>
<para/>
<para>locate -r 'file[^/]*\.txt' </para>
<para/></section></section><section><info><title/></info><section><info><title>Работа с файловой системой</title></info>
<para>отформатировать флоппи-диск с FAT </para>
<para/>
<para>mkdosfs -c -f 16 -n "название тома" /dev/fd0 или mkfs -t fat16 /dev/fd0 </para>
<para>"правильная" кодировка и права файлов для сменных носителей (floppy, CD, flash) </para>
<para/>
<para>необходимо прописать в /etc/fstab!!! </para>
<para>для CDROM</para>
<para>/dev/cdrom /mnt/cdrom iso9660 ro,nosuid,noauto,exec,user,nodev 0 0 </para>
<para/>
<para>для "дискетки"</para>
<para>/dev/fd0 /mnt/floppy vfat iocharset=koi8-r,sync,nosuid,codepage=866,user,--,noauto,nodev,unhide 0 0 </para>
<para/>
<para>для раздела Windows</para>
<para>/dev/hda1 /mnt/win vfat user,exec,umask=0,codepage=866,iocharset=koi8-r 0 0 </para>
<para>для "флешки"</para>
<para/>
<para>/dev/sda1 /mnt/flash vfat user,exec,umask=0,sync,codepage=866,iocharset=koi8-r 0 0 </para>
<para>вышенаписанное справедливо для локали koi8-r, ваша может отличаться (см. locale), в этом случае все "koi8-r" необходимо исправить на свои, и помните, что это, лишь, пример </para>
<para/></section></section><section><info><title/></info><section><info><title>Работа с календарем</title></info>
<para>вывести на экран календарь на текущий, предыдущий и следующий месяцы </para>
<para/>
<para>cal -3 </para>
<para>на какой день недели выпал в этом году день рождения Linux? </para>
<para/>
<para>date --date='25 Aug' +%A </para>
<para>конвертировать в дату (в соответствии с локалью) - 130204800 секунд, прошедшие с начала эпохи Unix </para>
<para/>
<para>date --date '1970-01-01 UTC 130204800 seconds' </para>
<para>Сколько сейчас времени на западном побережьи США (используйте tzselect чтобы узнать параметр для TZ) </para>
<para/>
<para>TZ="America/Los_Angeles" date </para>
<para/></section></section><section><info><title/></info><section><info><title>Работа с сетью</title></info>
<para>(Предварительно сделать emerge на net-tools, sys-apps/iproute2, net-dns/bind-tools)</para>
<para>показать сетевые интерфейсы </para>
<para/>
<para>ip link show </para>
<para>показать статус сетевых интерфейсов </para>
<para/>
<para>ethtool interface или /sbin/ifconfig </para>
<para>переименовать eth0 в wan </para>
<para/>
<para>ip link set dev eth0 name wan </para>
<para>добавить ip 1.2.3.4 с маской 255.255.255.0 на eth0 </para>
<para/>
<para>ip addr add 1.2.3.4/24 brd + dev eth0 </para>
<para>поднять интерфейс </para>
<para/>
<para>ip link set dev interface up </para>
<para>опустить интерфейс </para>
<para/>
<para>ip link set dev interface down </para>
<para>сделать шлюзом по умолчанию 1.2.3.254 </para>
<para/>
<para>ip route add default via 1.2.3.254 </para>
<para>показать ip адрес для name </para>
<para/>
<para>host name </para>
<para>показать прослушиваемые порты в системе (и кто их слушает) </para>
<para/>
<para>netstat -lp --inet </para>
<para>показать активные соединения </para>
<para/>
<para>netstat -p --inet </para>
<para/></section></section><section><info><title/></info><section><info><title>Математика</title></info>
<para>простое вычисление </para>
<para/>
<para>echo "(321-123)/123" | bc -l </para>
<para>простое целочисленное вычисление с использование bash </para>
<para/>
<para>echo "$(( (51+123)/2 ))" </para>
<para>использование python для научных вычислений </para>
<para/>
<para>echo "print (10E3-123)/123" | python </para>
<para>приведение систем счисления (в данном случае, десятичной к шестнадцатеричной) </para>
<para/>
<para>echo "obase=16;ibase=10;123" | bc </para>
<para>Более сложное вычисление - максимальная скорость передачи (в пакетах в секунду) в Fast Ethernet сети (100Mb) </para>
<para/>
<para>echo "framing=20; minsize=64; (100*10^6)/((framing+minsize)*8)" | bc </para>
<para>А здесь мы строим график зависимости скорости передачи от размера пакета всё в той же 100-мегабитной сети. </para>
<para/>
<para>echo "framing=20; plot [64:1518] (100*10**6)/((framing+x)*8)" | gnuplot -persist </para>
<para/>
<para/></section></section></section><section><info><title>Тонкость работы ccache с emerge</title></info>
<para/>
<para>Вы пробовали оценить эффективность работы ccache при пересборке системы? Проделайте опыт: очистите кэш (ccache -C) и запустите пересборку (emerge --emptytree world). После пересборки десятка-другого пакетов прервите процесс и посмотрите статистику (ccache -s) Запустите пересборку по новой и опять прервитесь на старом месте. Что показывает статистика? Много ли совпадений? </para>
<para/>
<para>А теперь добавьте в /etc/make.conf строчки </para>
<para>CC=gcc </para>
<para>CXX=g++ </para>
<para/>
<para>очистите кэш и статистику и повторите эксперимент заново. Не правда ли, что после этого кэш только и заработал? </para>
<para/>
<para>Суть: по состоянию на апрель 2005 ccache опознает как компилятор только стандартные имена типа gcc, g++ и не опознает такие имена как i686-pc-linux-gnu-gcc. Однако именно такие имена и используют пакеты в качестве компилятора после работы скриптов кофигурации configure </para>
<para/></section><section><info><title>Keymap</title></info>
<para/>
<para>Варианты раскладок клавиатуры для прописывания в /etc/conf.d/keymaps (в старых версиях baselayout переменная находится в файле /etc/rc.conf) Файл: /etc/conf.d/keymaps </para>
<para>...</para>
<para>KEYMAP="-u ru4"</para>
<para>...</para>
<para>Доступные варианты: </para>
<para>ru -- кодировка KOI-8, переключение [Right-Ctrl], одиночный символ [Right-Alt] </para>
<para>ru1 -- кодировка KOI-8, переключение [Right-Alt] </para>
<para>ru2 -- альтернативная кодировка (IBM866), переключение [Right-Alt] </para>
<para>ru3 -- кодировка KOI-8, 102 кнопочная клавиатура, переключение [CapsLock], [Shift+CapsLock] -- фиксация регистра </para>
<para>ru4 -- кодировка KOI-8, 105 кнопочная клавиатура, переключение [CapsLock], [Shift+CapsLock] -- фиксация регистра </para>
<para>ru-cp1251 -- кодировка CP1251, переключение [Right-Ctrl], одиночный символ [Right-Alt] </para>
<para>ru-ms -- раскладка как в Microsoft Cyrillic keyboard layout, переключение [Right-Ctrl] </para>
<para>ru_win -- кодировка CP1251, переключение [Right-Ctrl], одиночный символ [Right-Alt] </para>
<para>ru-yawerty -- кодировка KOI-8, раскладка "ЯВЕРТЫ" (это бывает удобно при работе на клавиатуре без русских символов), переключение [Right-Alt] </para>
<para/>
<para>Вариант, которого нет в стандартной поставке, но весьма удобен ru-utf. Переключение [Right-Ctrl], одиночный символ [Right-Alt]. Брать тут: http://mlclm.narod.ru/ru-utf.map.gz, сохранить в каталог /usr/share/kbd/keymaps/i386/qwerty или в случае отсутствия этого, в каталог /usr/share/keymaps/i386/qwerty. </para>
<para/>
<para>Кроме того есть вариант ru-mab. Он даёт переключение по [Ctrl+Shift]. Взять можно тут: http://moose.ylsoftware.com/gentoo.ru/ru-mab.map.gz Code: /etc/conf.d/keymaps </para>
<para>...</para>
<para>KEYMAP="ru-utf"</para></section>
</article>