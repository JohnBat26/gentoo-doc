<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbookxi.rng" type="xml"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <info>
        <title>Наивные вопросы юных линуксоидов</title>
    </info>
    <section>
        <info>
            <title>Вступление</title>
        </info>
        <para>Перейдя из ОС Windows в Linux пользователи сталкиваются с кучей непонятных им вещей. Есть много вопросов которые их тревожат, но спросить они не решаються – боятся. Так давайте же поможем им поскорее разобраться с новой замечательной системой. Может и сами узнаем чего нового.Примечание: Так как Gentoo новичкам не поставить, то этот материал носит скорее пропагандистский характер </para>
    </section>
    <section>
        <title>Общие вопросы</title>
        <section>
            <info>
                <title>Как ставить программы? </title>
            </info>
            <para>Первая проблема которая встает перед линуксоидом это установка программ. Программы можно ставить из исходников и бинарных пакетов. На бинарниках завязаны такие дистрибутивы как RedHat, Mandrake, Fedore Core, ASP Linux, ALT Linux, Debian и прочие. С исходниками работают Gentoo Linux и *BSD-системы. </para>
            <para>Чтобы установить программу в Gentoo Linux нужно только ввести: emerge программа emerge скачает все необходимое с интернета, скомпилирует и установит. Если же программы нет в дереве портов, то придеться ставить ее из тарболла. </para>
            <para>Поправочка: В Gentoo тоже можно ставить прекомпиленные (заранее собранные) программы путем вызова команды: <command>emerge --usepkg --getbinpkg</command> программа или короче так: <command>emerge -gk <replaceable>программа</replaceable></command>. Но сборка из исходных текстов предпочтительнее. </para>
        </section>
        <section>
            <info>
                <title>Что еще за тарболл? </title>
            </info>
            <para>Все программы в исходных текстах поставляются в виде тарболлов (файлы с расширением <filename>tar.gz</filename>, <filename>tar.bz2</filename>, <filename>tbz2</filename>, <filename>tgz</filename>, впрочем последние два – большая редкость). Тарболл по своей сути – это просто архив, который можно распаковать следующими командами: <command>tar -xvjf <replaceable>super_proga_0.1.tar.bz2</replaceable></command> для <filename>tar.bz2</filename> (или <filename>tbz2</filename>) и <command>tar -xvzf <replaceable>super_proga_0.1.tar.gz</replaceable></command> для <filename>tar.gz</filename> (<filename>tgz</filename>). И архив будет распакован в текущий каталог. </para>
            <para>Кстати <option>-v</option> – абсолютно лишнее. :) Dron </para>
            <para>Я бы сказал так, распаковка <command>tar –zxvf</command>, архивы <filename>bz</filename> и <filename>gz2</filename>
                <option>–jxvf</option>, удобно запомнить, различается только <option>j</option> в начале. =) das </para>
            <para>Некоторым проще запоминать <option>xzf</option> как eXtract Zipped File. <option>j</option> – для bzip2 wt </para>
            <para>Дальнейшие инструкции по установке можно прочитать в файле <filename>INSTALL</filename> или <filename>README</filename>, но чаще всего установка выглядит так: <command>./configure make</command>. Дальше от пользователя root: <command>make install</command>
            </para>
            <para>Но пользователям Gentoo лучше прочитать следующий раздел. </para>
        </section>
        <section>
            <title>Gentoo Way</title>
            <para>Установка из тарболлов может показаться достаточно простой на первый взгляд, однако, она может затруднить управление пакетами и создать некоторые проблемы в дальнейшем, поэтому лучше воспользоваться мощью системой управления пакетами portage. Наверняка, о беспроблемной сборке необходимой вам программы уже позаботилось сообщество пользователей и разработчиков Gentoo. Чтобы узнать это, попробуйте найти нужную вам программу в базе портежей набрав: <command>emerge -s <replaceable>[название программы]</replaceable></command> или по описанию: <command>emerge -S <replaceable>[ключевое слово]</replaceable></command> что правда занимает достаточно много времени, и лучше использовать специально для этого написаные утилиты, например esearch: <command>emerge esearch</command>
                <command>eupdatedb</command>
                <command>esearch <replaceable>[название программы]</replaceable></command> или по описанию <command>esearch -S <replaceable>[ключевое слово]</replaceable></command> так же можно проводить поиск по категориям. Например <command>esearch -F mail-client</command> покажет все почтовые клиенты, информация о которых есть в дереве портежей. Так же при поиске можно использовать регулярные выражения. </para>
            <para>Неплохим подспорьем может послужить GUI фронтенд к портежам, например Porthole (интерфейс GTK).Для любителей KDE есть Kentoo (встраивается в центр управления) и Guitoo. </para>
            <para>Если вам потребовалось установить программу из неофицального ebuild'а, сначала прочтите <link xlink:href="http://ru.gentoo-wiki.com/wiki/Portage_Overlay">Portage_Overlay</link>. </para>
            <para>Если же ebuild скрипта найти не удалось или нужно наложить дополнительные патчи, то это значит, что пора освоить написание скриптов. Для этого можно воспользоваться skel.ebuild'ом который находится с каталоге portage. Так же не повредит прочтение <link xlink:href="http://en.gentoo-wiki.com/wiki/HOWTO_Create_an_Updated_Ebuild">en:HOWTO Create an Updated Ebuild</link>. </para>
            <para>Удобной средой разработки и правки ebuild скриптов является abeni. </para>
        </section>
        <section>
            <info>
                <title>А кто такой root и как им стать?</title>
            </info>
            <para>Говоря языком Windows, root – это администратор. Но в отличие от Windows, root – абсолютный хозяин системы. Он может сделать все, даже удалить системные файлы, или произвести низкоуровневое форматирование жесткого диска. По идее, root всегда знает что делает, поэтому такая власть вполне оправданна. Рутом можно стать несколькими способами: </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>первоначально войти систему под этим аккаунтом. </para>
                    </listitem>
                    <listitem>
                        <para>через su. Для этого в консоли введите <command>su</command>
                        </para>
                        <screen><prompt>[user@gentoo user]$</prompt> <userinput>su</userinput>
Password:
<prompt>[root@gentoo user]#</prompt>
</screen>
                        <para>Пользователь user должен быть в группе wheel. При вводе пароля он отображаться не будет. </para>
                    </listitem>
                    <listitem>
                        <para>через sudo. Это дополнительная программа, которую можно установить командой: </para>
                        <screen><prompt>$</prompt> <userinput>emerge sudo</userinput></screen>
                        <para>Ее преимущества перед обычным su заключаются в том, что можно протоколировать все выполненные команды, а значит понять, кто и как именно сделал что-то непрвильно. :) Кроме того, можно разрешить определенным пользователям выполнять только определенные команды с правами root, что существенно повышает безопасность системы. И, наконец, для использования sudo не нужно знать пароль root – достаточно помнить свой. ;) Все эти и другие настройки производятся редактированием файла конфигурации sudo – <filename>/etc/sudoers</filename>. </para>
                        <para>Пользоваться ей очень просто: </para>
                        <screen><prompt>$</prompt> <userinput>sudo команда</userinput></screen>
                        <para>(например, <command>sudo ls -l</command>). Если же вам нужно выполнить не одну команду, а просто временно стать root, используйте следующий синтаксис: </para>
                        <screen><prompt>$</prompt> <userinput>sudo -s</userinput></screen>
                        <para>Для того, чтобы перестать быть root после этого, достаточно ввести команду </para>
                        <screen><prompt>$</prompt> <userinput>exit</userinput></screen>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
    </section>
    <section>
        <title>Секреты консоли</title>
        <section>
            <title>Основные команды</title>
            <para>Можно на 100% гарантировать, что количество команд в вашей Linux системе больше пары тысяч. Но практически все линуксоиды используют из этого количества не более 100 команд, хотя и это, пожалуй, завышенное число. Человеку, который линукс видел только на скринах, будет полезно узнать, как же использовать эту консоль. </para>
            <section>
                <title>Команда man</title>
                <para>Linux – отлично документированная система. Подробную информацию о программе, команде или основным конфигурационном файлам можно получить при помощи команды man. Например man whereis выдаст вам подробную справку по использованию команды <command>whereis</command>, а команда <command>man fstab</command> выдаст синтаксис конфигурационного файла <filename>/etc/fstab</filename>.</para>
                <para>Если вам не удалось найти нужную информацию, можно заглянуть в <filename>/usr/share/doc</filename> (в Gentoo Linux так же находится в <filename>/usr/doc</filename>). Там хранится документация программ. </para>
            </section>
            <section>
                <title>Команда cd</title>
                <para>Без этой команды навигация по файловой системе будет невозможна. Смысл её простой – сменить текущий каталог. А синтаксис такой: <command>cd /home/vasya/katalog</command></para>
                <para> Можно использовать как абсолютные, так и относительные пути к папкам. </para>
                <para><indexterm><primary>Абсолютный путь</primary></indexterm><firstterm>Абсолютный путь</firstterm> – это путь указанный от корневого каталога (<filename>/</filename>). </para>
                <para><indexterm><primary>Относительный путь</primary></indexterm><firstterm>Относительный путь</firstterm> – это путь указанный относительно текущего каталога. </para>
                <para>Например, если вы находитесь в каталоге <filename>/home/vasya</filename>, то для перехода в <filename>/home/vasya/katalog</filename> вам нужно ввести только <command>cd katalog</command>. Необходимо отметить, что в Linux нет такого понятия, как "диски". Все разделы жестких дисков, CD-приводы, сетевые диски и т.д. отображаются в виде каталогов файловой системы (обычно в <filename>/mnt</filename>).</para>
                <para>Чтобы узнать в каком каталоге вы сейчас находитесь используется команда <command>pwd</command>.</para>
            </section>
            <section>
                <title>Команда ls</title>
                <para>Используется для получения списка файлов и каталогов. Например, <command>ls</command> выведет нам содержимое текущего каталога. Для вывода информации о каталоге, в котором вы сейчас не находитесь, используется <command>ls /etc</command>. Наверняка вас не удовлетворят только имена файлов. Для увеличения количества выводимой информации используйте опцию "<option>-l</option>" <command>ls -l</command>. Теперь <command>ls</command> выведет вам много полезной информации, такой как права, время последней модификации, размер и прочее. <command>ls -la</command> с опцией "<option>-a</option>" покажет скрытые файлы (by morgoth) </para>
            </section>
            <section>
                <title>Команда cp</title>
                <para>Предназначена для копирования файлов и каталогов. Например, скопируем файл <filename>/home/vasya/katalog/linux.txt</filename> в каталог <filename>/home/vasya</filename>. Делается это так: <command>cp /home/vasya/katalog/linux.txt /home/vasya</command>. А вдруг мы хотим чтобы файл <filename>linux.txt</filename> получил имя <filename>gentoo.txt</filename>? Тогда делаем так: <command>cp /home/vasya/katalog/linux.txt /home/vasya/gentoo.txt</command>. По умолчанию <command>cp</command> не копирует каталоги. Чтож, заставим его это делать. Скопируем <filename>/home/vasya/katalog</filename> в каталог <filename>/tmp</filename> так: <command>cp -R /home/vasya/katalog /tmp</command>. Ключ <option>-R</option> указывает на рекурсивное копирование. Как и в случае с файлами, можно поменять конечное имя каталога: <command>cp -R /home/vasya/katalog /tmp/novoe_imya</command>. У <command>cp</command> есть еще один полезный ключ: <option>-p</option>. Он предназначен для сохранения
                    всех параметров файла (владельца, прав доступа, битов suid, sgid). Рекомендуем всегда указывать ключ <option>-p</option>, особенно если вы частенько сидите под суперпользователем (чего делать категорически не рекомендуется). </para>
            </section>
            <section>
                <title>Команда rm</title>
                <para>Предназначена для удаления фаилов. Например, удалим файл <filename>/home/vasya/katalog/linux.txt</filename>: <command>rm /home/vasya/katalog/linux.txt</command> или если каталог <filename>/home/vasya/katalog</filename> текущий, тогда можно так: <command>rm linux.txt</command>. Будте осторожны, удаленный файл нельзя восстановить, как в DOS или Windows.</para>
                <para>Для удаления пустого каталога <filename>/home/vasya/testdir</filename> введите <command>rmdir /home/vasya/testdir</command>. Не бойтесь указывать абсолютный путь к каталогу – будет удален только последний элемент пути. Для удаления этого же каталога рекурсивно (вместе с подкаталогами и файлами) введите <command>rm -r /home/vasya/testdir</command>.</para>
            </section>
            <section>
                <title>Команда df</title>
                <para>Предназначена для просмотра оставшегося места на диске <command>df -h</command>. Ключ <option>-h</option> позволяет увидеть вывод в удобном для человека формате (например <code>1K</code>
                    <code>234M</code>
                    <code>2G</code>) </para>
            </section>
        </section>
        <section>
            <title>А как мне быть если путь или имя очень длинные?</title>
            <para>Длинные пути к файлам и каталогам – довольно частое явление. И бороться с этим достаточно легко. Все современные оболчки (aka shell) обладают возможностью автодополнения. Что это значит? Например, есть файл <command>cd home/vasya/katalog/vtoroi_katalog/ooooooooooooochendlinnoeimyakataloga</command>. Ясно, что вбивать имя полностью – это сомнительное удовольствие. ;) Поэтому поручим часть работы shell'у. Мы пишем только часть имени, а остальное будет дополнять шелл. Для дополнения необходимо нажать <keycap>Tab</keycap>. Например: <command>cd /h&lt;TAB&gt;/v&lt;TAB&gt;/k&lt;TAB&gt;/v&lt;TAB&gt;/o&lt;TAB&gt;</command></para>
            <para>Примечание: в оболочке Zsh достаточно написать </para>
            <para><command>cd /h/v/k/v/o</command> и нажать "<keycap>Tab</keycap>". Оболочка сама развернет сокращение в полный путь. Но тут могут возникнуть проблемы, в том случае, если в каталоге <filename>/home</filename> есть 2 подкаталога <filename>/home/vasya</filename> и <filename>/home/vika</filename>. Шелл не сможет понять куда же вы хотите попасть. Чтобы помочь ему нужно указать еще одну букву в пути, то есть <command>/home/va&lt;TAB&gt;</command>, чтобы выбор был однозначным. Если вы не помните части пути, то можете два раза нажать Tab и вы увидите список возможных вариантов. Например: ls <command>/home/&lt;TAB&gt;&lt;TAB&gt;</command> выведет на экран содержимое директории <filename>/home</filename>. </para>
        </section>
        <section>
            <title>Как сделать чтобы программа запущенная из терминала работала после его закрытия?</title>
            <para>Такая ситуация возникает довольно часто.Например вам необходимо обновить систему по ssh находясь далеко от своего компьютера, но удерживать связь постоянно вы не можете. Для этой цели можно использовать программу <command>nohup</command>. Например, так можно запустить xmms: <command>nohup xmms</command>. Вызываемой программе можно передавать аргументы. Теперь при закрытии терминала xmms будет работать, работать и работать ;) или: <command>xmms &amp;</command> но это только освободит терминал. После закрытия терминала приложение завершиться. </para>
            <para>Так же можно использовать программу <command>screen</command>.</para>
        </section>
    </section>
    <section>
        <title>Графическая оболочка X Window</title>
        <section>
            <title>А как работать с буфером?</title>
            <para>Работа с буфером обмена в системе X Window гораздо удобнее, чем в ОС Windows. Для копирования и вставки текста делаем так: </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>выделяем нужный текст мышкой </para>
                    </listitem>
                    <listitem>
                        <para>в нужном месте щелкаем на среднюю кнопку или колесико мышки, и текст вставляется там, где курсор. </para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>Конечно, вы можете использовать и комбинации OC Windows (<keycombo><keycap>Ctrl</keycap><keycap>C</keycap></keycombo>, <keycombo><keycap>Ctrl</keycap><keycap>V</keycap></keycombo>), однако, следует помнить, что комбинация <keycombo><keycap>Ctrl</keycap><keycap>C</keycap></keycombo> экстренно остановит выполнение команды в терминале, другими словами, попытавшись скопировать вывод программы комбинацией <keycombo><keycap>Ctrl</keycap><keycap>C</keycap></keycombo>, вы рискуете убить ее выполнение. Будьте внимательнее. </para>
            <para>Возможно также использование комбинации <keycombo><keycap>Ctrl</keycap><keycap>Insert</keycap></keycombo> для копирования в буфер и <keycombo><keycap>Shift</keycap><keycap>Insert</keycap></keycombo> для вставки из него. </para>
        </section>
        <section>
            <title>Как заставить иксы стартовать при загрузке?</title>
            <para>Для этого их необходимо добавить в уровень запуска default. Для этого необходимо выполнить: <command>rc-update add xfs default</command> и <command>rc-update add xdm default</command>. Первой командой мы заставили автоматически стартовать сервер шрифтов, а вторая указывает на автозапуск менеджера входа в систему. Для того, чтобы вместо xdm запускался другой менеджер входа необходимо немного отредактировать <command>/etc/rc.conf</command>. </para>
            <example>
                <title>Файл: <filename>/etc/rc.conf</filename></title>
                <programlisting>..
DISPLAYMANAGER="kdm"
..</programlisting>
            </example>
            <para>
            </para>
            <para>Теперь вместо xdm будет запускаться kdm.</para>
            <example>
                <title>Файл: <filename>/etc/rc.conf</filename></title>
                <programlisting>..
DISPLAYMANAGER="gdm"
.. </programlisting>
            </example>
            <para>Теперь вместо xdm будет запускаться gdm более красивый менеджер.</para>
        </section>
    </section>
</article>
